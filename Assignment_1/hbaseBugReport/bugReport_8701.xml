<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:57:43 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-8701/HBASE-8701.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-8701] distributedLogReplay need to apply wal edits in the receiving order of those edits</title>
                <link>https://issues.apache.org/jira/browse/HBASE-8701</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;This issue happens in distributedLogReplay mode when recovering multiple puts of the same key + version(timestamp). After replay, the value is nondeterministic of the key&lt;/p&gt;

&lt;h5&gt;&lt;a name=&quot;Theoriginalconcernsituationraisedfromeclark%3A&quot;&gt;&lt;/a&gt;The original concern situation raised from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=eclark&quot; class=&quot;user-hover&quot; rel=&quot;eclark&quot;&gt;Elliott Clark&lt;/a&gt;:&lt;/h5&gt;

&lt;p&gt;For all edits the rowkey is the same.&lt;br/&gt;
There&apos;s a log with: [ A (ts = 0), B (ts = 0) ]&lt;br/&gt;
Replay the first half of the log.&lt;br/&gt;
A user puts in C (ts = 0)&lt;br/&gt;
Memstore has to flush&lt;br/&gt;
A new Hfile will be created with [ C, A ] and MaxSequenceId = C&apos;s seqid.&lt;br/&gt;
Replay the rest of the Log.&lt;br/&gt;
Flush&lt;/p&gt;

&lt;p&gt;The issue will happen in similar situation like Put(key, t=T) in WAL1 and Put(key,t=T) in WAL2&lt;/p&gt;

&lt;h5&gt;&lt;a name=&quot;Belowistheoption%28proposedbyTed%29I%27dliketouse%3A&quot;&gt;&lt;/a&gt;Below is the option(proposed by Ted) I&apos;d like to use:&lt;/h5&gt;

&lt;p&gt;a) During replay, we pass original wal sequence number of each edit to the receiving RS&lt;br/&gt;
b) In receiving RS, we store negative original sequence number of wal edits into mvcc field of KVs of wal edits&lt;br/&gt;
c) Add handling of negative MVCC in KVScannerComparator and KVComparator   &lt;br/&gt;
d) In receiving RS, write original sequence number into an optional field of wal file for chained RS failure situation &lt;br/&gt;
e) When opening a region, we add a safety bumper(a large number) in order for the new sequence number of a newly opened region not to collide with old sequence numbers. &lt;/p&gt;

&lt;p&gt;In the future, when we stores sequence number along with KVs, we can adjust the above solution a little bit by avoiding to overload MVCC field.&lt;/p&gt;

&lt;h5&gt;&lt;a name=&quot;Theotheralternativeoptionsarelistedbelowforreferences%3A&quot;&gt;&lt;/a&gt;The other alternative options are listed below for references:&lt;/h5&gt;

&lt;p&gt;Option one&lt;br/&gt;
a) disallow writes during recovery&lt;br/&gt;
b) during replay, we pass original wal sequence ids&lt;br/&gt;
c) hold flush till all wals of a recovering region are replayed. Memstore should hold because we only recover unflushed wal edits. For edits with same key + version, whichever with larger sequence Id wins.&lt;/p&gt;

&lt;p&gt;Option two&lt;br/&gt;
a) During replay, we pass original wal sequence ids&lt;br/&gt;
b) for each wal edit, we store each edit&apos;s original sequence id along with its key. &lt;br/&gt;
c) during scanning, we use the original sequence id if it&apos;s present otherwise its store file sequence Id&lt;br/&gt;
d) compaction can just leave put with max sequence id&lt;/p&gt;

&lt;p&gt;Please let me know if you have better ideas.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12651415">HBASE-8701</key>
            <summary>distributedLogReplay need to apply wal edits in the receiving order of those edits</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="jeffreyz">Jeffrey Zhong</assignee>
                                    <reporter username="jeffreyz">Jeffrey Zhong</reporter>
                        <labels>
                    </labels>
                <created>Thu, 6 Jun 2013 18:38:47 +0000</created>
                <updated>Sat, 21 Feb 2015 23:31:05 +0000</updated>
                            <resolved>Fri, 20 Dec 2013 22:32:03 +0000</resolved>
                                                    <fixVersion>0.98.0</fixVersion>
                    <fixVersion>0.99.0</fixVersion>
                                    <component>MTTR</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>18</watches>
                                                                <comments>
                            <comment id="13678395" author="enis" created="Fri, 7 Jun 2013 20:26:13 +0000"  >&lt;p&gt;I&apos;ve put the following comment on the parent jira &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-7006&quot; title=&quot;[MTTR] Improve Region Server Recovery Time - Distributed Log Replay&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-7006&quot;&gt;&lt;del&gt;HBASE-7006&lt;/del&gt;&lt;/a&gt;. I guess the discussions should continue here, so I am repeating my comments: &lt;br/&gt;
Here is a proposed scheme that can solve this problem:&lt;br/&gt;
The region will be opened for replaying as in previous. The normal writes go to the memstore, and the memstore is flushed as usual. The region servers who are reading the WAL and sending to the replaying RS will still be the same, except for the fact that the edits are sent with their seq_ids.&lt;br/&gt;
On the replaying RS, for all regions that are in replaying state, there is a single buffer. All edits are appended to this buffer without any sorting. This buffer can be accounted as a memstore, and it will have the memstore flush size as max size. Once this is reached, or due to global memstore pressure, we are asked to flush, we do spill this to disk after sorting. This buffer keeps &amp;lt;kv,seq&amp;gt; pairs, and sorts according to &amp;lt;kv,seq&amp;gt;. If there is not memory pressure, and buffer does not fill up, we don&apos;t need to spill to disk.&lt;br/&gt;
Once the replaying is finished, and master asks the region server to open the region for reading, then we do a final merge sort for the in-memory sorted buffer, and all on-disk spilled buffers and create an hfile, discarding kv&apos;s that have the same kv, but smaller seq_id. This file will be a single hfile that corresponds to a flush. This hfile will have a seq_id that is obtained from the wal edits. Then we add this hfile to the store, and open the region as usual. This kind of keeping an unsorted buffer, and sorting it with qsort with spills and final on-disk merge sort might even be faster, since otherwise, we would be doing an insertion to the memstore, which becomes an insertion sort.&lt;br/&gt;
The other thing we need to change is that replayed edits will not go into the wal again, so we keep track of recovering state for the region server, and re-do the work if there is a subsequent failure.&lt;br/&gt;
In sort, this will be close to the BigTable&apos;s in-memory sort for each WAL file approach, but instead we gather the edits for the region from all WAL files by doing the replay RPC, and do the sort per region. End result, we create a flushed hfile, as if the region just flushed before the crash.&lt;/p&gt;</comment>
                            <comment id="13678434" author="jeffreyz" created="Fri, 7 Jun 2013 21:02:01 +0000"  >&lt;p&gt;Thanks Enis for the proposed option. &lt;/p&gt;

&lt;p&gt;I firstly want to call the explicit version update as &quot;time travel updates&quot; because you can set something in the future or the past.&lt;/p&gt;

&lt;h5&gt;&lt;a name=&quot;Belowisanotheroptionforthe%22timetravelupdates%22issue%3A&quot;&gt;&lt;/a&gt;Below is another option for the &quot;time travel updates&quot; issue:&lt;/h5&gt;

&lt;p&gt;During replay we tag each KV with original sequence Id(may leverage the future cell tag). During compaction, we remove this tag totally and keep the kv with highest sequence Id. In scan code, we need to use the sequenceId tag if presents otherwise store file sequence Id value. &lt;/p&gt;

&lt;p&gt;Overall, after compaction there is no storage overhead because the extra sequence Id is removed. The only complexity added is to change the scan&amp;amp;compaction code a little bit to use the sequenceId tag.&lt;/p&gt;


</comment>
                            <comment id="13678475" author="stack" created="Fri, 7 Jun 2013 21:48:31 +0000"  >&lt;p&gt;Elliott and I had a chat and came up w/ something similar to the Enis proposal.  Let me write it out.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;Add new API to RS called replay.  Method would take a WALEdit or even a list of WALEdits which I think has seqid and target region in it.&lt;/li&gt;
	&lt;li&gt;Replay all WAL edits into an in-memory recovered.edits file: i.e. a datastructure that orders edits by sequenceid.  If it has to spill because of memory pressure, that is ok; we would write out this ordered-by-id &quot;recovered.edits&quot; file.&lt;/li&gt;
	&lt;li&gt;On notification that all WALs have been replayed, play the ordered-by-id &quot;recovered.edits&quot; into a memstore that is NOT the per-column-family memstore we use in normal operation (If we flushed &apos;recovered.edits&apos;, they will need to be merged w/ what we have in memory doing the replay).  This &apos;other&apos; memstore we call the replay-memstore (RMS).  The replay skips the WAL.  If the RMS has to flush during replay, that is fine.  The &apos;replayer&apos; will provide the seqid to write the hfile out with (this could be messy).  The seqid will be one gotten from the WALEdit, not from currently hosting RS.&lt;/li&gt;
	&lt;li&gt;Flush out the RMS using the seqid of the last edit.&lt;/li&gt;
	&lt;li&gt;Flip the region to take reads.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Elliott then went on to remark that what we want is mapreduce; our task would group-by-region, then sort by sequenceid, and finally write out an hfile (with retries and recovery, etc.)&lt;/p&gt;

&lt;p&gt;I like Enis&apos;s putting off sort till last moment.&lt;/p&gt;

&lt;p&gt;Chatting more w/ Elliott, if we let go of the requirement that we respect insert order when two edits have same coordinates, it certainly would make a lot of ops easier (this replay, compactions, etc.).  Was suggested too that this would be a good topic for the hackathon on weds if you fellas are going to come: &lt;a href=&quot;http://www.meetup.com/hackathon/events/123403802/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.meetup.com/hackathon/events/123403802/&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13678493" author="jeffreyz" created="Fri, 7 Jun 2013 22:00:47 +0000"  >&lt;p&gt;Yeah, we&apos;ll come to the hackathon in the afternoon to talk about this. Thanks. &lt;/p&gt;</comment>
                            <comment id="13678510" author="lhofhansl" created="Fri, 7 Jun 2013 22:23:10 +0000"  >&lt;p&gt;Coming late to this... It seems to me that we have edits with the same timestamps in different WAL files this can only happen when the client explicitly set the timestamps. Now, if a client does set the TS of two edits to the same timestamps it should not care about their relative ordering. So I&apos;d say: Let&apos;s just punt on solving this problem.&lt;/p&gt;</comment>
                            <comment id="13678538" author="sershe" created="Fri, 7 Jun 2013 22:48:07 +0000"  >&lt;p&gt;We had also had a discussion here, about both these and other schemes. We are in consensus with the above wrt &quot;streaming recovered edits&quot;, so let me provide a short brain dump for the other approach &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
On worker servers, we could rewrite HLogs into HFiles (in the simplest case, each worker writes one separate HFile per region, but bear with me... solution for too many HFile-s is described below). There&apos;s  little new code involved, just use WAL reader, memstore, and file writer. We might want to make slight changes to memstore for this - given that it will be write-only and single-threaded, for example, ConcurrentSkipList is not the best ds; etc. That should be trivial, as long as the new ds supports the same interface... &lt;br/&gt;
Each worker separately flushes all these memstores, commits the new HFile-s into target regions (seqnums don&apos;t require any special handling because they come from one, or several contiguous (see below), HLogs). Then it can nuke the processed HLogs; i.e. the recovery is incremental, which is good.&lt;br/&gt;
Each worker processes one HLog file in simple case; if there are more HLogs than servers doing the recovery, assign several contiguous HLog-s per server (e.g. 30 HLogs, replay on 9 servers =&amp;gt; 3-4 per server).&lt;br/&gt;
After all workers complete region is ready to accept reads and writes before any merge; the merge of the HFile-s will be done via compaction of all these small files. We can also open region for writing during recovery with very little special handling, as soon as all HFiles are added, store will just have to load them. We may have to disallow compactions, but that is true for every scheme, btw we should handle it in this JIRA anyway.&lt;br/&gt;
Moreover, as we rewrite the HLog as HFile(s), we can put one replica of new HFile onto the target server, so that &quot;replay to other server&quot; RPC cost is baked into normal HDFS replication cost.&lt;/p&gt;

&lt;p&gt;Now, the biggest problem with this scheme is how many HFile-s it can generate - up to # regions * min(# servers, # of WALs). To solve that, it is possible to create indexed MultiStoreFile, expanding the existing HalfStoreFile, and share it between multiple regions. That way, the /total/ number of HFile-s produced is bounded by min(# servers, # of WALs). This is slightly more involved, but again, region can be immediately opened for normal operation and files split via compaction, just like for region splits.&lt;br/&gt;
Locality is lost for some regions if we do that; if the worker who does the rewriting HLog to HFile knows some metadata of the WAL, its size etc., however, it can make a decision that trades off locality vs number of files (e.g. produce one MultiStoreFile per multiple regions on 3 servers and place replicas there, or whatever).&lt;/p&gt;

&lt;p&gt;I like this scheme in particular because it requires very little special new logic for correctness, or new code/new file formats/etc. Enis only likes this scheme with one MultiStoreFile per WAL as far as I understand (correct me if I&apos;m wrong &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;)&lt;/p&gt;</comment>
                            <comment id="13678546" author="sershe" created="Fri, 7 Jun 2013 22:56:34 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt; same TS can also result from system clock issues (and these will happen somewhere on any large cluster; however these can also cause TS-s to reverse, so we can probably ignore this case); then, one no-TS put + one explicit TS put where explicit TS happens to be a realistic time value that is the same as the implicit one. It might theoretically also happen if HBase can do two puts within one TS value from the same client sequentially... but yeah the defined-ness of the behavior prevents many optimizations. It is indeed spelled out in the book now though.&lt;/p&gt;</comment>
                            <comment id="13678551" author="eclark" created="Fri, 7 Jun 2013 23:00:07 +0000"  >&lt;blockquote&gt;&lt;p&gt;It seems to me that we have edits with the same timestamps in different WAL files this can only happen when the client explicitly set the timestamps.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Until we have a full Multi-Wal implementation, which is something that&apos;s definitely planned. &lt;/p&gt;</comment>
                            <comment id="13678636" author="lhofhansl" created="Sat, 8 Jun 2013 01:07:06 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sershe&quot; class=&quot;user-hover&quot; rel=&quot;sershe&quot;&gt;Sergey Shelukhin&lt;/a&gt; I thought we were talking about version of the same KV. So clock skew between servers could have an effect if one region server dies, another takes over, and then dies, and then only if the clock skew is &amp;gt; the time it takes the first region to be recovered, right?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=eclark&quot; class=&quot;user-hover&quot; rel=&quot;eclark&quot;&gt;Elliott Clark&lt;/a&gt; Yep. Even then I would posit that if the TS is the same the two event happened at the same time (as far as HBase is converned) and we should not need to go to length to maintain any ordering.&lt;/p&gt;

&lt;p&gt;Let&apos;s all talk at the Hackathon.&lt;/p&gt;</comment>
                            <comment id="13678664" author="sershe" created="Sat, 8 Jun 2013 03:12:54 +0000"  >&lt;p&gt;The clock can move on the same server if motherboard clock is faulty, at least I&apos;ve seen it happen in the past. But yeah about this case we don&apos;t have to worry (as it&apos;s impossible to handle with time-based timestamps anyway); implicit and explicit timestamps can still collide. If we can get rid of this requirement it would be nice, this was already discussed in some compaction jira though.&lt;br/&gt;
If we don&apos;t drop it, &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8709&quot; title=&quot;consider a scheme to allow compacting files in any combination&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8709&quot;&gt;&lt;del&gt;HBASE-8709&lt;/del&gt;&lt;/a&gt;-like seqNum management can allow us to strictly sort these though (that minus the out-of-order compactions)&lt;/p&gt;</comment>
                            <comment id="13678681" author="stack" created="Sat, 8 Jun 2013 04:50:41 +0000"  >&lt;p&gt;On the &apos;other approach&apos;, I like the incremental aspect &amp;#8211; being able to remove HLogs as we go.&lt;/p&gt;

&lt;p&gt;A MultiStoreFile would have edits from one WAL file for all regions in the WAL?  Which region would it live in and how would it get cleaned up?  (When all references had been dropped?)  We&apos;d have to write &apos;reference&apos; files into each region that pointed back to a range on this WAL?  Wouldn&apos;t we be making near as many NN operations as for the case where we wrote out an hfile per region?&lt;/p&gt;

&lt;p&gt;I think this multistorefile notion too complex.&lt;/p&gt;

&lt;p&gt;We could keep hfiles per region in memory and not write them until we had too but then we lose the incremental benefit and we start to arrive at the Enis/Elliott scheme?&lt;/p&gt;

&lt;p&gt;On another note, I was thinking we could enable distributed replay now as the default if we turned off bringing the region online for writes but I realize now that we cannot enable distributed replay until we fix this problem; so ignore my request in the parent issue that asks that we turn it on.&lt;/p&gt;

&lt;p&gt;On allowing KVs with the same coordinates returning sometimes in insert order and post distributed replay, possibly returning in a different order (if we give up respecting seqid on WAL split), I am not sure we should; it would mean we could not overwrite an existing KV definitively to remove it from the db.  Do we think this a big deal (rare yes, but perhaps a facility we need to retain?)?&lt;/p&gt;

&lt;p&gt;I commented over in hbase-8709.  Chatting w/ LarsH this evening he raised having seqid in the KV as is suggested there.   This has come up in a few context&apos;s.  If it was seqid rather than mvcc it would be of use replaying (though this seqid is out in the WAL&apos;s WALEdit file so would be redundnant having it in kv).  Replaying though, memstore would have to consider the seqid&apos; when sorting.  We would not collapse versions of same coordinates during replay in the memstore (as we currently do in memstore); we could only do the collapsing after all WALs had been replayed and we are flushing (This latter fact would mean the replay memstore would be different to our current memstore).&lt;/p&gt;



</comment>
                            <comment id="13678730" author="yuzhihong@gmail.com" created="Sat, 8 Jun 2013 11:32:53 +0000"  >&lt;p&gt;I am in favor of associating seqid along with KeyValue.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Replaying though, memstore would have to consider the seqid&apos; when sorting.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Looks like a new type of KVComparator should be created that considers seqid&apos;s, depending on how seqid is stored.&lt;/p&gt;

&lt;p&gt;Storing seqid along with KeyValue implies bumping minor version of HFile. If we use the upcoming call tag facility, minor version of HFile needs to be bumped only once.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;the replay memstore would be different to our current memstore&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;+1. This is the replay-memstore (RMS) mentioned above.&lt;/p&gt;

&lt;p&gt;For performance consideration, we need to balance the frequency of flushing w.r.t. normal memstore and RMS. Looks like RMS should be flushed less frequently (compared to flushing of normal memstore) when global heap pressure gets to some threshold. Meaning, we may need to throttle the concurrent writes coming into normal memstore.&lt;/p&gt;</comment>
                            <comment id="13679684" author="sershe" created="Mon, 10 Jun 2013 17:52:36 +0000"  >&lt;blockquote&gt;&lt;p&gt;A MultiStoreFile would have edits from one WAL file for all regions in the WAL? Which region would it live in and how would it get cleaned up? (When all references had been dropped?) We&apos;d have to write &apos;reference&apos; files into each region that pointed back to a range on this WAL? Wouldn&apos;t we be making near as many NN operations as for the case where we wrote out an hfile per region?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;It will have to use some form of links and references, and will have edits from multiple stores. Something like that is described in BigTable paper actually &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I think this multistorefile notion too complex.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;We could keep hfiles per region in memory and not write them until we had too but then we lose the incremental benefit and we start to arrive at the Enis/Elliott scheme?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Why more complex? Should be pretty simple, we already have something like that.&lt;br/&gt;
Incremental benefit is auxiliary; main benefit in my view is precisely that we don&apos;t have additional in-memory/file structures/separate memstores in the same store that need to be reconciled/communication channels.&lt;/p&gt;

&lt;p&gt;Agree on having seqIds for each KV... it will increase file size which is not a huge deal probably, but will solve many problems. Should we do it now while we are still before singularity?&lt;/p&gt;
</comment>
                            <comment id="13679799" author="stack" created="Mon, 10 Jun 2013 19:29:32 +0000"  >&lt;blockquote&gt;&lt;p&gt;It will have to use some form of links and references, and will have edits from multiple stores. Something like that is described in BigTable paper actually&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Where?  Thanks.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Why more complex?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Because I do not understand how it works.  I give an outline above of my understanding and going by it, I conclude it too complex.  Help me understand better.  Thanks.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Should be pretty simple, we already have something like that.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Where?&lt;/p&gt;

&lt;p&gt;We&apos;d associate seqid w/ kvs throughtout the system so we could do distributed log replay?  Associating seqid w/ keyvalue is a radical reworking of internals that has been punted on in the past because the size of the work involved was thought too large; the base KV would have to change as would how we carry edits in memstore, our policy incrementing/upserting when thousands received a second, and we&apos;d then have to redo how we currently persist seqid in hfiles on way in and out.  If a seqid, do we need a mvcc or should they be related and if not, how should they be related?  And so on.&lt;/p&gt;</comment>
                            <comment id="13679885" author="sershe" created="Mon, 10 Jun 2013 20:46:38 +0000"  >&lt;blockquote&gt;&lt;p&gt;Where? Thanks.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;page 8: &quot;We avoid duplicating log reads by first sort- ing the commit log entries in order of the keys &#10216;table, row name, log sequence number&#10217;. In the sorted output, all mutations for a particular tablet are contiguous and can therefore be read efficiently with one disk seek followed by a sequential read. To parallelize the sorting, we partition the log file into 64 MB seg- ments, and sort each segment in parallel on different tablet servers.&quot;&lt;/p&gt;

&lt;p&gt;Not clear if these outputs are ready to load or need to be replayed, but it should be ok to do the former.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Because I do not understand how it works. I give an outline above of my understanding and going by it, I conclude it too complex. Help me understand better. Thanks.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Where?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;HalfStoreFileReader.&lt;br/&gt;
How does HalfStoreFileReader work right now - by having reference and splitkey.&lt;br/&gt;
This thing can either have references (one per store), with multiple splitkey support; or, for a more involved solution w/o references, have (in the beginning, or tail) an index that points to precise locations to where each file&apos;s data starts. However in the latter case it&apos;s not clear where to store the file, as you said.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;We&apos;d associate seqid w/ kvs throughtout the system so we could do distributed log replay? &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;That would also allow things like picking files arbitrarily for compactions, for example.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Associating seqid w/ keyvalue is a radical reworking of internals that has been punted on in the past because the size of the work involved was thought too large; the base KV would have to change as would how we carry edits in memstore, our policy incrementing/upserting when thousands received a second, and we&apos;d then have to redo how we currently persist seqid in hfiles on way in and out. If a seqid, do we need a mvcc or should they be related and if not, how should they be related? And so on.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I might be missing something... can you elaborate why? Right now we use seqid, taken from the file metadata, as a last-ditch conflict resolution mechanism (see KeyValueHeap::KVScannerComparator) after timestamps and stuff.&lt;br/&gt;
We can do the same but take seqid from KV instead of the file. Granted, if resolving identical keys it&apos;s a pretty large number of bytes to store...&lt;br/&gt;
The thing where memstore overwrites the value appears to be plain incorrect to me when VERSIONS is more than 1 (whether you will get a version or not depends on when the memstore flush happens), so that&apos;s an additional (and automatic?) advantage.&lt;br/&gt;
We don&apos;t necessarily have to change anything else, what do you have in mind?&lt;/p&gt;
</comment>
                            <comment id="13679886" author="sershe" created="Mon, 10 Jun 2013 20:48:43 +0000"  >&lt;p&gt;*for resolving&lt;/p&gt;</comment>
                            <comment id="13680039" author="stack" created="Mon, 10 Jun 2013 23:19:51 +0000"  >&lt;p&gt;Thanks.  I see what you are referring to now.&lt;/p&gt;

&lt;p&gt;The description sounds like a mapreduce job (as Elliott suggested) but in essence is what Enis proposes (sort edits including consideration of seqid and when done spill hfiles which we then load on region open).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;This thing can either have references (one per store), with multiple splitkey support; or, for a more involved solution w/o references, have (in the beginning, or tail) an index that points to precise locations to where each file&apos;s data starts. However in the latter case it&apos;s not clear where to store the file, as you said.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah sounds like a lot of file writing and then fragile links that we&apos;d need to keep in order.&lt;/p&gt;

&lt;p&gt;Lets white board it on Weds.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I might be missing something... can you elaborate why?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I thought I had?  On 0.96 restart, we&apos;d read current hfiles and convert all KVs to KVversion2 as we read them (KVversion2 would include sequenceid).  New files would be written w/ KVversion2.  Memstores would have to change to factor in seqid (and would need to figure what to do on upsert, the overwrite of a memstore value....currently we let memstore values get overwritten when same coordinates...  which is fine given our current semantic that two KVs at same coordinates do  NOT count as different VERSIONS; we would have to change this...).  There are probably a bunch of places where we presume the old KVversion1 serialization format that we would have to hunt out.  This seems like a bunch of work to me?&lt;/p&gt;

&lt;p&gt;If we were going to go this route, we might as well get &apos;labels&apos; into the the KV too.  Might as well move over to using Cell interface.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The thing where memstore overwrites the value appears to be plain incorrect to me when VERSIONS is more than 1  (whether you will get a version or not depends on when the memstore flush happens)...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No.  KVs at same VERSION are considered the same; you will only ever get the last one written.&lt;/p&gt;


</comment>
                            <comment id="13684769" author="yuzhihong@gmail.com" created="Sun, 16 Jun 2013 20:15:59 +0000"  >&lt;p&gt;I will post a patch Monday morning which does the following:&lt;/p&gt;

&lt;p&gt;HLogSplitter#LogReplayOutputSink#groupEditsByServer() would pass sequence Id as an attribue of the Put/Delete.&lt;br/&gt;
The region server which does log replay would check for this attribute in the mutations. If present, the sequence Id would be negated and stored in memstoreTS field of the KeyValue.&lt;br/&gt;
KeyValueHeap#KVScannerComparator#compare(KeyValueScanner left, KeyValueScanner right) would check for the presence of sequence Id in the KeyValue&apos;s retrieved by left.peek() and right.peek(). If sequence Id is present, its negated value would be used to sort KeyValue&apos;s accordingly.&lt;/p&gt;

&lt;p&gt;The above approach avoids creating intermediate files while at the same time incurs minimal change to HFile format.&lt;/p&gt;</comment>
                            <comment id="13684860" author="jeffreyz" created="Mon, 17 Jun 2013 00:26:22 +0000"  >&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ted_yu&quot; class=&quot;user-hover&quot; rel=&quot;ted_yu&quot;&gt;Ted Yu&lt;/a&gt; for the new proposal which looks very promising because it allows us to keep current hfile format and solve same version update ordering issue of this JIRA.&lt;/p&gt;

&lt;p&gt;I&apos;ll add remaining small changes(documented below) on top of your patch &amp;amp; a test case.&lt;/p&gt;

&lt;p&gt;Along storing negative original sequence numbers into mvcc field, we need to extend the wal so that wal keys of edits created by replay command store the original log sequence number to handle chained RS failure situation.&lt;br/&gt;
In addition, in order to accept writes during recovering, we need to get the largest log sequence number from previous failed RS. There are several options to address that:&lt;/p&gt;

&lt;p&gt;1) add a large number to the max flushed sequenced number of store files of the failed region so that the new sequence number won&apos;t collide with old sequence value.(my favor option)&lt;br/&gt;
For example, adding 200 millions on top of max store file sequence id:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;it&apos;d take 300+ years to overflow long integer assuming the same region recovers every second&lt;/li&gt;
	&lt;li&gt;it&apos;d take 2+ days for a RS receives a change every millisecond and without a single flush&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;2) reject puts with explicit timestamp input during recovery&lt;br/&gt;
3) read through the last wal(may also the trailer of the second to last wal) to get the max sequence number. The disadvantage of this approach is recovery process is blocked till after reading the two possible wals. The recovery lease of the last wal may incur some time because it&apos;s most likely open when RS fails. &lt;/p&gt;

</comment>
                            <comment id="13684971" author="v.himanshu" created="Mon, 17 Jun 2013 04:48:50 +0000"  >&lt;p&gt;Re option 1/3: In-fact, as part of 8741, I am working on a hybrid solution ( combining 1 and 3 options): read the trailer of the second last wal (which would contain the log sequenceID of the WAL at time of rolling, and would not suffer from recover lease problem you mentioned), and then add a delta (sufficient enough to avoid collision) while opening the regions of the dead server. I am using RegionInfo to pass this number while opening the region. The patch is still work-in-progress; will try to upload it soon.&lt;/p&gt;</comment>
                            <comment id="13685537" author="yuzhihong@gmail.com" created="Mon, 17 Jun 2013 13:09:29 +0000"  >&lt;p&gt;Patch that illustrates the idea I described yesterday.&lt;/p&gt;</comment>
                            <comment id="13685996" author="jeffreyz" created="Mon, 17 Jun 2013 21:13:11 +0000"  >&lt;p&gt;This v4 patch is built on top of Ted&apos;s v3 patch by adding wal support on chained failures, new sequence number of a just opened recovering region and a test case. It&apos;s a promising solution by far with minimum changes. &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=himanshu%40cloudera.com&quot; class=&quot;user-hover&quot; rel=&quot;himanshu@cloudera.com&quot;&gt;Himanshu Vashishtha&lt;/a&gt; I used the simple safety bumper approach in the patch. If the approach of hbase-8741 runs well without degrading the performance, you can amend that part a little bit when you check in hbase-8741.&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;</comment>
                            <comment id="13686028" author="yuzhihong@gmail.com" created="Mon, 17 Jun 2013 21:27:21 +0000"  >&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+        /*
+         * &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(isInReplay) { walEdit. }
+         */
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The above can be removed, right ?&lt;/p&gt;
</comment>
                            <comment id="13686067" author="thomaspan" created="Mon, 17 Jun 2013 21:58:42 +0000"  >&lt;p&gt;Just want to share my thoughts out of HBase Hackathone last week. Though, I believe that people here have thorough thoughts on the implementation. This issue seems to be the exact distributed sort problem that well resolved by MapReduce platform. Sorted lists of WAL entry reach destination RS for final merge or replay. As the amount of data could be too much, the destination RS needs to use disk to store the data for final merge sort before being replayed. The final merge sort could be merged into normal compaction operations for optimal performance.&lt;/p&gt;</comment>
                            <comment id="13686081" author="stack" created="Mon, 17 Jun 2013 22:08:31 +0000"  >&lt;p&gt;Sometimes the mvcc number is a sequence number (a negative one!) and other times it is an mvcc.  This hack is spread about the code base.&lt;/p&gt;

&lt;p&gt;On the below:&lt;/p&gt;

&lt;p&gt;+  // in distributedLogReplay mode, we haven&apos;t read all wals so we don&apos;t know the last exact&lt;br/&gt;
+  // sequence number used by previous failed RS. Hence we introduce SEQNUM_SAFETY_BUMPER to add a&lt;br/&gt;
+  // large enough number to be sure that the new sequence number of the just opened region won&apos;t&lt;br/&gt;
+  // overlap with old sequence numbers.&lt;br/&gt;
+  // Using 200 million:&lt;br/&gt;
+  // 1) it&apos;d take 300+ years to overflow long integer assuming the same region recovers every second&lt;br/&gt;
+  // 2) it&apos;d take 2+ days for a RS receives a change every millisecond and without a single flush&lt;br/&gt;
+  static final long SEQNUM_SAFETY_BUMPER = 200 * 1024 * 1024; // 200 millions&lt;/p&gt;

&lt;p&gt;What does a flush do to the above?  It does not effect sequence number right?  It does not reset it.&lt;/p&gt;

&lt;p&gt;If a RS does 1k hits a second for two days, we are almost at 200million.&lt;/p&gt;

&lt;p&gt;The 200M here is meant to span all edits out in WAL logs?&lt;/p&gt;

&lt;p&gt;No explaination for why we set a -seqid into mvcc:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;kv.setMemstoreTS(localizedWriteEntry.getWriteNumber());&lt;br/&gt;
+          kv.setMemstoreTS(seqId == NO_SEQ_ID ? localizedWriteEntry.getWriteNumber() :&lt;br/&gt;
+            -seqId);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;KeyValueHeap has this pollution.  It goes negativing &quot;seqid&quot; w/o explaination.  Yeah, this hack is spread all over code base.  &lt;/p&gt;

&lt;p&gt;Why move recovering state setting from openregionhandler to HRegion?&lt;/p&gt;

&lt;p&gt;An HLogEdit doesn&apos;t have sequence number already?  What is logSeqNum?  What is relation to below?&lt;/p&gt;

&lt;p&gt;+  // used in distributedLogReplay to store original log sequence number of an edit&lt;br/&gt;
+  private long origLogSeqNum;&lt;/p&gt;

&lt;p&gt;Chatting w/ Himanshu, he wondered if it is possible that a memstore get flushed w/ a negative mvcc?&lt;/p&gt;</comment>
                            <comment id="13686149" author="v.himanshu" created="Mon, 17 Jun 2013 23:11:13 +0000"  >&lt;p&gt;Thanks for the patch, Ted and Jeffrey. &lt;/p&gt;

&lt;p&gt;Few comments: &lt;/p&gt;

&lt;p&gt;Once this is done, we have HFiles with positive and negative mvcc numbers?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (kv.getMemstoreTS() &amp;lt;= smallestReadPoint) {
+        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (kv.getMemstoreTS() &amp;gt; 0 &amp;amp;&amp;amp; kv.getMemstoreTS() &amp;lt;= smallestReadPoint) {
           kv.setMemstoreTS(0);
         }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now, when do we set it back to 0? &lt;/p&gt;

&lt;p&gt;Is it possible to have some doc on the scanner changes... Yeah, it needs scanner level change. &lt;br/&gt;
Anyway, we were trying to fix the mttr, but now it looks we are changing code path that is used by the core.. scan/get. Could it have some performance implications?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Chatting w/ Himanshu, he wondered if it is possible that a memstore get flushed w/ a negative mvcc?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yea, looks like there is no check for not flushing, etc while we are writing to the region. What happens if we are done with the replay, make the region up for read, but compaction has not kicked in yet. &lt;/p&gt;

&lt;p&gt;Re: &quot;bumping up the sequence number&quot; &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;+        nextSeqid += SEQNUM_SAFETY_BUMPER;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Stack pointed out a case in 8741, where a region (with exceptionally high sequenceId) is opened to a region server, and that regionserver dies immediately after opening it. I think the bumping-up scheme will not be sufficient.&lt;/p&gt;</comment>
                            <comment id="13686158" author="jeffreyz" created="Mon, 17 Jun 2013 23:21:28 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt; Thanks for the comments!&lt;/p&gt;

&lt;p&gt;In the v5 patch, I added a new verification step after flush.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Sometimes the mvcc number is a sequence number (a negative one!) and other times it is an mvcc. This hack is spread about the code base.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I have to admit that overloading mvcc number is a hack but it allows us without modifying hfile format by adding minimum changes(you can see Ted&apos;s v3 patch is only 9kb) to address the JIRA. I hope once the cell tag is in place we can clean the hack with trivial effort. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The 200M here is meant to span all edits out in WAL logs?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes. It&apos;s just a big enough number to make sure new sequence number won&apos;t collide with old log sequence number without reading wal files. A RS is extrem unlikely to have 200 million changes before a region flush because we flush a online region every hr by default and other logic to force a flush on regions with min sequence number when the number of log files reach certain limit.&lt;br/&gt;
Beging said that, we can leave this out and till we have a consensus in hbase-8741.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An HLogEdit doesn&apos;t have sequence number already? What is logSeqNum? What is relation to below?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;It&apos;s the original log sequence number when firstly replay a wal. Storing in waledit so that we can persistent the number into hlogkey of a wal Entry to handle the case when receiving RS fails again during a replay.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Chatting w/ Himanshu, he wondered if it is possible that a memstore get flushed w/ a negative mvcc?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;It&apos;s possible due to we have sequence number along with the KV.&lt;/p&gt;</comment>
                            <comment id="13686171" author="jeffreyz" created="Mon, 17 Jun 2013 23:32:48 +0000"  >
&lt;blockquote&gt;
&lt;p&gt;Could it have some performance implications?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Should not because just adding several more checks.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yea, looks like there is no check for not flushing, etc while we are writing to the region. What happens if we are done with the replay, make the region up for read, but compaction has not kicked in yet.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The changes in the scanner should cover the situation you mentioned. So far I didn&apos;t see any issue.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Stack pointed out a case in 8741, where a region (with exceptionally high sequenceId) is opened to a region server, and that regionserver dies immediately after opening it. I think the bumping-up scheme will not be sufficient.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I c. I can leave this part out till we have a consensus in 8741. &lt;/p&gt;</comment>
                            <comment id="13686175" author="enis" created="Mon, 17 Jun 2013 23:34:34 +0000"  >&lt;blockquote&gt;&lt;p&gt;Re option 1/3: In-fact, as part of 8741, I am working on a hybrid solution ( combining 1 and 3 options): read the trailer of the second last wal (which would contain the log sequenceID of the WAL at time of rolling, and would not suffer from recover lease problem you mentioned), and then add a delta (sufficient enough to avoid collision) while opening the regions of the dead server.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We can put an upper bound on the number of KVEdits that a single log file can contain (64M / 64byte = 1M, lets put the limit 10M), which means that the log will block and has to roll before accepting any more updates. Then max(max(hfile seqIds),max(all WAL trailers)) + #WALs without trailer * KV limit per WAL will give us a safe sequenceId. &lt;/p&gt;</comment>
                            <comment id="13686243" author="stack" created="Tue, 18 Jun 2013 00:41:01 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jeffreyz&quot; class=&quot;user-hover&quot; rel=&quot;jeffreyz&quot;&gt;Jeffrey Zhong&lt;/a&gt; When you say &apos;...but it allows us without modifying hfile format.&apos;, what you thinking?  I&apos;m not sure why we&apos;d need to modify hfile format to accommodate replay.&lt;/p&gt;

&lt;p&gt;On the 200M, I like Enis&apos;s suggestion that we set an upper bound on KVs per file.  It is a good idea for figuring a safe step in the sequenceids.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It&apos;s the original log sequence number when firstly replay a wal. Storing in waledit so that we can persistent the number into hlogkey of a wal Entry to handle the case when receiving RS fails again during a replay.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This seems like a hack on the hack.  What do we do if the replay fails a second time? (once for original server crash, then a crash while replay, then again when replaying the replay?)  &lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;It&apos;s possible due to we have sequence number along with the KV.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So it IS possible to have an hfile w/ a negative sequence number?  (We don&apos;t sort storefiles by sequenceid any more?)  If so, that&apos;ll mess us up?  Or the scan merge will accomodate?&lt;/p&gt;

&lt;p&gt;How do the replays work in memstore?  If a negative mvcc is added first, then a positive (because the region is open for writes), then another negative comes in, what happens?  Does the negative overwrite the positive at the same coordinates?  Will we flush w/ a negative sequenceid though the file has postiives in it?&lt;/p&gt;
</comment>
                            <comment id="13686282" author="jeffreyz" created="Tue, 18 Jun 2013 01:35:17 +0000"  >&lt;blockquote&gt;
&lt;p&gt;This seems like a hack on the hack. What do we do if the replay fails a second time? (once for original server crash, then a crash while replay, then again when replaying the replay?)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The original sequence number are used to store along with KV so that no matter how many RS failures we have during replay. The original sequence number will be used to determine the ordering.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt; So it IS possible to have an hfile w/ a negative sequence number? (We don&apos;t sort storefiles by sequenceid any more?) &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;No. We only touch mvcc field and hfile sequence id is intact. The negative mvcc value is only used to break the tie.(use the negative mvcc field if it&apos;s present instead of default hfile sequence id)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;How do the replays work in memstore? &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;new writes with positive mvcc wins because replay writes have negative mvcc values. Once the memstore is flushed, the negative mvcc number is used only to replace the default hfile sequence id(if they&apos;re presents) to break tie. Since recovery doesn&apos;t allow reads till full recovery, it should be fine a hfile contains negative and positive mvcc values.&lt;/p&gt;

&lt;p&gt;I&apos;ll creat a test case to see if that&apos;s the case because you raises the good concern.&lt;/p&gt;

</comment>
                            <comment id="13686285" author="jeffreyz" created="Tue, 18 Jun 2013 01:45:45 +0000"  >&lt;blockquote&gt;
&lt;p&gt;the original sequence number are used to store along with KV so that no matter how many RS failures we have during replay&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Basically I mean original sequence number value won&apos;t change even there is a chained RS failures during a recovery. &lt;/p&gt;</comment>
                            <comment id="13686454" author="jeffreyz" created="Tue, 18 Jun 2013 06:58:03 +0000"  >&lt;p&gt;v6 patch added a new test case which does same version updates recovery with writes during recovery process.&lt;/p&gt;

&lt;p&gt;This patch runs all unit tests well with &amp;amp; without distributedLogReplay turn on.&lt;/p&gt;

&lt;p&gt;For basic idea, please see Ted&apos;s v3 patch. &lt;/p&gt;</comment>
                            <comment id="13686885" author="stack" created="Tue, 18 Jun 2013 16:17:17 +0000"  >&lt;blockquote&gt;&lt;p&gt;The original sequence number are used to store along with KV so that no matter how many RS failures we have during replay. The original sequence number will be used to determine the ordering.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jeffreyz&quot; class=&quot;user-hover&quot; rel=&quot;jeffreyz&quot;&gt;Jeffrey Zhong&lt;/a&gt;.  I do not get why we have to have two sequenceids in an edit; the actual and the &apos;original&apos;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;We only touch mvcc field and hfile sequence id is intact. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Doesn&apos;t mvcc make it out to hfile so that when we merge it w/ the memstore (because there was say, an ongoing scan at the time of the flush), that we still respect whatever the mvcc was at the time and not show clients&apos; edits that are not meant for them?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;new writes with positive mvcc wins because replay writes have negative mvcc values. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Do you mean &apos;replace&apos; in the above?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;....the negative mvcc number is used only to replace the default hfile sequence id(if they&apos;re presents) to break tie.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The negative mvcc is out in the hfile occupying the sequenceid-for-the-hfile location?&lt;/p&gt;

&lt;p&gt;I think a test case would help.&lt;/p&gt;</comment>
                            <comment id="13687049" author="v.himanshu" created="Tue, 18 Jun 2013 18:37:15 +0000"  >&lt;p&gt;I have a follow up question on this -ve mvcc stuff.&lt;br/&gt;
Current flusher resets the mvcc point to 0 if it is older than the minimum readpoint across all the scanners. There are two cases here:&lt;/p&gt;

&lt;p&gt;a) Region is under recovery mode: The minimum readpoint will be maxSequenceIds (obtained from the StoreFiles) + 1, as the region is not available for read yet. Thus, it will reset this -ve sequenceId to 0? Flushed hfiles under recovery will not be having -ve numbers?&lt;/p&gt;

&lt;p&gt;Let&apos;s say we changed this and keep the -ve numbers intact.&lt;/p&gt;

&lt;p&gt;b) Recovery is completed, and region is available for read. There might be some scanners open and we would now have some legit min readpoint. &lt;br/&gt;
i) I see that as part of optimization, we set memstoreTS to 0 in case it is &amp;lt; MVCC.readpoint (even while simple scan). &lt;br/&gt;
Do we need to remove that optimization now?&lt;/p&gt;

&lt;p&gt;ii) How we handle the Deletes now. I see SQM comparing memstoreTS with mvccReadPoint at some places (see the match method). Especially settings where it wants to seePastDeleteMarkers, or the CF level attribute of retaining Delete markers. &lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt;, what you think about this delete handling with -ve mvcc values?&lt;/p&gt;

&lt;p&gt;Please let me know what you think of the above concerns. In case I missed something, please correct me. &lt;br/&gt;
Thanks.&lt;/p&gt;</comment>
                            <comment id="13687250" author="enis" created="Tue, 18 Jun 2013 21:54:11 +0000"  >&lt;p&gt;I have opened &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8763&quot; title=&quot;Combine MVCC and SeqId&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8763&quot;&gt;&lt;del&gt;HBASE-8763&lt;/del&gt;&lt;/a&gt; to discuss the MVCC + SeqID semantics further for 0.98+ releases. Let&apos;s use that to gather our long term plans. &lt;/p&gt;</comment>
                            <comment id="13687397" author="yuzhihong@gmail.com" created="Tue, 18 Jun 2013 23:53:27 +0000"  >&lt;p&gt;A new patch is coming which addresses the persistence of sequence Id in the KeyValue&apos;s created by distributed log replay.&lt;/p&gt;</comment>
                            <comment id="13687600" author="jeffreyz" created="Wed, 19 Jun 2013 04:35:11 +0000"  >&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=himanshu%40cloudera.com&quot; class=&quot;user-hover&quot; rel=&quot;himanshu@cloudera.com&quot;&gt;Himanshu Vashishtha&lt;/a&gt; for good comments. In the v7 patch, we really write negative mvcc into hfile. The patch runs all unit tests clean with &amp;amp; without distributedLogReplay.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I do not get why we have to have two sequenceids in an edit; the actual and the &apos;original&apos;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Oh, I see your question now. We don&apos;t have two sequence numbers.(there is no actual sequence number stored in WALEdit) Only this &apos;original&apos; one which is introduced in the patch.  &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Doesn&apos;t mvcc make it out to hfile so that when we merge it w/ the memstore (because there was say, an ongoing scan at the time of the flush), that we still respect whatever the mvcc was at the time and not show clients&apos; edits that are not meant for them?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Good point. Since recovery does NOT allow reads, the situation above won&apos;t happen. A read request will get an exception before actual read logic happens. After recovery. it means all writes are committed so there should be no issue to read them all. Because of the negative mvcc value(logically equal to 0), they will be fetched. The semantics around this are same as recovered edits recovery where MVCC values are 0.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Do you mean &apos;replace&apos; in the above?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;No, there is no replace and both versions of KV with different MVCC values exist in memstore. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The negative mvcc is out in the hfile occupying the sequenceid-for-the-hfile location?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;No. mvcc doesn&apos;t affect sequence id of a hfile because mvcc and sequence number are independent with each other&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;b) Recovery is completed, and region is available for read. There might be some scanners open and we would now have some legit min readpoint.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Read requests will be rejected till the region is recovered by which time all writes are committed. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Do we need to remove that optimization now?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;indeed, we need this. Thanks for the good point.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ii) How we handle the Deletes now.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Deletes won&apos;t be affected because delete always win of the same version no ordering gurantee. I also checked the code and negative mvcc doesn&apos;t affect the scenario you mentioned above.&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;</comment>
                            <comment id="13688648" author="stack" created="Wed, 19 Jun 2013 23:38:03 +0000"  >&lt;blockquote&gt;&lt;p&gt;Oh, I see your question now. We don&apos;t have two sequence numbers.(there is no actual sequence number stored in WALEdit) Only this &apos;original&apos; one which is introduced in the patch.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I was confusing WALEdit w/ HLogKey.  HLogKey has a seqid.  You are hoisting the seqid from HLogKey into WALEdit?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The semantics around this are same as recovered edits recovery where MVCC values are 0.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK.&lt;/p&gt;

&lt;p&gt;But hfiles could have a -ve sequenceid, right?  And these hfiles are added to the set of all hfiles.  How then w/ its -ve number do the hfiles sort on merge?  You have added code so that at merge time, the -ve number is allowed I suppose.&lt;/p&gt;

&lt;p&gt;Let me look at v7 patch.&lt;/p&gt;</comment>
                            <comment id="13688688" author="stack" created="Thu, 20 Jun 2013 00:14:57 +0000"  >&lt;p&gt;How will compactions deal with the -ve sequenceid?  Compactions select adjacent files.  They figure adjancey using sequenceid?&lt;/p&gt;</comment>
                            <comment id="13688707" author="sershe" created="Thu, 20 Jun 2013 00:35:01 +0000"  >&lt;p&gt;No, they don&apos;t... we discussed that during pre-Con meetup, compactions will have to be disabled (or made smarter - only existing files, or only new files, can be compacted) during recovery w/writes enabled.&lt;/p&gt;</comment>
                            <comment id="13688818" author="stack" created="Thu, 20 Jun 2013 02:59:11 +0000"  >&lt;blockquote&gt;&lt;p&gt;No, they don&apos;t... we discussed that during pre-Con meetup, compactions will have to be disabled (or made smarter - only existing files, or only new files, can be compacted) during recovery w/writes enabled.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sershe&quot; class=&quot;user-hover&quot; rel=&quot;sershe&quot;&gt;Sergey Shelukhin&lt;/a&gt; Sounds like we can have hfiles w/ -ve sequenceid.  It can contain replayed edits and edits that came in during replay.  We flip the region to start taking reads (and reenable compactions).  Compactions currently &amp;#8211; until kvs include a seqid &amp;#8211; are compacting adjacent files.  If we are figuring adjaceny using seqid, the -ve file goes to the end of the line though it was most-recently-written file.&lt;/p&gt;</comment>
                            <comment id="13688867" author="stack" created="Thu, 20 Jun 2013 04:51:02 +0000"  >&lt;p&gt;Looking at v7:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+      &lt;span class=&quot;code-comment&quot;&gt;// If both KeyValues carry seq Id, there is no need to negate the result of comparison
&lt;/span&gt;+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (left.getMemstoreTS() &amp;lt; 0 &amp;amp;&amp;amp; right.getMemstoreTS() &amp;lt; 0) {
+        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; Longs.compare(left.getMemstoreTS(), right.getMemstoreTS());
+      }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Needs better comment.  The value being compared is a ts but its called a seqid in the comment.  Confusing.&lt;/p&gt;

&lt;p&gt;Woah... whats up here?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-      decodeMemstoreTS = Bytes.toLong(fileInfo.get(HFileWriterV2.MAX_MEMSTORE_TS_KEY)) &amp;gt; 0;
+      &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] needDecoding = fileInfo.get(HFileWriterV2.NEED_DECODE_MEMSTORE_TS_KEY);
+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (needDecoding != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
+        decodeMemstoreTS = Bytes.toBoolean(needDecoding);
+      } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
+        decodeMemstoreTS = Bytes.toLong(fileInfo.get(HFileWriterV2.MAX_MEMSTORE_TS_KEY)) &amp;gt; 0;
+      }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Sometimes its a boolean and other times its a ts?&lt;/p&gt;

&lt;p&gt;What is the &apos;decoding&apos; that is going on here?&lt;/p&gt;

&lt;p&gt;Regards 200M.&lt;/p&gt;

&lt;p&gt;+ RS A crashes.  It was carrying 15 WALs.  The last WAL was unfinished.&lt;br/&gt;
+ RS B gets a region X from RS A.  We open it for writes while we are recovering this region.  We add 200M to its sequenceid because this region has seqids in excess of what the RS is currently carrying.  We take in 1 edit while recovering.  We do not flush.  We crash.&lt;br/&gt;
+ RS C recovers X.  It adds 200M to the its seqid.  We take in 1 edit while recovering X.&lt;/p&gt;

&lt;p&gt;What guarantees are there that the recovery done on RS C has seqids in excess of those of RS B?&lt;/p&gt;

&lt;p&gt;It seems wrong that a region would add itself to the list of recovering regions the HRegionServer is hosting.  Doesn&apos;t the HRegionServer have more context?  (And this is polluting HRegion w/ HRegionServer specifics).  Who judges the region can start accepting reads?  The HRegionServer?  If so, it should be managing whether a region is in recovering state, not the HRegion itself.&lt;/p&gt;

&lt;p&gt;Presumption here is that edits are sorted:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+        Mutation mutation = batchOp.operations[i].getFirst();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Is that safe presumption to make in replay?&lt;/p&gt;

&lt;p&gt;Is this the least sequenceid of the batch?&lt;/p&gt;

&lt;p&gt;No comment on why of a sudden we decide to negate the sequence number:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-          kv.setMemstoreTS(localizedWriteEntry.getWriteNumber());
+          kv.setMemstoreTS(seqId == NO_SEQ_ID ? localizedWriteEntry.getWriteNumber() :
+            -seqId);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Again, what is the difference between these two sequenceids?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
   &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; logSeqNum;
+  &lt;span class=&quot;code-comment&quot;&gt;// used in distributedLogReplay to store original log sequence number of an edit
&lt;/span&gt;+  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; origLogSeqNum;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What is an original log seq num?&lt;/p&gt;

&lt;p&gt;What is going on here?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+        &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; sequenceNum = (logKey.getOrigSequenceNumber() &amp;gt; 0) ? logKey.getOrigSequenceNumber()
+            : logKey.getLogSeqNum();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &apos;orig&apos; seq number is &amp;gt; 0 take it?  Is this &apos;if it is present&apos;?&lt;/p&gt;

&lt;p&gt;We only do this stuff for Puts and Deletes?  Don&apos;t we have other types out in the WAL?&lt;/p&gt;

&lt;p&gt;The HLogKey gets carried into WALEdit?  We have it in two places or it is just when we instantiate the WALEdit replaying edits?  Do we have to add it to WALEdit at all?&lt;/p&gt;

&lt;p&gt;We seem to be polluting types to carry info down into the depths of an HRegion.&lt;/p&gt;




</comment>
                            <comment id="13688954" author="jeffreyz" created="Thu, 20 Jun 2013 07:06:45 +0000"  >&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt; for the comments.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;How will compactions deal with the -ve sequenceid&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The sequence ids of hfile are intact as before.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Sometimes its a boolean and other times its a ts?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;decodeMemstoreTS is boolean. It&apos;s used to indicate hfilereader whether to decode memtoreTS(mvcc) number. An existing optimization to skip mvcc number decoding by using the following logic. Since we use negative mvcc, the optimization may skip decode mvcc number from a hfile.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Bytes.toLong(fileInfo.get(HFileWriterV2.MAX_MEMSTORE_TS_KEY)) &amp;gt; 0;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;Regards 200M.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This part will be updated later by 8741. I left the code there is to let one of my new test case pass where we test same version update comes during recovery.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is that safe presumption to make in replay?&lt;br/&gt;
Is this the least sequenceid of the batch?&lt;br/&gt;
Again, what is the difference between these two sequenceids?&lt;br/&gt;
Do we have to add it to WALEdit at all?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I think we may not need the origSequneceNumber because mvcc is part of KV and should be already written into WAL? Let me try to see if I can cut the origSequenceNumber.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is this &apos;if it is present&apos;?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We only do this stuff for Puts and Deletes? Don&apos;t we have other types out in the WAL?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Only puts and deletes are used for recovery purpose in WAL.&lt;/p&gt;</comment>
                            <comment id="13689316" author="stack" created="Thu, 20 Jun 2013 15:09:21 +0000"  >&lt;blockquote&gt;&lt;p&gt;The sequence ids of hfile are intact as before.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But some can be -ve?  So they will be out of order? (I don&apos;t see special handling in v7 &amp;#8211; I may have missed it).&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;




</comment>
                            <comment id="13690072" author="jeffreyz" created="Fri, 21 Jun 2013 06:51:17 +0000"  >&lt;blockquote&gt;
&lt;p&gt;But some can be -ve? So they will be out of order? &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;the negative mvcc is only used in KV comparison to resolve conflicts when row + timestamp is same. The hfile sequence number used in flush is from current region server log sequence number not the mvcc value. KVs of the same key+timestamp can be out of order in multiple store files while the right KV is selected with the help of these negative mvcc values(origin log sequence number). (You can refer to KVScannerComparator#compare)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is that safe presumption to make in replay?&lt;br/&gt;
Is this the least sequenceid of the batch?&lt;br/&gt;
Do we have to add it to WALEdit at all?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I checked the wal serialization code, kv isn&apos;t PBed and we don&apos;t write mvcc values into wal. Therefore, I still need to add the &quot;original log sequence number&quot; into receiving RS hlogkey of a wal entry to maintain the original order of changes when re-replaying these edits for a RS chain failure scenario.&lt;br/&gt;
During replay, we can use the last sequence id of a batch because a batch request is from a single wal and the relative order of changes is maintained when constructing the batch request. So the last KV wins if there are multiple KVs of the same key + timestamp.&lt;br/&gt;
I don&apos;t have to put the &quot;original seq number&quot; into WALEdit while need to change several method signatures to pass the info down.&lt;/p&gt;
</comment>
                            <comment id="13690521" author="sershe" created="Fri, 21 Jun 2013 17:56:33 +0000"  >&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Sounds like we can have hfiles w/ -ve sequenceid. It can contain replayed edits and edits that came in during replay. We flip the region to start taking reads (and reenable compactions). Compactions currently &#8211; until kvs include a seqid &#8211; are compacting adjacent files. If we are figuring adjaceny using seqid, the -ve file goes to the end of the line though it was most-recently-written file.&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What is -ve? Negative? last time I checked the replayed and new KVs were supposed to go into separate memstores, right? The recovery-memstore can then flush into a file with &quot;old&quot; (WAL-based) seqId, so adjacency would be maintained, we will just have a potential gap for some time which we should be mindful of (i.e. we&apos;ll have some old, good files, some new files from writes-during-recovery, and they would look adjacent but should not be compacted together until the recovered file(s) are inserted &quot;between&quot; them).&lt;br/&gt;
I don&apos;t think we can maintain the same guarantees if new and recovered KVs are written into mixed memstores (unless seqNums are also written there).&lt;/p&gt;</comment>
                            <comment id="13690524" author="sershe" created="Fri, 21 Jun 2013 17:58:36 +0000"  >&lt;p&gt;Well, it&apos;s also possible to ensure there&apos;s only one mixed memstore (as in, entire recovery and writes-during-recovery go into one single memstore), then if recovery can resolve conflicts inside it (using seqNums that are available from recovery I suppose), it can be flushed into correct file. But this is not practical...&lt;/p&gt;</comment>
                            <comment id="13691079" author="jeffreyz" created="Sat, 22 Jun 2013 08:06:29 +0000"  >&lt;p&gt;The basic idea of using MVCC field to store negative sequence number of replay edits is that we can identify the order of edits by referring their change sequence number. Storing negative values is to differentiate normal non-negative MVCC values.&lt;/p&gt;

&lt;p&gt;(Following are for edits of same key + timestamp)&lt;br/&gt;
Since we tag each recovered edit with its sequence number, we don&apos;t need separate memstores to flush. When a store file contains mix recovered edits and writes during recovery, new writes has non-negative mvcc values so they will use the sequence number of its hfile while recovered edits has negative MVCC they will use -MVCC value as their sequence number which are less than the hfile sequence number as we guarantee a newer hfile has higher sequence number. Similar logic is used to resolve recovered redits in different hfiles.&lt;/p&gt;

&lt;p&gt;Since the patch is attached, I think it&apos;s better to suggest potential issues based on patch. You can see basic idea from the small 8701-v3.txt.&lt;/p&gt;</comment>
                            <comment id="13691363" author="stack" created="Sun, 23 Jun 2013 06:51:09 +0000"  >&lt;blockquote&gt;&lt;p&gt;Therefore, I still need to add the &quot;original log sequence number&quot; into receiving RS hlogkey of a wal entry to maintain the original order of changes when re-replaying these edits for a RS chain failure scenario.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The original log sequence number is not serialized? (See #write method).  Should it be?&lt;/p&gt;

&lt;p&gt;I think I understand carrying the first seqid along now but it is messy.&lt;/p&gt;

&lt;p&gt;Let me review more.&lt;/p&gt;</comment>
                            <comment id="13691616" author="stack" created="Sun, 23 Jun 2013 21:47:29 +0000"  >&lt;p&gt;Pardon me.  I see that the &apos;original seqnum&apos; IS serialized, written into WALKey.&lt;/p&gt;

&lt;p&gt;In KV, why there are would be -ve mvcc needs to be explained.&lt;/p&gt;

&lt;p&gt;MINOR_VERSION_WITH_MVCC_SEQ_ID_UNION is defined but not used?&lt;/p&gt;

&lt;p&gt;What is &apos;decoding&apos;?  That it is -ve?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+  /** whether memstore (mvcc) timestamp field needs decoding in reader */
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What is this?  Should it be test for -ve?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (kv.getMemstoreTS() != 0) {
+      &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.needDecodeMemstoreTS = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
+    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Seems like any non-null mvcc needs &apos;decoding&apos;.  If so, do we need this flag stuff going on?  (Sorry for the dumb questions... just trying to figure whats going on here).&lt;/p&gt;

&lt;p&gt;Could you just do this in reader:&lt;/p&gt;

&lt;p&gt;decodeMemstoreTS = Bytes.toLong(fileInfo.get(HFileWriterV2.MAX_MEMSTORE_TS_KEY)) != 0;&lt;/p&gt;

&lt;p&gt;... and have to mess in Writer?&lt;/p&gt;

&lt;p&gt;I have already remarked on  how it is odd that HRegion adds itself to the recovering region list &amp;#8211; that the regionserver should be doing this, not the hregion (it used to be done in OpenRegionHandler?)&lt;/p&gt;

&lt;p&gt;If the log replay edits skip WAL, we don&apos;t have to carry this &apos;original seqid&apos;?  But doing it this way, we can archive WALs as we finish their replay and if the RS we are playing into dies, we can then play any left over WALs... and any WALs it may have accummulated in meantime.&lt;/p&gt;


&lt;p&gt;On this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-          &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.comparator.compare(kvNext, topScanner.peek()) &amp;gt;= 0) {
+          &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.comparator.compare(kvNext, &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.current.getSequenceID(),
+            topScanner.peek(), topScanner.getSequenceID()) &amp;gt;= 0) {
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Do you think above a bug fix?  It looks like hfile is seqid of 0 and memstore is seqid of MAX_VALUE.  Are they ever different?  Does the &apos;orig seqid&apos; ever get in the mix here?&lt;/p&gt;

&lt;p&gt;Is this method used in a few places?&lt;/p&gt;

&lt;p&gt;+    public int compare(KeyValue leftKV, long leftSeqId, KeyValue rightKV, long rightSeqId) {&lt;/p&gt;

&lt;p&gt;Previous we&apos;d get the seqid internal from the left and right key but not we allow the seqid being passed independent of the kvs being compared.  Is that what we want?  Why open up this compare?  For the scan compares on the heap?&lt;/p&gt;

&lt;p&gt;This is pretty fundamental change.  Compares mvcc first, then seqid.&lt;/p&gt;

&lt;p&gt;And if the mvcc is &amp;lt; 0 in the below, what happens?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-          &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (kv.getMemstoreTS() &amp;lt;= smallestReadPoint) {
+          &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (kv.getMemstoreTS() &amp;gt;= 0 &amp;amp;&amp;amp; kv.getMemstoreTS() &amp;lt;= smallestReadPoint) {
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ditto here:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (kv.getMemstoreTS() &amp;lt;= smallestReadPoint) {
+        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (kv.getMemstoreTS() &amp;gt; 0 &amp;amp;&amp;amp; kv.getMemstoreTS() &amp;lt;= smallestReadPoint) {
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;In general, little explanation in the patch on why things are as they are, the HRegion SEQNUM_SAFETY_BUMPER seqid counting needs to be done still (yeah, that is different issue), but high-level, this adds a load of complexity; too hard to follow what is going on (I am still not done w/ review; next up would be trying different failure scenarios).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The sequence ids of hfile are intact as before.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This means that the seqid we flush with is never -ve?&lt;/p&gt;
</comment>
                            <comment id="13692642" author="jeffreyz" created="Tue, 25 Jun 2013 00:56:08 +0000"  >&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt; for the detailed reviews!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I see that the &apos;original seqnum&apos; IS serialized, written into WALKey.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yeah. That&apos;s introduced by the latest patch to handle chained failure scenarios. That&apos;s why you see me the &quot;original sequence number&quot; passed down by WALEdit. If we use &quot;skipWal&quot; for edits replay, we won&apos;t need to do this and also might achieve even better performance. Let me know which way you lean towards.(I personally prefer skipwal option)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Seems like any non-null mvcc needs &apos;decoding&apos;. If so, do we need this flag stuff going on?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Not every one because most case mvcc has values 0 unless we have recovery edits.  mvcc optimization normally writes mvcc out as 0. Since we pass negative mvcc, the MAX_MEMSTORE_TS_KEY will be 0. In that case, hfilereader won&apos;t read the negative mvcc value at all which against the purpose to use mvcc to store negative sequence number. I&apos;ll change the boolean decodeMemstoreTS to a long MIN_MEMSTORE_TS_KEY to be more clear on whether a hfile contains negative mvcc values.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I have already remarked on how it is odd that HRegion adds itself to the recovering region list &#8211; that the regionserver should be doing this, not the hregion (it used to be done in OpenRegionHandler?)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I&apos;ll modify this part.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Previous we&apos;d get the seqid internal from the left and right key but not we allow the seqid being passed independent of the kvs being compared. Is that what we want?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This is to pass enough information to the compare() method in calls where only&#160;KeyValue&apos;s were passed before.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;MINOR_VERSION_WITH_MVCC_SEQ_ID_UNION is defined but not used?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;It serves the purpose for developers to know what purpose minor version 4 serves. Having a constant for version 4 is in line with prior practice.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This means that the seqid we flush with is never -ve?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;That&apos;s correct. I can add an assertion here.&lt;/p&gt;

&lt;p&gt;I&apos;ll try to provide a new patch based on your feedbacks. Thanks.&lt;/p&gt;</comment>
                            <comment id="13696063" author="jeffreyz" created="Sat, 29 Jun 2013 06:28:56 +0000"  >&lt;p&gt;In v8 patch, I incorporated &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt;&apos;s feedbacks and added a test case regarding compactions on hfiles containing negative mvcc values. &lt;/p&gt;

&lt;p&gt;In the patch, I didn&apos;t use skipWal for replay because it may causes many flushes(number of wals * number of regions of a wal) and not ideal fail over handling(have to replay the whole wal when receiving RS fails during replay)&lt;/p&gt;
</comment>
                            <comment id="13696066" author="thomaspan" created="Sat, 29 Jun 2013 06:31:23 +0000"  >&lt;p&gt;Happy holidays! I am out of office from June 28 to July 7 during July 4th week. Please contact Pradeep for any urgent issues. $0.02, -Thomas&lt;/p&gt;</comment>
                            <comment id="13696072" author="hadoopqa" created="Sat, 29 Jun 2013 08:13:45 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12590155/hbase-8701-v8.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12590155/hbase-8701-v8.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision .&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 6 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop1.0&lt;/font&gt;.  The patch compiles against the hadoop 1.0 profile.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop2.0&lt;/font&gt;.  The patch compiles against the hadoop 2.0 profile.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javadoc&lt;/font&gt;.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any new Findbugs (version 1.3.9) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 lineLengths&lt;/font&gt;.  The patch introduces lines longer than 100&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 core tests&lt;/font&gt;.  The patch passed unit tests in .&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop1-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop1-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/6171//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="13752704" author="stack" created="Wed, 28 Aug 2013 18:39:51 +0000"  >&lt;p&gt;Whats up w/ this patch?  Just needs more review?  Any testing &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jeffreyz&quot; class=&quot;user-hover&quot; rel=&quot;jeffreyz&quot;&gt;Jeffrey Zhong&lt;/a&gt;?&lt;/p&gt;</comment>
                            <comment id="13752882" author="jeffreyz" created="Wed, 28 Aug 2013 21:41:44 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt; The patch just needs rebase while it is using negative mvcc to store change sequence number of WALEdits to handle updates with same version. Since tag support is in horizon, I&apos;d like to port this patch using tags instead of mvcc field.  &lt;/p&gt;</comment>
                            <comment id="13752898" author="stack" created="Wed, 28 Aug 2013 21:51:34 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jeffreyz&quot; class=&quot;user-hover&quot; rel=&quot;jeffreyz&quot;&gt;Jeffrey Zhong&lt;/a&gt; I like that plan.  Moving out of 0.96&lt;/p&gt;</comment>
                            <comment id="13849420" author="jeffreyz" created="Mon, 16 Dec 2013 18:20:53 +0000"  >&lt;p&gt;Port the old patch to use tag. &lt;/p&gt;

&lt;p&gt;1) During KeyValue comparison after rowkey, colfam/qual, timestamp, type are compared(same key), log sequence number will be used if there is any otherwise mvcc will be used. So the extra cost to fetch the log sequence number from tag is trivial because comparison normally terminates much earlier before reaching log sequence number or mvcc. &lt;/p&gt;

&lt;p&gt;2) Only edits being replayed during recovery will be tagged with their own original log sequence number therefore the extra tag storage overhead is insignificant considering recovery doesn&apos;t happen often and tagging is only applied upon unflushed edits.&lt;/p&gt;</comment>
                            <comment id="13849591" author="yuzhihong@gmail.com" created="Mon, 16 Dec 2013 18:56:12 +0000"  >&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; Longs.compare(right.getMvccVersion(), left.getMvccVersion());
+      &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; leftChangeSeqNum = getReplaySeqNum(left);
+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (leftChangeSeqNum &amp;lt; 0) {
+        leftChangeSeqNum = left.getMvccVersion();
+      }
+      &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; RightChangeSeqNum = getReplaySeqNum(right);
+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (RightChangeSeqNum &amp;lt; 0) {
+        RightChangeSeqNum = right.getMvccVersion();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;What would happen if one Cell has sequence Id but the other cell doesn&apos;t have sequence Id ?&lt;/p&gt;

&lt;p&gt;Can you put the patch on review board ?&lt;/p&gt;

&lt;p&gt;Thanks&lt;/p&gt;</comment>
                            <comment id="13849634" author="jeffreyz" created="Mon, 16 Dec 2013 19:32:50 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=tedyu%40apache.org&quot; class=&quot;user-hover&quot; rel=&quot;tedyu@apache.org&quot;&gt;Ted Yu&lt;/a&gt; A good point. I&apos;ve updated the patch and moved it to review board(&lt;a href=&quot;https://reviews.apache.org/r/16304/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/16304/&lt;/a&gt;). Thanks.&lt;/p&gt;</comment>
                            <comment id="13849651" author="hadoopqa" created="Mon, 16 Dec 2013 19:50:32 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12618942/hbase-8701-tag.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12618942/hbase-8701-tag.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision .&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 6 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop1.0&lt;/font&gt;.  The patch compiles against the hadoop 1.0 profile.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop1.1&lt;/font&gt;.  The patch compiles against the hadoop 1.1 profile.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 javadoc&lt;/font&gt;.  The javadoc tool appears to have generated 1 warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 findbugs&lt;/font&gt;.  The patch appears to introduce 1 new Findbugs (version 1.3.9) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 site&lt;/font&gt;.  The patch appears to cause mvn site goal to fail.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 core tests&lt;/font&gt;.  The patch passed unit tests in .&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8176//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="13849786" author="hadoopqa" created="Mon, 16 Dec 2013 22:08:08 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12618955/hbase-8701-tag-v1.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12618955/hbase-8701-tag-v1.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision .&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 6 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop1.0&lt;/font&gt;.  The patch compiles against the hadoop 1.0 profile.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop1.1&lt;/font&gt;.  The patch compiles against the hadoop 1.1 profile.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 javadoc&lt;/font&gt;.  The javadoc tool appears to have generated 1 warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 findbugs&lt;/font&gt;.  The patch appears to introduce 1 new Findbugs (version 1.3.9) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 site&lt;/font&gt;.  The patch appears to cause mvn site goal to fail.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 core tests&lt;/font&gt;.  The patch passed unit tests in .&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8188//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="13851290" author="jeffreyz" created="Wed, 18 Dec 2013 02:39:46 +0000"  >&lt;p&gt;Incorporate the comments and make distributedLogReplay on by default when HFile v3 is used.&lt;/p&gt;</comment>
                            <comment id="13851291" author="jeffreyz" created="Wed, 18 Dec 2013 02:40:49 +0000"  >&lt;p&gt;There are two test case failures under TestVisibilityLabels due to known issues when distributedLogReplay is on.&lt;/p&gt;</comment>
                            <comment id="13851310" author="anoop.hbase" created="Wed, 18 Dec 2013 03:19:47 +0000"  >&lt;p&gt;Yes. &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10148&quot; title=&quot;[VisibilityController] Tolerate regions in recovery&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10148&quot;&gt;&lt;del&gt;HBASE-10148&lt;/del&gt;&lt;/a&gt; will solve that.. Hope I can commit that today&lt;/p&gt;</comment>
                            <comment id="13851337" author="hadoopqa" created="Wed, 18 Dec 2013 03:57:27 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12619233/hbase-8701-tag-v2.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12619233/hbase-8701-tag-v2.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision .&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 9 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop1.0&lt;/font&gt;.  The patch compiles against the hadoop 1.0 profile.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop1.1&lt;/font&gt;.  The patch compiles against the hadoop 1.1 profile.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 javadoc&lt;/font&gt;.  The javadoc tool appears to have generated 1 warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any new Findbugs (version 1.3.9) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 site&lt;/font&gt;.  The patch appears to cause mvn site goal to fail.&lt;/p&gt;

&lt;p&gt;     &lt;font color=&quot;red&quot;&gt;-1 core tests&lt;/font&gt;.  The patch failed these unit tests:&lt;br/&gt;
                       org.apache.hadoop.hbase.security.visibility.TestVisibilityLabels&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8207//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="13852059" author="jeffreyz" created="Wed, 18 Dec 2013 19:28:03 +0000"  >&lt;p&gt;Reattached tag-v2 patch to fix a javadoc warning&lt;/p&gt;</comment>
                            <comment id="13852154" author="hadoopqa" created="Wed, 18 Dec 2013 20:56:21 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12619390/hbase-8701-tag-v2.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12619390/hbase-8701-tag-v2.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision .&lt;br/&gt;
  ATTACHMENT ID: 12619390&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 9 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop1.0&lt;/font&gt;.  The patch compiles against the hadoop 1.0 profile.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop1.1&lt;/font&gt;.  The patch compiles against the hadoop 1.1 profile.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javadoc&lt;/font&gt;.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any new Findbugs (version 1.3.9) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 site&lt;/font&gt;.  The patch appears to cause mvn site goal to fail.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 core tests&lt;/font&gt;.  The patch passed unit tests in .&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8214//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="13852282" author="stack" created="Wed, 18 Dec 2013 23:17:35 +0000"  >&lt;p&gt;It will be odd if this feature is enable when hfilev3 is enabled.  It will be unexpected.  Since hfilev3 will not be on by default in 0.98, but it will be in trunk, this facility should probably go the same route.  Otherwise +1 &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jeffreyz&quot; class=&quot;user-hover&quot; rel=&quot;jeffreyz&quot;&gt;Jeffrey Zhong&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13853237" author="jeffreyz" created="Thu, 19 Dec 2013 20:00:56 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt; The v2-update patch removed the logic by turn distributedLogReplay on when HFile V3 is used. I&apos;ll turn on it by default whenever tags is turned on in trunk or other branches. &lt;/p&gt;

&lt;p&gt;I also run the whole test suite successfully with distributedLogReplay is on. &lt;/p&gt;</comment>
                            <comment id="13853242" author="stack" created="Thu, 19 Dec 2013 20:06:19 +0000"  >&lt;p&gt;+1 from me.  It is relatively safe +1&apos;ing this when it is not the default.  &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=himanshu%40cloudera.com&quot; class=&quot;user-hover&quot; rel=&quot;himanshu@cloudera.com&quot;&gt;Himanshu Vashishtha&lt;/a&gt; You have any comments on this patch?&lt;/p&gt;</comment>
                            <comment id="13853359" author="hadoopqa" created="Thu, 19 Dec 2013 21:50:59 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12619647/hbase-8701-tag-v2-update.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12619647/hbase-8701-tag-v2-update.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision .&lt;br/&gt;
  ATTACHMENT ID: 12619647&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 9 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop1.0&lt;/font&gt;.  The patch compiles against the hadoop 1.0 profile.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop1.1&lt;/font&gt;.  The patch compiles against the hadoop 1.1 profile.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javadoc&lt;/font&gt;.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any new Findbugs (version 1.3.9) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 site&lt;/font&gt;.  The patch appears to cause mvn site goal to fail.&lt;/p&gt;

&lt;p&gt;     &lt;font color=&quot;red&quot;&gt;-1 core tests&lt;/font&gt;.  The patch failed these unit tests:&lt;br/&gt;
                       org.apache.hadoop.hbase.master.TestDistributedLogSplitting&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8232//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="13854563" author="stack" created="Fri, 20 Dec 2013 21:13:24 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jeffreyz&quot; class=&quot;user-hover&quot; rel=&quot;jeffreyz&quot;&gt;Jeffrey Zhong&lt;/a&gt; Go ahead commit.  Himanshu is busy these times firefighting.&lt;/p&gt;</comment>
                            <comment id="13854633" author="jeffreyz" created="Fri, 20 Dec 2013 22:32:03 +0000"  >&lt;p&gt;Thanks for the reviews! I&apos;ve integrated the patch into 0.98 and trunk. &lt;/p&gt;</comment>
                            <comment id="13855039" author="hudson" created="Sun, 22 Dec 2013 00:53:41 +0000"  >&lt;p&gt;SUCCESS: Integrated in HBase-TRUNK #4742 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-TRUNK/4742/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-TRUNK/4742/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8701&quot; title=&quot;distributedLogReplay need to apply wal edits in the receiving order of those edits&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8701&quot;&gt;&lt;del&gt;HBASE-8701&lt;/del&gt;&lt;/a&gt;: distributedLogReplay need to apply wal edits in the receiving order of those edits (jeffreyz: rev 1552828)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/trunk/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-common/src/main/java/org/apache/hadoop/hbase/Tag.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-common/src/main/java/org/apache/hadoop/hbase/TagType.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterFileSystem.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/RegionStates.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/SplitLogManager.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/handler/ServerShutdownHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/SplitLogWorker.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/HLogSplitter.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlLists.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityUtils.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/HBaseTestingUtility.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestDistributedLogSplitting.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterNoCluster.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13855086" author="hudson" created="Sun, 22 Dec 2013 03:46:08 +0000"  >&lt;p&gt;FAILURE: Integrated in HBase-TRUNK-on-Hadoop-1.1 #14 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-TRUNK-on-Hadoop-1.1/14/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-TRUNK-on-Hadoop-1.1/14/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8701&quot; title=&quot;distributedLogReplay need to apply wal edits in the receiving order of those edits&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8701&quot;&gt;&lt;del&gt;HBASE-8701&lt;/del&gt;&lt;/a&gt;: distributedLogReplay need to apply wal edits in the receiving order of those edits (jeffreyz: rev 1552828)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/trunk/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-common/src/main/java/org/apache/hadoop/hbase/Tag.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-common/src/main/java/org/apache/hadoop/hbase/TagType.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterFileSystem.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/RegionStates.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/SplitLogManager.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/master/handler/ServerShutdownHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/SplitLogWorker.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/HLogSplitter.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlLists.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityUtils.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/HBaseTestingUtility.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestDistributedLogSplitting.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterNoCluster.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13855260" author="hudson" created="Sun, 22 Dec 2013 20:31:42 +0000"  >&lt;p&gt;SUCCESS: Integrated in HBase-0.98 #28 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-0.98/28/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-0.98/28/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8701&quot; title=&quot;distributedLogReplay need to apply wal edits in the receiving order of those edits&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8701&quot;&gt;&lt;del&gt;HBASE-8701&lt;/del&gt;&lt;/a&gt;: distributedLogReplay need to apply wal edits in the receiving order of those edits (jeffreyz: rev 1552831)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-common/src/main/java/org/apache/hadoop/hbase/Tag.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-common/src/main/java/org/apache/hadoop/hbase/TagType.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterFileSystem.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/master/RegionStates.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/master/SplitLogManager.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/master/handler/ServerShutdownHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/SplitLogWorker.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/HLogSplitter.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlLists.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityUtils.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/test/java/org/apache/hadoop/hbase/HBaseTestingUtility.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestDistributedLogSplitting.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterNoCluster.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13855315" author="hudson" created="Mon, 23 Dec 2013 00:02:19 +0000"  >&lt;p&gt;SUCCESS: Integrated in HBase-0.98-on-Hadoop-1.1 #25 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-0.98-on-Hadoop-1.1/25/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-0.98-on-Hadoop-1.1/25/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8701&quot; title=&quot;distributedLogReplay need to apply wal edits in the receiving order of those edits&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8701&quot;&gt;&lt;del&gt;HBASE-8701&lt;/del&gt;&lt;/a&gt;: distributedLogReplay need to apply wal edits in the receiving order of those edits (jeffreyz: rev 1552831)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-common/src/main/java/org/apache/hadoop/hbase/Tag.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-common/src/main/java/org/apache/hadoop/hbase/TagType.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterFileSystem.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/master/RegionStates.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/master/SplitLogManager.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/master/handler/ServerShutdownHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/SplitLogWorker.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/HLogSplitter.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessControlLists.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/main/java/org/apache/hadoop/hbase/security/visibility/VisibilityUtils.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/test/java/org/apache/hadoop/hbase/HBaseTestingUtility.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestDistributedLogSplitting.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.98/hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMasterNoCluster.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14330777" author="enis" created="Sat, 21 Feb 2015 23:31:05 +0000"  >&lt;p&gt;Closing this issue after 0.99.0 release. &lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12612336">HBASE-7006</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12588135" name="8701-v3.txt" size="8730" author="yuzhihong@gmail.com" created="Mon, 17 Jun 2013 13:09:29 +0000"/>
                            <attachment id="12618955" name="hbase-8701-tag-v1.patch" size="27591" author="jeffreyz" created="Mon, 16 Dec 2013 19:32:50 +0000"/>
                            <attachment id="12619647" name="hbase-8701-tag-v2-update.patch" size="45194" author="jeffreyz" created="Thu, 19 Dec 2013 20:00:56 +0000"/>
                            <attachment id="12619390" name="hbase-8701-tag-v2.patch" size="45328" author="jeffreyz" created="Wed, 18 Dec 2013 19:28:03 +0000"/>
                            <attachment id="12618942" name="hbase-8701-tag.patch" size="27015" author="jeffreyz" created="Mon, 16 Dec 2013 18:20:53 +0000"/>
                            <attachment id="12588222" name="hbase-8701-v4.patch" size="33576" author="jeffreyz" created="Mon, 17 Jun 2013 21:13:11 +0000"/>
                            <attachment id="12588249" name="hbase-8701-v5.patch" size="33516" author="jeffreyz" created="Mon, 17 Jun 2013 23:21:28 +0000"/>
                            <attachment id="12588301" name="hbase-8701-v6.patch" size="37780" author="jeffreyz" created="Tue, 18 Jun 2013 06:58:03 +0000"/>
                            <attachment id="12588537" name="hbase-8701-v7.patch" size="42505" author="jeffreyz" created="Wed, 19 Jun 2013 04:35:11 +0000"/>
                            <attachment id="12590155" name="hbase-8701-v8.patch" size="48239" author="jeffreyz" created="Sat, 29 Jun 2013 06:28:56 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>10.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 7 Jun 2013 20:26:13 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>331741</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310191" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Hadoop Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10343"><![CDATA[Reviewed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            1 year, 42 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1l8bb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>332072</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>