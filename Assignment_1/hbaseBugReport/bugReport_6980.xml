<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:41:36 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-6980/HBASE-6980.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-6980] Parallel Flushing Of Memstores [89-fb]</title>
                <link>https://issues.apache.org/jira/browse/HBASE-6980</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;For write dominated workloads, single threaded memstore flushing is an unnecessary bottleneck. With a single flusher thread, we are basically not setup to take advantage of the aggregate throughput that multi-disk nodes provide.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;For puts with WAL enabled, the bottleneck is more likely the &quot;single&quot; WAL per region server. So this particular fix may not buy as much unless we unlock that bottleneck with multiple commit logs per region server. (Topic for a separate JIRA-- &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-6981&quot; title=&quot;multiple commit logs per region server&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-6981&quot;&gt;&lt;del&gt;HBASE-6981&lt;/del&gt;&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;But for puts with WAL disabled (e.g., when using &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5783&quot; title=&quot;Faster HBase bulk loader&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5783&quot;&gt;&lt;del&gt;HBASE-5783&lt;/del&gt;&lt;/a&gt; style fast bulk imports), we should be able to support much better ingest rates with parallel flushing of memstores.&lt;/li&gt;
&lt;/ul&gt;
</description>
                <environment></environment>
        <key id="12611425">HBASE-6980</key>
            <summary>Parallel Flushing Of Memstores [89-fb]</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kannanm">Kannan Muthukkaruppan</assignee>
                                    <reporter username="kannanm">Kannan Muthukkaruppan</reporter>
                        <labels>
                    </labels>
                <created>Thu, 11 Oct 2012 20:24:46 +0000</created>
                <updated>Sat, 9 Feb 2013 06:54:19 +0000</updated>
                            <resolved>Sat, 9 Feb 2013 06:54:19 +0000</resolved>
                                                    <fixVersion>0.89-fb</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>11</watches>
                                                                <comments>
                            <comment id="13476528" author="kannanm" created="Mon, 15 Oct 2012 22:24:03 +0000"  >&lt;p&gt;I did a quick prototype against 89-fb with expected results. In my test setup, I was doing WAL-less puts, and previously wasn&apos;t able to go much beyond 100MB/second of ingest into HBase, but with parallel flushing, was able to get 3-4x improvement.&lt;/p&gt;

&lt;p&gt;Two locks that got in the way of the implementation were (which I temporarily just commented out in the prototype) are:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;In MemStoreFlusher.java, the lock variable named &quot;lock&quot; seems to be getting acquired in MemStoreFlusher.java:interruptIfNecessary() to ensure that an orderly shutdown is done after any in-progress flush completes.  Because the flushRegion() also grabs the same lock, we will need to figure out if we can simply get rid of the lock or use reader-writer locks (such that the flushers can grab it in read mode, and the interrupt grabs it in write mode).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;In HLog.java: startCacheFlush/completeCacheFlush() grab the cacheFlushLock. This lock is also grabbed by the log roller (rollWriter()) and HLog.close() methods. It is not clear to me yet why the rollWriter() needs to grab the cacheFlushLock.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If anyone has further thoughts on a good resolution for the above locks or the exact original intent for those locks (Stack?), please share your ideas.&lt;/p&gt;</comment>
                            <comment id="13476543" author="yuzhihong@gmail.com" created="Mon, 15 Oct 2012 22:49:36 +0000"  >&lt;p&gt;Here is javadoc for cacheFlushLock:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-comment&quot;&gt;// This lock prevents starting a log roll during a cache flush.
&lt;/span&gt;  &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; is insufficient because a cache flush spans two method calls.
&lt;/span&gt;  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; ReentrantReadWriteLock cacheFlushLock = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ReentrantReadWriteLock();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13476571" author="kannanm" created="Mon, 15 Oct 2012 23:31:43 +0000"  >&lt;p&gt;Ted:&lt;/p&gt;

&lt;p&gt;#1. I did see that javadoc. But I am still not clear why log rolling and flushes need to be mutually exclusive of each other. As long as we correctly track what is the min sequence id that has not yet been flushed, log rolling can maintain its correctness independent of the actual on-going flushes, right?&lt;/p&gt;

&lt;p&gt;#2. Also, in the code I saw for trunk:&lt;/p&gt;

&lt;p&gt;src/main/java/org/apache/hadoop/hbase/regionserver/wal/FSHLog.java:191:  &lt;/p&gt;

&lt;p&gt;private final Lock cacheFlushLock = new ReentrantLock();&lt;/p&gt;

&lt;p&gt;the lock was a RentrantLock(). &lt;/p&gt;

&lt;p&gt;In the code you pasted, however, it is ReentrantReadWriteLock(). &lt;/p&gt;

&lt;p&gt;Can you confirm with svn repo you are referring to? The one I checked was: &lt;a href=&quot;https://svn.apache.org/repos/asf/hbase/trunk/hbase-server&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/repos/asf/hbase/trunk/hbase-server&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;regards,&lt;br/&gt;
Kannan&lt;/p&gt;</comment>
                            <comment id="13476579" author="yuzhihong@gmail.com" created="Mon, 15 Oct 2012 23:44:03 +0000"  >&lt;p&gt;Turned out that I was looking at a local copy with &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-6466&quot; title=&quot;Enable multi-thread for memstore flush&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-6466&quot;&gt;&lt;del&gt;HBASE-6466&lt;/del&gt;&lt;/a&gt;.&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-6466&quot; title=&quot;Enable multi-thread for memstore flush&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-6466&quot;&gt;&lt;del&gt;HBASE-6466&lt;/del&gt;&lt;/a&gt; has similar goal with this JIRA.&lt;/p&gt;</comment>
                            <comment id="13476595" author="kannanm" created="Tue, 16 Oct 2012 00:09:33 +0000"  >&lt;p&gt;Thanks for the pointer-- wasn&apos;t aware of the JIRA. I am ok with closing this as a dup, or keep this for the 89-fb patch as the code base is slightly different in some of the parts.  (I think &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-6466&quot; title=&quot;Enable multi-thread for memstore flush&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-6466&quot;&gt;&lt;del&gt;HBASE-6466&lt;/del&gt;&lt;/a&gt; description doesn&apos;t adequately capture the motivation/wins we can get from this, especially for WAL-less ingest type use case. But we can update the description for that JIRA to reflect those aspects).&lt;/p&gt;

&lt;p&gt;I will check the patch to see how Chunhui is getting around the locks. &lt;/p&gt;</comment>
                            <comment id="13476602" author="kannanm" created="Tue, 16 Oct 2012 00:25:34 +0000"  >&lt;p&gt;The patch is also using reader-writer locks as I had mentioned... but the open question still remains- can we do better? I suppose for the purpose of parallelizing flusher threads, that suffices. But can anyone think of a good reason why cacheFlushLock needs to be grabbed by log rolling code at all?&lt;/p&gt;</comment>
                            <comment id="13476756" author="ram_krish" created="Tue, 16 Oct 2012 05:34:12 +0000"  >&lt;p&gt;@Kannan&lt;br/&gt;
I can try to explain what i see from the code.  I am sure you would have checked but just in case you have not.  I may be wrong so pls correct me.&lt;br/&gt;
From the flush code we see that once we do the startFlush() we acquire the cacheFlushLock.&lt;br/&gt;
The same is cleared in completeCacheFlush().  It is here where we write the latest seqid corresponding to that flush.  Suppose the seq ids 2,3,4 are getting flushed we write a seq id 5 for the current flush entry.  &lt;br/&gt;
As the javadoc too says, now suppose a log rolling happens without cacheflush lock&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; (updateLock) {
        &lt;span class=&quot;code-comment&quot;&gt;// Clean up current writer.
&lt;/span&gt;        Path oldFile = cleanupCurrentWriter(currentFilenum);
        &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.writer = nextWriter;
        &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.hdfs_out = nextHdfsOut;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The log writer may be changed and the completeCacheflush may write to a new file (if am not wrong).  &lt;br/&gt;
Also currently whenever we do flush the oldest seq id for the region is removed from the lastSeqWritten and the same is again populated back with a sort of encoded name for the region&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt; oldseq =
        lastSeqWritten.put(getSnapshotName(encodedRegionName), seq);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This was done for a dataloss issue by FB.  So may be if we don acquire the cacheFlushLock on rollWriter, the rollWriter() may see some regions(with encoded name) which has min seq id and will try to flush them too in&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
 &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; [] getOldestRegion(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt; oldestOutstandingSeqNum) {
    &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; [] oldestRegion = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
    &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (Map.Entry&amp;lt;&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; [], &lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;&amp;gt; e: &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.lastSeqWritten.entrySet()) {
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (e.getValue().longValue() == oldestOutstandingSeqNum.longValue()) {
        &lt;span class=&quot;code-comment&quot;&gt;// Key is encoded region name.
&lt;/span&gt;        oldestRegion = e.getKey();
        &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
      }
    }
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; oldestRegion;
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;May be other experts can give a better answer if am not right here. Thanks.&lt;/p&gt;</comment>
                            <comment id="13477194" author="karthik.ranga" created="Tue, 16 Oct 2012 17:34:44 +0000"  >&lt;p&gt;@ramakrishna - this should not be necessary for ensuring no data loss right? Once we have a snapshot memstore, we automatically should know the max seq id to which it has data - that would never change.&lt;/p&gt;

&lt;p&gt;1. From what I remember of the code (when I was looking into something unrelated), we track the &lt;b&gt;min&lt;/b&gt; seq id from the current memstore instead of the max seq id from the snapshot memstore to put into the HLog when its rolled after a flush. So this synchronization becomes necessary - if we store the max seq id along with the memstore that is flushed, we should be able to eliminate the locks.&lt;/p&gt;

&lt;p&gt;2. Also, its arguable if we need the absolute correct max-seq-id flushed. In a very small % of cases, we would end up rolling logs a bit slower. As long as we are conservative with updating the max seq id in the HLog we should be good, right?&lt;/p&gt;</comment>
                            <comment id="13477575" author="kannanm" created="Wed, 17 Oct 2012 03:35:38 +0000"  >&lt;p&gt;Ramakrishna,&lt;/p&gt;

&lt;p&gt;Thanks for your email.&lt;/p&gt;

&lt;p&gt;#1. It is not clear why we even write a META entry for flushes...&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; WALEdit completeCacheFlushLogEdit() {
    KeyValue kv = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; KeyValue(METAROW, METAFAMILY, &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;,
      &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis(), COMPLETE_CACHE_FLUSH);
    WALEdit e = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; WALEdit();
    e.add(kv);
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; e;
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The replayRecoveredEdits() logic skips over these entries anyway. And the only reference I see for this special entry in HLog is in unit tests.&lt;/p&gt;

&lt;p&gt;#2. Yes, currently there is a lot of comments (related to lastSeqWritten) before the function HLog.java:startCacheFlush(), but the logic is not very clear to me. The changes were committed as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3845&quot; title=&quot;data loss because lastSeqWritten can miss memstore edits&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3845&quot;&gt;&lt;del&gt;HBASE-3845&lt;/del&gt;&lt;/a&gt;. I think we should be able to simplify that logic. I think I see some potential bugs there even it stands now-- will need to spend some more time looking at this, and will write down an update here.&lt;/p&gt;

&lt;p&gt;But bottom line, I still don&apos;t see any good fundamental reason we need to hold this lock for the duration of the entire flush (even given the lastSeqWritten map logic).&lt;/p&gt;</comment>
                            <comment id="13477647" author="ram_krish" created="Wed, 17 Oct 2012 06:08:36 +0000"  >&lt;blockquote&gt;&lt;p&gt;#1. It is not clear why we even write a META entry for flushes...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes.  This is actually not used but still that forms the latest entry.  So currently in 0.94 and trunk uses a map to form the name of the replayedits file that should have the seq id of maximum of the edits.  Previously i remember that it was minimum of the seq id that was used for naming the replayEdits. &lt;br/&gt;
In one of the issues we were discussing on the usefulness of the meta data entry after flush. We can once again verify and we can remove it if there is not much usefulness from it.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;we track the min seq id from the current memstore instead of the max seq id from the snapshot memstore&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The HLog keeps track of the minSeqid for the region. So you suggesting that we can only track the max seq id whenever an append happens to HLog? So on flush start we just clear this entry and use that max value for completing the flush. &lt;br/&gt;
Thanks for the insights.  &lt;/p&gt;
</comment>
                            <comment id="13478212" author="tlipcon" created="Wed, 17 Oct 2012 18:41:47 +0000"  >&lt;p&gt;If I remember correctly, there is a reason for the flush marker: it ensures that the RS hasn&apos;t been fenced on HDFS &amp;#8211; i.e that it hasn&apos;t lost its connection to ZK and already had its log splitting started.&lt;/p&gt;

&lt;p&gt;The reason this is important is that, otherwise, it could move on to delete old log segments, which would potentially break the log split process.&lt;/p&gt;

&lt;p&gt;It may be that the locking can be more lax, though.&lt;/p&gt;</comment>
                            <comment id="13478622" author="kannanm" created="Thu, 18 Oct 2012 03:08:55 +0000"  >&lt;p&gt;Todd: If RS zk expires, and master initiates recovery/log splitting, then the first step is to rename the log directory from .logs/rs to .logs/rs-splitting. And then the lease recovery is done on the individual files within the directory. Because of the directory name, any attempt by the old RS to delete any old log files (in the old path) should fail. Therefore, still not seeing the value of writing the flush marker.&lt;/p&gt;</comment>
                            <comment id="13487263" author="kannanm" created="Tue, 30 Oct 2012 21:24:26 +0000"  >&lt;p&gt;#1) This change has now been committed in 89-fb. Here&apos;s the commit info:&lt;/p&gt;

&lt;p&gt;   &lt;a href=&quot;http://svn.apache.org/viewvc?view=revision&amp;amp;revision=1403627&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?view=revision&amp;amp;revision=1403627&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;#2) This case should also help region server restart time or cluster restart time because when stopping a region server the memstores need to get flushed, and now the flushes can happen in parallel.&lt;/p&gt;</comment>
                            <comment id="13487265" author="kannanm" created="Tue, 30 Oct 2012 21:25:45 +0000"  >&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/viewvc?view=revision&amp;amp;revision=1403627&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc?view=revision&amp;amp;revision=1403627&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13487266" author="kannanm" created="Tue, 30 Oct 2012 21:26:51 +0000"  >&lt;p&gt;@ Todd: any comments on by 17/Oct comment regarding RS expiry handling and flush marker?&lt;/p&gt;</comment>
                            <comment id="13492466" author="apurtell" created="Wed, 7 Nov 2012 16:19:07 +0000"  >&lt;p&gt;Since this was committed to 89-fb should this issue be resolved? Looks like forward porting would be addressed by &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-6466&quot; title=&quot;Enable multi-thread for memstore flush&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-6466&quot;&gt;&lt;del&gt;HBASE-6466&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 15 Oct 2012 22:49:36 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>247787</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 years, 6 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i08pun:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>48787</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>