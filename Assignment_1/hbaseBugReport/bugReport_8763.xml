<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:58:17 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-8763/HBASE-8763.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-8763] Combine MVCC and SeqId</title>
                <link>https://issues.apache.org/jira/browse/HBASE-8763</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8701&quot; title=&quot;distributedLogReplay need to apply wal edits in the receiving order of those edits&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8701&quot;&gt;&lt;del&gt;HBASE-8701&lt;/del&gt;&lt;/a&gt; and a lot of recent issues include good discussions about mvcc + seqId semantics. It seems that having mvcc and the seqId complicates the comparator semantics a lot in regards to flush + WAL replay + compactions + delete markers and out of order puts. &lt;/p&gt;

&lt;p&gt;Thinking more about it I don&apos;t think we need a MVCC write number which is different than the seqId. We can keep the MVCC semantics, read point and smallest read points intact, but combine mvcc write number and seqId. This will allow cleaner semantics + implementation + smaller data files. &lt;/p&gt;

&lt;p&gt;We can do some brainstorming for 0.98. We still have to verify that this would be semantically correct, it should be so by my current understanding.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12653582">HBASE-8763</key>
            <summary>Combine MVCC and SeqId</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.png">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="jeffreyz">Jeffrey Zhong</assignee>
                                    <reporter username="enis">Enis Soztutar</reporter>
                        <labels>
                    </labels>
                <created>Tue, 18 Jun 2013 21:51:47 +0000</created>
                <updated>Sat, 6 Feb 2016 15:51:31 +0000</updated>
                            <resolved>Sat, 7 Jun 2014 01:26:41 +0000</resolved>
                                                    <fixVersion>0.99.0</fixVersion>
                                    <component>regionserver</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>33</watches>
                                                                                                            <comments>
                            <comment id="13687345" author="enis" created="Tue, 18 Jun 2013 23:01:59 +0000"  >&lt;p&gt;I also realized that, if I am not wrong, current multi row atomic mutations is broken with scanners + RS crashes. Since mvcc is not persisted, if a multi put changing r1,r100 happens where mvcc = 100, the scanner with mvcc = 90 will not see r1. Just after passing r1, the scanner might fail, and the new scanner in the new region server will get another mvcc, but since the changes for previous multi put has been persisted (in log recovery), the scanner will happily see r100 mutation. &lt;/p&gt;

&lt;p&gt;The underlying reason  multi puts + scanner for a region has to see a snapshot of the region, but mvcc is ephemeral. This can also be fixed by saving the seqId&apos;s in hfiles, and when a region scanner is opened, the client obtains the scanner seqId (mvcc read point) and uses this number in case of failover.&lt;/p&gt;</comment>
                            <comment id="13687444" author="sershe" created="Wed, 19 Jun 2013 00:34:24 +0000"  >&lt;p&gt;+1 on idea after we have discussed it&lt;/p&gt;</comment>
                            <comment id="13702436" author="sershe" created="Mon, 8 Jul 2013 21:17:57 +0000"  >&lt;p&gt;I have another idea, related to this, that intends to solve problems with clock skew also.&lt;br/&gt;
If user doesn&apos;t supply ts, we can also combine ts with seqId and mvcc &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; That way conflicts due to clock skew won&apos;t happen assuming seqId doesn&apos;t go back; which it doesn&apos;t under current assumptions such as compactions and log recovery.&lt;br/&gt;
If user does, we can store user ts and seqId or just user ts (but then user has to avoid conflicts, same as now).&lt;br/&gt;
This makes mixed scenarios more difficult though, and some people may rely in default ts actually storing time.&lt;/p&gt;</comment>
                            <comment id="13702546" author="stack" created="Mon, 8 Jul 2013 22:35:30 +0000"  >&lt;p&gt;Can we just do the mvcc and seqid unification?  It would be a nice simplification.  Only hitch I see is ensuring that we write the WAL in sequenceid order (might require a little sort before we add to the WAL done under lock).&lt;/p&gt;

&lt;p&gt;On merging in ts, that looks like we&apos;d be asking for trouble (smile).  That&apos;d be radical.&lt;/p&gt;</comment>
                            <comment id="13780489" author="v.himanshu" created="Fri, 27 Sep 2013 22:03:17 +0000"  >&lt;p&gt;Hey Enis &amp;amp; Jeffrey, could you guys please share the approach for this issue which is currently under testing. Thanks.&lt;/p&gt;</comment>
                            <comment id="13780598" author="enis" created="Sat, 28 Sep 2013 00:07:41 +0000"  >&lt;p&gt;Definitely. I have a patch which works on 90% of the unit tests &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Was going to create a RB, but never got to make it stable enough, perf test, handle old mvcc numbers in files, etc. &lt;br/&gt;
The approach is that we get keep MVCC, but mvcc write number will be the log sequence number. So instead of: &lt;br/&gt;
1. get mvcc number&lt;br/&gt;
2. memstore insert&lt;br/&gt;
3. append no sync&lt;br/&gt;
4. sync&lt;br/&gt;
we are doing:&lt;br/&gt;
1. append no sync&lt;br/&gt;
2. memstore insert&lt;br/&gt;
3. sync&lt;/p&gt;

&lt;p&gt;You can check the TrxManager, which keeps track of on the fly transactions. MVCC is an impl of TrxMngr. HLog will order the transactions by the update lock, and create and add a trx to the Trx manager. TrxManager still ensures that the transactions are committed (made visible) in serial order. row locking order is also not changed, meaning, read-write transcations still have to wait for on-flight transactions to finish, after they acquire the row locks. &lt;/p&gt;</comment>
                            <comment id="13780599" author="enis" created="Sat, 28 Sep 2013 00:08:41 +0000"  >&lt;p&gt;Attaching the patch which is a wip. Feel free to comment though. &lt;/p&gt;</comment>
                            <comment id="13833224" author="apurtell" created="Tue, 26 Nov 2013 23:41:20 +0000"  >&lt;p&gt;Moving out of 0.98. Put back if you feel otherwise.&lt;/p&gt;</comment>
                            <comment id="13837109" author="jeffreyz" created="Tue, 3 Dec 2013 00:00:44 +0000"  >&lt;p&gt;Today I had some discussion with &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=enis&quot; class=&quot;user-hover&quot; rel=&quot;enis&quot;&gt;Enis Soztutar&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=tedyu%40apache.org&quot; class=&quot;user-hover&quot; rel=&quot;tedyu@apache.org&quot;&gt;Ted Yu&lt;/a&gt; on this topic and found it might be possible to handle the JIRA issue in a simpler way. Below are the steps:&lt;/p&gt;

&lt;p&gt;1) Memstore insert using long.max as the initial write number&lt;br/&gt;
2) append no sync&lt;br/&gt;
3) sync&lt;br/&gt;
4) update WriteEntry&apos;s write number to the sequence number returned from Step 2&lt;br/&gt;
5) CompleteMemstoreInsert. In this step, make current read point to be &amp;gt;= the sequence number from Step 2. The reasoning behind this is that once we sync till the sequence number, all changes with small sequence numbers are already synced into WAL. Therefore, we should be able to bump up read number to the last sequence number synced.&lt;/p&gt;

&lt;p&gt;Currently, we maintain an internal queue which might defer the read point bump up if transactions complete order is different than that of MVCC internal write queue. &lt;/p&gt;

&lt;p&gt;By doing above, it&apos;s possible to remove the logics maintaining writeQueue so it means we can remove two locking and one queue loop in write code path. Sounds too good to be true &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. Let me try to write a quick patch and run it against unit tests to see if the idea could fly.&lt;/p&gt;</comment>
                            <comment id="13837226" author="enis" created="Tue, 3 Dec 2013 01:52:37 +0000"  >&lt;p&gt;This may actually work with a very small amount of changes. It would be great if you can hack up a working patch and run the unit tests. In my case, I&apos;ve seen the current set of UT&apos;s to cover most of the concurrency issues I ran into while developing this. &lt;/p&gt;</comment>
                            <comment id="13837300" author="jeffreyz" created="Tue, 3 Dec 2013 03:55:46 +0000"  >&lt;p&gt;I tried a small patch. Since we support SKIP_WAL model, the MVCC.writeQueue is still needed to main the write order because there is no wal sync operation at all.  Also there are quite a few test cases doesn&apos;t do appendNosync between mvcc.beginMemstoreInsert and mvcc.completeMemstoreInsert so they are needed to be adjusted. So far I didn&apos;t find block issues but still need to verify it thoroughly.&lt;/p&gt;</comment>
                            <comment id="13838077" author="jeffreyz" created="Tue, 3 Dec 2013 19:38:33 +0000"  >&lt;p&gt;I attached the &quot;Proof of Concept&quot; patch and there are a few unit tests failed. &lt;/p&gt;

&lt;p&gt;The basic idea is like we have two buckets: one has all in progress writes and the other contains all committed writes. Once a write is done we assign a log sequence number(after sync) and move it to the committed bucket by bumping up the mvcc read point to be &amp;gt;= the log sequence number. &lt;/p&gt;

&lt;p&gt;The major changes are in HRegion.java and MultiVersionConsistencyControl.java. &lt;/p&gt;

&lt;p&gt;Since Increment, Append and etcs need to wait for all previous in-progress transactions complete, I have to keep a collection MultiVersionConsistencyControl#inProgressWrites.&lt;/p&gt;</comment>
                            <comment id="13839529" author="stack" created="Thu, 5 Dec 2013 00:15:28 +0000"  >
&lt;blockquote&gt;&lt;p&gt;1) Memstore insert using long.max as the initial write number&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What will we do if two edits arrive with same coordinates?  How will we distingush them if both have long.max during the time it takes to sync and converte long.max to a legit seqid?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Currently, we maintain an internal queue which might defer the read point bump up if transactions complete order is different than that of MVCC internal write queue.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;A reason to unify MVCC and WAL seqid (smile).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;By doing above, it&apos;s possible to remove the logics maintaining writeQueue ...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We need the writeQueue for performance reasons, right?  We need to add edits in bulk under a lock and this lock is expensive to obtain (maybe I am missing something?)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;...so it means we can remove two locking and one queue loop in write code path. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What are the two locks J?&lt;/p&gt;

&lt;p&gt;Otherwise, sounds great.  Will look at patches...&lt;/p&gt;</comment>
                            <comment id="13839728" author="jeffreyz" created="Thu, 5 Dec 2013 02:47:32 +0000"  >&lt;blockquote&gt;
&lt;p&gt;What will we do if two edits arrive with same coordinates? How will we distingush them if both have long.max during the time it takes to sync and converte long.max to a legit seqid?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Basically the MVCC write number only needs to make sure scanner can&apos;t see them before a write is done. Therefore we can assign them to Long.MAX. It means all in-progress writes belongs to one bucket and scanner can&apos;t see them.  Once a write is done, we assign them the logSeqNumber in WAL appending order and then bump up the min read point so that all writes before current log sequence number are visible to scanners. In this case, client can see changes in the order we commit the writes.&lt;/p&gt;

&lt;p&gt;There are two orders in today&apos;s code because we assign the write number before a write starts: receiving order and commit order. For example, Put1 has write number 1 and Put2 has write number 2 while Put2 can finish earlier than Put1 but Put2 still need wait for Put1 to finish. This cause issues for replication and recovery because both replies on the order(commit order) in the WAL file.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What are the two locks J?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In file MultiVersionConsistencyControl, the locks guard the access to writeQueue. Since we don&apos;t need keep the receiving order(which have to today because large write number could complete earlier than smaller write number), we can remove the related code as you can see my proof-of-concept patch beginMemstoreInsertUseSeqNum &amp;amp; advanceMemstoreUseSeqNum. I still keep a collection inProgressWrites because our Increment, Append etc needs all in-progress done but this part can be optimized by just keeping a hashmap for rows which row lock are released but not wal synced yet. &lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; WriteEntry beginMemstoreInsert() {
    &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; (writeQueue) {
      &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; nextWriteNumber = ++memstoreWrite;
      WriteEntry e = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; WriteEntry(nextWriteNumber);
      writeQueue.add(e);
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; e;
    }
  }

  &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; advanceMemstore(WriteEntry e) {
    &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; (writeQueue) {
       ...
         &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (!writeQueue.isEmpty()) {
        ...
         }
     }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
</comment>
                            <comment id="13839816" author="stack" created="Thu, 5 Dec 2013 05:04:49 +0000"  >&lt;blockquote&gt;&lt;p&gt;It means all in-progress writes belongs to one bucket and scanner can&apos;t see them. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;These will not be in the memstore, right?  They will be held aside?   We only add to memstore after they get their seqid?  Else, the second edit overwrites the first?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;...Put1 has write number 1 and Put2 has write number 2 while Put2 can finish earlier than Put1 but Put2 still need wait for Put1 to finish. This cause issues for replication and recovery because both replies on the order(commit order) in the WAL file.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes. I like the way you call this out.  Please talk this fact up going forward.&lt;/p&gt;

&lt;p&gt;Sorry, let me go look at your code.  That should help me follow along.&lt;/p&gt;


</comment>
                            <comment id="13856987" author="sershe" created="Thu, 26 Dec 2013 18:30:45 +0000"  >&lt;p&gt;Any update on this? Resolving this confusion would help greatly.&lt;/p&gt;</comment>
                            <comment id="13857569" author="stack" created="Fri, 27 Dec 2013 17:16:37 +0000"  >&lt;p&gt;Marking critical.  Let&apos;s make a decision on this.  A few other developments in the pipeline are simplified if we do this.&lt;/p&gt;</comment>
                            <comment id="13857630" author="liyin" created="Fri, 27 Dec 2013 18:48:56 +0000"  >&lt;p&gt;I totally vote for combining the MVCC and SeqID. Furthermore, it will be even more straightforward if the SeqID does not shared across all the Regions. Ideally, each region shall have its own monotonously increasing seq id. &lt;/p&gt;</comment>
                            <comment id="13857661" author="sershe" created="Fri, 27 Dec 2013 19:29:33 +0000"  >&lt;p&gt;I thought the latter was already done?&lt;/p&gt;</comment>
                            <comment id="13857665" author="yuzhihong@gmail.com" created="Fri, 27 Dec 2013 19:35:03 +0000"  >&lt;p&gt;Right. See &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8741&quot; title=&quot;Scope sequenceid to the region rather than regionserver (WAS: Mutations on Regions in recovery mode might have same sequenceIDs)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8741&quot;&gt;&lt;del&gt;HBASE-8741&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13857680" author="liyin" created="Fri, 27 Dec 2013 19:54:24 +0000"  >&lt;p&gt;Thanks for jira ! &lt;br/&gt;
If SeqID has already been per-region basis, and we want to combine the MVCC, then how do we want to handle the group commit across multiple regions ? &lt;/p&gt;</comment>
                            <comment id="13857813" author="jeffreyz" created="Fri, 27 Dec 2013 22:45:23 +0000"  >&lt;p&gt;I&apos;m working with &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=enis&quot; class=&quot;user-hover&quot; rel=&quot;enis&quot;&gt;Enis Soztutar&lt;/a&gt; on this though in a slow pace because the feature can most likely be released in 0.99 or later. There are work left to be done like upgrade handling &amp;amp; performance evaluation. &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=liyin&quot; class=&quot;user-hover&quot; rel=&quot;liyin&quot;&gt;Liyin Tang&lt;/a&gt; Not much special handing on log group commit which you can check on hbase-8741. Basically log sequence number won&apos;t monotonically increase in a WAL while it is for a single region. MVCC will become a region specific value not global in RS level so we need to maintain a map region -&amp;gt; read point for scanning.&lt;/p&gt;</comment>
                            <comment id="13857820" author="liyin" created="Fri, 27 Dec 2013 22:56:48 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jeffreyz&quot; class=&quot;user-hover&quot; rel=&quot;jeffreyz&quot;&gt;Jeffrey Zhong&lt;/a&gt;, I see. Thanks for the clarification and it makes sense to me now !&lt;/p&gt;</comment>
                            <comment id="13985066" author="jeffreyz" created="Wed, 30 Apr 2014 01:56:36 +0000"  >&lt;p&gt;This is updated POC version. All small/medium tests including TestAtomicOperation are passed except TestExportSnapshot. I&apos;ll try to fix it soon. Thanks. &lt;/p&gt;</comment>
                            <comment id="13985080" author="enis" created="Wed, 30 Apr 2014 02:28:09 +0000"  >&lt;p&gt;Great to see progress Jeffrey. &lt;/p&gt;

&lt;p&gt;As talked offline, I think we do not want to allocate 2 objects on heap rather than one: &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; mvcc = 0;  &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; value is not part of a serialized KeyValue (not in HFiles)
&lt;/span&gt;+  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; MutableLong mvcc;  &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; value is not part of a serialized KeyValue (not in HFiles)&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Although, changing the mvcc long after object construction may require it to be declared volatile. &lt;br/&gt;
I think you are using the technique of double incrementing the seqId, once at trx start and once at end right? Did you try your &quot;append 1B to seqId for memstore&quot; approach? &lt;/p&gt;

&lt;p&gt;I think I also changed Cell.getMvcc() to Cell.getSeqId(). Maybe worth doing once we get the patch fully running and performant. &lt;/p&gt;</comment>
                            <comment id="13985127" author="stack" created="Wed, 30 Apr 2014 03:44:29 +0000"  >&lt;p&gt;You the man &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jeffreyz&quot; class=&quot;user-hover&quot; rel=&quot;jeffreyz&quot;&gt;Jeffrey Zhong&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Spelling here waitForPreviousTransactoinsComplete&lt;/p&gt;

&lt;p&gt;What is happening here?&lt;/p&gt;

&lt;p&gt;         syncOrDefer(txid, durability);&lt;br/&gt;
+        // Get LogSequenceNumber from WAL Sync&lt;br/&gt;
+        if(walEdit.getLogKey() != null) &lt;/p&gt;
{
+          seqNumber.setValue(walEdit.getLogKey().getLogSeqNum());
+        }

&lt;p&gt;The seqNumber of the last wallEdit added to the WAL and sync&apos;d?  The seq number could be well beyond this in actually?  Does that matter?  Should we let you have access to last sync&apos;d id out of WAL?&lt;/p&gt;

&lt;p&gt;You import but don&apos;t use?&lt;/p&gt;

&lt;p&gt;+import org.apache.commons.lang.mutable.MutableInt;&lt;br/&gt;
+import org.apache.commons.lang.mutable.MutableLong;&lt;/p&gt;

&lt;p&gt;... maybe a few times.&lt;/p&gt;

&lt;p&gt;Why you use the MutableLong instead of say a long or a volatile?&lt;/p&gt;

&lt;p&gt;Will do a closer review later.  So far looks great.&lt;/p&gt;


</comment>
                            <comment id="13986354" author="stack" created="Thu, 1 May 2014 05:09:41 +0000"  >&lt;p&gt;(Pardon me; am excited about this one so went back to do some more study...)&lt;/p&gt;

&lt;p&gt;So yeah, why do a MutableLong in KV rather than just a volatile?  Probably same in the end...  I see you want to get a reference to a KV.  You trying to tie a KV to something else in case the mvcc gets updated?&lt;/p&gt;

&lt;p&gt;Maybe this is it:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;newKv.setMvccVersion(kv.getMvccVersion());&lt;br/&gt;
+    newKv.setMvccVersion(kv.getMvccVersionReference());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;We are cloning.  The original gets updated later?  You want to make sure clone is updated too?&lt;/p&gt;

&lt;p&gt;Would be cool if we could get rid of this clone one day.&lt;/p&gt;
</comment>
                            <comment id="13986360" author="jeffreyz" created="Thu, 1 May 2014 05:29:40 +0000"  >&lt;p&gt;The reason using MutableLong object is that at the very beginning we don&apos;t know the real sync sequence number(due to the late binding) so I use MutableLong object which keeps a &quot;faked&quot; big sequence number. All new KVs and related of this transation reference this mvcc mutablelong object. Once after the corresponding WALEdit is synced(after SyncOrDefer call), we have the real sequence number and I reset the value of the MutaleLong in one place so all new KVs in MemStore will see the updated sequence number(because they keep the reference to this MVCC(MutableLong) instance.&lt;/p&gt;

&lt;p&gt;If our WAL Sync doesn&apos;t late binding then I don&apos;t need to use MutableLong.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=enis&quot; class=&quot;user-hover&quot; rel=&quot;enis&quot;&gt;Enis Soztutar&lt;/a&gt; is suggesting not to use MutableLong while keeping all new KVs and reset their MVCC values in an extra loop. This may be hard to implement because our pre &amp;amp; post co-processor copies MVCC values as in the code you pasted above(where I changed to copy reference)&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
newKv.setMvccVersion(kv.getMvccVersionReference());
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;My plan is to get all tests pass and then do enhancement/refactoring that you and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=enis&quot; class=&quot;user-hover&quot; rel=&quot;enis&quot;&gt;Enis Soztutar&lt;/a&gt; are suggesting.&lt;/p&gt;
</comment>
                            <comment id="13987070" author="stack" created="Thu, 1 May 2014 22:16:50 +0000"  >&lt;blockquote&gt;&lt;p&gt;...and I reset the value of the MutaleLong in one place so all new KVs in MemStore will see the updated sequence number...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Nice.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If our WAL Sync doesn&apos;t late binding then I don&apos;t need to use MutableLong.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;IIUC, if we want the region sequence id (and hence the mvcc) to reflect the order in which edits appear in the WAL, we must do late binding.  See my natterings over in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-11099&quot; title=&quot;Two situations where we could open a region with smaller sequence number&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-11099&quot;&gt;&lt;del&gt;HBASE-11099&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;...and reset their MVCC values in an extra loop....&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Tell me more.  Where the KVs be &apos;kept&apos;?  In the WALEdit?  The extra loop would be after a sync or on append?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;...our pre &amp;amp; post co-processor copies MVCC values...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok.  Ugly.  Would be cool getting this in w/o breaking CPs in 1.0 but we should break the API after 1.0 if forcing inefficiency.&lt;/p&gt;</comment>
                            <comment id="13988512" author="jeffreyz" created="Sat, 3 May 2014 01:24:14 +0000"  >&lt;p&gt;Submit the patch to let QA run to see how many failures. &lt;/p&gt;</comment>
                            <comment id="13988513" author="jeffreyz" created="Sat, 3 May 2014 01:24:29 +0000"  >&lt;p&gt;Trigger QA run&lt;/p&gt;</comment>
                            <comment id="13988533" author="hadoopqa" created="Sat, 3 May 2014 02:16:48 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12643167/hbase-8763.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12643167/hbase-8763.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision .&lt;br/&gt;
  ATTACHMENT ID: 12643167&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 6 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 javadoc&lt;/font&gt;.  The javadoc tool appears to have generated 4 warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any new Findbugs (version 1.3.9) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;     &lt;font color=&quot;red&quot;&gt;-1 core tests&lt;/font&gt;.  The patch failed these unit tests:&lt;br/&gt;
                       org.apache.hadoop.hbase.io.TestHeapSize&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9452//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="13988928" author="jeffreyz" created="Sun, 4 May 2014 06:28:46 +0000"  >&lt;p&gt;The v1 patch runs fine in my local test env. Trigger one more QA run.&lt;/p&gt;</comment>
                            <comment id="13992516" author="stack" created="Thu, 8 May 2014 05:18:14 +0000"  >&lt;p&gt;This changes with hbase-11109:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+          flushSeqId = &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.sequenceId.incrementAndGet();
+        } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
+          &lt;span class=&quot;code-comment&quot;&gt;// use the provided sequence Id as WAL is not being used &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; flush.
&lt;/span&gt;+          flushSeqId = myseqid;
....

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;... but that is fine.  Let 11109 worry about it.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure I&apos;m clear on what could be rolled back out of memstore around flush.  Or, can there be more doc on how mvcc and sequence id are interacting here?  For those who come after us?&lt;/p&gt;

&lt;p&gt;This should be called sequenceId: +    MutableLong seqNumber = new MutableLong();&lt;/p&gt;

&lt;p&gt;A left shift would be better? +    return beginMemstoreInsert(curSeqNum + 1000000000);&lt;/p&gt;

&lt;p&gt;Did a quick skim.  Early- vs late-binding would change this patch?&lt;/p&gt;

&lt;p&gt;Is the best write up on how this is going to work going forward what is above in this issue?  Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jeffreyz&quot; class=&quot;user-hover&quot; rel=&quot;jeffreyz&quot;&gt;Jeffrey Zhong&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13994785" author="jeffreyz" created="Mon, 12 May 2014 04:13:33 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Early- vs late-binding would change this patch?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, it makes the patch much easier for edits with durablity=SKIP_WAL &amp;amp; ASYNC_WAL situation otherwise it would do similar things of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-11135&quot; title=&quot;Change region sequenceid generation so happens earlier in the append cycle rather than just before added to file&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-11135&quot;&gt;&lt;del&gt;HBASE-11135&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&apos;m not sure I&apos;m clear on what could be rolled back out of memstore around flush. Or, can there be more doc on how mvcc and sequence id are interacting here?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;During flush, we take a region write lock(prevent all writes coming into a region), append a marker in MVCC queue, get flush sequence Id, take a mem store snapshot and then release the region write lock. After lock release, we wait for the MVCC marker we appended while holding the write lock in order for all in-flight transactions before acquiring the region write lock to complete(either succeed or rollback).  Since there is only one copy of MVCC which is a MutableLong object referenced by all related KVs, the rollback of KVs from mem store should have no issue.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is the best write up on how this is going to work going forward what is above in this issue?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Sure. I&apos;ll modify this patch on top of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-11135&quot; title=&quot;Change region sequenceid generation so happens earlier in the append cycle rather than just before added to file&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-11135&quot;&gt;&lt;del&gt;HBASE-11135&lt;/del&gt;&lt;/a&gt; and then a write up on the final implementation.&lt;/p&gt;</comment>
                            <comment id="13996821" author="stack" created="Tue, 13 May 2014 19:47:10 +0000"  >&lt;p&gt;I committed hbase-11135 so hopefully this patch is cleaner.  I opened &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-11160&quot; title=&quot;Undo append waiting on region edit/sequence id update&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-11160&quot;&gt;&lt;del&gt;HBASE-11160&lt;/del&gt;&lt;/a&gt; for the case where we can hopefully let go of append having to wait on edit/sequence id updates (early-binding instead of late-binding).&lt;/p&gt;</comment>
                            <comment id="13997068" author="jeffreyz" created="Wed, 14 May 2014 00:06:46 +0000"  >&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt;! I&apos;m migrating my patch on top of hbase-11135 now.&lt;/p&gt;</comment>
                            <comment id="13999492" author="jeffreyz" created="Fri, 16 May 2014 01:04:39 +0000"  >&lt;p&gt;Full test suite passed locally. TestAcidGuarantees passed 10 times in one loop.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt; I&apos;ve moved the sequenceId wait for assignment from ring buffer consumer to rpc handlers. Hopefully we can restore the performance.&lt;/p&gt;

&lt;p&gt;After mvcc &amp;amp; log sequence combining, one idea I come up today is that we can introduce a client read flushed changes only mode. &lt;/p&gt;

&lt;p&gt;In this mode, a client only read changes are flushed. During recovery we can set its scanner read point to last flushed sequence id while the region is still under recovery. The total recovery time for those clients are failure detection time + region assignment time.&lt;/p&gt;

&lt;p&gt;I also attached a write up on this JIRA.&lt;/p&gt;
</comment>
                            <comment id="14000131" author="stack" created="Fri, 16 May 2014 18:49:52 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jeffreyz&quot; class=&quot;user-hover&quot; rel=&quot;jeffreyz&quot;&gt;Jeffrey Zhong&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Excellent work.  Thanks for the writeup.  Helps.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;After mvcc &amp;amp; log sequence combin....&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We can do a bunch of stuff...&lt;/p&gt;

&lt;p&gt;But I like your idea about clients being able to read at least to last flush.  Sweet.&lt;/p&gt;

&lt;p&gt;Some comments on the patch:&lt;/p&gt;

&lt;p&gt;Should beginMemstoreInsert assign a write mvcc number at all?&lt;/p&gt;

&lt;p&gt;This won&apos;t work:&lt;/p&gt;

&lt;p&gt;+        w = mvcc.beginMemstoreInsert(this.sequenceId.incrementAndGet());&lt;/p&gt;

&lt;p&gt;Or at least I don&apos;t think you are getting what you think you are getting.  See the note on sequenceid.  I think you have to use the new getNextSequenceId.  Then you do this +          flushSeqId = getNextSequenceId(wal); at end of flush.  Do we need the earlier mvcc?&lt;/p&gt;

&lt;p&gt;You do it thrice I see (There is &apos;lag&apos; between adding of append to ring buffer and it being consumed and its edit/sequence id being updated... perhaps an edit is in the ring buffer, you update the sequence id thinking you are getting the last sequence id but subsequently, the ring buffer consumer runs...).&lt;/p&gt;



&lt;p&gt;Misspelling: waitForPreviousTransactoinsComplete&lt;/p&gt;

&lt;p&gt;I asked already and I think you explained but still not sure what is going on here:&lt;/p&gt;

&lt;p&gt;+      mvcc.waitForPreviousTransactoinsComplete(w);&lt;br/&gt;
+      w = null;&lt;/p&gt;

&lt;p&gt;Call this appendNoSyncFakedWALEdit appendNoSyncNoAppend?  It will make folks sit up and wonder why you would do such a thing and they&apos;d read the javadoc.  It is more explicit than appendNoSyncFakedWALEdit.&lt;/p&gt;



&lt;p&gt;I&apos;d think the below is temporary? It is convenient updating once and all related get the update.  Is that the only reason?  Could we iterate the KVs that make up the edit and set their MVCC?  The edits are not yet in the memstore, right?  They get their mvcc before they are added to the MemStore? (Always?)&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private long mvcc = 0;  // this value is not part of a serialized KeyValue (not in HFiles)&lt;br/&gt;
+  private MutableLong mvcc; // this value is not part of a serialized KeyValue (not in HFiles)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This is the clone that we need to get rid of, right (smile)?&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;newKv.setMvccVersion(kv.getMvccVersion());&lt;br/&gt;
+    newKv.setMvccVersion(kv.getMvccVersionReference());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;nit: don&apos;t need to set the memstoreRead... it is done in the declaration.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.memstoreRead = this.memstoreWrite = 0;&lt;br/&gt;
+    memstoreRead = 0;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Set top bits rather than add a big number?: +    curSeqNum.setValue(originalVal + 1000000000);&lt;/p&gt;

&lt;p&gt;Do we need to have MemStore know about HLogKeys?  And that they have this odd &apos;waiting&apos; thing that you can do on them?&lt;/p&gt;

&lt;p&gt;+      long newSeqNum = walKey.waitForLogSeqNumAssigned();&lt;br/&gt;
+      e.setWriteNumber(newSeqNum);&lt;/p&gt;

&lt;p&gt;Could we do the wait in the WAL system before we call completeMemstoreInsertWithSeqNum passing in the sequence id to use?  Could the consumer on the ring buffer call the Memstore. completeMemstoreInsertWithSeqNum?&lt;/p&gt;

&lt;p&gt;Hmm... maybe we should make the writeQueue a disruptor too?  Later.&lt;/p&gt;

&lt;p&gt;+1 on moving the latch from waledit to walkey.  Nice.&lt;/p&gt;

&lt;p&gt;You fixing this test? TestMultiParallel&lt;/p&gt;

&lt;p&gt;Patch looks good.  Can give a closer review later.  This first pass should do for now.&lt;/p&gt;

&lt;p&gt;Great stuff Jeffrey&lt;/p&gt;
</comment>
                            <comment id="14000278" author="jeffreyz" created="Fri, 16 May 2014 20:39:51 +0000"  >&lt;p&gt;The v3 fix a test case failure &amp;amp; trigger QA run&lt;/p&gt;</comment>
                            <comment id="14000455" author="jeffreyz" created="Fri, 16 May 2014 23:00:37 +0000"  >&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt; for the good comments! I&apos;ll make corresponding changes in my next patch. Please see my answers below:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hmm... maybe we should make the writeQueue a disruptor too? Later.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;That&apos;s a good idea. I could also remove the writeQueue even without disruptor. Basically return the previous highestUnsyncedSequence from disruptor consumer code where we stampRegionSequenceId in FSHLog#append() before current wal append, inside syncOrDefer we will wait for this previous highestUnsyncedSequence for skip_wal &amp;amp; async_wal case. Let&apos;s do it later in a separate JIRA.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Should beginMemstoreInsert assign a write mvcc number at all?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;No need to assign a write number and I could pass 0 here. The main purpose for the call is inserting a marker so that later code can wait all mvcc transactions before marker complete. this.sequenceId.incrementAndGet() is just a way to pass some &quot;good&quot; number without messing up the memstore read point later by mvcc.advanceMemstore(w) call. &lt;br/&gt;
I&apos;ll pass HLog.NO_SEQUENCE_ID value then.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Misspelling: waitForPreviousTransactoinsComplete&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Good catch.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Call this appendNoSyncFakedWALEdit appendNoSyncNoAppend&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Ok. I&apos;ll make the change&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It is convenient updating once and all related get the update. Is that the only reason?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;It&apos;s not only for convenient but for correctness. Let&apos;s say we have two updates coming in the order of c1, c2 while c1 could have seqId=2 and c2 could have seqId=1. As you know wal syncer syncs all available pending appends and it&apos;s likely both wal entries for e1 and e2 are synced at same time. Therefore, the mvcc for c1 will advance memstore read point to 2. Since MutableLong is used here, so we know for sure c1&apos;s MVCC has been updated to 1 before c2 gets its seqid=2 otherwise we could end up with the situation that memstore read point has been set to 2 while c1&apos;s mvcc in menstore hasn&apos;t been updated yet depending on the caller thread scheduling.(Unless I pass MVCC into ring buffer where we keep the reference of all new KVs and update mvcc for them in disruptor consumer code) .&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Set top bits rather than add a big number?: + curSeqNum.setValue(originalVal + 1000000000);&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;How about the case if the first bit is already used for a large sequence number? In theory, I only need to bump the number to 2 * the number of rpc handlers because the writeQueue will be blocked if current mvcc isn&apos;t complete. The big number here is just to be safe.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Do we need to have MemStore know about HLogKeys?&lt;br/&gt;
Could we do the wait in the WAL system before we call completeMemstoreInsertWithSeqNum passing in the sequence id to use? Could the consumer on the ring buffer call the Memstore. completeMemstoreInsertWithSeqNum?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Memstore doesn&apos;t know hlogkey but MVCC. I can do it outside of MVCC but that requires all places calling completeMemstoreInsertWithSeqNum need to remember to call the waitForLogSequence. It may leave hole in the future. &lt;/p&gt;</comment>
                            <comment id="14000515" author="hadoopqa" created="Fri, 16 May 2014 23:50:35 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12645323/hbase-8763-v3.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12645323/hbase-8763-v3.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision .&lt;br/&gt;
  ATTACHMENT ID: 12645323&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 12 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 javadoc&lt;/font&gt;.  The javadoc tool appears to have generated 6 warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any new Findbugs (version 1.3.9) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 core tests&lt;/font&gt;.  The patch passed unit tests in .&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9526//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14000519" author="stack" created="Fri, 16 May 2014 23:53:32 +0000"  >&lt;p&gt;+1 on removing waitQueue in new JIRA&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I&apos;ll pass HLog.NO_SEQUENCE_ID value then.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes.  I tried to make it so only the WAL system does the sequence id update so these this.sequenceId.incrementAndGet()  make me go yuck (smile)&lt;/p&gt;

&lt;p&gt;+1 on MutableLong (I may ask you to make the same explanation again in the future so remember this bit of text so you can copy/paste it next time I ask).&lt;/p&gt;

&lt;p&gt;Ok on not setting top bits. Add comments on how large needs to be (theoretically). Helps others coming along after better understand.&lt;/p&gt;

&lt;p&gt;On MemStore knowing about WALKey, as in+  public void completeMemstoreInsertWithSeqNum(WriteEntry e, HLogKey walKey) throws IOException {, that is just butt ugly (pardon the technical term).  Doing &apos;+import org.apache.hadoop.hbase.regionserver.wal.HLogKey;&apos; is so ugly, I&apos;d suggest we have an Interface that has one method in it &amp;#8211; waitForLogSeqNumAssigned or getSequenceId or getLogSeqNumAssigned (and just hide the fact that we are waiting) &amp;#8211; and pass that instead.&lt;/p&gt;

&lt;p&gt;Good stuff Jay-Z&lt;/p&gt;
</comment>
                            <comment id="14000581" author="jeffreyz" created="Sat, 17 May 2014 01:01:21 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I&apos;d suggest we have an Interface that has one method in it &#8211; waitForLogSeqNumAssigned or getSequenceId or getLogSeqNumAssigned (and just hide the fact that we are waiting) &#8211; and pass that instead.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Ok, I&apos;ll do that in my next patch. The QA run succeeded except java doc warnings which will be cleared in my next patch. Thanks.&lt;/p&gt;</comment>
                            <comment id="14005183" author="jeffreyz" created="Wed, 21 May 2014 20:28:09 +0000"  >&lt;p&gt;The v4 patch addressed &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt; comments and clean the java doc warnings. Thanks.&lt;/p&gt;</comment>
                            <comment id="14010314" author="stack" created="Tue, 27 May 2014 21:37:12 +0000"  >&lt;p&gt;Patch looks great.&lt;/p&gt;

&lt;p&gt;On commit, remove this comment.  Doesn&apos;t seem appropriate to the statement that follows:&lt;/p&gt;

&lt;p&gt;+        // Record the mvcc for all transactions in progress.&lt;/p&gt;

&lt;p&gt;You need to do this?&lt;/p&gt;

&lt;p&gt;-&lt;br/&gt;
+      mvccNum.setValue(this.sequenceId.incrementAndGet());&lt;/p&gt;

&lt;p&gt;I&apos;m trying to keep it so all sequenceid increments happen inside HLog only.&lt;/p&gt;

&lt;p&gt;You do it in a few places.  Does it have to increment?  Could you just get current?  Would that work?&lt;/p&gt;

&lt;p&gt;This should almost be a method because it happens more than a few times:&lt;/p&gt;

&lt;p&gt;+          if(walKey == null)&lt;/p&gt;
{
+            // Append a faked WALEdit in order for SKIP_WAL updates to get mvccNum assigned
+            walKey = this.appendNoSyncNoAppend(this.log, mvccNum);
+          }

&lt;p&gt;Rename SequenceNumberAssignor as SequenceNumber and method as getSequenceNumber?&lt;/p&gt;

&lt;p&gt;If no one else reviews in next few days, I&apos;ll give it another go (having trouble concentrating on this because I&apos;ve looked at a few versions of this patch....).  Overall I think this is excellent.&lt;/p&gt;

&lt;p&gt;Maybe we should just commit and then tune up in new issues?&lt;/p&gt;

&lt;p&gt;Not sure we can get our speedup back looking at this patch at the mo.&lt;/p&gt;</comment>
                            <comment id="14010336" author="hadoopqa" created="Tue, 27 May 2014 21:45:04 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12646094/hbase-8763-v4.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12646094/hbase-8763-v4.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision .&lt;br/&gt;
  ATTACHMENT ID: 12646094&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 12 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 patch&lt;/font&gt;.  The patch command could not apply the patch.&lt;/p&gt;

&lt;p&gt;Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9607//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9607//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14010616" author="jeffreyz" created="Wed, 28 May 2014 01:00:36 +0000"  >&lt;p&gt;Rebase master branch and address &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt; comments.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;   +      mvccNum.setValue(this.sequenceId.incrementAndGet());&lt;br/&gt;
Does it have to increment?  Could you just get current?  Would that work?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes. get current won&apos;t work because there could be multiple changes for the same row. In that case, the later coming change would have same MVCC value which makes the ordering of KVs in Heap questionable. &lt;/p&gt;</comment>
                            <comment id="14010637" author="stack" created="Wed, 28 May 2014 01:26:07 +0000"  >&lt;p&gt;Then, does it have to be getSequenceId?  There may be appends in flight inside in the disruptor and so you&apos;ll get a sequence id that may be superceded?&lt;/p&gt;</comment>
                            <comment id="14010682" author="hadoopqa" created="Wed, 28 May 2014 02:38:00 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12647028/hbase-8763-v5.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12647028/hbase-8763-v5.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision .&lt;br/&gt;
  ATTACHMENT ID: 12647028&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 12 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javadoc&lt;/font&gt;.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any new Findbugs (version 1.3.9) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 release audit&lt;/font&gt;.  The applied patch generated 31 release audit warnings (more than the trunk&apos;s current 0 warnings).&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 core tests&lt;/font&gt;.  The patch passed unit tests in .&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//testReport/&lt;/a&gt;&lt;br/&gt;
Release audit warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/patchReleaseAuditProblems.txt&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/patchReleaseAuditProblems.txt&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9610//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14010789" author="jeffreyz" created="Wed, 28 May 2014 05:10:26 +0000"  >&lt;blockquote&gt;
&lt;p&gt;There may be appends in flight inside in the disruptor and so you&apos;ll get a sequence id that may be superceded?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes. The mvccNum.setValue(this.sequenceId.incrementAndGet()); here ensures the ordering of KVs when inserted into memstore for the same row key and their mvcc values will be replaced later with actual sequence id while the ordering is maintained. Because appendNoSync also happens while rowlock is held so their actual sequence Ids maintain the same ordering.&lt;/p&gt;</comment>
                            <comment id="14014411" author="jeffreyz" created="Sat, 31 May 2014 00:16:18 +0000"  >&lt;p&gt;The v5.1 is the patch which keep KeyValue untouched(v5 is using MutableLong for mvcc in KeyVavlue) because there is a concern on the possible GC pressure for the new object as it may stay in heap for a while till memstore flush.&lt;/p&gt;</comment>
                            <comment id="14014466" author="hadoopqa" created="Sat, 31 May 2014 02:00:12 +0000"  >&lt;p&gt;&lt;font color=&quot;green&quot;&gt;+1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12647731/hbase-8763-v5.1.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12647731/hbase-8763-v5.1.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision .&lt;br/&gt;
  ATTACHMENT ID: 12647731&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 15 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javadoc&lt;/font&gt;.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any new Findbugs (version 1.3.9) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 core tests&lt;/font&gt;.  The patch passed unit tests in .&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9654//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14018163" author="stack" created="Wed, 4 Jun 2014 20:54:27 +0000"  >&lt;p&gt;Looking at 5.1:&lt;/p&gt;

&lt;p&gt;Why return a Pair?  We are passing in the Cell?  Can&apos;t caller use passed in Cell and just leave addTo returning long as before (I am missing something I know... pardon my being slow).  We are making a new object each time we add to memstore, the Pair.&lt;/p&gt;

&lt;p&gt;Why would the below take a list of kvs to appendNoSyncNoAppend?  When would it ever make sense passing a list of kvs?  (Hmm... I think I see why &amp;#8211; when we want to just set an mvcc on the KV though we are not appending it &amp;#8211; is that right?  If so, a comment on the @param would help)&lt;/p&gt;

&lt;p&gt;In the appendNoSyncNoAppend we make HLogKey.  We call System.currentTimeMillis.  This edit is never appended.  Can we NOT call System.currentTimeMillis?  Just pass a -1 or something instead?  Or can we make a noop HLogKey defined as a static in HLogKey and just use it every time rather than create a new one each time through?  Just as we have WALEdit.EMPTY_WALEDIT?&lt;/p&gt;

&lt;p&gt;On beginMemstoreInsert, why take a value at all?  Wny not just return the WriteEntry that has special value for the write number?  If we ever try to use this number advancing the read point, throw exceptions?  Remove the current beginMemstoreInsert that does not take an entry?  I see that in your new method, waitForPreviousTransactionsComplete, you put something into the mvcc queue w/ a HLog.NO_SEQUENCE_ID and wait for this edit to go around so you can be sure queue is cleared.  So you have second use for special mvcc/sequenceid number.  Should the NO_SEQUENCE_ID be it?  and you just use it when beginMemstoreInsert is called setting it into the WriteEntry?  Should the number even come from HLog?  Could it be private to this class?&lt;/p&gt;

&lt;p&gt;When we do waitForPreviousTransactionsComplete, does WriteEntry have a writeNumber set? Or is it NO_SEQUENCE_ID?  If it is the latter, yeah, just change beginMemstoreInsert to not take a param, or at least, not take this particular one because it is means of asking for a special behavior.  If the writeNumber is set, where does that happen?&lt;/p&gt;

&lt;p&gt;NO_SEQUENCE_ID Should be a define in your new SequenceId interface?&lt;/p&gt;

&lt;p&gt;A comment on wny you do &apos;w = null;&apos; would be helpful in flush: e.g. &quot;Set to null to indicate success&quot;&lt;/p&gt;

&lt;p&gt;Change name of memstoreKVs to be memstoreCells (be forward thinking!)&lt;/p&gt;

&lt;p&gt;I am not clear still on why the below is ok up in HRegion#doMiniBatchMutation (Do we need the MutableLong here still? Why not just set the sequenceid into beginMemstoreInsertWithSeqNum and you are doing this when you use it   kv.setMvccVersion(mvccNum.longValue())&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      mvccNum.setValue(this.sequenceId.incrementAndGet());&lt;/p&gt;

&lt;p&gt;At a minimum it needs a comment explaining why (Sorry if I am being dense here).&lt;/p&gt;

&lt;p&gt;You know why we add to memstore first before WAL?  For speed IIRC.  I should go research it.  This rollback stuff could be tricky.&lt;/p&gt;

&lt;p&gt;So then here:&lt;/p&gt;

&lt;p&gt;        mvccNum.setValue(this.sequenceId.incrementAndGet());&lt;br/&gt;
        w = mvcc.beginMemstoreInsertWithSeqNum(mvccNum);&lt;/p&gt;

&lt;p&gt;We are getting a seqid and setting it as write number. We have not yet gone on the ring buffer.  Every edit is getting a write number like this?  MVCC read number happens only after the WAL append has happened.&lt;/p&gt;

&lt;p&gt;Man, the mvcc stuff should be redone w/ disruptor.  Looks like ideal disruptor case.&lt;/p&gt;

&lt;p&gt;StoreFlusher change no longer needed?&lt;/p&gt;

&lt;p&gt;Can these be lists of Cells rather than   private final transient List&amp;lt;KeyValue&amp;gt; memstoreKVs;?  You can do cell.setMvccVersion.&lt;/p&gt;

&lt;p&gt;Why this?&lt;/p&gt;

&lt;p&gt;  long appendNoSync(HTableDescriptor htd, HRegionInfo info, HLogKey key, WALEdit edits,&lt;br/&gt;
      AtomicLong sequenceId, boolean inMemstore, List&amp;lt;KeyValue&amp;gt; memstoreKVs)&lt;/p&gt;

&lt;p&gt;Unnecssary import in HLogSplitter?  Unnecessary change in WALEdit?&lt;/p&gt;





&lt;p&gt;Are we not passing the KVs twice?  Once in WALEdits and then again in this new memstoreKVs argument?&lt;/p&gt;

&lt;p&gt;I&apos;m running tests now to see what this patch does for performance.  After our chat yesterday, yes, I see, it should not have much of an impact (especially looking at what you did in FSHLog).  That&apos;d be cool.&lt;/p&gt;

&lt;p&gt;I&apos;m excited about this patch coming in.  Great work Mr. Zhong.&lt;/p&gt;


















</comment>
                            <comment id="14018165" author="liyin" created="Wed, 4 Jun 2014 20:57:03 +0000"  >&lt;p&gt;Hi, I am out of office since 9/1/2012 to 9/16/2012 and I cannot access to this email.&lt;br/&gt;
In urgent case, please forward your email to liyintang@gmail.com&lt;/p&gt;

&lt;p&gt;Thanks a lot&lt;br/&gt;
Liyin&lt;/p&gt;</comment>
                            <comment id="14018385" author="stack" created="Thu, 5 Jun 2014 00:58:37 +0000"  >&lt;p&gt;This patch seems to get us our speed back.  Good on one &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jeffreyz&quot; class=&quot;user-hover&quot; rel=&quot;jeffreyz&quot;&gt;Jeffrey Zhong&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Below do basic 1, 5, 25, and 200 threads test:&lt;/p&gt;

&lt;p&gt;Here is nopatch, the current master branch:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
nopatch1.1.txt:2014-06-04 12:11:52,176 INFO  [main] wal.HLogPerformanceEvaluation: Summary: threads=1, iterations=1000000, syncInterval=0 took 1224.313s 816.785ops/s
nopatch5.1.txt:2014-06-04 12:29:02,864 INFO  [main] wal.HLogPerformanceEvaluation: Summary: threads=5, iterations=1000000, syncInterval=0 took 1025.163s 4877.273ops/s
nopatch25.1.txt:2014-06-04 12:53:02,973 INFO  [main] wal.HLogPerformanceEvaluation: Summary: threads=25, iterations=1000000, syncInterval=0 took 1434.641s 17425.963ops/s
nopatch200.1.txt:2014-06-04 13:40:30,333 INFO  [main] wal.HLogPerformanceEvaluation: Summary: threads=200, iterations=1000000, syncInterval=0 took 2841.947s 70374.289ops/s
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here is w/ patch applied:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
patch1.1.txt:2014-06-04 14:37:04,973 INFO  [main] wal.HLogPerformanceEvaluation: Summary: threads=1, iterations=1000000, syncInterval=0 took 1228.775s 813.819ops/s
patch5.1.txt:2014-06-04 14:53:53,623 INFO  [main] wal.HLogPerformanceEvaluation: Summary: threads=5, iterations=1000000, syncInterval=0 took 1003.234s 4983.882ops/s
patch25.1.txt:2014-06-04 15:17:17,952 INFO  [main] wal.HLogPerformanceEvaluation: Summary: threads=25, iterations=1000000, syncInterval=0 took 1398.927s 17870.840ops/s
patch200.1.txt:2014-06-04 15:47:36,297 INFO  [main] wal.HLogPerformanceEvaluation: Summary: threads=200, iterations=1000000, syncInterval=0 took 1813.013s 110313.609ops/s
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14019021" author="jeffreyz" created="Thu, 5 Jun 2014 17:40:27 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt; Thanks for the review and good comments.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Why return a Pair? We are passing in the Cell? Can&apos;t caller use passed in Cell and just leave addTo returning long as before (I am missing something I know... pardon my being slow). We are making a new object each time we add to memstore, the Pair.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;That&apos;s the issue on how we add cells to memestore today. Basically it does copy the passed in Cells and put newly created Cells into memstore. So I have to return those newly added Cells to update mvcc later(because JAVA doesn&apos;t support reference to a primitive type). In future, we shouldn&apos;t make copies when add cells into memstore.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If so, a comment on the @param would help&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Sure. I&apos;ll do that.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt; create a new one each time through? Just as we have WALEdit.EMPTY_WALEDIT?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Good point! I&apos;ll do that.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;On beginMemstoreInsert, why take a value at all&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;It&apos;s used by beginMemstoreInsertWithSeqNum. One way is that I can let beginMemstoreInsert to call beginMemstoreInsertWithSeqNum instead. After this, I think it can address several following comments.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;NO_SEQUENCE_ID Should be a define in your new SequenceId interface?&lt;br/&gt;
A comment on wny you do &apos;w = null;&apos; would be helpful in flush: e.g. &quot;Set to null to indicate success&quot;&lt;br/&gt;
Change name of memstoreKVs to be memstoreCells (be forward thinking!)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Ok, I&apos;ll change that.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Do we need the MutableLong here still? &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The reason is that I want to hide the fact of bumping 1 billion number inside this function and keep the bumping in one place. I could define a constant for this purpose&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Can these be lists of Cells rather than private final transient List&amp;lt;KeyValue&amp;gt; memstoreKVs;? You can do cell.setMvccVersion.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We don&apos;t have setMvccVersion in Cell interface. Do you want to create one?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Are we not passing the KVs twice? Once in WALEdits and then again in this new memstoreKVs argument?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;My firstly version(not published) is using KVs in WALEdits while HRegion#doProcessRowWithTimeout let clients to create WALEdits so it&apos;s impossible to merge those two lists.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Man, the mvcc stuff should be redone w/ disruptor. Looks like ideal disruptor case.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The issue lands in we have different durability modes so the disruptor way maybe hard. As in the earlier review thread, we could remove mvcc writeQueue while it needs to keep the sequence id of the last unflushed edit with sync_wal durability. Let the optimization be done later.&lt;/p&gt;







</comment>
                            <comment id="14020071" author="jeffreyz" created="Fri, 6 Jun 2014 17:15:13 +0000"  >&lt;p&gt;The V5.2 patch addressed &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt; comments except one that I can&apos;t use a static EMPTY_HLOGKEY in function HRegion#appendNoSyncNoAppend because I need hlog key to return assigned log sequence Id.&lt;/p&gt;</comment>
                            <comment id="14020272" author="hadoopqa" created="Fri, 6 Jun 2014 19:24:53 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12648663/hbase-8763-v5.2.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12648663/hbase-8763-v5.2.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision .&lt;br/&gt;
  ATTACHMENT ID: 12648663&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 15 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 javadoc&lt;/font&gt;.  The javadoc tool appears to have generated 3 warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any new Findbugs (version 1.3.9) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;     &lt;font color=&quot;red&quot;&gt;-1 core tests&lt;/font&gt;.  The patch failed these unit tests:&lt;/p&gt;


&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9708//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14020352" author="stack" created="Fri, 6 Jun 2014 20:52:43 +0000"  >&lt;p&gt;All above comments are good by me.&lt;/p&gt;

&lt;p&gt;This is good: getPreAssignedWriteNumber&lt;/p&gt;

&lt;p&gt;+1 Please fix the javadoc on commit and file follow on issues.  Please also add a comment that explains why the Pair is needed and conditions under which we can remove it.  Also explain in comment why the MutableLong is used though it seems it not needed.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;We don&apos;t have setMvccVersion in Cell interface. Do you want to create one?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ugh.  Cell Interface is read-only as it should be.  Would it make sense having another Interface, MVCCSettable with a setMvccVersion in it?  This would be server-side only?  Is there ever a time when we know the mvcc constructing a Cell such that we can shove it in on Construction other than at deserializing or clone time?&lt;/p&gt;
</comment>
                            <comment id="14020621" author="jeffreyz" created="Sat, 7 Jun 2014 01:26:41 +0000"  >&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt; for all the discussions &amp;amp; reviews! I&apos;ve fixed all the javadoc warnings &amp;amp; removed all references of MutableLong. I&apos;ll create follow up JIRA shortly.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is there ever a time when we know the mvcc constructing a Cell such that we can shove it in on Construction other than at deserializing or clone time?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Since we do late-binding style sequence Id assignment, it&apos;s hard to &quot;shove it in on Construction&quot; because we firstly add KVs into memstore and then append to WAL.&lt;/p&gt;</comment>
                            <comment id="14020676" author="hudson" created="Sat, 7 Jun 2014 03:47:40 +0000"  >&lt;p&gt;SUCCESS: Integrated in HBase-TRUNK #5182 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-TRUNK/5182/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-TRUNK/5182/&lt;/a&gt;)&lt;br/&gt;
hbase-8763: Combine MVCC and SeqId (jzhong: rev c682d57e92d9f18a02e1fe8dc50c5caa116e5d4a)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/Store.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/FSHLog.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestStore.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/FSWALEntry.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestMultiVersionConsistencyControl.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMultiParallel.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MultiVersionConsistencyControl.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/HLog.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/HLogUtil.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/DefaultMemStore.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MemStore.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/HLogSplitter.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/HLogKey.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/wal/WALEdit.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/SequenceNumber.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestDefaultMemStore.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFlusher.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14330836" author="enis" created="Sat, 21 Feb 2015 23:31:32 +0000"  >&lt;p&gt;Closing this issue after 0.99.0 release. &lt;/p&gt;</comment>
                            <comment id="15135681" author="hudson" created="Sat, 6 Feb 2016 08:16:40 +0000"  >&lt;p&gt;SUCCESS: Integrated in HBase-1.1-JDK8 #1741 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-1.1-JDK8/1741/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-1.1-JDK8/1741/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15213&quot; title=&quot;Fix increment performance regression caused by HBASE-8763 on branch-1.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15213&quot;&gt;&lt;del&gt;HBASE-15213&lt;/del&gt;&lt;/a&gt; Fix increment performance regression caused by &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8763&quot; title=&quot;Combine MVCC and SeqId&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8763&quot;&gt;&lt;del&gt;HBASE-8763&lt;/del&gt;&lt;/a&gt; on (stack: rev 7ac940b4b06c3ac14cb6d2702e2a5db415d8a6f8)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MultiVersionConsistencyControl.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15135685" author="hudson" created="Sat, 6 Feb 2016 08:17:05 +0000"  >&lt;p&gt;FAILURE: Integrated in HBase-1.1-JDK7 #1654 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-1.1-JDK7/1654/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-1.1-JDK7/1654/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15213&quot; title=&quot;Fix increment performance regression caused by HBASE-8763 on branch-1.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15213&quot;&gt;&lt;del&gt;HBASE-15213&lt;/del&gt;&lt;/a&gt; Fix increment performance regression caused by &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8763&quot; title=&quot;Combine MVCC and SeqId&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8763&quot;&gt;&lt;del&gt;HBASE-8763&lt;/del&gt;&lt;/a&gt; on (stack: rev 7ac940b4b06c3ac14cb6d2702e2a5db415d8a6f8)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MultiVersionConsistencyControl.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15135845" author="hudson" created="Sat, 6 Feb 2016 15:51:31 +0000"  >&lt;p&gt;FAILURE: Integrated in HBase-1.0 #1142 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-1.0/1142/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-1.0/1142/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15213&quot; title=&quot;Fix increment performance regression caused by HBASE-8763 on branch-1.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15213&quot;&gt;&lt;del&gt;HBASE-15213&lt;/del&gt;&lt;/a&gt; Fix increment performance regression caused by &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8763&quot; title=&quot;Combine MVCC and SeqId&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8763&quot;&gt;&lt;del&gt;HBASE-8763&lt;/del&gt;&lt;/a&gt; on (stack: rev 6c555d36cd9928e44281b3280e57dd5f98b63fc8)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MultiVersionConsistencyControl.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12720262">HBASE-11315</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12653776">HBASE-8770</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12677877">HBASE-9905</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12704125">HBASE-10856</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="12310050">
                    <name>Regression</name>
                                            <outwardlinks description="breaks">
                                        <issuelink>
            <issuekey id="12895334">HBASE-14460</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12645149" name="HBase MVCC &amp; LogSeqId Combined.pdf" size="53396" author="jeffreyz" created="Fri, 16 May 2014 01:05:02 +0000"/>
                            <attachment id="12616841" name="hbase-8736-poc.patch" size="27163" author="jeffreyz" created="Tue, 3 Dec 2013 19:38:33 +0000"/>
                            <attachment id="12642580" name="hbase-8763-poc-v1.patch" size="34263" author="jeffreyz" created="Wed, 30 Apr 2014 01:56:36 +0000"/>
                            <attachment id="12643253" name="hbase-8763-v1.patch" size="37959" author="jeffreyz" created="Sun, 4 May 2014 06:28:46 +0000"/>
                            <attachment id="12645175" name="hbase-8763-v2.patch" size="68198" author="jeffreyz" created="Fri, 16 May 2014 04:37:40 +0000"/>
                            <attachment id="12645323" name="hbase-8763-v3.patch" size="69540" author="jeffreyz" created="Fri, 16 May 2014 20:39:51 +0000"/>
                            <attachment id="12646094" name="hbase-8763-v4.patch" size="71867" author="jeffreyz" created="Wed, 21 May 2014 20:28:09 +0000"/>
                            <attachment id="12647731" name="hbase-8763-v5.1.patch" size="86014" author="jeffreyz" created="Sat, 31 May 2014 00:16:18 +0000"/>
                            <attachment id="12648663" name="hbase-8763-v5.2.patch" size="86917" author="jeffreyz" created="Fri, 6 Jun 2014 17:15:13 +0000"/>
                            <attachment id="12647028" name="hbase-8763-v5.patch" size="71626" author="jeffreyz" created="Wed, 28 May 2014 01:00:36 +0000"/>
                            <attachment id="12605610" name="hbase-8763_wip1.patch" size="131424" author="enis" created="Sat, 28 Sep 2013 00:08:41 +0000"/>
                    </attachments>
                <subtasks>
                            <subtask id="12712974">HBASE-11135</subtask>
                            <subtask id="12713993">HBASE-11160</subtask>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 19 Jun 2013 00:34:24 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>333859</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310191" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Hadoop Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10343"><![CDATA[Reviewed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            44 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1llbz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>334186</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>