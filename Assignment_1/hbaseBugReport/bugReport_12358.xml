<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 20:32:15 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-12358/HBASE-12358.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-12358] Create ByteBuffer backed Cell</title>
                <link>https://issues.apache.org/jira/browse/HBASE-12358</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;As part of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12224&quot; title=&quot;Facilitate using ByteBuffer backed Cells in the HFileReader&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12224&quot;&gt;&lt;del&gt;HBASE-12224&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12282&quot; title=&quot;Ensure Cells and its implementations work with Buffers also&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12282&quot;&gt;&lt;del&gt;HBASE-12282&lt;/del&gt;&lt;/a&gt; we wanted a Cell that is backed by BB.  Changing the core Cell impl would not be needed as it is used in server only.  So we will create a BB backed Cell and use it in the Server side read path. This JIRA just creates an interface that extends Cell and adds the needed API.&lt;br/&gt;
The getTimeStamp and getTypebyte() can still refer to the original Cell API only.  The getXXxOffset() and getXXXLength() can also refer to the original Cell only.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12751033">HBASE-12358</key>
            <summary>Create ByteBuffer backed Cell</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12724166">HBASE-11425</parent>
                                    <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="3">Duplicate</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="ram_krish">ramkrishna.s.vasudevan</reporter>
                        <labels>
                    </labels>
                <created>Tue, 28 Oct 2014 08:49:23 +0000</created>
                <updated>Wed, 24 Jun 2015 03:06:03 +0000</updated>
                            <resolved>Wed, 24 Jun 2015 03:06:03 +0000</resolved>
                                                                    <component>regionserver</component>
                    <component>Scanners</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="14186637" author="anoop.hbase" created="Tue, 28 Oct 2014 09:22:34 +0000"  >&lt;p&gt;On an impl of the new Interface, one can call getXXXArray() and getXXXBuffer() returning byte[] and BB respectively. What will be getXXXOffset() returning then?  The offset in buffer and array might be different. So how to handle?&lt;br/&gt;
We will need new API for getting offset in buffer&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="14187476" author="stack" created="Tue, 28 Oct 2014 21:12:32 +0000"  >&lt;p&gt;Its not a Buffer backed Cell, its a ByteBufferBackedCell so change the name BufferBackedCell?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12224&quot; title=&quot;Facilitate using ByteBuffer backed Cells in the HFileReader&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12224&quot;&gt;&lt;del&gt;HBASE-12224&lt;/del&gt;&lt;/a&gt; has nothing in it on why we&apos;d want ByteBuffer readers.  Can we do up one pager on what we are about (Read using DBBs?) and why DBB?&lt;/p&gt;

&lt;p&gt;Cell is broke for DBBs because it presumes you can get backing array?  Should we add an hasArray then?&lt;/p&gt;

&lt;p&gt;Looking at the Interface, we are going to be creating a BB each time we want to look at a few bytes or do a family compare.  We want to do that?  Or what are the ops we might want to do?  If all compares could we give the Cells to compare to comparator and it then internal to itself does the right thing if hasArray is false, etc.&lt;/p&gt;

&lt;p&gt;Good stuff&lt;/p&gt;
</comment>
                            <comment id="14187480" author="stack" created="Tue, 28 Oct 2014 21:14:00 +0000"  >&lt;p&gt;Oh, pardon me. I notice now that these are subtasks of a bigger issue. Will poke up there for some answers to my above questions also.&lt;/p&gt;</comment>
                            <comment id="14187496" author="stack" created="Tue, 28 Oct 2014 21:22:22 +0000"  >&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12224&quot; title=&quot;Facilitate using ByteBuffer backed Cells in the HFileReader&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12224&quot;&gt;&lt;del&gt;HBASE-12224&lt;/del&gt;&lt;/a&gt; has nothing in it on why we&apos;d want ByteBuffer readers.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ignore this question. I can find some justifiation up in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-11425&quot; title=&quot;Cell/DBB end-to-end on the read-path&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-11425&quot;&gt;&lt;del&gt;HBASE-11425&lt;/del&gt;&lt;/a&gt; (a one-pager would still be a good project I think rather than rely on comments scattered about JIRA, IMO).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Cell is broke for DBBs because it presumes you can get backing array? Should we add an hasArray then?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-11425&quot; title=&quot;Cell/DBB end-to-end on the read-path&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-11425&quot;&gt;&lt;del&gt;HBASE-11425&lt;/del&gt;&lt;/a&gt; explains. Ignore above (except maybe something to hasArray &amp;#8211; for later)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Or what are the ops we might want to do?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;In &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-11425&quot; title=&quot;Cell/DBB end-to-end on the read-path&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-11425&quot;&gt;&lt;del&gt;HBASE-11425&lt;/del&gt;&lt;/a&gt;, says &quot;...We can handle class by class....&quot; when talking about getting at arrays.  Yeah, we can do that and pull out common cases (like comparator).&lt;/p&gt;

&lt;p&gt;Seems like the BR vs BB still hanging out there.... I like Andrew Purtell questions up in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-11425&quot; title=&quot;Cell/DBB end-to-end on the read-path&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-11425&quot;&gt;&lt;del&gt;HBASE-11425&lt;/del&gt;&lt;/a&gt;....&lt;/p&gt;


</comment>
                            <comment id="14187981" author="anoop.hbase" created="Wed, 29 Oct 2014 04:19:33 +0000"  >&lt;p&gt;Thanks Stack.  Let us try writing it down.  Ram is working on the code path and once coding underway some or other reqs also may come up. So the doc in some time.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Seems like the BR vs BB still hanging out there..&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes. What we wanted is if the API is not java.nio.BB as return type we can use some other BB kind of implementation (like netty) which is faster. Some of Andy&apos;s experiments shown that the position/limit checks in nio BB impls makes the perf bad and not getting inlining also.  But when we have again one more indirection of accessing a Buffer via BR APIs, the Unsafe based optimization might be harder&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; If Unsafe is available we can get rid of these extra ops like DBB/HBB.  Or can we have our own impl like HBB/DBB? java.nio.ByteBuffer allow to extend.&lt;/p&gt;

&lt;p&gt;Regarding new ByteBufferBackedCell which extends Cells&lt;br/&gt;
Can we do this way?  ByteBufferBackedCell (or some better name?) not extending Cell but it is having APIs like Cell (instead of array based it will be Buffer based) and read path deal with this Interface. SOme thing like a ReadCell.  The Filters and related CP hooks deal with new Cell type. So we ensure that all deal with Buffer APIs and avoid need for temp byte[] creation (if array based APIs are called)&lt;br/&gt;
We might have to change interface like KeyValueScanner, RegionScanner etc.&lt;br/&gt;
Till the RPCServer sendReponse we might need change. See &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12289&quot; title=&quot;Avoid onheap buffer copying at RPCServer#serResponse&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12289&quot;&gt;&lt;del&gt;HBASE-12289&lt;/del&gt;&lt;/a&gt;.  With changes we can avoid this copy in simple cases. But when RPC layer compression or sasl is enabled we might need to do this copy. Compression case am checking some way we can avoid. sasl beacuse of HDFS API am not sure whether this is possible at all.&lt;br/&gt;
All these can land in 2.0 only then&lt;/p&gt;</comment>
                            <comment id="14188045" author="ram_krish" created="Wed, 29 Oct 2014 05:56:12 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt;&lt;br/&gt;
I should have mentioned &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12282&quot; title=&quot;Ensure Cells and its implementations work with Buffers also&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12282&quot;&gt;&lt;del&gt;HBASE-12282&lt;/del&gt;&lt;/a&gt; also along with &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12224&quot; title=&quot;Facilitate using ByteBuffer backed Cells in the HFileReader&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12224&quot;&gt;&lt;del&gt;HBASE-12224&lt;/del&gt;&lt;/a&gt;.  If you take the POC patch in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12282&quot; title=&quot;Ensure Cells and its implementations work with Buffers also&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12282&quot;&gt;&lt;del&gt;HBASE-12282&lt;/del&gt;&lt;/a&gt; that would give an idea as what changes we would be needed to make things work in the read path with Cell that have BBs in them. &lt;br/&gt;
BR to BB is a case which has to be brainstormed and the best advantage we would get is that when we can have our own implementation of BR backed with some new type of BB.  &lt;br/&gt;
I would feel before doing that we should have our subtasks helping us out to achieve this.&lt;/p&gt;

&lt;p&gt;Reg the change to the Cell interface or creating a new Cell - creating a new  cell would make things go in 2.0. In other words it would mean that the read path would deal with Cell that are buffer based and write would deal with cells that are byte[] based.  CP would be exposed with  both type of cells.  Can we have annotations in the API that are exposed to cells and filters that tells which one to use and which one to use? That may be confusing but if we can have a cleaner way of showing which APIs are in the read and which one in write then may be it may make sense to extend Cell only for the new BB based cell.&lt;/p&gt;</comment>
                            <comment id="14188051" author="stack" created="Wed, 29 Oct 2014 06:13:28 +0000"  >&lt;blockquote&gt;&lt;p&gt;So the doc in some time.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Suggest sooner rather than later.  Doesn&apos;t have to be fancy and can change as we learn stuff.  Its just handy to have a reference doc because its hard to track across JIRAs.  Thanks.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Some of Andy&apos;s experiments shown that the position/limit checks in nio BB impls makes the perf bad and not getting inlining also. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah. Can look at what others have done too to get the speed up.  Netty good because has refcounting but downside is we are not going to get netty bufs from dfsclient; we can deal.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I would feel before doing that we should have our subtasks helping us out to achieve this.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Any POC&apos;ing to do in here first? Will help figure the tasks.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Can we do this way?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Would be good to try it first and be prepared to throw it away if it is awkward (I know its a bunch of work).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Compression case am checking some way we can avoid. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, hopefully no or minimal copying compressing.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ram_krish&quot; class=&quot;user-hover&quot; rel=&quot;ram_krish&quot;&gt;ramkrishna.s.vasudevan&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I would feel before doing that we should have our subtasks helping us out to achieve this.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Would be good to have general direction decided before the subtasks?  A bit of POC&apos;ing and a bit of spec how we are to proceed?  Then easy making up the subtasks.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;APIs are in the read and which one in write then may be it may make sense to extend Cell only for the new BB based cell.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hopefully we can avoid one way to write and another to read.&lt;/p&gt;

&lt;p&gt;Thanks lads.  Let me look at &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12282&quot; title=&quot;Ensure Cells and its implementations work with Buffers also&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12282&quot;&gt;&lt;del&gt;HBASE-12282&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14188064" author="ram_krish" created="Wed, 29 Oct 2014 06:26:03 +0000"  >&lt;p&gt;I will write a doc and share it here to get the comments and what we will be working on.&lt;/p&gt;</comment>
                            <comment id="14188168" author="anoop.hbase" created="Wed, 29 Oct 2014 09:27:52 +0000"  >&lt;blockquote&gt;&lt;p&gt;CP would be exposed with both type of cells. Can we have annotations in the API that are exposed to cells and filters that tells which one to use and which one to use? That may be confusing but if we can have a cleaner way of showing which APIs are in the read and which one in write then may be it may make sense to extend Cell only for the new BB based cell.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;If we continue to pass Cell in read path.. every where we need buffers, we will end up in casting. That is ugly. Can we change all places in read path to new interface BBBackedCell or some other better name.&lt;br/&gt;
Like what we pass to Filter, to cps, what StoreScanner, InternalScanner, RegionScanner returns.. etc...   It can land in 2.0 only I believe.&lt;br/&gt;
One option as Stack suggested have a hasArray() in Cell and based on decide which API to call in places like Comparators. (where we deal with Cells only).  Here the impls should throw Exception out of getxxxArray() API if hasArray() is false. (like BB impls)&lt;br/&gt;
Or else not make BBBackedCell to extend Cell at all. So we will see only getxxxBuffer() in read path. One adv is there is no diff in Public exposed Cell. It might not make much sense for hasArray() at client side because there we deal with Cells backed by Array only. Only in read path it make sense.&lt;/p&gt;</comment>
                            <comment id="14188198" author="ram_krish" created="Wed, 29 Oct 2014 10:02:02 +0000"  >&lt;p&gt;May be hasArray() would be the  best option so that the exposed APIs are not changed. So users using the CP and filters should use the hasArray() to determine which one to use getXXxArray or getXXXBuffer.&lt;/p&gt;</comment>
                            <comment id="14189425" author="stack" created="Thu, 30 Oct 2014 01:14:38 +0000"  >&lt;p&gt;Removing fix versions. The parent issue has none and this seems like non-critical improvement &#8211; shouldn&apos;t be in the way of 1.0. Put it back if I have it wrong.&lt;/p&gt;</comment>
                            <comment id="14190277" author="ram_krish" created="Thu, 30 Oct 2014 16:01:23 +0000"  >&lt;p&gt;An updated patch that adds hasArray to Cell.  Added some util methods in ByteBufferUtils and some part is copied from &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12345&quot; title=&quot;Unsafe based ByteBuffer Comparator&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12345&quot;&gt;&lt;del&gt;HBASE-12345&lt;/del&gt;&lt;/a&gt; as it is not yet committed. I will add some test cases once we are sure that this approach is fine. &lt;br/&gt;
I created a bigger patch changing through the read path but that is becoming bigger and bigger and have some challenges in that.  Doing them as individual subtasks may not be directly feasible for now.  Anyway we can finalise it once we are ok with this JIRA as that forms the basis of further things. &lt;/p&gt;</comment>
                            <comment id="14191673" author="ram_krish" created="Fri, 31 Oct 2014 10:37:06 +0000"  >&lt;p&gt;Some APIs needs some small changes.  Will update the patch once done and adding test cases. &lt;/p&gt;</comment>
                            <comment id="14191764" author="ram_krish" created="Fri, 31 Oct 2014 12:54:43 +0000"  >&lt;p&gt;Updated patch with test cases.  Also adds ByteBufferBackedKeyOnlyKeyValue.&lt;/p&gt;</comment>
                            <comment id="14191878" author="hadoopqa" created="Fri, 31 Oct 2014 14:49:22 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12678464/HBASE-12358_2.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12678464/HBASE-12358_2.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision .&lt;br/&gt;
  ATTACHMENT ID: 12678464&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 11 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 javac&lt;/font&gt;.  The applied patch generated 115 javac compiler warnings (more than the trunk&apos;s current 102 warnings).&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 javadoc&lt;/font&gt;.  The javadoc tool appears to have generated 3 warning messages.&lt;/p&gt;

&lt;p&gt;                &lt;font color=&quot;red&quot;&gt;-1 checkstyle&lt;/font&gt;.  The applied patch generated 3792 checkstyle errors (more than the trunk&apos;s current 3774 errors).&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 findbugs&lt;/font&gt;.  The patch appears to introduce 2 new Findbugs (version 2.0.3) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 lineLengths&lt;/font&gt;.  The patch introduces the following lines longer than 100:&lt;br/&gt;
    +  public static final int ROW_OFFSET = Bytes.SIZEOF_INT /* keylength &lt;b&gt;/+ Bytes.SIZEOF_INT /&lt;/b&gt; valuelength */;&lt;br/&gt;
+  public static long getKeyValueDataStructureSize(int rlength, int flength, int qlength, int vlength) {&lt;br/&gt;
+  public static ByteBufferBackedCell createFirstOnRow(final ByteBuffer row, int roffset, short rlength) {&lt;br/&gt;
+  public static ByteBufferBackedCell createLastOnRow(final ByteBuffer row, final int roffset, final int rlength,&lt;br/&gt;
+    return new ByteBufferBackedKeyValue(row, roffset, rlength, family, foffset, flength, qualifier, qoffset,&lt;br/&gt;
+  public static boolean equals(final ByteBuffer left, int leftOffset, int leftLen, final ByteBuffer right,&lt;br/&gt;
+  public static boolean equals(final ByteBuffer left, int leftOffset, int leftLen, final byte[] right,&lt;br/&gt;
+  public static boolean equals(final byte[] left, int leftOffset, int leftLen, final ByteBuffer right,&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 core tests&lt;/font&gt;.  The patch passed unit tests in .&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-rest.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-rest.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-annotations.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/newPatchFindbugsWarningshbase-annotations.html&lt;/a&gt;&lt;br/&gt;
Checkstyle Errors: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/checkstyle-aggregate.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/checkstyle-aggregate.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;                Javadoc warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/patchJavadocWarnings.txt&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//artifact/patchprocess/patchJavadocWarnings.txt&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/11542//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14192171" author="stack" created="Fri, 31 Oct 2014 18:04:15 +0000"  >&lt;p&gt;As a POC, v2 looks cleaner.&lt;/p&gt;

&lt;p&gt;What is ByteBufferBackedKeyValue then?  An old-school KeyValue only backed by BB?  Thats a good POC exercise I&apos;d say.&lt;/p&gt;

&lt;p&gt;You don&apos;t need HeapSize and Settable... because ByteBufferBackedCell implements them already:&lt;/p&gt;

&lt;p&gt;+public class ByteBufferBackedKeyValue implements ByteBufferBackedCell, HeapSize, Cloneable,&lt;br/&gt;
+    SettableSequenceId {&lt;/p&gt;

&lt;p&gt;Don&apos;t repeat these defines in new class I&apos;d say... just refer to them from KeyValue?&lt;/p&gt;

&lt;p&gt;+  /** Size of the key length field in bytes */&lt;br/&gt;
+  public static final int KEY_LENGTH_SIZE = Bytes.SIZEOF_INT;&lt;/p&gt;

&lt;p&gt;Or if you do bring them over, make them private so this madness (smile) doesn&apos;t leak about.&lt;/p&gt;

&lt;p&gt;On below, you can actually instantiate an empty one?&lt;/p&gt;

&lt;p&gt;+  public ByteBufferBackedKeyValue() &lt;/p&gt;
{
+
+  }


&lt;p&gt;We can&apos;t have a util per type as in ByteBufferBackedKeyValueUtil&lt;/p&gt;

&lt;p&gt;Could we have single util and it uses factory to get type particular methods?  Can do later.&lt;/p&gt;

&lt;p&gt;What you fellas think of adding this?&lt;/p&gt;

&lt;p&gt;+  public boolean hasArray() {&lt;/p&gt;

&lt;p&gt;Does it belong in Cell?  I mean, if it returns false, what are you to do?  Go find BB version?  Where you find that?  A factory can be used to figure the configured type inside server/client but as to whether or not we should use BBs rather than arrays... This is one way adding it to Cell but if DBBs, what you to do?&lt;/p&gt;

&lt;p&gt;On other hand, we are not going to have that many implementations of Cell... so if Cell answer false, then you presume it has implemented BBBCell... and use the BB methods.  SOmething like that.&lt;/p&gt;</comment>
                            <comment id="14194244" author="ram_krish" created="Mon, 3 Nov 2014 04:49:31 +0000"  >&lt;blockquote&gt;&lt;p&gt;On other hand, we are not going to have that many implementations of Cell... so if Cell answer false, then you presume it has implemented BBBCell... and use the BB methods. SOmething like that.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes something like that. But the comparators will have to do some more conditional checks if the cells on both sides are BB backed. If all cells are of the same type it is much easier.&lt;br/&gt;
To have hasArray() is fine but the way we consume it has to be measured for cases where one cell is BB and the other is from memstore which is byte[].&lt;/p&gt;</comment>
                            <comment id="14194267" author="ram_krish" created="Mon, 3 Nov 2014 05:43:49 +0000"  >&lt;p&gt;+1 on removing the HeapSize and SettableSEqunceId and to have a factory method later.&lt;/p&gt;</comment>
                            <comment id="14194295" author="anoop.hbase" created="Mon, 3 Nov 2014 06:24:36 +0000"  >&lt;blockquote&gt;&lt;p&gt;Or can we have our own impl like HBB/DBB? java.nio.ByteBuffer allow to extend.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;No I am wrong. Constructors in ByteBuffer  is not public !&lt;/p&gt;</comment>
                            <comment id="14214295" author="ram_krish" created="Mon, 17 Nov 2014 05:45:34 +0000"  >&lt;p&gt;Before we go about with the patch and the doc, from the code changes we found that it would be better to go with BRs rather than BBs. And most importantly for cells backed with BRs we would need the the getXXXBuffer() methods in the Cell itself so that later in the comparisons and code that tries to do a comparison with byte[] we could directly call Cell.getXXXBuffer() instead of checking if the Cell is byte[] backed or it is backed by BR.&lt;br/&gt;
This would avoid lot of conditions in the comparator code which is getting used in almost every where in the read code path. &lt;br/&gt;
As Anoop already pointed out for all the filters and exposed APIs the user might need to use Cell.hasArray() to determine whether to use getXXXArray() or getXXXBuffer().  &lt;br/&gt;
We could change every where to BBBackedCell in the read path but that would be much more bigger change.  Or we should go about with a totally new Cell in the read path that does not extend Cell.&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt;&lt;br/&gt;
Pls add on your points because this step of adding getXXXBuffer() in the Cell would help to make this simpler.&lt;br/&gt;
If we are agreeing to have getXXXBuffer APIs in the Cell then our work would be bit simplified and would look clean also mainly in the comparators etc.&lt;/p&gt;</comment>
                            <comment id="14214319" author="stack" created="Mon, 17 Nov 2014 06:11:46 +0000"  >&lt;blockquote&gt;&lt;p&gt;Before we go about with the patch and the doc, from the code changes we found that it would be better to go with BRs rather than BBs. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Can you say more why you found this &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ram_krish&quot; class=&quot;user-hover&quot; rel=&quot;ram_krish&quot;&gt;ramkrishna.s.vasudevan&lt;/a&gt;?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;...we would need the the getXXXBuffer() methods in the Cell itself ....&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You mean a getFamilyArray would have a companion getFamilyBuffer, and so on?  What would the getFamilyBuffer return?&lt;/p&gt;

&lt;p&gt;Doing comparisons when the bytes are off heap, how would that work?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;As Anoop already pointed out for all the filters and exposed APIs the user might need to use Cell.hasArray() to determine whether to use getXXXArray() or getXXXBuffer(). &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We&apos;d have to do this even if Cell was BR backed?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Or we should go about with a totally new Cell in the read path that does not extend Cell.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We want to have a single Interface that can be pasesd through the read-path and then do different implementations? It&apos;d be interesting if we couldn&apos;t figure one that works for on-heap/off-heap.&lt;/p&gt;

&lt;p&gt;Good stuff &lt;/p&gt;</comment>
                            <comment id="14214337" author="ram_krish" created="Mon, 17 Nov 2014 06:31:21 +0000"  >&lt;blockquote&gt;&lt;p&gt;Can you say more why you found this ramkrishna.s.vasudevan?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Pls refer to this comment from Anoop&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;No I am wrong. Constructors in ByteBuffer is not public !&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;So when we want to have multiple BBs forming a HFileBlock then we cannot extend BB to create a MultiBB and hence we thought we need our own way Class to represent the BBs. So BR would be an  option for that and for now BR would have a BB inside it and that BB could be onheap/offheap.  This is going to cause additional redirection but we need to measure the performance before we have our own impl of BR.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;You mean a getFamilyArray would have a companion getFamilyBuffer, and so on? What would the getFamilyBuffer return?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes we would have a companion.  If Cell says hasArray() as false but we try using getFamilyArray then we would copy the buffer to an array and then return it.  (costly). The reverse one where hasArray is true ( assume a Kv), now we would wrap the byte[] in a BR object and send it. (multiple short lived objects would be created here).&lt;br/&gt;
Hence the use of hasArray is very important. Users should be using this APIs prudently to decide which API to use. &lt;br/&gt;
If we need to avoid this we need to introduce a new Cell type which does not extend Cell and use it in the read path.  Then user has to rewrite his code based on that new Cell but it will not have this getXXxArray and getXXXBuffer confusion.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Doing comparisons when the bytes are off heap, how would that work?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;No problem. Since we would return only the BRs here we would create a BBBacked BR and that could be offheap or onheap.  All the util methods that we add would check if this BB inside BR is onheap/offheap and based on that the comparisons would work.  This works even now in our POC.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;We&apos;d have to do this even if Cell was BR backed?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes or we should totally have a new Cell impl (that does not extend Cell). A total incompatible change.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;We want to have a single Interface that can be pasesd through the read-path and then do different implementations? It&apos;d be interesting if we couldn&apos;t figure one that works for on-heap/off-heap.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We can do this the only thing is how we use the Cell interface.  The representation of on heap and offheap would go into that Cell&apos;s impl and rest of the code would not bother about it.&lt;/p&gt;
</comment>
                            <comment id="14214344" author="ram_krish" created="Mon, 17 Nov 2014 06:47:40 +0000"  >&lt;p&gt;Inorder to use getXXXBuffer() every where in the read path we would need to ensure on thing is that from the memstore also we would get a BR backed Cell.  That could be an onheap BR but will unify the code path instead of having multiple conditions.&lt;/p&gt;</comment>
                            <comment id="14214823" author="anoop.hbase" created="Mon, 17 Nov 2014 16:44:29 +0000"  >&lt;blockquote&gt;
&lt;p&gt;You mean a getFamilyArray would have a companion getFamilyBuffer, and so on? What would the getFamilyBuffer return?&lt;br/&gt;
Doing comparisons when the bytes are off heap, how would that work?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;For comparison we will always use getxxxBuffer() APIs. We can compare two BBs. (on heap or offheap) using ByteBufferUtils. Pls see patch in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12345&quot; title=&quot;Unsafe based ByteBuffer Comparator&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12345&quot;&gt;&lt;del&gt;HBASE-12345&lt;/del&gt;&lt;/a&gt; which even having the Unsafe optimization. Ya we change BB to BR in APIs, we can have similar util API.&lt;br/&gt;
In Read path Cells can come from HFiles and/or Memstore.  HFile cells can be backed by buffer (BR wrap we can make out) as the file data is actually in buffer (Either we read from HDFS or in cache).  In case of Memstore the Cells are backed by byte[]. getxxxBuffer() APIs need create new object every time. These are short lived objects any way. We discussed abt one way to solve this (in most cases). By default MSLAB is ON. The API in MSLAB returns a BR already. A new Cell impl can back this with out much of overhead on heap size. So getxxxbuffer() API , no need to create new Objects.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;As Anoop already pointed out for all the filters and exposed APIs the user might need to use Cell.hasArray() to determine whether to use getXXXArray() or getXXXBuffer().&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We&apos;d have to do this even if Cell was BR backed?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;BR will be either backed by array or buffer. The buffer can be offheap also where there is no backing array. In such case getxxxArray() might throw UnsupportedOpException. So hasArray() will be needed. &lt;/p&gt;</comment>
                            <comment id="14234450" author="ram_krish" created="Thu, 4 Dec 2014 18:36:49 +0000"  >&lt;p&gt;Before we decide on BB or BR, we would like to highlight some points here so that we could decide on the behaviour of the new Cell APIs.&lt;br/&gt;
Assume we will be working with BBs so we would introduce getXXXBuffer() APIs and also hasArray() in Cell itself directly. &lt;br/&gt;
If we try to extend the cell or create a new Cell then everywhere we need to do instanceOf check or do type conversion and that is why adding new APIS to Cell interface itself makes sense.&lt;br/&gt;
Plan is to use this getXXXBuffer API through out the read path.&lt;br/&gt;
Now there are two ways to use it &lt;br/&gt;
1) Use getXXXBuffer along with getXXXOffset, getXXXLength like how we use now for getXXXArray APIs with the offset and   length. Doing so would ensure that every where in the filters and CP one has to just replace the getXXXArray with getXXXBuffer and continue to use getXXXOffset and getXXXLength. We would do some wrapping of the byte[] with a BB incase of KeyValue type of cells so that getXXXBuffer along with offset and length holds true everywhere. Note that here if hasARray is false (for KV case) then getXXXArray would also work.&lt;/p&gt;

&lt;p&gt;2)The other way of using this is that use only getXXXBuffer() API and ensure that the BB is always duplicated/sliced and only the portion of the total BB is returned which represents the individual component of the Cell. In this case there is no use of getXXXOffset (as it is going to be 0) and getXXXLength() is any way going to be the sliced BB&apos;s limit.&lt;/p&gt;

&lt;p&gt;But in the 2nd approach we may end up in creating lot of small objects even while doing comparison.&lt;/p&gt;

&lt;p&gt;Now the next problem that comes is what to do with the getXXXArray() APIs. If one sees hasArray() as false (a DBB backed Cell) and uses the getXXXArray() API along with offset and length - what should we do. Should we create a byte[] from the DBB and return it? Then in that case what would should the getXXXOffset() return for a getXXXBuffer or getXXXArray()?&lt;/p&gt;

&lt;p&gt;If we go with the 2nd approach then getXXXBuffer() should be clearly documented saying that it has to be used without Offset and length and use getXXXOFfset and getXXXLength only with getXXXArray().&lt;/p&gt;

&lt;p&gt;Now if a Cell is backed by on heap BB then we could definitely return getXXXArray() also - but what to return in the getXXXOffset would be determined by what appraoch to use for getXXXBuffer. (based on (1) and (2)).&lt;/p&gt;

&lt;p&gt;We wanted to open up this topic now so that to get some feedback on what could be an option here.  Since it is an user facing Interface we need to be careful with this.&lt;/p&gt;

&lt;p&gt;I would suggest that whenever a Cell is BB backed(Onheap or offheap) always hasARray would be false in that Cell impl.&lt;br/&gt;
Every where we would use getXXXBuffer along with getXXXOffest and getXXXLength.  Even in case of KV we could wrap the byte[] with BB so that we have uniformity through the read code and we don&apos;t have too many &apos;if&apos; else conditions.&lt;/p&gt;

&lt;p&gt;When ever hasArray is false - using getXXXArray API would throw UnSupportedOperation Exception.&lt;/p&gt;

&lt;p&gt;AS said if we want getXXXArray to be supported as per the existing way then getXXXBuffer and getXXXOffset, getXXXLength should be clearly documented.&lt;/p&gt;

&lt;p&gt;Thoughts!!!&lt;/p&gt;



</comment>
                            <comment id="14234468" author="anoop.hbase" created="Thu, 4 Dec 2014 18:50:24 +0000"  >&lt;blockquote&gt;&lt;p&gt;Note that here if hasARray is false (for KV case) then getXXXArray would also work.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Correction : hasArray() is true&lt;/p&gt;</comment>
                            <comment id="14234861" author="stack" created="Fri, 5 Dec 2014 00:55:59 +0000"  >&lt;p&gt;Nice writeup.  Belongs on dev list &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt; I&apos;d say so gets more of an airing.&lt;/p&gt;</comment>
                            <comment id="14234972" author="anoop.hbase" created="Fri, 5 Dec 2014 02:45:50 +0000"  >&lt;p&gt;Sure&lt;/p&gt;</comment>
                            <comment id="14598005" author="anoop.hbase" created="Tue, 23 Jun 2015 17:29:24 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-13387&quot; title=&quot;Add ByteBufferedCell an extension to Cell&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-13387&quot;&gt;&lt;del&gt;HBASE-13387&lt;/del&gt;&lt;/a&gt; has discussion on this same issue and a design doc. That will add the new ByteBufferBackedCell interface and its usage around the core. (Like CellComparator).   We can handle this there and close this issue as a duplicate?&lt;/p&gt;</comment>
                            <comment id="14598791" author="anoop.hbase" created="Wed, 24 Jun 2015 03:06:03 +0000"  >&lt;p&gt;Closing as dup of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-13387&quot; title=&quot;Add ByteBufferedCell an extension to Cell&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-13387&quot;&gt;&lt;del&gt;HBASE-13387&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12677567" name="HBASE-12358.patch" size="2772" author="ram_krish" created="Tue, 28 Oct 2014 08:50:01 +0000"/>
                            <attachment id="12678215" name="HBASE-12358_1.patch" size="57068" author="ram_krish" created="Thu, 30 Oct 2014 16:01:23 +0000"/>
                            <attachment id="12678464" name="HBASE-12358_2.patch" size="75702" author="ram_krish" created="Fri, 31 Oct 2014 12:54:43 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 28 Oct 2014 09:22:34 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            1 year, 25 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i21nrz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>