<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 20:15:56 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-10656/HBASE-10656.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-10656]  high-scale-lib&apos;s Counter depends on Oracle (Sun) JRE, and also has some bug</title>
                <link>https://issues.apache.org/jira/browse/HBASE-10656</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;Cliff&apos;s high-scale-lib&apos;s Counter is used in important classes (for example, HRegion) in HBase, but Counter uses sun.misc.Unsafe, that is implementation detail of the Java standard library and belongs to Oracle (Sun). That consequently makes HBase depend on the specific JRE Implementation.&lt;/p&gt;

&lt;p&gt;To make matters worse, Counter has a bug and you may get wrong result if you mix a reading method into your logic calling writing methods.&lt;/p&gt;

&lt;p&gt;In more detail, I think the bug is caused by reading an internal array field without resolving memory caching, which is intentional the comment says, but storing the read result into a volatile field. That field may be not changed after you can see the true values of the array field, and also may be not changed after updating the &quot;next&quot; CAT instance&apos;s values in some race condition when extending CAT instance chain.&lt;/p&gt;

&lt;p&gt;Anyway, it is possible that you create a new alternative class which only depends on the standard library. I know Java8 provides its alternative, but HBase should support Java6 and Java7 for some time.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12698366">HBASE-10656</key>
            <summary> high-scale-lib&apos;s Counter depends on Oracle (Sun) JRE, and also has some bug</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="ikeda">Hiroshi Ikeda</assignee>
                                    <reporter username="ikeda">Hiroshi Ikeda</reporter>
                        <labels>
                    </labels>
                <created>Mon, 3 Mar 2014 07:53:51 +0000</created>
                <updated>Thu, 3 Nov 2016 21:29:39 +0000</updated>
                            <resolved>Fri, 14 Mar 2014 23:31:11 +0000</resolved>
                                                    <fixVersion>0.96.2</fixVersion>
                    <fixVersion>0.98.1</fixVersion>
                    <fixVersion>0.99.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>14</watches>
                                                                                                            <comments>
                            <comment id="13917815" author="ikeda" created="Mon, 3 Mar 2014 07:58:03 +0000"  >&lt;p&gt;Added a sample class.&lt;/p&gt;</comment>
                            <comment id="13918328" author="stack" created="Mon, 3 Mar 2014 18:05:06 +0000"  >&lt;p&gt;Nice work &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ikeda&quot; class=&quot;user-hover&quot; rel=&quot;ikeda&quot;&gt;Hiroshi Ikeda&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We use Unsafe in other areas of the code base too so a total purge would take more than just our undoing use of high-scale-lib counters.&lt;/p&gt;

&lt;p&gt;Are we susceptible to the bug you&apos;ve identified?  Do we do the write while read w/o protection?   Are these high-scale counters used for metrics only or for more critical countings?  I&apos;ve not looked.&lt;/p&gt;

&lt;p&gt;Thanks you &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ikeda&quot; class=&quot;user-hover&quot; rel=&quot;ikeda&quot;&gt;Hiroshi Ikeda&lt;/a&gt; for digging in here.&lt;/p&gt;</comment>
                            <comment id="13918335" author="nkeywal" created="Mon, 3 Mar 2014 18:11:15 +0000"  >&lt;p&gt;Is there any reference to this bug in the high-scale-lib repo?&lt;/p&gt;</comment>
                            <comment id="13918968" author="ikeda" created="Tue, 4 Mar 2014 03:07:36 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;We use Unsafe in other areas of the code base too so a total purge would take more than just our undoing use of high-scale-lib counters.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I know org.apache.hadoop.hbase.util.Bytes uses Unsafe but it swithces logic in runtime so that Oracle JDK is indispensable only for build time. On the contrary, high-scale-lib crachs in runtime when it fails to find Unsafe. I don&apos;t find any things like this in code of HBase, though I&apos;m not sure about the other 3rd party libraries.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Are we susceptible to the bug you&apos;ve identified?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I worry a little about HBaseServer using the Counter for some threshold, but by and large I agree that the effect of the bug itself doesn&apos;t seem so serious.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Do we do the write while read w/o protection?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Without locks, reading the count is just only weakly consisntent like ConcurrentHashMap.size(). While there are threads chainging the count, the count read is just an estimate, but if there are no such threads while reading the count it should give the correct count at the time.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=nkeywal&quot; class=&quot;user-hover&quot; rel=&quot;nkeywal&quot;&gt;Nicolas Liochon&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Is there any reference to this bug in the high-scale-lib repo?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I just found the bug (or just buggy specification that allows losing counts?) when I used it by way of experiment, and I didn&apos;t so hardly search information about it in web, because I think the dependency to Oracle JRE is a much more substantial problem. I think this is not listed up on the bug tickets in the sourceforge&apos;s high-scale-lib page.&lt;/p&gt;</comment>
                            <comment id="13919004" author="stack" created="Tue, 4 Mar 2014 04:29:00 +0000"  >&lt;blockquote&gt;&lt;p&gt;On the contrary, high-scale-lib crachs in runtime when it fails to find Unsafe.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We should have a fallback implementation as you suggest.&lt;/p&gt;</comment>
                            <comment id="13919111" author="apurtell" created="Tue, 4 Mar 2014 08:00:50 +0000"  >&lt;blockquote&gt;&lt;p&gt;We should have a fallback implementation as you suggest.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;</comment>
                            <comment id="13919130" author="ikeda" created="Tue, 4 Mar 2014 08:31:56 +0000"  >&lt;p&gt;Added a revised test. Sorry, the previously added test prints wrong consumed time. I created non-blocking logic, which should cause few context switches, and I should have woken up at first the thread recording its start time.&lt;/p&gt;

&lt;p&gt;Avoiding cache-line contention is one of the key words to improve performance, but ironically we only detect it via failure of CAS with intentionally colliding accesses. I think the size of cache-line differ from environments, and if the estimate is small the chance of the detection reduces. For my environment it seems the size of cache-line is 64bit * 8 and setting MyCounter.Cat.CACHE_LINE_SCALE to 4 works well.&lt;/p&gt;

&lt;p&gt;I used a well-spreaded hashcode using Thread.getId() under the assumption that the ID is sequentially increasing, but that therefore reduces the chance of failure of CAS, and that is bad if estimate size of the cache-line is small. That&apos;s a dilemma.&lt;/p&gt;</comment>
                            <comment id="13919140" author="ikeda" created="Tue, 4 Mar 2014 08:42:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;MyCounter.Cat.CACHE_LINE_SCALE to 4&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry, &quot;MyCounter.Cat.CACHE_LINE_SCALE to 3&quot; is correct because 8 = 1 &amp;lt;&amp;lt; 3&lt;/p&gt;</comment>
                            <comment id="13920636" author="ikeda" created="Wed, 5 Mar 2014 08:10:55 +0000"  >&lt;p&gt;Added an alternative counter class, using some logic from LongAdder in Java8.&lt;/p&gt;

&lt;p&gt;The counter reuse resources when extending the internal hash table, so that it avoids complexity of race condition caused by the extending, and it avoid to hold old unused resources and their sum cache for performance. Instead, the counter has to create an instance per each value holder. I think this may be overhead, but each instance can be independently placed in memory so that this may help to reduce cache line contention. &lt;/p&gt;

&lt;p&gt;Like LongAdder, each value holder is surrounded by 2 of fixed size pads. Each of the pads consists of 7 long values (64bit * 7). That means, this expects the size of cache line is fixed to about 64bit * 16.&lt;/p&gt;

&lt;p&gt;This counter simply uses Thread.getId() as hashcode. The reversed bit of the id is well spreaded, but cache line contention is not avoidable before every extending the hash table if the estimate size of cache line is small. With starting small hash size, this may come frequently in the early stages, and anyone don&apos;t know whether the extendings will be stopped at a good point or not.&lt;/p&gt;

&lt;p&gt;Unlike LongAdder, when this counter creates the internal hash table (that is an array of references to value holders), this counter fills it with value holder instances. Creating instances on demand is too complex to keep consistency. In source code of LongAdder I referred, I didn&apos;t find out what ensures happens-before relation between putting value holders on demand to the internal array and referring them from the array in order to sum up the values.&lt;/p&gt;

&lt;p&gt;Besides the above concerns, in my environment, the added counter seems to have enough performance to (a bit faster than) high-scale-lib even without mixing read operations.&lt;/p&gt;</comment>
                            <comment id="13922059" author="ikeda" created="Thu, 6 Mar 2014 06:16:44 +0000"  >&lt;p&gt;Added a performance test and its output in my environment, which has 8 core.&lt;/p&gt;</comment>
                            <comment id="13923731" author="ikeda" created="Fri, 7 Mar 2014 09:55:54 +0000"  >&lt;p&gt;Added a patch for 0.96, and a patch for trunk and 0.98.&lt;br/&gt;
I hope these patches are correct and can be built, but I created these patches with just handwriting, because I have no environment to build HBase. I hope somebody will revise and continue.&lt;/p&gt;</comment>
                            <comment id="13923818" author="hadoopqa" created="Fri, 7 Mar 2014 12:02:52 +0000"  >&lt;p&gt;&lt;font color=&quot;green&quot;&gt;+1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12633340/HBASE-10656-trunk.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12633340/HBASE-10656-trunk.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision .&lt;br/&gt;
  ATTACHMENT ID: 12633340&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 2 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop1.0&lt;/font&gt;.  The patch compiles against the hadoop 1.0 profile.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop1.1&lt;/font&gt;.  The patch compiles against the hadoop 1.1 profile.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javadoc&lt;/font&gt;.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any new Findbugs (version 1.3.9) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 core tests&lt;/font&gt;.  The patch passed unit tests in .&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/8921//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="13924460" author="stack" created="Fri, 7 Mar 2014 23:06:41 +0000"  >&lt;blockquote&gt;&lt;p&gt;... because I have no environment to build HBase&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It looks like you did a good job hand-writing your patch given all tests pass.&lt;/p&gt;

&lt;p&gt;Am I reading your table correctly?  It says your implementation consistently faster than cliff click lib and AtomicInteger?&lt;/p&gt;

&lt;p&gt;What happens if the below does no longer holds?&lt;/p&gt;

&lt;p&gt;+    // ...The cache-line size is expected to be equal to or&lt;br/&gt;
+    // less than about 128 Bytes (= 64 Bits * 16).&lt;/p&gt;

&lt;p&gt;We will lose the cache line advantage and stuff will slow?&lt;/p&gt;

&lt;p&gt;I did a cursory review.  This looks great.  Looking at LongAdder, its public domain so copying from it is fine (I was concerned about license issues).&lt;/p&gt;</comment>
                            <comment id="13925593" author="ikeda" created="Mon, 10 Mar 2014 09:34:15 +0000"  >&lt;blockquote&gt;&lt;p&gt;Am I reading your table correctly? It says your implementation consistently faster than cliff click lib and AtomicInteger?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, the table says my counter works well.&lt;/p&gt;

&lt;p&gt;For increment, comparing to high-scale-lib, the newly created counter has just a bit advantage, which is coming from simplicity of logic, and just meaningful in micro-bench, I think.&lt;/p&gt;

&lt;p&gt;For getting a value, high-sacle-lib&apos;s counter forgets to skip pads to sum up values (almost bug). Using a volatile instance variable to cache the sum may also causes overhead, but anyway, high-scale-lib&apos;s counter gives a wrong value so that I don&apos;t want to use it.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What happens if the below does no longer holds?&lt;/p&gt;

&lt;p&gt;+ // ...The cache-line size is expected to be equal to or&lt;br/&gt;
+ // less than about 128 Bytes (= 64 Bits * 16).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;By the previously uploaded result of my performance test, for AtomicLong, using more threads requires more time. It starts contention using 2 threads, with gradually increasing to 8 threads, which causes full contention because my environment has 8 core.&lt;/p&gt;

&lt;p&gt;The same overhead may be occurred for the newly created counter if the actual cache line is larger than the size I expected.&lt;br/&gt;
It seems that only just contention with 2 threads may be relatively large. It is possible that the performance drastically reduces.&lt;/p&gt;

&lt;p&gt;However, in the first place, the effect of adding pads basically depends on the implementation of JRE. I referred the source code of LongAdder and added pads like it, and I think it is practical because the LongAdder is written by an expert, but logically VM may eliminate that unused pads under the name of optimization.&lt;/p&gt;

&lt;p&gt;Also adding pads can waste memory. The newly created counter uses about 16 long variables for one cell, and supposing the internal array requires 8 length to avoid contention, it requires the same memory as 128 long variables per a counter. I think it is already sufficiently done to waste memory.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Looking at LongAdder, its public domain so copying from it is fine (I was concerned about license issues).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I just borrow a trick of padding and copy&amp;amp;paste names of pad variables (that are never used and any names will go) from LongAdder. There are the other ideas in LongAdder, but it depends on VM implementation in the end, and performance costs of the ticks didn&apos;t seem trivial comparing to the main logic (just increment), so I just give priority to make my counter simple. It may be required to revise if it is too rough.&lt;/p&gt;</comment>
                            <comment id="13935818" author="stack" created="Fri, 14 Mar 2014 23:30:30 +0000"  >&lt;p&gt;Patches rotted a little.  Here is what I applied.&lt;/p&gt;
</comment>
                            <comment id="13935820" author="stack" created="Fri, 14 Mar 2014 23:31:11 +0000"  >&lt;p&gt;Nice patch.  Thanks you &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ikeda&quot; class=&quot;user-hover&quot; rel=&quot;ikeda&quot;&gt;Hiroshi Ikeda&lt;/a&gt;  I applied to all branches 0.96-0.99&lt;/p&gt;</comment>
                            <comment id="13935902" author="hudson" created="Sat, 15 Mar 2014 01:09:05 +0000"  >&lt;p&gt;FAILURE: Integrated in hbase-0.96-hadoop2 #241 (See &lt;a href=&quot;https://builds.apache.org/job/hbase-0.96-hadoop2/241/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/hbase-0.96-hadoop2/241/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10656&quot; title=&quot; high-scale-lib&amp;#39;s Counter depends on Oracle (Sun) JRE, and also has some bug&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10656&quot;&gt;&lt;del&gt;HBASE-10656&lt;/del&gt;&lt;/a&gt; high-scale-lib&apos;s Counter depends on Oracle (Sun) JRE, and also has some bug (stack: rev 1577760)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-common/src/main/java/org/apache/hadoop/hbase/util/Counter.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-common/src/test/java/org/apache/hadoop/hbase/util/TestCounter.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-server/pom.xml&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-server/src/main/java/org/apache/hadoop/hbase/ipc/RpcServer.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/TableMapReduceUtil.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-server/src/main/java/org/apache/hadoop/hbase/metrics/ExactCounterMetric.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/CompactionTool.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MemStoreFlusher.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/pom.xml&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13935935" author="hudson" created="Sat, 15 Mar 2014 02:15:55 +0000"  >&lt;p&gt;FAILURE: Integrated in hbase-0.96 #350 (See &lt;a href=&quot;https://builds.apache.org/job/hbase-0.96/350/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/hbase-0.96/350/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10656&quot; title=&quot; high-scale-lib&amp;#39;s Counter depends on Oracle (Sun) JRE, and also has some bug&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10656&quot;&gt;&lt;del&gt;HBASE-10656&lt;/del&gt;&lt;/a&gt; high-scale-lib&apos;s Counter depends on Oracle (Sun) JRE, and also has some bug (stack: rev 1577760)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-common/src/main/java/org/apache/hadoop/hbase/util/Counter.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-common/src/test/java/org/apache/hadoop/hbase/util/TestCounter.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-server/pom.xml&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-server/src/main/java/org/apache/hadoop/hbase/ipc/RpcServer.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/TableMapReduceUtil.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-server/src/main/java/org/apache/hadoop/hbase/metrics/ExactCounterMetric.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/CompactionTool.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MemStoreFlusher.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.96/pom.xml&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13935956" author="hudson" created="Sat, 15 Mar 2014 03:00:11 +0000"  >&lt;p&gt;FAILURE: Integrated in HBase-TRUNK #5013 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-TRUNK/5013/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-TRUNK/5013/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10656&quot; title=&quot; high-scale-lib&amp;#39;s Counter depends on Oracle (Sun) JRE, and also has some bug&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10656&quot;&gt;&lt;del&gt;HBASE-10656&lt;/del&gt;&lt;/a&gt; high-scale-lib&apos;s Counter depends on Oracle (Sun) JRE, and also has some bug (stack: rev 1577759)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/trunk/hbase-common/src/main/java/org/apache/hadoop/hbase/util/Counter.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-common/src/test/java/org/apache/hadoop/hbase/util/TestCounter.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/pom.xml&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/ipc/RpcServer.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/TableMapReduceUtil.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/metrics/ExactCounterMetric.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/CompactionTool.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MemStoreFlusher.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/pom.xml&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/docbkx/developer.xml&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13936362" author="hudson" created="Sun, 16 Mar 2014 01:24:34 +0000"  >&lt;p&gt;SUCCESS: Integrated in HBase-TRUNK-on-Hadoop-1.1 #119 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-TRUNK-on-Hadoop-1.1/119/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-TRUNK-on-Hadoop-1.1/119/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10656&quot; title=&quot; high-scale-lib&amp;#39;s Counter depends on Oracle (Sun) JRE, and also has some bug&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10656&quot;&gt;&lt;del&gt;HBASE-10656&lt;/del&gt;&lt;/a&gt; high-scale-lib&apos;s Counter depends on Oracle (Sun) JRE, and also has some bug (stack: rev 1577759)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/trunk/hbase-common/src/main/java/org/apache/hadoop/hbase/util/Counter.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-common/src/test/java/org/apache/hadoop/hbase/util/TestCounter.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/pom.xml&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/ipc/RpcServer.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/TableMapReduceUtil.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/metrics/ExactCounterMetric.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/CompactionTool.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/MemStoreFlusher.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/pom.xml&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/docbkx/developer.xml&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13941512" author="ikeda" created="Thu, 20 Mar 2014 08:30:57 +0000"  >&lt;p&gt;I&apos;m a little worried about that the new Counter may consume too much memory. The Counter usually expands its internal table to distinguish threads&apos; IDs. That means, for example, using two threads with ID=0 and 256 requires 512 length for the table, and each element uses about 16 long variables, and the table consequently consumes about 8192 long variable (= 64KB) for only just one counter. This can become worse for using ID=0 and 512, or ID=0 and 1024, etc.&lt;/p&gt;

&lt;p&gt;(However, I think high-scale-lib&apos;s Counter usually consume more memory than the new Counter, because using random hash has more chances to collide than using sequential one.)&lt;/p&gt;

&lt;p&gt;After some trials I has concluded that we have only 3 methods to give a different index (or something) to a thread without synchronization,&lt;br/&gt;
(1) Thread.getId(),&lt;br/&gt;
(2) Object.hashCode() (or System.identityHashCode() for more safety), and&lt;br/&gt;
(3) ThreadLocal. &lt;br/&gt;
Only using (3) can change the index, and we require it instead of extending the internal table. Performance cost of using ThreadLocal is not trivial comparing to the main logic (just increment), but we have no choice.&lt;/p&gt;

&lt;p&gt;I attached files:&lt;br/&gt;
MyCounter3.java, which is an alternative Counter,&lt;br/&gt;
PerformanceTestApp2.java and its result files.&lt;br/&gt;
Also I attached the additional patch for the case that we decide to adopt it.&lt;/p&gt;

&lt;p&gt;According to the result of the performance test, for increment, MyCounter3 requires more 30-40% overhead than MyCounter2, which is also slower than high-scale-lib&apos;s Counter when using a lot of threads. I could not recover the overhead of ThreadLocal after all.&lt;/p&gt;

&lt;p&gt;(For getting a value, MyCounter3 is faster than MyCounter2 when using a lot of threads because the internal table to traverse to sum values is smaller.)&lt;/p&gt;

&lt;p&gt;I am not sure whether the patch should be applied or not.&lt;/p&gt;

&lt;p&gt;By the way, Java8 is recently released and I tried and was surprised that, LongAdder is much more faster than any counters, without unlimitedly consuming memory. I wanted to know the trick, but I just found that it uses Unsafe to directly access Thread&apos;s newly added instance variable to store thread-local information bypassing ThreadLocal. That&apos;s cheat! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13941918" author="stack" created="Thu, 20 Mar 2014 16:32:20 +0000"  >&lt;blockquote&gt;&lt;p&gt;That&apos;s cheat! &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Smile&lt;/p&gt;

&lt;p&gt;Thank you for the continued investigations &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ikeda&quot; class=&quot;user-hover&quot; rel=&quot;ikeda&quot;&gt;Hiroshi Ikeda&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think high-scale-lib&apos;s Counter usually consume more memory than the new Counter&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is interesting.&lt;/p&gt;

&lt;p&gt;Have you looked at how much is consumed in an actual hbase deploy?   Can I check for you?&lt;/p&gt;</comment>
                            <comment id="13942838" author="ikeda" created="Fri, 21 Mar 2014 06:23:11 +0000"  >&lt;p&gt;Sorry I just guess it by some trials of my counters with replacing ID and hashcode, and I don&apos;t have practical scale HBase for my tests.&lt;/p&gt;

&lt;p&gt;If in actual usages in HBase the performance overhead of ThreadLocal is not so apparent, I prefer the last counter because of its durability in general situtations in the current and near future HBase. Even if the measuerd consumed memory is low, it may still depend on situations and luck (though using the sequential ID gives more adaptability to restricted situations).&lt;/p&gt;</comment>
                            <comment id="13943339" author="stack" created="Fri, 21 Mar 2014 18:18:54 +0000"  >&lt;blockquote&gt;&lt;p&gt;... I prefer the last counter....&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You mean MyCounter3.java?  I can try it...&lt;/p&gt;</comment>
                            <comment id="13944745" author="ikeda" created="Mon, 24 Mar 2014 04:46:07 +0000"  >&lt;p&gt;Yes, I mean I want to apply the additional patch (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10656&quot; title=&quot; high-scale-lib&amp;#39;s Counter depends on Oracle (Sun) JRE, and also has some bug&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10656&quot;&gt;&lt;del&gt;HBASE-10656&lt;/del&gt;&lt;/a&gt;-addition.patch), which reflects MyCounter3.java.&lt;/p&gt;

&lt;p&gt;I believe the performance cost of ThreadLocal is usually ignorable for usual meaningful logic and unpredictably consuming memory is more serious, but if there is anyone who doubt it, strictly speaking, measuring is required.&lt;/p&gt;</comment>
                            <comment id="13946169" author="stack" created="Tue, 25 Mar 2014 05:00:32 +0000"  >&lt;p&gt;Committed &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10656&quot; title=&quot; high-scale-lib&amp;#39;s Counter depends on Oracle (Sun) JRE, and also has some bug&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10656&quot;&gt;&lt;del&gt;HBASE-10656&lt;/del&gt;&lt;/a&gt;-addition.patch over in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10822&quot; title=&quot;Thread local addendum to HBASE-10656 Counter&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10822&quot;&gt;&lt;del&gt;HBASE-10822&lt;/del&gt;&lt;/a&gt;  Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ikeda&quot; class=&quot;user-hover&quot; rel=&quot;ikeda&quot;&gt;Hiroshi Ikeda&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13946173" author="hudson" created="Tue, 25 Mar 2014 05:01:35 +0000"  >&lt;p&gt;FAILURE: Integrated in HBase-TRUNK #5037 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-TRUNK/5037/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-TRUNK/5037/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10822&quot; title=&quot;Thread local addendum to HBASE-10656 Counter&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10822&quot;&gt;&lt;del&gt;HBASE-10822&lt;/del&gt;&lt;/a&gt; Thread local addendum to &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10656&quot; title=&quot; high-scale-lib&amp;#39;s Counter depends on Oracle (Sun) JRE, and also has some bug&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10656&quot;&gt;&lt;del&gt;HBASE-10656&lt;/del&gt;&lt;/a&gt; Counter (stack: rev 1581141)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/trunk/hbase-common/src/main/java/org/apache/hadoop/hbase/util/Counter.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14331351" author="enis" created="Sat, 21 Feb 2015 23:35:38 +0000"  >&lt;p&gt;Closing this issue after 0.99.0 release. &lt;/p&gt;</comment>
                            <comment id="15586749" author="stack" created="Tue, 18 Oct 2016 21:43:48 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ikeda&quot; class=&quot;user-hover&quot; rel=&quot;ikeda&quot;&gt;Hiroshi Ikeda&lt;/a&gt; Here is an interesting observation by a coworker &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=misha%40cloudera.com&quot; class=&quot;user-hover&quot; rel=&quot;misha@cloudera.com&quot;&gt;Misha Dmitriev&lt;/a&gt;. I can open new issue to discuss but posting here for moment:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;To induce high load on MONITORING TOOL in my small 8-machine cluster, V suggested to create 10 hbase tables with 1K regions each - in this way, MONITORING TOOL gets 10K new entities to monitor. I&apos;ve done that and it worked for MONITORING TOOL as expected. However, one thing that we noticed is that HBase Region Servers in my cluster are now constantly running GC....&lt;/p&gt;

&lt;p&gt;I decided to take a quick look, took a heap dump from one of the region servers and analyzed it with the same tool (&lt;a href=&quot;http://www.jxray.com&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.jxray.com&lt;/a&gt;) that I use in the MONITORING TOOL work. The output is attached.&lt;/p&gt;

&lt;p&gt;One finding is that 41% of memory is occupied by instances of org.apache.hadoop.hbase.util.Counter$Cell class, and they seem to be actively &quot;churned&quot; by GC all the time. I looked at the code of this class, and one thing that immediately caught my eye is this:&lt;/p&gt;

&lt;p&gt;  private static class Cell {&lt;br/&gt;
    // Pads are added around the value to avoid cache-line contention with&lt;br/&gt;
    // another cell&apos;s value. The cache-line size is expected to be equal to or&lt;br/&gt;
    // less than about 128 Bytes (= 64 Bits * 16).&lt;/p&gt;

&lt;p&gt;    @SuppressWarnings(&quot;unused&quot;)&lt;br/&gt;
    volatile long p0, p1, p2, p3, p4, p5, p6;&lt;br/&gt;
    volatile long value;&lt;br/&gt;
    @SuppressWarnings(&quot;unused&quot;)&lt;br/&gt;
    volatile long q0, q1, q2, q3, q4, q5, q6;&lt;/p&gt;

&lt;p&gt;So, as far as I understand, the only meaningful data field in this class, &apos;value&apos;, is deliberately &quot;padded&quot; with empty fields just to make an instance of this class big enough to fit the entire 128-byte cache line.&lt;/p&gt;

&lt;p&gt;This looks like a very extreme optimization that would work if there were very few objects in memory, or at least very few of Counter$Cell instances, so that they were kept in the cache all the time. But clearly in our case making these objects artificially large greatly increases the GC pressure and ultimately makes everything much slower.&lt;/p&gt;

&lt;p&gt;Can somebody shed some light on this? In particular:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Why do so many Counter instances are created and destroyed all the time despite the fact that there is no HBase activity going on?&lt;/li&gt;
	&lt;li&gt;I don&apos;t think the setup with 10K regions is very unconventional. If so many Cell objects need to be maintained, then probably it&apos;s worth providing e.g. another implementation that&apos;s simply optimized for size rather than for memory cache performance?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;On Question #1, it is probably our metrics accounting that is going on. On #2, you might have input.&lt;/p&gt;</comment>
                            <comment id="15586863" author="apurtell" created="Tue, 18 Oct 2016 22:26:18 +0000"  >&lt;p&gt;Master / 2.0 can use LongAdder, available in JRE 8: &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAdder.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAdder.html&lt;/a&gt; . I don&apos;t have a ready answer for 1.x or 0.98 (although the latter may be retired soon). &lt;/p&gt;</comment>
                            <comment id="15586946" author="enis" created="Tue, 18 Oct 2016 22:58:55 +0000"  >&lt;blockquote&gt;&lt;p&gt;Master / 2.0 can use LongAdder, available in JRE 8&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We already do so. &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I don&apos;t have a ready answer for 1.x or 0.98&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I was suggesting in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16146&quot; title=&quot;Counters are expensive...&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16146&quot;&gt;&lt;del&gt;HBASE-16146&lt;/del&gt;&lt;/a&gt; that we can do a backport of LongAdder in HBase. I did not check the license implications though. &lt;/p&gt;</comment>
                            <comment id="15586960" author="apurtell" created="Tue, 18 Oct 2016 23:04:08 +0000"  >&lt;p&gt;Public domain, category A, provided we use the JSR166 sources not what was donated to OpenJDK and relicensed as GPL 2 (category X)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/LongAdder.java?view=co&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/LongAdder.java?view=co&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;/*
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

</comment>
                            <comment id="15587121" author="enis" created="Wed, 19 Oct 2016 00:10:27 +0000"  >&lt;p&gt;Great. Looked at the code for Striped64, it uses Contended annotation though which is Java-8 only AFAIK. So we have have to do the same trickery with our own padding, thus suffering from the same GC problem above. &lt;/p&gt;</comment>
                            <comment id="15587146" author="misha@cloudera.com" created="Wed, 19 Oct 2016 00:22:57 +0000"  >&lt;p&gt;To be more specific, our RegionServers end up with millions of Counter$Cell objects in memory:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
 #instances     Shallow size     #instances    Shallow size       &lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt; name
  garbage       garbage           live         live                         
----------------------------------------------------------------------------
 2,985,951   396,571K (32.8%)      766,919    101,856K (8.4%)     org.apache.hadoop.hbase.util.Counter$Cell
 2,985,949     69,983K (5.8%)      766,918     17,974K (1.5%)     org.apache.hadoop.hbase.util.Counter$Cell[]
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I think there is no point in talking about optimizations where we forcefully prevent two Cell objects from sharing a single cache line where there are so many of them that they just cause memory blowup.&lt;/p&gt;

&lt;p&gt;A simple way of solving this problem would be to just remove the extra padding long fields. However, I am totally new to HBase and don&apos;t know whether a large number of these objects is always the case. Maybe in some setups there are very few of them. In that case, maybe it would make sense to have two alternative implementations of Cell:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;one that assumes a small number of objects and optimized for cache speed, as now&lt;/li&gt;
	&lt;li&gt;another that&apos;s just as compact as possible.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15587191" author="stack" created="Wed, 19 Oct 2016 00:39:49 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=misha%40cloudera.com&quot; class=&quot;user-hover&quot; rel=&quot;misha@cloudera.com&quot;&gt;Misha Dmitriev&lt;/a&gt; There was no load on the cluster, right?&lt;/p&gt;</comment>
                            <comment id="15587208" author="misha@cloudera.com" created="Wed, 19 Oct 2016 00:48:32 +0000"  >&lt;p&gt;Correct - no user activity. Though you may be right that the monitoring tool does something inside HBase.&lt;/p&gt;</comment>
                            <comment id="15587767" author="ikeda" created="Wed, 19 Oct 2016 05:48:11 +0000"  >&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The Counter is not intended to be frequently created and discarded into garbage. There seems many abuses &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/tongue.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The javadoc of sun.misc.Contended in Java 8 says: &quot;The effects of this annotation will nearly always add significant space overhead to objects.&quot; It seems VM implementations will automatically add pads for you and abusing LongAdder will still cause the same memory issue.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;As I wrote in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16616&quot; title=&quot;Rpc handlers stuck on ThreadLocalMap.expungeStaleEntry&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16616&quot;&gt;&lt;del&gt;HBASE-16616&lt;/del&gt;&lt;/a&gt;, it would be good to change indexHolderThreadLocal to be static, not only to avoid frequently calling ThreadLocalMap.expungeStaleEntry, also to avoid frequently calling ThreadLocalMap.getEntryAfterMiss, which seems the cause of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16146&quot; title=&quot;Counters are expensive...&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16146&quot;&gt;&lt;del&gt;HBASE-16146&lt;/del&gt;&lt;/a&gt; according to comments, but still counters require memory overhead and should not be abused.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Revert &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16146&quot; title=&quot;Counters are expensive...&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16146&quot;&gt;&lt;del&gt;HBASE-16146&lt;/del&gt;&lt;/a&gt; or it would be better to replace all counters with AtomicLong. Cache line contention is difficult to be detected on the language level and we should stretch a net to catch the sign by chance through many cache line contentions occur, even though the degradation is visible, and it wastes to use the sign just once, throw away, and continue to suffer further contentions.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I don&apos;t like to remove pads and pray &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/tongue.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15589346" author="misha@cloudera.com" created="Wed, 19 Oct 2016 17:36:51 +0000"  >&lt;p&gt;I am 99% sure that the JVM doesn&apos;t automatically generate padding for any objects (other than the fact that all objects in memory are 8-byte aligned, I think - i.e. they can only start at addresses 0, 8, 16 and so on).&lt;/p&gt;

&lt;p&gt;Otherwise, I fully agree that it&apos;s best if it&apos;s possible to just keep a small number of objects and avoid permanent creation/GC.&lt;/p&gt;</comment>
                            <comment id="15589431" author="enis" created="Wed, 19 Oct 2016 18:11:40 +0000"  >&lt;blockquote&gt;&lt;p&gt;Revert &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16146&quot; title=&quot;Counters are expensive...&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16146&quot;&gt;&lt;del&gt;HBASE-16146&lt;/del&gt;&lt;/a&gt; or it would be better to replace all counters with AtomicLong. Cache line contention is difficult to be detected on the language level and we should stretch a net to catch the sign by chance through many cache line contentions occur, even though the degradation is visible, and it wastes to use the sign just once, throw away, and continue to suffer further contentions.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;No. AtomicLong is pretty bad for metrics usage. See the micro benchmarks in various jiras, including &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-7612&quot; title=&quot;[JDK8] Replace use of high-scale-lib counters with intrinsic facilities&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-7612&quot;&gt;&lt;del&gt;HBASE-7612&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15222&quot; title=&quot;Use less contended classes for metrics&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15222&quot;&gt;&lt;del&gt;HBASE-15222&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16146&quot; title=&quot;Counters are expensive...&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16146&quot;&gt;&lt;del&gt;HBASE-16146&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I am 99% sure that the JVM doesn&apos;t automatically generate padding for any objects (other than the fact that all objects in memory are 8-byte aligned, I think - i.e. they can only start at addresses 0, 8, 16 and so on).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Please read &lt;a href=&quot;http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-November/007309.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-November/007309.html&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;I think the main problem is that we have A LOT of per-region metrics that are latency histograms. These latency histograms create many many Counter / LongAdder objects. We should get rid of per-region latencies and maybe look at reducing the per-region metric overhead. &lt;/p&gt;</comment>
                            <comment id="15621076" author="ikeda" created="Mon, 31 Oct 2016 03:16:40 +0000"  >&lt;blockquote&gt;&lt;p&gt;No. AtomicLong is pretty bad for metrics usage.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I meant the patch of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16146&quot; title=&quot;Counters are expensive...&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16146&quot;&gt;&lt;del&gt;HBASE-16146&lt;/del&gt;&lt;/a&gt; makes Counter worse than AtomicLonger. Moreover, if the usage frequently creates and drops instances, AtomicLonger might give a good result, especially against Counter with ThreadLocal per instance. I suspect the benchmark MultiHistogramBenchmark in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16146&quot; title=&quot;Counters are expensive...&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16146&quot;&gt;&lt;del&gt;HBASE-16146&lt;/del&gt;&lt;/a&gt; calls FastLongHistogram.reset in its measurement, but I failed to find its source code.&lt;/p&gt;</comment>
                            <comment id="15634357" author="ghelmling" created="Thu, 3 Nov 2016 21:29:39 +0000"  >&lt;p&gt;Yes, it does call reset() after each iteration, because that simulates the actual usage in our metrics code.  Benchmarking against a long lived histogram does not represent what actually happens on a live regionserver.  If the argument is that we should not be using Counter in histograms, that something we can look at.  Again, benchmarks on &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16146&quot; title=&quot;Counters are expensive...&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16146&quot;&gt;&lt;del&gt;HBASE-16146&lt;/del&gt;&lt;/a&gt; show HdrHistogram implementations outperforming all others.&lt;/p&gt;

&lt;p&gt;The benchmark there also shows that Counter remains much better than AtomicLong.  Where do you see it now performing worse?&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12634866" name="10656-098.v2.txt" size="17345" author="stack" created="Fri, 14 Mar 2014 23:30:30 +0000"/>
                            <attachment id="12634865" name="10656-trunk.v2.patch" size="18125" author="stack" created="Fri, 14 Mar 2014 23:30:30 +0000"/>
                            <attachment id="12634867" name="10656.096v2.txt" size="17188" author="stack" created="Fri, 14 Mar 2014 23:30:30 +0000"/>
                            <attachment id="12633339" name="HBASE-10656-0.96.patch" size="17754" author="ikeda" created="Fri, 7 Mar 2014 09:55:54 +0000"/>
                            <attachment id="12635747" name="HBASE-10656-addition.patch" size="2841" author="ikeda" created="Thu, 20 Mar 2014 08:30:57 +0000"/>
                            <attachment id="12633340" name="HBASE-10656-trunk.patch" size="18884" author="ikeda" created="Fri, 7 Mar 2014 09:55:54 +0000"/>
                            <attachment id="12632193" name="MyCounter.java" size="3909" author="ikeda" created="Mon, 3 Mar 2014 07:58:03 +0000"/>
                            <attachment id="12632794" name="MyCounter2.java" size="2572" author="ikeda" created="Wed, 5 Mar 2014 08:10:55 +0000"/>
                            <attachment id="12635743" name="MyCounter3.java" size="4065" author="ikeda" created="Thu, 20 Mar 2014 08:30:57 +0000"/>
                            <attachment id="12632471" name="MyCounterTest.java" size="1737" author="ikeda" created="Tue, 4 Mar 2014 08:31:56 +0000"/>
                            <attachment id="12632194" name="MyCounterTest.java" size="1871" author="ikeda" created="Mon, 3 Mar 2014 07:58:03 +0000"/>
                            <attachment id="12633050" name="PerformanceTestApp.java" size="4599" author="ikeda" created="Thu, 6 Mar 2014 06:16:44 +0000"/>
                            <attachment id="12635744" name="PerformanceTestApp2.java" size="5756" author="ikeda" created="Thu, 20 Mar 2014 08:30:57 +0000"/>
                            <attachment id="12633052" name="output.pdf" size="68656" author="ikeda" created="Thu, 6 Mar 2014 06:16:44 +0000"/>
                            <attachment id="12633051" name="output.txt" size="1908" author="ikeda" created="Thu, 6 Mar 2014 06:16:44 +0000"/>
                            <attachment id="12635746" name="output2.pdf" size="154395" author="ikeda" created="Thu, 20 Mar 2014 08:30:57 +0000"/>
                            <attachment id="12635745" name="output2.txt" size="2664" author="ikeda" created="Thu, 20 Mar 2014 08:30:57 +0000"/>
                    </attachments>
                <subtasks>
                            <subtask id="12703355">HBASE-10822</subtask>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>17.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 3 Mar 2014 18:05:06 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>376724</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310191" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Hadoop Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10343"><![CDATA[Reviewed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            6 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1swzz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>377019</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>