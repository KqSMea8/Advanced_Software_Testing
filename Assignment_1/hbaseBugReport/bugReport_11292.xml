<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 20:21:49 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-11292/HBASE-11292.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-11292] Add an &quot;undelete&quot; operation</title>
                <link>https://issues.apache.org/jira/browse/HBASE-11292</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;While column families can be configured to keep deleted cells (allowing time range queries to still retrieve those cells), deletes are still somewhat unique in that they are irreversible operations.  Once a delete has been issued on a cell, the only way to &quot;undelete&quot; it is to rewrite the data with a timestamp newer than the delete.&lt;/p&gt;

&lt;p&gt;The idea here is to add an &quot;undelete&quot; operation, that would make it possible to cancel a previous delete.  An undelete operation will be similar to a delete, in that it will be written as a marker (&quot;tombstone&quot; doesn&apos;t seem like the right word).  The undelete marker, however, will sort prior to a delete marker, canceling the effect of any following delete.&lt;/p&gt;

&lt;p&gt;In the absence of a column family configured to KEEP_DELETED_CELLS, we can&apos;t be sure if a prior delete marker and the effected cells have already been garbage collected.  In this case (column family not configured with KEEP_DELETED_CELLS) it may be necessary for the server to reject undelete operations to avoid creating the appearance of a client contact for undeletes that can&apos;t reliably be honored.&lt;/p&gt;

&lt;p&gt;I think there are additional subtleties of the implementation to be worked out, but I&apos;m also interested in a broader discussion of interest in this capability.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12718202">HBASE-11292</key>
            <summary>Add an &quot;undelete&quot; operation</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="ghelmling">Gary Helmling</reporter>
                        <labels>
                            <label>Phoenix</label>
                    </labels>
                <created>Tue, 3 Jun 2014 17:22:12 +0000</created>
                <updated>Fri, 6 Mar 2015 19:49:33 +0000</updated>
                                                                            <component>Deletes</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>13</watches>
                                                                <comments>
                            <comment id="14016905" author="jamestaylor" created="Tue, 3 Jun 2014 17:35:10 +0000"  >&lt;p&gt;+1 for this new operation as it will help in the implementation of transactions. Would every &lt;b&gt;type&lt;/b&gt; of Delete need a corresponding Undelete?&lt;/p&gt;

&lt;p&gt;When KEEP_DELETED_CELLS is on, assume:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Put is done at t1&lt;/li&gt;
	&lt;li&gt;Delete is done at t5&lt;/li&gt;
	&lt;li&gt;Undelete is done at t7&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If a client does a read at t6, the Delete would be in effect, while if a client does a read at t8, the Delete would not be in effect. Is that how it&apos;d work?&lt;/p&gt;</comment>
                            <comment id="14017207" author="lhofhansl" created="Tue, 3 Jun 2014 22:11:09 +0000"  >&lt;p&gt;I fear that the implications are tricky.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;we have delete bloom filters to avoid seeks to the beginning on the row to check for family delete markers. Those would no longer work, or in other words we&apos;d need boom filters for the undelete markers.&lt;/li&gt;
	&lt;li&gt;will we every need so to undo an undelete? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
	&lt;li&gt;how does this fit into the discussion about using sequence numbers to order operations?&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Still +1 on doing this if ts semantics are like the ones I introduced for KEEP_DELETED_CELLS (as James mentions)&lt;/p&gt;</comment>
                            <comment id="14017841" author="ghelmling" created="Wed, 4 Jun 2014 16:43:32 +0000"  >&lt;blockquote&gt;&lt;p&gt;Would every type of Delete need a corresponding Undelete?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, I think it would be necessary to have complete parity between the two, since the goal is to cancel any type of delete operation.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When KEEP_DELETED_CELLS is on, assume:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Put is done at t1&lt;/li&gt;
	&lt;li&gt;Delete is done at t5&lt;/li&gt;
	&lt;li&gt;Undelete is done at t7&lt;br/&gt;
If a client does a read at t6, the Delete would be in effect, while if a client does a read at t8, the Delete would not be in effect. Is that how it&apos;d work?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yes, I think this would work exactly as you describe.  In the case of supporting timestamp-overriding transactions, though, the Delete and Undelete would occur at the same timestamp (t5), since the Undelete would be rolling back the Delete that was part of the transaction.&lt;/p&gt;</comment>
                            <comment id="14017885" author="ghelmling" created="Wed, 4 Jun 2014 17:16:07 +0000"  >&lt;blockquote&gt;&lt;p&gt;we have delete bloom filters to avoid seeks to the beginning on the row to check for family delete markers. Those would no longer work, or in other words we&apos;d need boom filters for the undelete markers.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm, I wasn&apos;t familiar with these, but, yes, sounds like we would unfortunately need another set of bloom filters for the undeletes.  There would also need to be some change to the use of the delete bloom filters if operations were ordered by seqid, wouldn&apos;t there?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;will we every need so to undo an undelete? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, I thought of this as well.  What undoes the undeletes?  In a sense this shifts the irreversible operation to the undelete.  I think this is an inherent problem with the approach of sorting operations within the same timestamp by operation type.  There is always going to be something that sorts first, which effectively becomes undoable.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;how does this fit into the discussion about using sequence numbers to order operations?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think the discussion to order operations by seqid is simply an alternate approach to the some of the same underlying problems.  For the issue mentioned above, sorting by seqid is conceptually simpler &amp;#8211; there is no need for a separate undelete operation and undoing a delete is possible by re-issuing a new put for the previous value at the same timestamp as the previous delete.  Of course that means that the final outcome depends on the server observed ordering of the operations.  But at the same time, there is no &quot;irreversible&quot; operation.&lt;/p&gt;

&lt;p&gt;For the use case I&apos;m considering (a single client rolling back it&apos;s previously persisted changes at a given timestamp), ordering by seqid would also work.  Since it&apos;s a single client rolling back it&apos;s own operations, the operations can be ordered by the client, so there&apos;s no lack of determinism in server side ordering.  Rolling back a delete with seqid ordering would be slightly more complicated, though, since the client would have to perform a read to find the previous value prior to the delete, then issue a new put, instead of simply issuing an undelete with the same parameters as the prior delete.&lt;/p&gt;

&lt;p&gt;Or you could combine both approaches and order operations by seqid, but add an undelete operation as well.  The undelete would then sort prior to the delete by virtue of being issued after it.  It would still be a no-read operation.  And the undelete could be undone by issuing a new delete.  Maybe this combination ultimately winds up being best.&lt;/p&gt;

&lt;p&gt;Thanks for the comments.  I&apos;m open to however we can most efficiently solve this with the least amount of added complexity.&lt;/p&gt;</comment>
                            <comment id="14017894" author="stack" created="Wed, 4 Jun 2014 17:22:56 +0000"  >&lt;blockquote&gt;&lt;p&gt;There is always going to be something that sorts first, which effectively becomes undoable.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Our sorting on type is a mistake (as &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sershe&quot; class=&quot;user-hover&quot; rel=&quot;sershe&quot;&gt;Sergey Shelukhin&lt;/a&gt; has noted a few times).  Would fixing this help here?&lt;/p&gt;</comment>
                            <comment id="14018962" author="jamestaylor" created="Thu, 5 Jun 2014 16:56:06 +0000"  >&lt;blockquote&gt;&lt;p&gt;the Delete and Undelete would occur at the same timestamp (t5), since the Undelete would be rolling back the Delete that was part of the transaction&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think this is fine. I can&apos;t think of a use case where you&apos;d need to see the Delete at a given timestamp.&lt;/p&gt;</comment>
                            <comment id="14020617" author="jeffreyz" created="Sat, 7 Jun 2014 01:20:01 +0000"  >&lt;blockquote&gt;
&lt;p&gt; since the client would have to perform a read to find the previous value prior to the delete, then issue a new put, instead of simply issuing an undelete with the same parameters as the prior delete.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I think there is no difference in terms of the read because you need to read the previous &quot;delete&quot; put as well to construct the &quot;undelete&quot; put while the other way need to read&amp;amp;write more data.&lt;/p&gt;</comment>
                            <comment id="14075492" author="lhofhansl" created="Sat, 26 Jul 2014 21:22:29 +0000"  >&lt;p&gt;Can we turn this around and implement undelete with redoing the corresponding put and handling the ambiguities with seq ids?&lt;br/&gt;
I&apos;ve been arguing against this, since it would break idempotency of HBase actions, but on light of this I might relent &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
I guess it would require to know what exactly the delete affected, which may or may not possible.&lt;/p&gt;

&lt;p&gt;Yet another way to look at it is: why undelete at all? Ignoring failed transactions needs to be implemented anyway, so instead of undo one could just continue to ignore the transaction.&lt;/p&gt;</comment>
                            <comment id="14075496" author="jamestaylor" created="Sat, 26 Jul 2014 22:05:37 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think there is no difference in terms of the read because you need to read the previous &quot;delete&quot; put as well to construct the &quot;undelete&quot; put while the other way need to read&amp;amp;write more data.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jeffreyz&quot; class=&quot;user-hover&quot; rel=&quot;jeffreyz&quot;&gt;Jeffrey Zhong&lt;/a&gt;, the Undelete is issued by the client, the same client that issued the Delete. It&apos;s done to undo the effects of a failed transaction (i.e. like a compensating transaction). You don&apos;t need to lookup the prior state of the row. You just need to issue an Undelete with the same rowkey and timestamp as the Delete.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Yet another way to look at it is: why undelete at all? Ignoring failed transactions needs to be implemented anyway, so instead of undo one could just continue to ignore the transaction.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt;, I agree, this is a fallback. It puts more pressure on being able to &quot;prune&quot; this invalid list. If that can be figured out and done efficiently, than the need for an Undelete decreases. Maybe that should be discussed in a separate JIRA?&lt;/p&gt;

&lt;p&gt;Assuming that an Undelete may only be done for a Delete (i.e. an Undelete can not be undeleted), is it feasible then? Besides requiring another set of Bloom filters, are their more gotchas? Is it too heavy a burden to have another set of Bloom filters? Any other options?&lt;/p&gt;</comment>
                            <comment id="14114463" author="ghelmling" created="Thu, 28 Aug 2014 22:10:36 +0000"  >&lt;blockquote&gt;&lt;p&gt;Yet another way to look at it is: why undelete at all? Ignoring failed transactions needs to be implemented anyway, so instead of undo one could just continue to ignore the transaction.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, for the transaction case specifically, that is a fair approach to take.  We can (and do) ignore writes from the failed transaction, but we also need a way to clear transaction IDs from the invalid set so that it doesn&apos;t continue to grow.  This is difficult, but it does need to be solved, regardless of whether or not we have undeletes.  If we can do this efficiently enough, then there&apos;s really no further need to attempt to rollback failed transactions at all.&lt;/p&gt;

&lt;p&gt;However, from the HBase perspective, it has been a long standing issue (or constraint at least) that deletes cannot be undone.  Just ordering operations by seqid so that you can redo any deleted puts is not a symmetric solution, for the reasons described above (in the case of a single row delete marker, you have to rewrite all of the columns in the row).&lt;/p&gt;</comment>
                            <comment id="14281227" author="lhofhansl" created="Sat, 17 Jan 2015 06:02:39 +0000"  >&lt;p&gt;Let&apos;s revive this. What I have been proposing in a meeting we had was an &quot;UNDO&quot; cell type. Undo would sort before deletes and simply undo the next cell that immediately follows in sort order. Another UNDO with the same TS would undo the UNDO, as so on.&lt;/p&gt;

&lt;p&gt;I do not think we want to undo Puts, we have deletes for that.&lt;br/&gt;
So we would need to two new Cell type: undo delete (for version and column delete markers) and undo delete family for family delete markers.&lt;/p&gt;

&lt;p&gt;I think my comments on family delete bloom filters above are misguided. At worst we&apos;d see a performance degradation for seeking to the beginning of the row when that is not necessary when the delete is undone.&lt;/p&gt;

&lt;p&gt;The only trick part here is that all seeking before a row or column or to the end of a row or column need to be seeking correctly with UNDO cell types.&lt;/p&gt;</comment>
                            <comment id="14281229" author="lhofhansl" created="Sat, 17 Jan 2015 06:09:39 +0000"  >&lt;p&gt;The other tricky part is to to avoid removing identical cells (in terms of row, col, ts) if their type is UNDO.&lt;br/&gt;
Also do we need REDO? What if we &quot;undid&quot; a delete, and then want to delete at the exact coordinates (row, col, ts) again? That delete would continue to be shadowed until the UNDO marker is gone, or we undo the UNDO.&lt;/p&gt;

&lt;p&gt;Would need to carefully think through the compaction implications. F.e. when can I safely compact the UNDO markers? Need to be able to guarantee that every affected Cell is also deleted. That is not true for all compactions (not even major ones).&lt;/p&gt;</comment>
                            <comment id="14281237" author="jamestaylor" created="Sat, 17 Jan 2015 06:43:38 +0000"  >&lt;p&gt;If it simplifies things, for Tephra transactions in Phoenix, we only need the ability to 1) undo a column delete markers and 2) undo a column family delete marker. We don&apos;t need to be able to undo an undo or to redo.&lt;/p&gt;</comment>
                            <comment id="14308197" author="lhofhansl" created="Thu, 5 Feb 2015 23:01:00 +0000"  >&lt;p&gt;I will think about this in earnest during the next few days.&lt;/p&gt;

&lt;p&gt;Related: A scan coprocessor can currently not ignore delete markers (without reimplementing the entire delete marker logic). I am not sure about a good interface for this (seems like we need a pass down a list of excluded timeranges). &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ghelmling&quot; class=&quot;user-hover&quot; rel=&quot;ghelmling&quot;&gt;Gary Helmling&lt;/a&gt;, any ideas?&lt;/p&gt;</comment>
                            <comment id="14323681" author="jamestaylor" created="Tue, 17 Feb 2015 05:45:11 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt; - that&apos;s a good point. What about even ignoring a Put? Does the Tephra TransactionVisibilityFilter&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; handle ignoring a Put such that an earlier Put would be seen? Do all scans have to be raw scans, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ghelmling&quot; class=&quot;user-hover&quot; rel=&quot;ghelmling&quot;&gt;Gary Helmling&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; &lt;a href=&quot;https://github.com/caskdata/tephra/blob/develop/tephra-hbase-compat-0.98/src/main/java/co/cask/tephra/hbase98/coprocessor/TransactionVisibilityFilter.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/caskdata/tephra/blob/develop/tephra-hbase-compat-0.98/src/main/java/co/cask/tephra/hbase98/coprocessor/TransactionVisibilityFilter.java&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14326949" author="ghelmling" created="Thu, 19 Feb 2015 03:34:04 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt; some ability to apply a filter to the delete marker would be ideal (at least in this case having a filter indicate a SKIP), but how that changes ScanQueryMatcher is of course tricky.  Need to look at this a bit and think about it.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jamestaylor&quot; class=&quot;user-hover&quot; rel=&quot;jamestaylor&quot;&gt;James Taylor&lt;/a&gt; yes we ignore puts from in progress or deleted transactions in the filter.  This happens with normal (not raw) scans currently.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12776006">PHOENIX-1674</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 3 Jun 2014 17:35:10 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>396404</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            1 year, 43 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1w8wn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>396526</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>