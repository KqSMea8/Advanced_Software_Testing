<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 20:15:58 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-10659/HBASE-10659.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-10659] [89-fb] Optimize the threading model in HBase write path</title>
                <link>https://issues.apache.org/jira/browse/HBASE-10659</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;Recently, we have done multiple prototypes to optimize the HBase (0.89)write path. And based on the simulator results, the following model is able to achieve much higher overall throughput with less threads.&lt;/p&gt;

&lt;p&gt;IPC Writer Threads Pool: &lt;br/&gt;
IPC handler threads will prepare all Put requests, and append the WALEdit, as one transaction, into a concurrent collection with a read lock. And then just return;&lt;/p&gt;

&lt;p&gt;HLogSyncer Thread:&lt;br/&gt;
Each HLogSyncer thread is corresponding to one HLog stream. It swaps the concurrent collection with a write lock, and then iterate over all the elements in the previous concurrent collection, generate the sequence id for each transaction, and write to HLog. After the HLog sync is done, append these transactions as a batch into a blocking queue. &lt;/p&gt;

&lt;p&gt;Memstore Update Thread:&lt;br/&gt;
The memstore update thread will poll the blocking queue and update the memstore for each transaction by using the sequence id as MVCC. Once the memstore update is done, dispatch to the responder thread pool to return to the client.&lt;/p&gt;

&lt;p&gt;Responder Thread Pool:&lt;br/&gt;
Responder thread pool will return the RPC call in parallel. &lt;/p&gt;

&lt;p&gt;We are still evaluating this model and will share more results/numbers once it is ready. But really appreciate any comments in advance !&lt;/p&gt;</description>
                <environment></environment>
        <key id="12698497">HBASE-10659</key>
            <summary>[89-fb] Optimize the threading model in HBase write path</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="liyin">Liyin Tang</reporter>
                        <labels>
                    </labels>
                <created>Mon, 3 Mar 2014 19:36:57 +0000</created>
                <updated>Thu, 6 Mar 2014 01:41:36 +0000</updated>
                                                                                <due></due>
                            <votes>0</votes>
                                    <watches>10</watches>
                                                                <comments>
                            <comment id="13918966" author="tlipcon" created="Tue, 4 Mar 2014 03:04:23 +0000"  >&lt;p&gt;Curious: do you have just a single memstore update thread per region? Any results on whether throughput is better when the workload is skewed towards a single hot region on a server?&lt;/p&gt;

&lt;p&gt;Are you doing any sorting of the batch before going into the memstore update thread? That might result in some better performance as well if you have hot and cold regions of keyspace.&lt;/p&gt;</comment>
                            <comment id="13919033" author="liyin" created="Tue, 4 Mar 2014 05:29:12 +0000"  >&lt;p&gt;1) Since updating memstore is much faster than HLog syncing, one memstore-update-thread seems to be sufficient. Or we can make it configurable as each HLogSyncer thread will have a corresponding memstore-update-thread.&lt;/p&gt;

&lt;p&gt;2)  The HLogSyncer thread will batch multiple transactions, as a group commit, from different IPC writer threads, and then sync this group commit into HLog stream. And then, the memstore-update-thread will take this group commit and update the corresponding memstore in (sequence id) order.&lt;/p&gt;</comment>
                            <comment id="13919049" author="stack" created="Tue, 4 Mar 2014 06:16:40 +0000"  >&lt;p&gt;bq, IPC handler threads will prepare all Put requests, and append the WALEdit, as one transaction, into a concurrent collection with a read lock. And then just return;&lt;/p&gt;

&lt;p&gt;Return to the client?  The client then waits on notification back from server on when the append completes?  When you say &apos;prepare all Put requests&apos;, do you mean the unmarshalling form RPC into a Put instance?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Each HLogSyncer thread is corresponding to one HLog stream. It swaps the concurrent collection with a write lock, and then iterate over all the elements in the previous concurrent collection, generate the sequence id for each transaction, and write to HLog. After the HLog sync is done, append these transactions as a batch into a blocking queue.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You have multiple WALs per server?  So one HLogSyncer per WAL?  The concurrent collections are kept by WAL or you have one collection and sort it by WALs after taking it under write lock?&lt;/p&gt;

&lt;p&gt;....&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Responder thread pool will return the RPC call in parallel.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In // because each MemStore Update Thread of which there may be many, each checks out a Responder to reply to the client its mvcc/sequenceid?&lt;/p&gt;

&lt;p&gt;Thanks Liyin.  Just trying to understand and figuring it how it maps to trunk.&lt;/p&gt;

&lt;p&gt;You like the asynchronous response back there in 0.89fb?  We don&apos;t use it as you do in trunk.&lt;/p&gt;

&lt;p&gt;We keep talking about unifying seqid and mvcc....&lt;/p&gt;</comment>
                            <comment id="13919818" author="liyin" created="Tue, 4 Mar 2014 19:28:40 +0000"  >&lt;p&gt;1) IPC writer thread will do all the sanity check as a preparation, such as figure out which Region and whether it is enabled.&lt;br/&gt;
2) IPC writer thread will handoff the Put request, and then start to process next IPC request. It won&apos;t block or wait for the current Put request to finish. The responder thread will finally return the call to the clients. &lt;br/&gt;
3) One HLogSyncer per WAL, and each HLogSyncer has its own concurrent collections to swap between.&lt;br/&gt;
4)  I don&apos; fully understand your last question. Since the HLogSyncer thread has already one the sequencing for each transaction, memstore-update-thread could just reuse the same sequence id as MVCC.&lt;/p&gt;

&lt;p&gt;The basic motivation of this new write path is to reduce the thread interleaving and synchronizations in the critical write path as much as possible.&lt;/p&gt;</comment>
                            <comment id="13921846" author="stack" created="Thu, 6 Mar 2014 01:30:12 +0000"  >&lt;blockquote&gt;&lt;p&gt;I  don&apos; fully understand your last question. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Its ok.  You answered it.  The way we do client response is different between trunk and 0.89.  We went different route in trunk to &apos;...reduce the thread interleaving...&apos; with handlers&apos; coming together on a ring buffer with one thread pulling from the ring and then multiple sync&apos;ing threads syncing.  Handlers&apos;s hang out stuck on a latch till their sync clears.  We need to do like you lads and have the seqid be the mvcc up in memstore.&lt;/p&gt;</comment>
                            <comment id="13921860" author="liyin" created="Thu, 6 Mar 2014 01:41:36 +0000"  >&lt;p&gt;One of key motivations is to avoid handler waiting on the sync thread. This model requires more IPC handler threads to reach the maximum QPS. I will share more detail numbers once it is ready.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 4 Mar 2014 03:04:23 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>376855</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            2 years, 41 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1sxt3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>377150</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>