<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:26:56 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-5347/HBASE-5347.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-5347] GC free memory management in Level-1 Block Cache</title>
                <link>https://issues.apache.org/jira/browse/HBASE-5347</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;On eviction of a block from the block-cache, instead of waiting for the garbage collecter to reuse its memory, reuse the block right away.&lt;/p&gt;

&lt;p&gt;This will require us to keep reference counts on the HFile blocks. Once we have the reference counts in place we can do our own simple blocks-out-of-slab allocation for the block-cache.&lt;/p&gt;

&lt;p&gt;This will help us with&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;reducing gc pressure, especially in the old generation&lt;/li&gt;
	&lt;li&gt;making it possible to have non-java-heap memory backing the HFile blocks&lt;/li&gt;
&lt;/ul&gt;
</description>
                <environment></environment>
        <key id="12541701">HBASE-5347</key>
            <summary>GC free memory management in Level-1 Block Cache</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="7">Later</resolution>
                                        <assignee username="khemani">Prakash Khemani</assignee>
                                    <reporter username="khemani">Prakash Khemani</reporter>
                        <labels>
                    </labels>
                <created>Tue, 7 Feb 2012 22:05:01 +0000</created>
                <updated>Wed, 29 Aug 2012 14:50:14 +0000</updated>
                            <resolved>Wed, 29 Aug 2012 14:50:14 +0000</resolved>
                                                                        <due></due>
                            <votes>0</votes>
                                    <watches>15</watches>
                                                                <comments>
                            <comment id="13202898" author="stack" created="Tue, 7 Feb 2012 22:50:55 +0000"  >&lt;p&gt;Very nice idea (if the reference counting can be figured).&lt;/p&gt;</comment>
                            <comment id="13202919" author="stack" created="Tue, 7 Feb 2012 23:08:14 +0000"  >&lt;p&gt;Blocks are not all of the same size.  Will this be an issue?  Blocks of an awkward size &amp;#8211; say a block that happen to have a massive KeyValue in them and they exceed massively the default block size &amp;#8211; would need to be treated differently?&lt;/p&gt;</comment>
                            <comment id="13203871" author="khemani" created="Wed, 8 Feb 2012 19:24:10 +0000"  >&lt;p&gt;initial diff for feedback &lt;a href=&quot;https://reviews.facebook.net/D1635&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.facebook.net/D1635&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13205647" author="khemani" created="Fri, 10 Feb 2012 19:06:17 +0000"  >&lt;p&gt;another advantage of this approach will be that we will be able to get rid of low/high water marks in LRUBlockCache and make block eviction synchronous with demand. The default value of the watermarks is set to 75%  and 85% (in 89). That means we waste somewhere around 20% of the block-cache today because of asynchronous garbage collection.&lt;/p&gt;</comment>
                            <comment id="13205651" author="zhihyu@ebaysf.com" created="Fri, 10 Feb 2012 19:10:05 +0000"  >&lt;p&gt;Agreed.&lt;br/&gt;
This initiative is on the right track.&lt;/p&gt;</comment>
                            <comment id="13206021" author="lhofhansl" created="Sat, 11 Feb 2012 05:02:18 +0000"  >&lt;p&gt;Nice patch.&lt;br/&gt;
How does this interact with the off-heap cache effort?&lt;/p&gt;</comment>
                            <comment id="13206043" author="lhofhansl" created="Sat, 11 Feb 2012 06:46:44 +0000"  >&lt;p&gt;Seems to me that we should target this for 0.96.&lt;/p&gt;</comment>
                            <comment id="13206510" author="khemani" created="Sun, 12 Feb 2012 20:24:57 +0000"  >&lt;p&gt;If this approach works then we will not need to do off-heap caching anymore.&lt;/p&gt;
</comment>
                            <comment id="13209020" author="phabricator@reviews.facebook.net" created="Thu, 16 Feb 2012 00:40:58 +0000"  >&lt;p&gt;khemani has commented on the revision &quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5347&quot; title=&quot;GC free memory management in Level-1 Block Cache&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5347&quot;&gt;&lt;del&gt;HBASE-5347&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;jira&amp;#93;&lt;/span&gt; GC free memory management in Level-1 Block Cache&quot;.&lt;/p&gt;

&lt;p&gt;INLINE COMMENTS&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/KeyValue.java:2099 Stack, there is a lot of cleanup needed. I will get back to your feedback soon.&lt;/p&gt;

&lt;p&gt;  Regarding the ReferenceQueue mechanism and the fact that it gets cleaned up at best at GC speeds ... yes you are right that if all dead KVs ended up on this reference-queue then this approach won&apos;t be any better. But if a kv.deref() is called explicitly before the kv is put up for garbage collection then that kv will not land on this reference-queue.&lt;/p&gt;

&lt;p&gt;  The reference-queue is only there to catch those instances where we might have forgotten to do an explicit kv.deref(). Hopefully there won&apos;t be too many such cases.&lt;/p&gt;

&lt;p&gt;REVISION DETAIL&lt;br/&gt;
  &lt;a href=&quot;https://reviews.facebook.net/D1635&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.facebook.net/D1635&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13209062" author="phabricator@reviews.facebook.net" created="Thu, 16 Feb 2012 01:48:58 +0000"  >&lt;p&gt;khemani updated the revision &quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5347&quot; title=&quot;GC free memory management in Level-1 Block Cache&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5347&quot;&gt;&lt;del&gt;HBASE-5347&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;jira&amp;#93;&lt;/span&gt; GC free memory management in Level-1 Block Cache&quot;.&lt;br/&gt;
Reviewers: Kannan, mbautin, dhruba, nspiegelberg, stack, JIRA&lt;/p&gt;

&lt;p&gt;  In this iteration I have been testing these changes by starting in the region server a 1000 threads that continuously call incrementColumnValue() on large random keys. In this patch there are some temporary changes to HRegionInterface to do this testing ...&lt;/p&gt;

&lt;p&gt;  In the test that I run on my dev cluster, there is enough data in the test table, the java heap is set to 24GB, block-cache is set to 60% of the heap. Without this patch I pretty soon run into GC pauses. With this patch, and even without any blocks-out-of-large-slab allocation and without changing to synchronous eviction in lru block cache, there are no GC pauses.&lt;/p&gt;

&lt;p&gt;  So, there are two kinds of objects being reference counted in this patch - HFileBlocks and KeyValues. HFileBlocks are easy to reference counts because they only exist in HFileScanners and below. KeyValues (those ones who directly refer to data in HFileBlock) are more difficult to reference count.&lt;/p&gt;

&lt;p&gt;  My earlier approach was that the StoreFileScanner will hand out pinned key-values and the higher layers will not have to bother about deref()ing the key-values. The key-values will be deref()&apos;d only when they are written out. But this approach has many issues and quickly becomes non-intuitive. For example, with that older approach, StoreFileScanner will not be able to deref() its cur kv when it is closed and it will have to rely on the GC for cleanup.&lt;/p&gt;

&lt;p&gt;  In the current approach you don&apos;t have to ref() the kv that you get from a scanner if you are going to keep it beyond the next scanner&apos;s next(), seek(), reseek() or close() call. (If you don&apos;t ref it then you will soon get a nullptrexception). You should also deref it when you are done, but it is not absolutely required.&lt;/p&gt;

&lt;p&gt;  I have lot more cleanup to do. I will revert some of the method name changes. I will refactor the code in new classes. There is lot many tests to be written. I will re-write this in a way such that it can be run with or without the hfile-block-pool. The block pool enhancements and lru-block cache enhancements in separate diffs.&lt;/p&gt;

&lt;p&gt;  This changes the programming model quite a bit ...&lt;/p&gt;

&lt;p&gt;  Some number from the test that I am running&lt;/p&gt;

&lt;p&gt;  totKVRef        49046639&lt;br/&gt;
  totKVDeref      49022691&lt;br/&gt;
  totKVDead       17&lt;br/&gt;
  totKVDeadDeadDead       1839873&lt;/p&gt;

&lt;p&gt;  49 million KVs have been reference counted. Out of that somehow the code forgets to deref 17 of them. About 2 million of them end up on the deadKVs ReferenceQueue even though they have been properly deref&apos;d ... don&apos;t know why this happens.&lt;/p&gt;

&lt;p&gt;  curHFBPoolBlocks        165746&lt;br/&gt;
  curHFBPoolCapacity      11541225472&lt;br/&gt;
  curHFBPoolFreeBlocks    22050&lt;br/&gt;
  curHFBPoolFreeCapacity  1535385600&lt;/p&gt;

&lt;p&gt;  The block cache has 10 GB of active blocks. 1.5GB is maintained in the free pool by the eviction process. We will be able to use all the block cache memory (that is around 14.5GB) once LRUBlockCache eviction is made synchronous.&lt;/p&gt;

&lt;p&gt;  totHFBPoolSystemAlloc   235873&lt;br/&gt;
  totHFBPoolSystemFree    60075&lt;br/&gt;
  totHFBPoolBlocksAllocated       165746&lt;br/&gt;
  totHFBPoolLargeBlocksAllocated  70127&lt;br/&gt;
  totHFBPoolLargeBlocksFreed      60075&lt;br/&gt;
  totHFBPoolReuse 5459025&lt;/p&gt;

&lt;p&gt;  235K allocations were done from the system. Some of these were blocks larger than 69K so they were not managed by the pool. The blocks got resused 5.5m times.&lt;/p&gt;





&lt;p&gt;  216732&lt;/p&gt;

&lt;p&gt;REVISION DETAIL&lt;br/&gt;
  &lt;a href=&quot;https://reviews.facebook.net/D1635&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.facebook.net/D1635&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;AFFECTED FILES&lt;br/&gt;
  pom.xml&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/KeyValue.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/client/HTable.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/client/Result.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/BlockCache.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/BlockType.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/CacheConfig.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/Cacheable.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFile.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlock.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlockIndex.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFilePrettyPrinter.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderV1.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderV2.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileScanner.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterV1.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterV2.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/LruBlockCache.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/SimpleBlockCache.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/mapreduce/LoadIncrementalHFiles.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/GetClosestRowBeforeTracker.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/KeyValueHeap.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/Store.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/StoreFile.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/StoreScanner.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/metrics/SchemaConfigured.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/util/CompoundBloomFilter.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/util/Counters.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/util/DoublyLinkedListElement.java&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/util/DoublyLinkedListHead.java&lt;br/&gt;
  src/test/java/org/apache/hadoop/hbase/io/TestHalfStoreFileReader.java&lt;br/&gt;
  src/test/java/org/apache/hadoop/hbase/io/hfile/TestCacheOnWrite.java&lt;br/&gt;
  src/test/java/org/apache/hadoop/hbase/io/hfile/TestCachedBlockQueue.java&lt;br/&gt;
  src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFile.java&lt;br/&gt;
  src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFileBlock.java&lt;br/&gt;
  src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFileBlockIndex.java&lt;br/&gt;
  src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFileWriterV2.java&lt;br/&gt;
  src/test/java/org/apache/hadoop/hbase/io/hfile/TestLruBlockCache.java&lt;br/&gt;
  src/test/java/org/apache/hadoop/hbase/io/hfile/TestSeekTo.java&lt;br/&gt;
  src/test/java/org/apache/hadoop/hbase/mapreduce/TestHFileOutputFormat.java&lt;br/&gt;
  src/test/java/org/apache/hadoop/hbase/regionserver/TestCompaction.java&lt;br/&gt;
  src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java&lt;/p&gt;</comment>
                            <comment id="13209105" author="phabricator@reviews.facebook.net" created="Thu, 16 Feb 2012 03:54:58 +0000"  >&lt;p&gt;tedyu has commented on the revision &quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5347&quot; title=&quot;GC free memory management in Level-1 Block Cache&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5347&quot;&gt;&lt;del&gt;HBASE-5347&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;jira&amp;#93;&lt;/span&gt; GC free memory management in Level-1 Block Cache&quot;.&lt;/p&gt;

&lt;p&gt;INLINE COMMENTS&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/KeyValue.java:2193 Should we use some timeout for the remove() call ?&lt;br/&gt;
  remove() is a blocking call, see:&lt;br/&gt;
  &lt;a href=&quot;http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/ref/ReferenceQueue.html#remove%28%29&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/ref/ReferenceQueue.html#remove%28%29&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;  Would the current code make the cleanup thread in region server less useful ?&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/KeyValue.java:2207 Please rename this counter totKVOnRefQueue or something similar&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/KeyValue.java:2260 When would the return value be used ?&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/KeyValue.java:2245 this.bytes is cleared upon exit of deref().&lt;br/&gt;
  Please document this in javadoc.&lt;/p&gt;

&lt;p&gt;REVISION DETAIL&lt;br/&gt;
  &lt;a href=&quot;https://reviews.facebook.net/D1635&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.facebook.net/D1635&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13210742" author="phabricator@reviews.facebook.net" created="Sat, 18 Feb 2012 01:47:58 +0000"  >&lt;p&gt;mbautin has commented on the revision &quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5347&quot; title=&quot;GC free memory management in Level-1 Block Cache&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5347&quot;&gt;&lt;del&gt;HBASE-5347&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;jira&amp;#93;&lt;/span&gt; GC free memory management in Level-1 Block Cache&quot;.&lt;/p&gt;

&lt;p&gt;  Looks pretty good (provided that it works as intended). Some comments inline.&lt;/p&gt;

&lt;p&gt;  Could you please add some description of the pinning/unpinning and ref/deref concept (and the difference between the two) somewhere in javadoc? Otherwise a lot of this code is very difficult to read. The added complexity is justified by the performance benefit, but we will have to maintain this code for a long time, so it should be as self-documenting as possible (think about new developers joining the project).&lt;/p&gt;

&lt;p&gt;INLINE COMMENTS&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/KeyValue.java:2180 Remove this line&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/util/DoublyLinkedListElement.java:1 License&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/util/DoublyLinkedListHead.java:1 License&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/KeyValue.java:1222 It would be useful to mention in the javadoc that the KV is being dereferenced in this method because it does not refer to the backing array of an HFile block anymore.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/KeyValue.java:2091 Could you put the code specific to reference counting code into some other class? KeyValue is already huge.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/KeyValue.java:2141-2186 Make these counters final.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/KeyValue.java:2192 Remove this line and other commented-out code in this function.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/KeyValue.java:2222 Is this increment thread-safe?&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/KeyValue.java:2237 Naming conventions: listNum.&lt;/p&gt;

&lt;p&gt;  A more serious comment: is it possible that one thread will call ref() much more often? If so, wouldn&apos;t it be better to load-balance between in-use lists randomly? Note that with the current solution we still have to lock at an individual list level, because multiple threads can still map to the same in-use list. But I agree that hashing on thread id decreases the amount of contention.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/client/HTable.java:623-658 &#8226; It might not be a good idea to add test-only methods to HTable, because that class is used directly by a lot of clients. In other words, clients pass around HTable instances and don&apos;t cast them to HTableInterface.&lt;/p&gt;

&lt;p&gt;  I think we should move these methods to a test-only class and/or make them package-private.&lt;/p&gt;

&lt;p&gt;  &#8226; Replace &quot;anyrandomrow&quot; with a constant.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/HalfStoreFileReader.java:112 This method name change is not terribly useful without an explanation of what &quot;pinned&quot; is. Would it be better to explain this in javadoc and keep the old name? This also applies to all other changes of method names including the word &quot;Pinned&quot; or &quot;AndPin&quot;.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/BlockCache.java:39 Are these name changes necessary? Maybe it is better to just add javadoc explaining the &quot;pinning&quot; part.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/CacheConfig.java:322 Nice refactoring&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/Cacheable.java:39-43 We definitely need javadoc describing what pin/unpin is and how to use it.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFile.java:373 What exactly is pinned here, and how would the caller unpin it, if that&apos;s the intent of the method name change? The return value is an output stream.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlock.java:119 Make this final?&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlock.java:168 initialize2 is not a very descriptive counter name&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlock.java:1092 Is it possible to separate &quot;pool allocator&quot; interface from implementation, rather than just calling a static method? This way we could swap in alternative allocators in tests.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlock.java:1499 Please move the pool code to a separate class. Also, it would be nice to separate pool allocator interface from implementation, as I mentioned.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlockIndex.java:196 Should these be IOExceptions, since the method already throws them?&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderV1.java:412 &quot;Inx&quot; is a very rare abbreviation for &quot;index&quot;. Better to spell out &quot;Index&quot;.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderV1.java:694-695 Make final&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlock.java:1628-1669 Make these final.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderV2.java:408 Would the additional copy cause a performance regression based on this method&apos;s use cases?&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderV2.java:417 Would the additional copy cause a performance regression based on this method&apos;s use cases?&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileScanner.java:128 add a &quot;}&quot; at the end of the &quot;{@link KeyValue&quot;&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileScanner.java:127 in any HFileBlock&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/LruBlockCache.java:390-391 Make final&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java:2874-2876 Make final&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java:3071 Fix formatting (&quot;i =0&quot;).&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java:2812-2878 This has to be in a separate class.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/KeyValueHeap.java:410-411 Make final&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/StoreFile.java:1404 Do we unpin on close? As far as I remember, this used to be a wrapper over a ByteArrayInputStream.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/StoreFileScanner.java:399-400 Make final&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/StoreScanner.java:547-548 Make final&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/metrics/SchemaConfigured.java:37 Why would we need to log into this class&apos;s logger from a subclass? Please define another logger in the subclass directly instead.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/util/Counters.java:1 License&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/util/Counters.java:25 Naming convention: rename to COUNTER_CLASSES&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/util/Counters.java:23 This class probably needs a better name, since it is very specific kind of counters accessed through reflection.&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/util/DoublyLinkedListElement.java:1 License&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/util/DoublyLinkedListHead.java:1 License&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/util/DoublyLinkedListHead.java:4 Make private?&lt;br/&gt;
  src/test/java/org/apache/hadoop/hbase/io/hfile/TestLruBlockCache.java:83 Most changes in this class and a lot of other changes in this diff are simply name changes. Not sure if they are necessary. One advantage is definitely in reminding the caller to unpin blocks.&lt;/p&gt;

&lt;p&gt;REVISION DETAIL&lt;br/&gt;
  &lt;a href=&quot;https://reviews.facebook.net/D1635&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.facebook.net/D1635&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13210750" author="tlipcon" created="Sat, 18 Feb 2012 02:01:55 +0000"  >&lt;p&gt;Hey folks. I haven&apos;t been through the patch yet, but just wanted to throw out one idea that I think can make reference-counted systems a little simpler: in Cocoa (the OSX development framework) there&apos;s a class called NSAutoreleasePool, an instance of which is carried around as part of the local thread context. You can then call &quot;autorelease&quot; on any object, which will not immediately decrement the ref count, but adds it to the pool. When you release the pool, all referenced objects are decremented at that point.&lt;/p&gt;

&lt;p&gt;This idea might make it easier to manage references. For example, when something is read by a scanner, it could be read with ref count incremented but put on the request&apos;s autorelease pool. Then, when any IPC handler thread is returned to the thread pool, the auto release pool could be decremented. This ensures that any stuff we reference is kept around for the whole request lifecycle but still automatically dereffed at the end.&lt;/p&gt;

&lt;p&gt;Do you think such a construct would be useful here?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html&lt;/a&gt; has some more info.&lt;/p&gt;</comment>
                            <comment id="13211290" author="zhihyu@ebaysf.com" created="Sun, 19 Feb 2012 08:54:46 +0000"  >&lt;p&gt;In filterRow(), we should deref the KeyValue which is removed from the list of KeyValues parameter.&lt;br/&gt;
In 0.89-fb branch, I found DependentColumnFilter where the above change should be added.&lt;/p&gt;</comment>
                            <comment id="13211598" author="khemani" created="Sun, 19 Feb 2012 23:30:33 +0000"  >&lt;p&gt;Thanks for the reviews. I will make another pass pretty soon.&lt;/p&gt;

&lt;p&gt;Todd, What you have suggested will not help when a piece of code wants to&lt;br/&gt;
bump up the reference count because it is keeping the reference to the&lt;br/&gt;
object in some state variable. (for example the store scanner does it&lt;br/&gt;
after a flush). But your suggestion will work in those cases where a piece&lt;br/&gt;
of code forgets to decrement the reference count. The current patch also&lt;br/&gt;
has similar characteristics. It cannot automatically bump up the reference&lt;br/&gt;
count. But if it forgets to do dereference and decrement the ref count&lt;br/&gt;
then it relies on  WeakReferences and garbage collection to do the same.&lt;/p&gt;




&lt;p&gt;On 2/19/12 12:56 AM, &quot;Zhihong Yu (Commented) (JIRA)&quot; &amp;lt;jira@apache.org&amp;gt;&lt;/p&gt;

</comment>
                            <comment id="13211610" author="lhofhansl" created="Mon, 20 Feb 2012 00:08:47 +0000"  >&lt;p&gt;@Ted: That might be right thing to do in filterRow(), but I am slowly getting this feeling that this will put a lot of onus to account for this on various HBase parts (such as filters).&lt;/p&gt;</comment>
                            <comment id="13214074" author="phabricator@reviews.facebook.net" created="Wed, 22 Feb 2012 22:45:47 +0000"  >&lt;p&gt;khemani has commented on the revision &quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5347&quot; title=&quot;GC free memory management in Level-1 Block Cache&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5347&quot;&gt;&lt;del&gt;HBASE-5347&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;jira&amp;#93;&lt;/span&gt; GC free memory management in Level-1 Block Cache&quot;.&lt;/p&gt;

&lt;p&gt;INLINE COMMENTS&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderV2.java:417 I had changed getKey() and getValue() to copy the data because these aren&apos;t in any performance critical path&lt;br/&gt;
  src/main/java/org/apache/hadoop/hbase/regionserver/StoreFile.java:1404 yes, we unpin on close. That is why I had to change the return of getGeneralBloomFilter() from DataInput to DataInputStream&lt;/p&gt;

&lt;p&gt;REVISION DETAIL&lt;br/&gt;
  &lt;a href=&quot;https://reviews.facebook.net/D1635&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.facebook.net/D1635&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13214088" author="zhihyu@ebaysf.com" created="Wed, 22 Feb 2012 23:02:09 +0000"  >&lt;p&gt;@Lars:&lt;br/&gt;
Just saw your comment @ 20/Feb/12 00:08&lt;/p&gt;

&lt;p&gt;I agree with your observation - it is hard to know whether user filters would do the right action.&lt;br/&gt;
I was thinking that the deref can be done outside filterRow() - in nextInternal() e.g.&lt;br/&gt;
How about:&lt;br/&gt;
1. call deref() for every element in results&lt;br/&gt;
2. call filterRow()&lt;br/&gt;
3. call ref() on the remaining elements in results&lt;/p&gt;</comment>
                            <comment id="13214368" author="lhofhansl" created="Thu, 23 Feb 2012 06:26:24 +0000"  >&lt;p&gt;That should work, and it would not put any burden on the writer on the author of a new Filter.&lt;br/&gt;
I need to look at the patch again to get a sense of a extend of extra code we need to sprinkle all over the HBase code base to account for the KVs. On first path it didn&apos;t seem horrid.&lt;/p&gt;

&lt;p&gt;I am generally curious, though, (almost) all the cached blocks have the exact same size, right? The GC (in theory) should have a relatively easy time to reuse the freed space (and it&apos;s interesting - to me anyway - that it doesn&apos;t do this efficiently).&lt;/p&gt;</comment>
                            <comment id="13214377" author="zhihyu@ebaysf.com" created="Thu, 23 Feb 2012 06:37:26 +0000"  >&lt;p&gt;I think we can introduce a new config parameter called &apos;hbase.filter.auto.refcount&apos; e.g.&lt;br/&gt;
If the value of this config is true (default), we use procedure described @ 22/Feb/12 23:02&lt;br/&gt;
If the value is false, we assume (with good release notes of course) the filter writer is fully aware of what he/she is doing.&lt;/p&gt;</comment>
                            <comment id="13214417" author="tlipcon" created="Thu, 23 Feb 2012 07:35:19 +0000"  >&lt;p&gt;Rather than introduce a global config, each filter could use an annotation or marker (ie empty) interface, eg:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
class MyFilter &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; FilterBase &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; RefCountAware
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
@RefCountAware
class MyFilter &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; FilterBase
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13215085" author="khemani" created="Thu, 23 Feb 2012 21:41:47 +0000"  >
&lt;p&gt;Lars, you are right. I have been trying to induce a Full GC but without&lt;br/&gt;
any success. (I can induce a full GC if I artificially hold some&lt;br/&gt;
key-values in queue and force them to be tenured.)&lt;/p&gt;

&lt;p&gt;On 89-fb, my test-case is doing random increments on a space of slightly&lt;br/&gt;
more than 40GB worth of Key-value data. The heap is set to 36GB. The LRU&lt;br/&gt;
cache has a high and low watermark of .98 and .85 percents. The region&lt;br/&gt;
server spawns 1000 threads that continuously do the increments. The&lt;br/&gt;
eviction thread manages to keep the block-cache at about 85% always.&lt;br/&gt;
Cache-on-write is turned on to induce more cache churn. All the 12 disks&lt;br/&gt;
are close to 100% read pegged. GC takes 60% of the CPU (sum of user times&lt;br/&gt;
in 1000 lines of gc log / (elapsed time * #cpus)). Compactions that get&lt;br/&gt;
started never complete while the load is on.&lt;/p&gt;

&lt;p&gt;I guess I have to change the dynamics of the test case to induce GC pauses.&lt;/p&gt;



&lt;p&gt;On 2/22/12 11:35 PM, &quot;Todd Lipcon (Commented) (JIRA)&quot; &amp;lt;jira@apache.org&amp;gt;&lt;br/&gt;
wrote:&lt;/p&gt;

</comment>
                            <comment id="13223574" author="phabricator@reviews.facebook.net" created="Tue, 6 Mar 2012 19:21:55 +0000"  >&lt;p&gt;mbautin has resigned from the revision &quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5347&quot; title=&quot;GC free memory management in Level-1 Block Cache&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5347&quot;&gt;&lt;del&gt;HBASE-5347&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;jira&amp;#93;&lt;/span&gt; GC free memory management in Level-1 Block Cache&quot;.&lt;/p&gt;

&lt;p&gt;  We are not actively pursuing this approach anymore due to non-reproducibility of GC issues.&lt;/p&gt;

&lt;p&gt;REVISION DETAIL&lt;br/&gt;
  &lt;a href=&quot;https://reviews.facebook.net/D1635&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.facebook.net/D1635&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13227744" author="stack" created="Mon, 12 Mar 2012 18:27:22 +0000"  >&lt;blockquote&gt;&lt;p&gt;We are not actively pursuing this approach anymore due to non-reproducibility of GC issues.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That sounds interesting.  Was it that there was no discernible difference seen in GC managing the allocations ourselves?  Would love to hear more if there are lessons to be had Mikhail (and Prakash).  Good on you lads.&lt;/p&gt;</comment>
                            <comment id="13272579" author="phabricator@reviews.facebook.net" created="Thu, 10 May 2012 18:12:50 +0000"  >&lt;p&gt;dhruba has resigned from the revision &quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5347&quot; title=&quot;GC free memory management in Level-1 Block Cache&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5347&quot;&gt;&lt;del&gt;HBASE-5347&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;jira&amp;#93;&lt;/span&gt; GC free memory management in Level-1 Block Cache&quot;.&lt;/p&gt;

&lt;p&gt;REVISION DETAIL&lt;br/&gt;
  &lt;a href=&quot;https://reviews.facebook.net/D1635&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.facebook.net/D1635&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To: Kannan, nspiegelberg, stack, JIRA, khemani&lt;br/&gt;
Cc: HBase Diffs Facebook Group, tedyu, khemani, stack, nspiegelberg, mbautin&lt;/p&gt;</comment>
                            <comment id="13444110" author="ivarley" created="Wed, 29 Aug 2012 14:50:14 +0000"  >&lt;p&gt;Prakash, should this issue be closed if it&apos;s not being pursued any further? Sounds like there was broad general interest, but didn&apos;t end up being a useful direction? I&apos;m changing this to &quot;Later&quot; for now, but feel free to outright close if you think it&apos;s no longer a useful direction.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12514745" name="ASF.LICENSE.NOT.GRANTED--D1635.5.patch" size="191659" author="phabricator@reviews.facebook.net" created="Thu, 16 Feb 2012 01:48:59 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 7 Feb 2012 22:50:55 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>226988</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 years, 16 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0ht7b:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>101993</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>