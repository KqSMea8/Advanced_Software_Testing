<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 18:52:25 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-1304/HBASE-1304.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-1304] New client server implementation of how gets and puts are handled. </title>
                <link>https://issues.apache.org/jira/browse/HBASE-1304</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;Creating an issue where the implementation of the new client and server will go. Leaving &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1249&quot; title=&quot;Rearchitecting of server, client, API, key format, etc for 0.20&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1249&quot;&gt;&lt;del&gt;HBASE-1249&lt;/del&gt;&lt;/a&gt; as a discussion forum and will put code and patches here.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12421797">HBASE-1304</key>
            <summary>New client server implementation of how gets and puts are handled. </summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.png">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="streamy">Jonathan Gray</assignee>
                                    <reporter username="erikholstad@gmail.com">Erik Holstad</reporter>
                        <labels>
                    </labels>
                <created>Wed, 1 Apr 2009 17:05:32 +0000</created>
                <updated>Sun, 13 Sep 2009 22:24:31 +0000</updated>
                            <resolved>Sat, 6 Jun 2009 01:29:43 +0000</resolved>
                                    <version>0.20.0</version>
                                    <fixVersion>0.20.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12702585" author="erikholstad@gmail.com" created="Fri, 24 Apr 2009 22:31:13 +0000"  >&lt;p&gt;This is a rather big patch with a lot of changes but will try to break it down as good as I can.&lt;br/&gt;
Two big components, the client and the server side, client first:&lt;br/&gt;
On the client I have added a couple of classes that will take care of querying and adding of data.&lt;br/&gt;
The classes for adding are:&lt;br/&gt;
RowUpdates, Family where the former wraps the later. The Family class is a container for the columns and values that you want to &lt;br/&gt;
add for that family. These are converted to KeyValues when sent to the server. &lt;/p&gt;

&lt;p&gt;Classes for getting are:&lt;br/&gt;
AbstractGet, common methods for all get classes&lt;br/&gt;
Family, same as above but without the value, since only getting&lt;br/&gt;
Get, interface&lt;br/&gt;
GetRow, getting everything from a row&lt;br/&gt;
GetFamilies, getting everything from a list of families&lt;br/&gt;
GetColumns, getting everything from a list of families where specific columns are specified&lt;br/&gt;
GetTop, getting the last n inserts from every family from a list of families&lt;/p&gt;

&lt;p&gt;TimeRange, every Get includes a TimeRange for the KeyValues you want to fetch&lt;br/&gt;
In every get you can also specify a filter, this has not been implemented yet, but is going to be used for the user to make a custom filter&lt;br/&gt;
that will be used on the server.&lt;/p&gt;


&lt;p&gt;On the server side I have mirroring GetClasses, that basically implements one method, the compareTo(KeyValue, multiFamily) which is different for all the different calls. The notion of a multiFamily is introduced to make the comparison faster for all compares between KeyValue today for fetches, since all KeyValues share the same family, but still keep it open for the future.&lt;br/&gt;
New classes on server:&lt;/p&gt;

&lt;p&gt;AbstractServerGet, &lt;br/&gt;
Deletes, is a class the contains all deletes + a timestamp for a deleteFamily if one is found&lt;br/&gt;
ServerGet&lt;br/&gt;
ServerGetColumns&lt;br/&gt;
ServerGetFamilies&lt;br/&gt;
ServerGetTop&lt;br/&gt;
There is no ServerGetRow, since it is only a GetFamilies for all and are dealt with on the server&lt;/p&gt;

&lt;p&gt;Most of the things have been tested individually but I get problem when trying to send data between the client and the server as shown in src/test/../client/TestNewHTable.java. Think it is not a big problem but haven&apos;t been able to deal with is since I don&apos;t really understand what is needed for the rpc to work. All the classes that I are sending back and forth are &quot;hopefully&quot; implementing Writable and are tested in src/test/.../TestSerialization.java&lt;/p&gt;

&lt;p&gt;Also updated KeyValue to be Writable since it is going to be the return format.&lt;/p&gt;</comment>
                            <comment id="12703528" author="stack" created="Tue, 28 Apr 2009 07:57:19 +0000"  >&lt;p&gt;Couple of comments:&lt;/p&gt;

&lt;p&gt;Is multifamily a boolean that says whether a HCD has more than one?   Can&apos;t client just count the families in an HCD rather than set an attribute?&lt;/p&gt;

&lt;p&gt;From HConstants:&lt;/p&gt;

&lt;p&gt;&quot;Max length a family can have because of the limitation in TFile.&quot;   Shouldn&apos;t this define be in KeyValue if it isn&apos;t already?&lt;/p&gt;

&lt;p&gt;Whats happening in KeyValue?  Seems like most of added code is stuff already in KV?  There are conflicts that need resolving.  Looks like in most cases you want to keep what is in trunk.&lt;/p&gt;

&lt;p&gt;This method:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void set(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; KeyValue kv){
+    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.bytes = kv.getBuffer();
+    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.offset = kv.getOffset();
+    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.length = kv.getLength();
+  } 
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;is a duplicate of a copy constructor from earlier in KV.&lt;/p&gt;

&lt;p&gt;newCommit is not the best name for a method; can we think of something else.  Takes different arg. so maybe just call it commit?&lt;/p&gt;

&lt;p&gt;GetColumns vs. GetFamilies, vs. GetRow: why have 3 types?  Why ain&apos;t a get of all on a row a Get with no family spec?   Why ain&apos;t a get of a column a Get with an explicit column spec?  And a get on a family, a get with a family as opposed to column spec?  Why not a single Get class?&lt;/p&gt;

&lt;p&gt;What is GetTop?  There is no class comment explaining it?  How does this differ from get n versions?&lt;/p&gt;

&lt;p&gt;RowUpdate should be carrying KeyValues?&lt;/p&gt;

&lt;p&gt;newGet is not going to work.  We&apos;ll be stuck with this method name for ever.&lt;/p&gt;

&lt;p&gt;Looks like we start using byte [] for family when we get serverside.  Family class just client side &amp;#8211; and sent over the wire &amp;#8211; only to be made into a byte []?  Should be sent as byte [], not as Object?  We should be slim as possible in RPC &amp;#8211; byte arrays where we can &amp;#8211; to save on net traffic&lt;/p&gt;

&lt;p&gt;Seems like bunch of isDelete code belongs in comparators?&lt;/p&gt;






</comment>
                            <comment id="12703706" author="erikholstad@gmail.com" created="Tue, 28 Apr 2009 16:36:32 +0000"  >&lt;p&gt;+ Yes multiFamily is a boolean that I thought would live in HCD, but I don&apos;t have any preferences in this case and I don&apos;t know how the client would count that, but that might be really easy.&lt;br/&gt;
+ The reason that I put MAX_FMAILY_LENGTH in HConstant was that MAX_ROW_LENGTH was already in there so I thought that it was the place to put things like that.&lt;br/&gt;
+ In KeyValue, this might be the case that the stuff that I added are already in there, will try to change that when going through the code. Yes the set method is not needed, not sure right now why I put that there.&lt;br/&gt;
+ So the reasoning around the naming is that the names that I&apos;m using now are just working names, I run both old implementations side by side, so I can compare the codes and behaviour between them. I don&apos;t intend to keep all the new names when I got this to work, only used for debugging purposes.&lt;br/&gt;
+ The reason behind having different classes for the different Get types is more a way to explain to the user that the calls behave differently and has really nothing to do with the underlying implementation, like you say they could all pretty much be one class, and they also are in the background.&lt;br/&gt;
+ GetTop is not aimed for getting  versions it is for getting the first columns in a family, if you for let&apos;s say are putting the timestamp in the column name and want to fetch the most recent insert, this is when you would use GetTop instead of Get with versions.&lt;br/&gt;
+ RowUpdates are carrying KeyValues, but the way I have done it now, this is transparent to the user and is done at commit time, could definitely be changed.&lt;br/&gt;
+ newGet, see above.&lt;br/&gt;
+ Not really sure what you mean with that Family is being used as a byte[] on the server side. I totally agree that we should try to send as few bytes as possible over the wire, but to me it&lt;br/&gt;
isn&apos;t that obvious that including the family in every byte[] together with the columnName will be less than putting the familyName once and only putting the columns in a list and wrapping this in an object will be bigger. &lt;br/&gt;
+ Are you referring to isDeleted? Yes, this code could live somewhere else, but it is just that it has state, so then you need to have state where it lives. Just seemed easy to have all the things that are related to the compareTo(KeyValue) live in the same place for now, since they all interact with each other.&lt;/p&gt;</comment>
                            <comment id="12703768" author="stack" created="Tue, 28 Apr 2009 17:46:18 +0000"  >&lt;p&gt;+ I think multifamily as an attribute a little redundant&lt;br/&gt;
+ MAX_FAMILY_LENGTH belongs better in KV&lt;br/&gt;
+ Ok on new names (was thinking we should start up a new hosting HTable class so you could keep method names like commit)&lt;br/&gt;
+ I think figuring the high-level class model, what the user sees, is probably the first order of business &amp;#8211; or at least belongs up there as a priority.  The model needs to be tests for puts, deletes, gets and scans; everything.&lt;br/&gt;
+ Could GetTop be a Get against a family?  Versions would in this case return that many of the family entries (the &apos;top&apos; columns).&lt;br/&gt;
+ RowUpdates needs to passing KeyValues.&lt;br/&gt;
+ Regards Family object verses repeating family name in an array of arrays, lets say average get goes against one or two families, and that family name is generally short &amp;#8211; url, ts, page.  Given that Family object with its internal List is how much?  50/80 bytes?  Then on average I&apos;d think current setup cheaper?&lt;br/&gt;
+ Family seems like a bad name for this class.  Column would be better?&lt;br/&gt;
+ I didn&apos;t look at the isDeleted too deeply but seemed like duplication here with other parts of the patch.  I know what you mean about carrying state  &amp;#8211; can make it hard not duplicating code snippets &amp;#8211; but we should make an effort; when I see all this state-carrying code, I see lots of opportunity for bugs.... Needs good testing.&lt;/p&gt;

&lt;p&gt;I&apos;m not seeing a focus on zero-copy in this patch; passing KV out to client.  Am I missing it or is it just not there yet?&lt;/p&gt;

&lt;p&gt;I&apos;m thinking that what with working out model, figuring out optimal client/server message passing, changing deletes to work in the new way, effectively rewriting regionserver again &amp;#8211; took me about a month to do it recently &amp;#8211; to implement the new server-side versions of new client-side objects, I&apos;m thinking that 0.20.0 is 4-8 weeks out if we include this stuff.  I think that too long to wait.&lt;/p&gt;</comment>
                            <comment id="12707513" author="streamy" created="Fri, 8 May 2009 20:29:09 +0000"  >&lt;p&gt;Contains end to end implementation of a Get.&lt;/p&gt;

&lt;p&gt;Most of the server-side stuff can be fully reused for Scans, etc.&lt;/p&gt;

&lt;p&gt;Some unit testing has been done, but NOT fully tested yet.  Would like to get feedback on the design before continuing further.&lt;/p&gt;</comment>
                            <comment id="12707534" author="streamy" created="Fri, 8 May 2009 21:45:02 +0000"  >&lt;p&gt;You now specify a KeyComparator when instantiating your QueryMatcher.&lt;/p&gt;

&lt;p&gt;Gets will now work for catalog tables as well.&lt;/p&gt;

&lt;p&gt;Next step is implementing Scans on top of QueryMatcher (and deps), then puts, then deletes.  Compactions will, pretty much, be a special version of Scans, implemented using a heap-style merge across memcache + storefiles as discussed in other issues.&lt;/p&gt;</comment>
                            <comment id="12707549" author="stack" created="Fri, 8 May 2009 22:41:42 +0000"  >&lt;p&gt;toString format needs to change in Delete, Get, etc., to match how we toString elsewhere using ruby-style for maps/arrays &amp;#8211; just for consistency sake.  Ruby-style is pretty much how java-style works representing Maps and Lists and it matches shell.&lt;/p&gt;

&lt;p&gt;Lets just drop RowLock from the new objects and use a long for lockid altogether?  Thats all it is and one less object.  Also io package not referencing item in client package.&lt;/p&gt;

&lt;p&gt;Below is odd especially when Get does not implement Map&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Set&amp;lt;Map.Entry&amp;lt;&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[],TreeSet&amp;lt;&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[]&amp;gt;&amp;gt;&amp;gt; entrySet() {
+    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.familyMap.entrySet();
+  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Check for null array here:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Result(KeyValue [] kvs) {
+    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.row = kvs[0].getRow();
+    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.kvs = kvs;
+  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Does Result get instantiated server-side?  Would be nice if it wasn&apos;t; if Clients made it, if the Server passed back List&amp;lt;KV&amp;gt;.  Would save on Result instantiation and creation (and duplication) of a row in constructor (maybe getRow could be lazy.... don&apos;t create one unless its called).&lt;/p&gt;

&lt;p&gt;Put some spaces in here so its more readable:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; SortedMap&amp;lt;&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[],SortedMap&amp;lt;&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[],SortedMap&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;,&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[]&amp;gt;&amp;gt;&amp;gt; getMap() {
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Seems a pity creating a TreeMap when usual case is single family.   Later we can optimize and only create the TreeMap on addition of second family?&lt;/p&gt;

&lt;p&gt;Whats this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+  /**
+   * Returns a {@link RowResult}.
+   * @&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; a RowResult
+   */
+  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; RowResult rowResult() {
+    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RowResult();
+  &lt;span class=&quot;code-comment&quot;&gt;//  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; RowResult.createRowResult(kvs);
&lt;/span&gt;+  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The below could be written as: &quot;return this.kvs == null || this.kvs.length == 0;&quot;&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.kvs == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; || &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.kvs.length == 0) {
+      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
+    }
+    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Fix these: &quot;+    for(int i=0; i&amp;lt;length; i++) &quot; &amp;#8211; add spaces.&lt;/p&gt;

&lt;p&gt;Lots of common code.  Common base abstract class?&lt;/p&gt;

&lt;p&gt;These should be static defines rather than created on each construction.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.minStamp = Bytes.toBytes(0L);
+    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.maxStamp = Bytes.toBytes(&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;.MAX_VALUE);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Regards TimeRange, are we for sure that most compares of timestamps are byte [] rather than long?  This class is written for byte [].  Surely compare of two longs is faster than creation of byte array representation and then byte compare?&lt;/p&gt;

&lt;p&gt;These should be made on TimeRange creation?  Or at least cached?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+    &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; min = Bytes.toLong(minStamp);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Above is minor.  In general this TimeRange byte [] compare of longs seems like an optimization that&apos;d never register its so small?&lt;/p&gt;

&lt;p&gt;More to follow.&lt;/p&gt;
</comment>
                            <comment id="12707566" author="erikholstad@gmail.com" created="Fri, 8 May 2009 23:53:53 +0000"  >&lt;p&gt;@Stack&lt;br/&gt;
We wanted to keep Result as a client side Class, but it gets complicated when you are using them in MapReduce jobs and things like that, so that is why we added the creation of it&lt;br/&gt;
on the server side, do agree that we should try  to not do this if we can avoid it.&lt;/p&gt;

&lt;p&gt;TimeRanges are used for for gets and scans where you would compare the times with times that comes from KeyValues that are in bytes, the other place we compare time is on the ttl&lt;br/&gt;
check, this time is created once, so we don&apos;t have to do if for every compare.&lt;br/&gt;
I can&apos;t say how much this is going to effect total performance but I think we should try to make everything as fast as possible, don&apos;t really see the downside in comparing them as byte []&lt;br/&gt;
instead of longs.&lt;/p&gt;
</comment>
                            <comment id="12707574" author="stack" created="Sat, 9 May 2009 00:17:08 +0000"  >&lt;p&gt;I skipped review of KV since I&apos;ve done this earlier&lt;/p&gt;

&lt;p&gt;ColumnCount is all ^M.  Please remove them.  Same for ColumnTracker, etc.&lt;/p&gt;

&lt;p&gt;Is CC supposed to be threadsafe? If so, change counter to be AtomicInteger&lt;/p&gt;

&lt;p&gt;Why are data members in this class public?&lt;/p&gt;

&lt;p&gt;This import in ColumnTracker looks unused: +import org.apache.hadoop.hbase.regionserver.QueryMatcher.MatchCode;&lt;/p&gt;

&lt;p&gt;The below should be set on the datamembers rather than in the Constructor:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; DeleteTracker() {
+    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.deletes = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
+    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.delete = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
+    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.newDeletes = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;KeyValue&amp;gt;();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Why doesn&apos;t DeleteTracker#isDeleted just take a KV rather than all of its vitals?&lt;/p&gt;

&lt;p&gt;What is a DeleteTracker?  No class comment.  What is a familyStamp?&lt;/p&gt;

&lt;p&gt;newDeletes doesn&apos;t seem like a good name.  New relative to what?&lt;/p&gt;

&lt;p&gt;What is iterator a data member?  I don&apos;t see where its initialized.    It looks broke.&lt;/p&gt;

&lt;p&gt;This class probably doesn&apos;t compile?  I see a data member referenced as delete and as deletes.&lt;/p&gt;

&lt;p&gt;Javadoc chart should be inside &amp;lt;pre&amp;gt;&amp;lt;/pre&amp;gt; else formatting will be lost. &lt;/p&gt;

&lt;p&gt;I&apos;ll skip this class till its complete.&lt;/p&gt;

&lt;p&gt;No javadoc on class ExplicitColumnTracker .  Skiipping... Don&apos;t know what it does.&lt;/p&gt;

&lt;p&gt;Is this a regression?&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; kv.matchingColumnNoDelimiter(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.col, &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.familylength);
+        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; kv.matchingColumnNoDelimiter(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.col);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Replace...&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(get.numFamilies() &amp;gt; 0) {
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;with get.isEmpty()?  isEmpty might run faster?&lt;/p&gt;


&lt;p&gt;Yeah, replace this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+      &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;(Map.Entry&amp;lt;&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[],TreeSet&amp;lt;&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[]&amp;gt;&amp;gt; entry : get.entrySet()) {
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;with get.getFamily().getEntrySet()&lt;/p&gt;

&lt;p&gt;Lets reference NavigableSet rather than TreeSet as in below:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+      &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;(Map.Entry&amp;lt;&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[],TreeSet&amp;lt;&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[]&amp;gt;&amp;gt; entry : get.entrySet()) {
{code

This looks wrong in HRegion:

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;+            this.comparator.getRawComparator());&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

We should be checking we are passing right comparator.

Whats &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; in the Memcache.get:

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;+      matcher.update();&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

This looks odd in internalGet:

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;+        case SKIP:&lt;br/&gt;
+          break;&lt;br/&gt;
+        case NEXT:&lt;br/&gt;
+          return false;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Should NEXT be getting the next in the set?  SKIP means skip out?  Above they both return same answer.  Is this what is wanted?&lt;/p&gt;

&lt;p&gt;More to follow.&lt;/p&gt;

</comment>
                            <comment id="12707577" author="streamy" created="Sat, 9 May 2009 00:27:38 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Below is odd especially when Get does not implement Map&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Get.entrySet() now replaced with Get.getFamilyMap()&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Seems a pity creating a TreeMap when usual case is single family. Later we can optimize and only create the TreeMap on addition of second family?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yeah, there a number of additional optimizations that can be made all over the place.  Will be good to see profiling, so my focus is on major algorithmic improvements first and then we can dig in further if need be.  Depending how things go, we can get additional server-side optimizations by having separate client-side/server-side Get/Put/etc that share a common Writable format.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What&apos;s this? (Result.rowResult())&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Will return existing RowResult.  Commented out because I&apos;ve not integrated all the code into this patch yet.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lots of common code. Common base abstract class?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Which class(es) are you referring to?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Regards TimeRange, are we for sure that most compares of timestamps are byte [] rather than long? This class is written for byte []. Surely compare of two longs is faster than creation of byte array representation and then byte compare?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Erik liked the idea of storing byte[]&apos;s, but that&apos;s what we could be comparing to.  While writing the code, I found it so much easier to deal with longs.  There is a difference between comparing byte[]&apos;s vs converting a byte[] to a long and comparing longs directly, but again it&apos;s orders of magnitude less significant than other changes (as you suggest), so I&apos;d rather keep it simple.  I&apos;m thinking of changing TimeRange to just storing the longs.  We can change to byte[] later if shown to make a measurable difference.&lt;/p&gt;


&lt;p&gt;Regarding Result being constructed server-side... I agree we should save wherever possible, but in this case I think a single object instantiation per query is tolerable to keep things easier to work with.  Result is where our custom Writable implementation lives, which leaves the door open for further optimizations (reading all KeyValues into one big byte[] rather than single byte[] allocation per KV).  We also might have other things to attach to it in the future.  That being said, it&apos;s about three lines of code to change this and I don&apos;t feel that strongly either way.&lt;/p&gt;

&lt;p&gt;+1 on all other formatting/spacing/refactor changes, will do.&lt;/p&gt;

&lt;p&gt;Thanks a bunch for the review stack.  Keep it coming.&lt;/p&gt;</comment>
                            <comment id="12707587" author="stack" created="Sat, 9 May 2009 00:50:10 +0000"  >&lt;p&gt;No class comment on QueryMatcher.  What is it?&lt;/p&gt;

&lt;p&gt;All ^Ms still.   Need to remove.&lt;/p&gt;

&lt;p&gt;Does this enum need to be public?  Shouldn&apos;t it be package private?  Also, doc using javadoc rather than comments:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+  &lt;span class=&quot;code-comment&quot;&gt;// ColumnMatcher.match() &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; codes
&lt;/span&gt;+  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;enum&lt;/span&gt; MatchCode { 
+    INCLUDE, &lt;span class=&quot;code-comment&quot;&gt;// Include in result 
&lt;/span&gt;+    SKIP,    &lt;span class=&quot;code-comment&quot;&gt;// Do not include in result
&lt;/span&gt;+    NEXT,    &lt;span class=&quot;code-comment&quot;&gt;// Move to next StoreFile
&lt;/span&gt;+    DONE     &lt;span class=&quot;code-comment&quot;&gt;// Query done, &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;
&lt;/span&gt;+  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Is the comment for next right?  We just made use of this enum in Memcache.&lt;/p&gt;

&lt;p&gt;Data members should be final.&lt;/p&gt;

&lt;p&gt;Things like this.deletes should be moved out of constructor and instead make the declaration and assignment happen in the one statement.&lt;/p&gt;

&lt;p&gt;Why not use the defines that are in KV rather than do below:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+    offset += Bytes.SIZEOF_INT + Bytes.SIZEOF_INT;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is usually written as ret &amp;lt; 0 rather than as +    if(ret &amp;lt;= -1) {&lt;/p&gt;

&lt;p&gt;There are methods in KV for doing some of this stuff that is in match.  Having it here and in KV makes it hard if we want to change KV internals.  Use the KV defines or just use the KV methods getKeyLength, getRowOffset, etc.  There are even versions where you can pass stuff you&apos;ve already calculated &amp;#8211; lengths and offsets &amp;#8211; so the KV method doesn&apos;t do it again.&lt;/p&gt;

&lt;p&gt;Where do we accumulate deletes?  In this match I don&apos;t see that we are adding to the deletes structure.&lt;/p&gt;

&lt;p&gt;Below could be written as return timestamp &amp;lt; oldestStamp instead of as:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(timestamp &amp;lt; oldestStamp) {
+      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
+    }
+    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If expired and memcache, do you just want to remove it?  It&apos;d be rare case I suppose?&lt;/p&gt;

&lt;p&gt;Could we early out here:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+    &lt;span class=&quot;code-comment&quot;&gt;// Read from Memcache
&lt;/span&gt;+    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.memcache.get(matcher, result);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We don&apos;t check the return from this.memcache.get?&lt;/p&gt;

&lt;p&gt;Rather than do this.storefiles.size() == 0, do isEmpty.  storefiles is a concurrentskipmaplist.  size is expensive on this structures.&lt;/p&gt;

&lt;p&gt;Do we have to make the List&amp;lt;HFileScanner&amp;gt; storefileScanners?  Can&apos;t we just process the store files one at a time as they come out of the descendingMap?  Whats advantage of preallocating scanners?  They are used once only anyways?  Just do just-in-time allocation close to where they are used?&lt;/p&gt;

&lt;p&gt;What is a StoreFileScanner?  Members should be final.&lt;/p&gt;

&lt;p&gt;Remove the ^Ms.&lt;/p&gt;

&lt;p&gt;Again SKIP and NEXT seem off.&lt;/p&gt;

&lt;p&gt;Isn&apos;t it possible that INCLUDE might want us to keep going in the store file?  Perhaps more answers to get (same up in memcache).  Instead we break on INCLUDE.&lt;/p&gt;

&lt;p&gt;What is a WildcardColumnTracker&lt;/p&gt;

&lt;p&gt;Bytes is a Writable?  Whats difference between Bytes and ImmutableBytesWritable?  Why is it Writable?  Should we deprecate ImmutableBytesWritable and use this instead?&lt;/p&gt;

&lt;p&gt;Should use Bytes.toString() rather than new String when doing the toString for Bytes.  The former does utf8.  Latter whatever the user locale.&lt;/p&gt;

&lt;p&gt;parseColumn doesn&apos;t belong in Bytes.  Put it in KeyValue?&lt;/p&gt;

&lt;p&gt;There do not seem to be any new tests?&lt;/p&gt;

&lt;p&gt;What do we have here?  Does it work?  What more is to be done?  What you have for an estimate before you have it all put back together?  I see deletes still needs to be worked through, I see scanners and puts still need to be done.  Seems like a bunch of work still to do?  What you reckon lads?&lt;/p&gt;









</comment>
                            <comment id="12707691" author="erikholstad@gmail.com" created="Sat, 9 May 2009 17:07:40 +0000"  >&lt;p&gt;@Stack&lt;br/&gt;
Thanks for all the comments. &lt;/p&gt;

&lt;p&gt;About Bytes vs ImmutableBytesWritable, I totally forgot about Immutable, we can use that instead , the only thing is that the name is so long &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; The place where this is used is when we building lists on the server from the KeyValues that we are looking at and don&apos;t want to copy. But it might be a good idea to keep Bytes as a clean util class, or not, but it doesn&apos;t really matter.&lt;/p&gt;

&lt;p&gt;What we are doing now is that Jon is restructuring my code and I&apos;m doing testing on it as we go,  So to answer your question, no it doesn&apos;t work as it is right now, I&apos;m still testing it. Puts are already done and are not that complicated, Deletes a little bit more complex but also done, but are maybe going to see rewrite. So what we have left to do is scanners and then compactions. &lt;/p&gt;

&lt;p&gt;I think that we should have a version up and running at the end of next week, then we need to put the old client side methods back in there that uses the new api, but that should be too bad.&lt;/p&gt;</comment>
                            <comment id="12707694" author="stack" created="Sat, 9 May 2009 17:58:18 +0000"  >&lt;p&gt;@holstad&lt;/p&gt;

&lt;p&gt;I&apos;m fine using Bytes instead of ImmutableBytes.  We just need to add the deprecated to ImmutableBytes.... Would we have to move Bytes to io package?  Maybe best to just leave Bytes as utility class.  Hadoop has BytesWritable already taken but its not what we want.  Bytes should be instantiable so we can use it in things like Map&amp;lt;Bytes&amp;gt;.  I like that bit of utility (though we should be careful where its used &amp;#8211; don&apos;t want to introduce new class instantiation when not needed and after doing all the work purging them).&lt;/p&gt;

&lt;p&gt;Good stuff.&lt;/p&gt;</comment>
                            <comment id="12707833" author="erikholstad@gmail.com" created="Sun, 10 May 2009 19:42:35 +0000"  >&lt;p&gt;@Stack.&lt;br/&gt;
Yeah, sounds good to deprecate Immutable and keep Bytes in util. I&apos;m just a little bit confused why we should be careful to use it. For the MR jobs we still need something that wraps a byte[], no?&lt;/p&gt;</comment>
                            <comment id="12707839" author="stack" created="Sun, 10 May 2009 20:36:09 +0000"  >&lt;p&gt;Thinking on it more, we should keep IBW and not make Bytes Writable.  Lets not pollute util with io and MR stuff.&lt;/p&gt;

&lt;p&gt;Whats missing from IBW is passing a byte array with offset and length and NOT making a copy in the IBW constructor; only pull on the buffer when we serialize.&lt;/p&gt;

&lt;p&gt;I wonder if such a thing would even work in a MR context?  Can we just change the IBW behavior internally?&lt;/p&gt;</comment>
                            <comment id="12707868" author="erikholstad@gmail.com" created="Mon, 11 May 2009 02:24:33 +0000"  >&lt;p&gt;@Stack&lt;br/&gt;
I think we should do that too, we keep Bytes as it is,  ImmutableBytesWritable we change so that to constructor that takes the byte[], offset and length, doesn&apos;t copy&lt;br/&gt;
and do the cipy when we actually write. I think that will work, but like you said we need to test it to see that it actually does the right thing.&lt;br/&gt;
So what we need to do is to remove the copy line in the constructor and add the two fields, offset and length, to the class, sound ok?&lt;/p&gt;</comment>
                            <comment id="12708295" author="streamy" created="Tue, 12 May 2009 02:03:43 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1304&quot; title=&quot;New client server implementation of how gets and puts are handled. &quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1304&quot;&gt;&lt;del&gt;HBASE-1304&lt;/del&gt;&lt;/a&gt; v4 CHANGELOG&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added unit tests for both ColumnTrackers and DeleteTracker.  Begun work on ColumnMatcher unit test.&lt;/li&gt;
	&lt;li&gt;Fixes toString methods to ruby-style for Delete, Get, Put, Result, Scan, TimeRange&lt;/li&gt;
	&lt;li&gt;TimeRange is now all longs, for now&lt;/li&gt;
	&lt;li&gt;All ^M newlines should be removed, let me know if not&lt;/li&gt;
	&lt;li&gt;Added class comments for ColumnTracker and implementors ExplicitColumnTracker/WildcardColumnTracker&lt;/li&gt;
	&lt;li&gt;Added class comments for QueryMatcher and javadoc comments for MatchCode enum&lt;/li&gt;
	&lt;li&gt;Cleaned up small methods to return (x &amp;lt; y) rather than if branches&lt;/li&gt;
	&lt;li&gt;Added Get.hasFamilies() which wraps !Map.isEmpty()&lt;/li&gt;
	&lt;li&gt;Made QueryMatcher.MatchCode package private&lt;/li&gt;
	&lt;li&gt;Changed to storefiles.isEmpty instead of expensive .size()&lt;/li&gt;
	&lt;li&gt;parseColumn moved to KV from Bytes&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Result&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added null checks&lt;/li&gt;
	&lt;li&gt;Cleaned spacing all over the place&lt;/li&gt;
	&lt;li&gt;Cleaned up .rowResult() and .isEmpty()&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;DeleteTracker&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added class comment for DeleteTracker&lt;/li&gt;
	&lt;li&gt;Two bugfixes for DeleteTracker found from unit tests&lt;/li&gt;
	&lt;li&gt;DeleteTracker.add now takes individual fields rather than just a KeyValue&lt;/li&gt;
	&lt;li&gt;DeleteTracker.Delete private class is being used to store fields, no more KV parsing in DeleteTracker&lt;/li&gt;
	&lt;li&gt;There are a number of potential approaches to further optimize DeleteTracker.  Isolating this behavior to a class should make it easier for everyone to profile/benchmark/improve it down the road.&lt;/li&gt;
	&lt;li&gt;Currently working on extensive unit testing for this class.&lt;/li&gt;
	&lt;li&gt;Took initial assignment out of constructor and set directly to data members.&lt;/li&gt;
	&lt;li&gt;Iterator initialized correctly now.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@stack&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;CC and others do not need to be thread-safe, yet.  We have no multi-threaded Get/Scans.&lt;/li&gt;
	&lt;li&gt;MatchCode is a return type of ColumnTracker.checkColumn, it is not unused.&lt;/li&gt;
	&lt;li&gt;DeleteTracker now takes even more vitals vs a KeyValue.  Why should we reparse KeyValues when the work has already been done in the caller?&lt;/li&gt;
	&lt;li&gt;Regression you mention is only an inefficiency, it will be completely removed once this is finished (it&apos;s for old ColumnMatcher)&lt;/li&gt;
	&lt;li&gt;Reason for NavigableSet vs TreeSet?  Don&apos;t need navigable, just want to TreeSet stuff, and that&apos;s what it is.  Result makes extensive use of TreeSet, changing to NavigableSet is going to make things even wilder looking.  No strong opinion, just wondering what you think (I like to keep things short) &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
	&lt;li&gt;Why this.comparator.getRawComparator() looks wrong in HRegion?  I&apos;m passing the regions raw comparator, we can add a check but seems there are serious things wrong if a Region is instantiated with an incorrect comparator.  Didn&apos;t we want to try to remove checks all over the place for isMeta type things?&lt;/li&gt;
	&lt;li&gt;Added comments to QueryMatcher, should answer your questions.&lt;/li&gt;
	&lt;li&gt;After we do some more testing, I will switch KeyValue parsing to utilize existing methods in KV class rather than doing inline.  Will also use &amp;lt; 0 rather than &amp;lt;= -1 as you suggest.&lt;/li&gt;
	&lt;li&gt;Deletes are accumulated with DeleteTracker.add&lt;/li&gt;
	&lt;li&gt;You are right about earlying out from Memcache.get(), I was returning to do that but not handling properly in Store.get&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12708296" author="streamy" created="Tue, 12 May 2009 02:07:02 +0000"  >&lt;p&gt;Fixed patch path.&lt;/p&gt;</comment>
                            <comment id="12708362" author="streamy" created="Tue, 12 May 2009 08:22:32 +0000"  >&lt;p&gt;I&apos;m about 2/3 done with scanners.  The last bit is the hardest to deal with because of the multi-leveled complexity.  A scan is opened, and then nexted one row at a time.  Each query uses one region at a time, and for that region, has a scanner per store (family) and for each store, a scanner for memcache and one for the storefiles.  Within the storefiles, there is a scanner for each hfile.  This has to be all be intelligently and efficiently merged.&lt;/p&gt;

&lt;p&gt;The primary issue I&apos;m dealing with now is that Memcache is not immutable, so the &quot;next&quot; row can change between calls.  For that reason, it doesn&apos;t seem to make sense to actually make them stateful.  Rather, it uses tailSet() on every next call.&lt;/p&gt;

&lt;p&gt;Should have a patch up for Scans tomorrow.  I&apos;ve done some stuff for Puts and Deletes but not patch-ready yet, should be tomorrow or wednesday depending on scanner testing goes.&lt;/p&gt;</comment>
                            <comment id="12708476" author="stack" created="Tue, 12 May 2009 15:51:33 +0000"  >&lt;p&gt;@jon&lt;/p&gt;

&lt;p&gt;TreeSet is implementation of SortedSet interface.  Was suggesting we use the Interface rather than the implementation.  TreeSet also implements NavigableSet.  NavigableSet is richer than SortedSet.&lt;/p&gt;

&lt;p&gt;On this.comparator.getRawComparator, my fault.  Was misreading.  It looks right in code.&lt;/p&gt;</comment>
                            <comment id="12708539" author="stack" created="Tue, 12 May 2009 18:06:24 +0000"  >&lt;p&gt;Should we add define for non-lockid of -1L?&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; lockId = -1L;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We going to use utility method for this?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void deleteColumn(&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; [] column) {
+    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; len = column.length;
+    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i=0;
+    &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; b = 0;
+    &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;(; i&amp;lt;len; i++) {
+      b = column[i];
+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(b == &apos;:&apos;) {
+        &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
+      }
+    }
..
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Sorry, every time I read these Get, Delete, Result, classes, I want to put them into the client package.  Pains me that they are in &apos;generic&apos; io but I suppose it makes sense?&lt;/p&gt;

&lt;p&gt;Ain&apos;t QueryMatcher the server-side version of Get?  Does that mean we could move these above classes into client package?&lt;/p&gt;

&lt;p&gt;ColumnCount is all ^Ms.  ColumnTracker the same as is DeleteTracker (as do others).  No biggie.&lt;/p&gt;

&lt;p&gt;In ColumnTracer &lt;b&gt;Interface&lt;/b&gt; it says this in class comment:&lt;/p&gt;

&lt;p&gt;+ * This class is NOT thread-safe as queries are never multi-threaded &lt;/p&gt;


&lt;p&gt;NewDeletes is not a good name.  Should minimally be explained in class with a comment.  Should be allocated when its defined rather than have the definition and allocation span over into Constructor.&lt;/p&gt;

&lt;p&gt;In DeleteTracker, iterator is data member.  Its created in finalize.  That seems a little odd?  finalize is a loaded java term.  Perhaps use something else?&lt;/p&gt;

&lt;p&gt;What is happening here?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void add(&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; [] buffer, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; qualifierOffset, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; qualifierLength,

+      &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; timestamp, &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; type) {

+    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(type == KeyValue.Type.DeleteFamily.getCode()) {

+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(timestamp &amp;gt; familyStamp) {

+        familyStamp = timestamp;

+      }

+      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;

+    }


....
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Why not pass in the KV here:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(timestamp &amp;gt; familyStamp) {

+      &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.newDeletes.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Delete(buffer, qualifierOffset, qualifierLength,

+          type, timestamp));

+    }

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;... rather than make a new one to add to newDeletes?  Maybe in context, passing KV is not possible?&lt;/p&gt;

&lt;p&gt;Below looks odd.  We don&apos;t seem to be adding to deletes just returning after setting familyStamp (should we be moving on the familyStamp in this way?).  Whats going on here?  Its not clear.  Comment would help.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void add(&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; [] buffer, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; qualifierOffset, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; qualifierLength,

+      &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; timestamp, &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; type) {

+    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(type == KeyValue.Type.DeleteFamily.getCode()) {

+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(timestamp &amp;gt; familyStamp) {

+        familyStamp = timestamp;

+      }

+      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;

+    }

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;How does the delete datamember in DeleteTracker get set?&lt;/p&gt;

&lt;p&gt;Rewrite this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.familyStamp == 0L &amp;amp;&amp;amp; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.delete == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {

+      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;

+    }

+    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Move below to top of class.  Make it static?&lt;/p&gt;

&lt;p&gt;+  protected enum DeleteCompare { &lt;/p&gt;


&lt;p&gt;On the new Delete class, its needed really?  &lt;/p&gt;

&lt;p&gt;If internal class, I don&apos;t think you need to do below:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+   * Fields are &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; because they are accessed often, directly, and only

+   * within &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; class.

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;They can be private I think... at least the class should be.  Make it static too.&lt;/p&gt;

&lt;p&gt;Should DeleteCompare enums be member of Delete?&lt;/p&gt;

&lt;p&gt;Bytes doesn&apos;t need to be Writable any more, right?  Just Comparable?&lt;/p&gt;

&lt;p&gt;Thats enough for now.&lt;/p&gt;</comment>
                            <comment id="12708612" author="streamy" created="Tue, 12 May 2009 20:37:52 +0000"  >&lt;p&gt;Applies cleanly against latest trunk and compiles.  No other changes.&lt;/p&gt;</comment>
                            <comment id="12708776" author="stack" created="Wed, 13 May 2009 06:15:00 +0000"  >&lt;p&gt;Sorry, broke your patch Jon &amp;#8211; I applied the Writable and HeapSize pieces from this patch so I could close two issues and fix &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1411&quot; title=&quot;remove HLogEdit&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1411&quot;&gt;&lt;del&gt;HBASE-1411&lt;/del&gt;&lt;/a&gt;.  Hope thats OK.&lt;/p&gt;</comment>
                            <comment id="12709264" author="streamy" created="Thu, 14 May 2009 05:02:36 +0000"  >&lt;p&gt;v6 patch adds Scanners.  Some unit tests included, more in the works, end to end testing coming.  Anyone interested in helping out, this patch now contains full implementations of Gets and Scans, end to end.  Filters have been removed from scanner logic for the time being, this obviously needs to be put back but we need revisit them.&lt;/p&gt;

&lt;p&gt;Note, this patch will NOT compile (v5 does).  I am still in the process of moving internal code to the new scanners.&lt;/p&gt;

&lt;p&gt;Tomorrow afternoon I will post a fresh patch that applies cleanly to trunk, compiles, and adds Puts and Deletes.  I may not be able to completely remove all the old gets() by then but will try.&lt;/p&gt;

&lt;p&gt;Compactions are very easy now, they will work seamlessly with the new scanner implementations.&lt;/p&gt;

&lt;p&gt;So for now the best way to help is to review the code in this patch, especially scanners.  There are major changes to how things work, but I hope the new implementation is easier to follow.&lt;/p&gt;</comment>
                            <comment id="12709709" author="stack" created="Fri, 15 May 2009 05:21:27 +0000"  >&lt;p&gt;Tests look great (especially bit where pieces are tested individually instead of as part of a minihbasecluster spinup).  In fact, they are beautiful.  I love the fact that they go on and on.&lt;/p&gt;

&lt;p&gt;This is a little odd:&lt;/p&gt;

&lt;p&gt;+  private final boolean PRINT = false;&lt;/p&gt;

&lt;p&gt;Just use a logger and emit output.  Who cares.&lt;/p&gt;

&lt;p&gt;These names on DeleteCompare seem odd but maybe they&apos;ll make sense when I get to the class:&lt;/p&gt;

&lt;p&gt;INCLUDE_NEW_NEXT_NEW&lt;br/&gt;
NEXT_NEW&lt;/p&gt;

&lt;p&gt;Whats going on here?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+    List&amp;lt;KeyValue&amp;gt; l1 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;KeyValue&amp;gt;();
+    l1.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; KeyValue(row1, fam1, col5, data));
+    l1.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; KeyValue(row2, fam1, col1, data));
+    l1.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; KeyValue(row2, fam1, col2, data));
+    scanners.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Scanner(l1));
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Scanners take a list of KVs?  Even though they have different rows?&lt;/p&gt;

&lt;p&gt;Not important, just a thought --&amp;gt; Should KeyValueScanner implement java Queue and be called KeyValueQueue altogther?  next method becomes poll.  The unimplementables such as remove throw unimplemented exceptions.&lt;/p&gt;

&lt;p&gt;Is there anything left in InternalScanner other than close?&lt;/p&gt;

&lt;p&gt;I&apos;m about 1/3rd of the way through.  Thats enough for now.  Will return to it in morning.&lt;/p&gt;</comment>
                            <comment id="12709883" author="erikholstad@gmail.com" created="Fri, 15 May 2009 15:30:51 +0000"  >&lt;p&gt;@Stack&lt;br/&gt;
Are you mocking the test &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
I just think it is better to test the individual parts not a part of a cluster setup, and start up the cluster where you have a test that actually deals with sending data between the client and the server. Running all the unit test for HBase takes quite some time and I think that depends a little on that we are starting the clusters even though in some cases they are not needed to test the individual units, so just trying to keep testing time to a minimum, but that can of course be changed if you want to do it differently.&lt;/p&gt;

&lt;p&gt;The print boolean is basically to not output any info when you have the test working, but will change to use the logger instead.&lt;/p&gt;

&lt;p&gt;What is weird with the names?&lt;/p&gt;

&lt;p&gt;The reason that the Scanner in the test takes a list of KeyValues is that at the time when the test was written there were no implementation of that scanner, so I had to create a private class to test the KeyValueHeap, so the way that inserting into the private test Scanner has really nothing to do with how it is going to look in the real scanner.&lt;/p&gt;</comment>
                            <comment id="12709895" author="stack" created="Fri, 15 May 2009 16:20:28 +0000"  >&lt;p&gt;the praise is genuine.  I love unit tests especially when not those awkward to debut integration tests that make up the bulk of our tests. &lt;/p&gt;</comment>
                            <comment id="12710069" author="streamy" created="Sat, 16 May 2009 04:52:08 +0000"  >&lt;p&gt;Full implementation of Gets, Scans, Puts, and Deletes.&lt;/p&gt;

&lt;p&gt;Lots more unit tests on the way, there are a number of new ones already in this patch.  I have also modified all existing tests to use the new API.  Internally, most things are moved to the new API (all scans, puts, and deletes) but some gets remain, that&apos;s next.&lt;/p&gt;

&lt;p&gt;Have done a lot towards removing col:fam notation throughout, still some here and there.  Also removed more and more HSK references.&lt;/p&gt;

&lt;p&gt;This patch applies cleanly to current trunk and should compile.  Non-cluster unit tests are all working but there are still some bugs preventing the cluster from coming all the way up so we&apos;ve not run those tests yet.&lt;/p&gt;</comment>
                            <comment id="12710127" author="streamy" created="Sat, 16 May 2009 17:54:34 +0000"  >&lt;p&gt;Dropped some thoughts on IRC, figured I&apos;d post here:&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;10:42am&amp;#93;&lt;/span&gt; jgray2: dj_ryan: i don&apos;t think v7 patch contains changes to compactions yet... not following your questions exactly but compactions need to be merged with scan code&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:43am&amp;#93;&lt;/span&gt; jgray2: gets can be redone as scans&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:43am&amp;#93;&lt;/span&gt; jgray2: and that&apos;s probably the direction we&apos;ll need to go&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:43am&amp;#93;&lt;/span&gt; jgray2: if millions of columns in a single row&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:44am&amp;#93;&lt;/span&gt; jgray2: you basically need to scan them, even within the row&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:44am&amp;#93;&lt;/span&gt; jgray2: QueryMatcher makes the decision about what to do with a KV given the parameters of the query&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:45am&amp;#93;&lt;/span&gt; jgray2: the two complex bits of it are a DeleteTracker and the ColumnTracker&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:45am&amp;#93;&lt;/span&gt; jgray2: two implementations of each&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:46am&amp;#93;&lt;/span&gt; jgray2: ScanDT and GetDT are different because, right now, a Get is not a low-level KV merge like a Scan is&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:46am&amp;#93;&lt;/span&gt; jgray2: so when you&apos;re scanning (or compacting) you actually look at a Stores keys in strict sorted order&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:46am&amp;#93;&lt;/span&gt; jgray2: merging all storefiles + memcache&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:46am&amp;#93;&lt;/span&gt; jgray2: so when tracking deletes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:46am&amp;#93;&lt;/span&gt; jgray2: you need to track very little&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:47am&amp;#93;&lt;/span&gt; jgray2: in a Get, you grab all keys from each storefile, starting at memcache, then going through them newest to oldest&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:47am&amp;#93;&lt;/span&gt; jgray2: so deletes you read in one storefile will apply to any storefiles that are older&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:47am&amp;#93;&lt;/span&gt; jgray2: so GetDT is quite a bit more complex&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:47am&amp;#93;&lt;/span&gt; jgray2: we need to benchmark and see if scans are gooder&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:47am&amp;#93;&lt;/span&gt; jgray2: because they are much more &quot;correct&quot;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:47am&amp;#93;&lt;/span&gt; jgray2: if you do manual timestamp setting, gets can give you indeterminate results&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:48am&amp;#93;&lt;/span&gt; jgray2: but scans are always strictly sorted&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:48am&amp;#93;&lt;/span&gt; jgray2: ColumnTracker is implemented as either ExplicitCT or WildcardCT&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:48am&amp;#93;&lt;/span&gt; jgray2: explicit is when qualifiers are given, wildcard if all in a family&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:48am&amp;#93;&lt;/span&gt; jgray2: so it tracks that, and then max versions for each&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:49am&amp;#93;&lt;/span&gt; jgray2: honestly i&apos;ve not looked at compactions since i wrote scanners but have had it in mind&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:50am&amp;#93;&lt;/span&gt; jgray2: it will use QueryMatcher and CT/DT directly&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:50am&amp;#93;&lt;/span&gt; jgray2: wildcardCT where maxVerisons = family setting&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:50am&amp;#93;&lt;/span&gt; jgray2: ScanDT&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:50am&amp;#93;&lt;/span&gt; jgray2: QueryMatcher already does TTL enforcement and such&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:51am&amp;#93;&lt;/span&gt; jgray2: the only difference is in a minor compaction you still need to output deletes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:51am&amp;#93;&lt;/span&gt; jgray2: that are not fully enforced or overridden&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:51am&amp;#93;&lt;/span&gt; jgray2: so then we&apos;ll probably have a CompactDT&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:52am&amp;#93;&lt;/span&gt; jgray2: might need a slight modification here and there, i don&apos;t think QM is written to ever permit deletes out to the result&lt;/p&gt;</comment>
                            <comment id="12710129" author="streamy" created="Sat, 16 May 2009 18:01:40 +0000"  >&lt;p&gt;CT and DT interfaces have .update() and .reset() methods.  Update is called in Get operations when you move from one storefile to another (deletes apply to older storefiles only, so they are read into another array and then a sorted merge is done in update()).  Reset is called in Scan operations in between rows.  No enforcement of anything crosses row boundaries, outside of filters.&lt;/p&gt;

&lt;p&gt;Filters need to be reimplemented (well, reintegrated at least).  Anyone interested in them, take a look into the existing RowFilter interface and the implementations... There are a number of varying methods, some of which are only used in one or two implementations.  At the least, I&apos;d like to have three separate calls for row, qualifier name, and value.  They are a bit more combined now.  The allRemaining and other methods are also good for early-out scenarios.  But we might be able to have enum return codes instead so we have fewer methods in the interface?  They seem a bit complex... Would be nice if we could make the interface really simple, eventually I&apos;d like to see that work dynamically at run-time so you don&apos;t have to compile filters in the server jars.&lt;/p&gt;</comment>
                            <comment id="12710153" author="stack" created="Sun, 17 May 2009 00:06:47 +0000"  >&lt;p&gt;FYI, Ryan put up trunk+1304v7 here: &lt;a href=&quot;http://github.com/ryanobjc/hbase/tree/hbase-1304&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://github.com/ryanobjc/hbase/tree/hbase-1304&lt;/a&gt;  Lets work off here going forward?&lt;/p&gt;

&lt;p&gt;Also, from #hbase:&lt;/p&gt;

&lt;p&gt;20:47 &amp;lt; dj_ryan&amp;gt; jgray&lt;br/&gt;
20:47 &amp;lt; dj_ryan&amp;gt; so my thought is&lt;br/&gt;
20:47 &amp;lt; dj_ryan&amp;gt; if you say that deletes always apply to later files&lt;br/&gt;
20:47 &amp;lt; dj_ryan&amp;gt; for optimization in gets&lt;br/&gt;
20:47 &amp;lt; dj_ryan&amp;gt; when you minor compact you may run into the situation where deletes apply to puts from the same file&lt;br/&gt;
21:16 &amp;lt; dj_ryan&amp;gt; here&apos;s what i am thinking&lt;br/&gt;
21:17 &amp;lt; dj_ryan&amp;gt; lets say you have (for the same, row, cf, cq)&lt;br/&gt;
21:17 &amp;lt; dj_ryan&amp;gt; delete, 6&lt;br/&gt;
21:17 &amp;lt; dj_ryan&amp;gt; then&lt;br/&gt;
21:17 &amp;lt; dj_ryan&amp;gt; no&lt;br/&gt;
21:17 &amp;lt; dj_ryan&amp;gt; start over&lt;br/&gt;
21:17 &amp;lt; dj_ryan&amp;gt; row1,fam,col1, 10, put, X&lt;br/&gt;
21:17 &amp;lt; dj_ryan&amp;gt; row1,fam,col1, 9, delete&lt;br/&gt;
21:17 &amp;lt; dj_ryan&amp;gt; next file:&lt;br/&gt;
21:18 &amp;lt; dj_ryan&amp;gt; row1,fam,col1,8,put&lt;br/&gt;
21:18 &amp;lt; dj_ryan&amp;gt; &amp;lt;end&amp;gt;&lt;br/&gt;
21:18 &amp;lt; dj_ryan&amp;gt; ok so this is great&lt;br/&gt;
21:18 &amp;lt; dj_ryan&amp;gt; the delete applies to the 2nd file&lt;br/&gt;
21:18 &amp;lt; dj_ryan&amp;gt; but during a minor compaction we end up with:&lt;br/&gt;
21:18 &amp;lt; dj_ryan&amp;gt; row1,fam,fol1, 10, put x&lt;br/&gt;
21:18 &amp;lt; dj_ryan&amp;gt; row1,fam,col1, 9, delete&lt;br/&gt;
21:18 &amp;lt; dj_ryan&amp;gt; row1, fam, col1, 8, put&lt;br/&gt;
21:18 &amp;lt; dj_ryan&amp;gt; and now we have a situation where the delete applies to a put of the same file&lt;/p&gt;</comment>
                            <comment id="12710162" author="streamy" created="Sun, 17 May 2009 02:12:45 +0000"  >&lt;p&gt;@ryan, good stuff...&lt;/p&gt;

&lt;p&gt;first, remember there are three different types of deletes.  Delete (a single version of the exact specified stamp), DeleteColumn (all versions &amp;lt;= specified stamp), and DeleteFamily (all versions of all columns &amp;lt;= specified stamp).&lt;/p&gt;

&lt;p&gt;So, if the case above is talking about a DeleteColumn of col1 @ timestamp 9, then the put @ ts=8 should be deleted, as well as any other col1s in later storefiles with ts &amp;lt;= 9.&lt;/p&gt;

&lt;p&gt;When we actually do the compaction, we will process it with something like the ScanDeleteTracker, that processes the deletes as you go (merging multiple storefiles).  So, the DT would actually prevent the put @ ts=8 from being output to the compacted file.  However, since in this case it is DeleteColumn, we have to retain the delete in the outputted and compacted file.  So we &lt;/p&gt;

&lt;p&gt;Like I mentioned before, the difference between ScanDT and CompactDT is that the compaction one will need to make a decision about which deletes to output and which to clear.  The two cases you will clear deletes from the compacted file is if it is an explicit Delete of a single version and that version exists in the merged files, or if you have a delete that overrides another delete (like a DeleteColumn of col1 @ ts =9 and @ ts = 20.  The ts = 9 would not be included in the compacted file.&lt;/p&gt;

&lt;p&gt;Alternatively, we can make Gets like Scans and then we don&apos;t need the property of deletes only applying to older ones.  What we lose is the ability to early-out of a get w/o having to open and read all the storefiles.  You&apos;ll never be able to just touch memcache, you&apos;ll always need to open every storefile.&lt;/p&gt;</comment>
                            <comment id="12710167" author="ryanobjc" created="Sun, 17 May 2009 05:09:20 +0000"  >&lt;p&gt;A few thoughts:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;It never makes sense to &apos;delete into the future&apos; - imagine if you inserted data that was masked by a delete placed there X days/months/years before.  It would be confusing.&lt;/li&gt;
	&lt;li&gt;Given that previous, deletes are scoped to &apos;now&apos; or before, given the following facts:
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;Deletes remove puts from the memcache immediately&lt;/li&gt;
		&lt;li&gt;No compactions&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Given these 3 facts, a delete would apply only to previous files. This fulfills Jon&apos;s previous needs for get early out.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Now, under the simple minor compaction case, where we just merge all the keys without any delete processing, we run into the scenario whereby:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Deletes now potentially to the current file&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Now, a scan must process every file because it needs to get to the next row.  But a get is a specialized scan, whereby once we have fulfilled the needs of the current query we don&apos;t have to next() the rest of the store files/hfiles (e: jon&apos;s early out).  For example, let&apos;s says we are looking for the columns:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;A,B  - 1 version&lt;br/&gt;
Once we have fulfilled those requirements we can stop looking in files.  Right now scanners will seek all hfiles at the same time which is something that isn&apos;t strictly necessary in a &apos;get()&apos;.  Early outs prevent us from scanning the rest of the files, gaining speed.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Now, I&apos;m not sure exactly how by having the &apos;delete applies only to earlier files&apos; helps the early outs - since no matter what, deletes always come before the puts they apply to even in the same file.&lt;/p&gt;

&lt;p&gt;In the end, I&apos;m concerned about minor compactions removing deleted key/values - are we sure we want this behaviour?&lt;/p&gt;</comment>
                            <comment id="12710181" author="erikholstad@gmail.com" created="Sun, 17 May 2009 08:23:25 +0000"  >&lt;p&gt;@Ryan&lt;br/&gt;
The way I see it is that the fact that deletes only apply to earlier files is not something that is going to speed up the early out scenario for all cases, where it will help is when you have queries that don&apos;t need to touch files but only get data from memcache, since you don&apos;t need to process any deletes in memcache. The fact that deletes do, in the new implementation, only apply to older files is more like a bi product from the fact that deletes in memcache are immediately applied to the data in there.&lt;/p&gt;

&lt;p&gt;If that is the right approach, that is a different story. The reason that I think that it makes sense comes from the fact that deletes take up a lot of resources and time when processing data, so I would like for them to be as efficient as possible. The best thing would be to apply them to the whole store as soon as they came in, but since that is not realistic we have to do something else.&lt;br/&gt;
So be deleting everything in memcache that is effected by the incoming  delete we save time and space, by having less data to process and less flushes calls leading to fewer compactions of any kind.&lt;/p&gt;

&lt;p&gt;The above reasoning might not make sense in all cases, but for a majority I think it does.&lt;/p&gt;

&lt;p&gt;When it comes down to minor compactions, not sure if you are worried about them taking longer time than before where we &quot;just&quot; merged the results. If that is the case, most of the work for that merge is to find out which KeyValue should be the next, actually deleting the entries effected by a delete wouldn&apos;t add that much overhead. &lt;/p&gt;

&lt;p&gt;What are your concerns when it comes to removing deleted KeyValues in a minor compaction, they are still going to be removed eventually and there is currently now way to undo your delete to get them back, so the way I see it they are just a burden for the system. What kinda of behaviour would you like to see?&lt;/p&gt;

&lt;p&gt;Regards Erik&lt;/p&gt;</comment>
                            <comment id="12710183" author="ryanobjc" created="Sun, 17 May 2009 08:46:20 +0000"  >&lt;p&gt;I&apos;m just thinking about what the usage scenario for deletes are - ultimately if you want a different value instead of the original, you are better off to just insert over, rather than to delete then put again.  &lt;/p&gt;

&lt;p&gt;Deleting immediately from the memcache is fine with me.&lt;/p&gt;

&lt;p&gt;So the question is, do we want the complexity of deletes in the scan/get, or do we want to take the higher hit on compactions - potentially.  I don&apos;t think compaction &amp;amp; deletion at the same time is overly complex, and if it makes the scan/get simpler, then perhaps it would be best.&lt;/p&gt;

&lt;p&gt;So far I don&apos;t think the scan delete tracker works - can you confirm/deny?&lt;/p&gt;
</comment>
                            <comment id="12710192" author="ryanobjc" created="Sun, 17 May 2009 11:15:38 +0000"  >&lt;p&gt;here are some correctness comments via a patch that layers on top of your patch indicating the areas and fixes that i think should be.&lt;/p&gt;

&lt;p&gt;i also pushed this to the aforementioned git hub.&lt;/p&gt;</comment>
                            <comment id="12710214" author="streamy" created="Sun, 17 May 2009 19:26:41 +0000"  >&lt;p&gt;Right, if you want to have a different value you just do another PUT, there is not delete.  In that case, if you don&apos;t want versioning, you set max versions = 1 and on compaction older values would not get output to the compacted file.  That is enforced in the ColumnTracker (Wildcard in compaction case).&lt;/p&gt;</comment>
                            <comment id="12710217" author="stack" created="Sun, 17 May 2009 19:47:18 +0000"  >&lt;p&gt;Sounds like the dictum that deletes only apply to the next file is one we could do without if we had to.  But, hopefully, its one of those rules you take upon yourself to make processing cleaner (I haven&apos;t looked closely enough at code yet).&lt;/p&gt;

&lt;p&gt;@Holstad My guess is that memcache is cleaner if deletes are applied on insertion rather than what we have now where we have to back up just in case current cell has been deleted?&lt;/p&gt;

&lt;p&gt;I&apos;m fine removing deleted (and expired) puts as part of minor compaction.  I don&apos;t think it&apos;ll be too taxing.  Obviously, the delete itself must persist in case older files have matching puts (Major compactions are the time when cells can be dropped because they exceed the maximum-versions count on the Store and its the time when you get to drop the delete cells themselves after all of the puts they overshadow have been let go).&lt;/p&gt;

&lt;p&gt;I don&apos;t think we are doing this or even proposing doing this but just in case, +1 on not deleting into the future.&lt;/p&gt;</comment>
                            <comment id="12710267" author="erikholstad@gmail.com" created="Mon, 18 May 2009 04:14:58 +0000"  >&lt;p&gt;@Ryan&lt;br/&gt;
The handling of the deletes for a scan is quite simple actually, much simpler than for a get query and like Jon said it might make sense to move everything to be a scan for correctness of the call, but we need to do timing tests on that first to see what would be the best deal. I don&apos;t really see how we not have to deal with deletes in both get/scan + compactions, unless we would do a major compaction every time, so there would never be any deletes in the system. Right now I think we would use the same logic for a compaction as for a scan call if everything goes as planned. &lt;br/&gt;
Are there anything wrong with the unit tests for the scan delete tracker? Or is there some other issue that makes you think it is broken? We haven&apos;t made a full client/server/client test yet, so I can&apos;t confirm that is works all the way, but please let me know what is broken.&lt;/p&gt;

&lt;p&gt;@Stack&lt;br/&gt;
Yeah, I think that applying the deletes in memcache will keep it cleaner and we use less resources for the gets and the scans after that. I guess we don&apos;t have to use the fact that deletes only apply to earlier files, but I think it makes sense to use it to make gets faster, unless we make them scans and don&apos;t have to worry about it.&lt;/p&gt;</comment>
                            <comment id="12710324" author="ryanobjc" created="Mon, 18 May 2009 09:50:32 +0000"  >&lt;p&gt;I have done some recent work layering on top of v7:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://github.com/ryanobjc/hbase/commits/hbase-1304&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://github.com/ryanobjc/hbase/commits/hbase-1304&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This fixes the scan bugs I was mentioning, look at StoreScannerTest - this test used to fail at line 76, but does not anymore.&lt;/p&gt;

&lt;p&gt;I have more work to be done, including filters (some ideas there), and eventually bloom filters (will need help in the heap to make it happen I think) - bf is more a prototype, we wont likely get it until 0.21.&lt;/p&gt;

&lt;p&gt;A scan won&apos;t be as fast as a get, for 2 main reasons:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;have to seek every hfile at init time&lt;/li&gt;
	&lt;li&gt;once query matcher indicates we are &apos;done&apos;, we still have to continue consuming key values until the next row.  We could flag this and skip this, but the &apos;scanner&apos; would be useless for follow up queries.&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;I havent thought about the get() case nearly as much as the scan, so I don&apos;t have any ideas for filters, etc there yet.  Do you?&lt;/p&gt;</comment>
                            <comment id="12710385" author="apurtell" created="Mon, 18 May 2009 15:38:28 +0000"  >&lt;blockquote&gt;&lt;p&gt;once query matcher indicates we are &apos;done&apos;, we still have to continue consuming key values until the next row. We could flag this and skip this, but the &apos;scanner&apos; would be useless for follow up queries.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What kind of performance implication is that? (Re: &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-867&quot; title=&quot;If millions of columns in a column family, hbase scanner won&amp;#39;t come up&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-867&quot;&gt;&lt;del&gt;HBASE-867&lt;/del&gt;&lt;/a&gt;)&lt;/p&gt;</comment>
                            <comment id="12710398" author="erikholstad@gmail.com" created="Mon, 18 May 2009 16:22:21 +0000"  >&lt;p&gt;@Ryan&lt;br/&gt;
Nice job!&lt;br/&gt;
I agree that we can&apos;t early out when we hit deleteFamily since we don&apos;t know if there will be any DeleteColumn and Delete that is newer, is that what you are saying too?&lt;br/&gt;
DeleteFamily doesn&apos;t have to be first on the row though, there might be some columns with the null qualifier that sits before.&lt;/p&gt;

&lt;p&gt;Don&apos;t really follow why the seek() method will not work.&lt;/p&gt;

&lt;p&gt;The way I saw the problem with &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-867&quot; title=&quot;If millions of columns in a column family, hbase scanner won&amp;#39;t come up&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-867&quot;&gt;&lt;del&gt;HBASE-867&lt;/del&gt;&lt;/a&gt; was that we had two problems:&lt;br/&gt;
1. Scanning was too slow in general, since if you asked for all columns and not explicit ones that query would time out too, which is really bad.&lt;br/&gt;
2. When asking for explicit column you would still have to next through all of them even if you had them all for the current row, this is what seek() is trying to help out with, by going back to the file and ask for the next row, so we don&apos;t have too next through many blocks.&lt;/p&gt;

&lt;p&gt;The thing with filters and gets is more of a Filter design issue. But I think that if we rewrite Filters to fit them new implementation better I see no problem in putting them in there, after all this is one of the things that we wanted to accomplish with this rewrite.&lt;/p&gt;</comment>
                            <comment id="12710431" author="jimk" created="Mon, 18 May 2009 18:11:48 +0000"  >&lt;p&gt;&amp;gt; ryan rawson commented on &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1304&quot; title=&quot;New client server implementation of how gets and puts are handled. &quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1304&quot;&gt;&lt;del&gt;HBASE-1304&lt;/del&gt;&lt;/a&gt;:&lt;br/&gt;
&amp;gt; ------------------------------------&lt;br/&gt;
&amp;gt; A few thoughts:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; - It never makes sense to &apos;delete into the future&apos; - imagine if you&lt;br/&gt;
&amp;gt; inserted data that was masked by a delete placed there X&lt;br/&gt;
&amp;gt; days/months/years before.  It would be confusing.&lt;/p&gt;

&lt;p&gt;I agree. +1 on not deleting into the future. &lt;/p&gt;

&lt;p&gt;The exception to this rule is LATEST_TIMESTAMP which HRegion converts&lt;br/&gt;
to &apos;now&apos;. If I read this (somewhat lengthy) discussion correctly, any&lt;br/&gt;
timestamp specified for a delete that does not exactly match a&lt;br/&gt;
timestamp for a cell, that delete will be ignored. Converting&lt;br/&gt;
LATEST_TIMESTAMP to &apos;now&apos; will break if my reading is correct.&lt;/p&gt;

&lt;p&gt;&amp;gt; In the end, I&apos;m concerned about minor compactions removing deleted&lt;br/&gt;
&amp;gt; key/values - are we sure we want this behaviour?&lt;/p&gt;

&lt;p&gt;I am not concerned with removing deleted key/values on a minor&lt;br/&gt;
compaction because as Erik points out, there is no way to undo a&lt;br/&gt;
delete. The delete record still needs to be written so that key/values&lt;br/&gt;
from older stores can be removed (along with the delete record) during&lt;br/&gt;
a major compaction.&lt;/p&gt;
</comment>
                            <comment id="12710436" author="streamy" created="Mon, 18 May 2009 18:23:59 +0000"  >&lt;p&gt;I think everyone is in agreement about the future.  Any stamp given on anything (put or delete) that is &amp;gt; now, becomes now.&lt;/p&gt;

&lt;p&gt;As far as a Delete at LATEST, yes right now it needs to be an exact match.  So, a Delete at LATEST will likely not do anything.  Delete is for a single version.  DeleteColumn is for all versions &amp;lt;= a specified stamp.  So if you want to delete the latest version of something, you don&apos;t need to know it&apos;s stamp as long as you don&apos;t mind clearing all versions before it.  Any time you want to delete &lt;em&gt;only&lt;/em&gt; a single version, you must know and specify the exact stamp.  I think that is fair and understandable, to do otherwise I fear will sacrifice some of the good properties.&lt;/p&gt;

&lt;p&gt;Perhaps we can figure a way to do a single-version delete of the latest version of a column without affecting older ones.  But it seems you&apos;ll have to either actually perform some kind of Get during the delete to figure the stamp, which there is not currently any of outside of touching Memcache, or all of our DeleteTracker&apos;ing will need to change how it handles Deletes.&lt;/p&gt;

&lt;p&gt;Thoughts from others?&lt;/p&gt;</comment>
                            <comment id="12710448" author="erikholstad@gmail.com" created="Mon, 18 May 2009 19:00:43 +0000"  >&lt;p&gt;Personally I&apos;m a little bit confused about the whole concept of deleting the latest put, would you do this to get access the the second to last entry or when and how would this be used?&lt;/p&gt;

&lt;p&gt;When it comes to finding the timestamp for a put maybe we can return that from the server, so that if you wanted to keep track of latest you have that option even if you don&apos;t set an explicit ts client side.&lt;/p&gt;</comment>
                            <comment id="12710453" author="streamy" created="Mon, 18 May 2009 19:07:53 +0000"  >&lt;p&gt;My opinion is, if you care about what the stamps are, then you should set them manually.  We could certainly figure out a way for a Put to return a long, but could be very tricky considering a single put could be built with a different timestamp for each column.&lt;/p&gt;

&lt;p&gt;And what you&apos;re saying about the deleting of latest put, Erik, I agree that this is actually not a particularly common use case and it should be sufficient to allow explicit deletion by stamp.  Any time you are mucking with the version-level, you must be aware of the version dimension (the timestamp).  Since many use cases do not involve versions, I don&apos;t want to pollute everything else to allow for something like explicitly deleting LATEST but no others before it.&lt;/p&gt;</comment>
                            <comment id="12716784" author="ryanobjc" created="Fri, 5 Jun 2009 23:00:25 +0000"  >&lt;p&gt;this is the final patch to be committed&lt;/p&gt;</comment>
                            <comment id="12716785" author="ryanobjc" created="Fri, 5 Jun 2009 23:01:02 +0000"  >&lt;p&gt;this is ready to go into SVN finally.  Some tests have been disabled.&lt;/p&gt;</comment>
                            <comment id="12716790" author="ryanobjc" created="Fri, 5 Jun 2009 23:39:00 +0000"  >&lt;p&gt;late breaking ruby fix for shell&lt;/p&gt;</comment>
                            <comment id="12716792" author="ryanobjc" created="Fri, 5 Jun 2009 23:43:54 +0000"  >&lt;p&gt;supplemental patch to fix shell&lt;/p&gt;</comment>
                            <comment id="12716807" author="ryanobjc" created="Sat, 6 Jun 2009 00:20:55 +0000"  >&lt;p&gt;fixes a test failure&lt;/p&gt;</comment>
                            <comment id="12716814" author="ryanobjc" created="Sat, 6 Jun 2009 01:29:43 +0000"  >&lt;p&gt;Commited, thanks to holstad,jgray,rawson,stack.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                                                <inwardlinks description="is blocked by">
                                        <issuelink>
            <issuekey id="12385804">HBASE-33</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12416456">HBASE-1249</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                            <outwardlinks description="incorporates">
                                        <issuelink>
            <issuekey id="12413939">HBASE-1182</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12403558">HBASE-861</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12415194">HBASE-1206</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12425250">HBASE-1410</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12410045" name="HBASE-1304-fix.patch" size="620" author="ryanobjc" created="Sat, 6 Jun 2009 00:20:55 +0000"/>
                            <attachment id="12408334" name="HBASE-1304-ryan.patch" size="12534" author="ryanobjc" created="Sun, 17 May 2009 11:15:38 +0000"/>
                            <attachment id="12410041" name="HBASE-1304-supp.patch" size="924" author="ryanobjc" created="Fri, 5 Jun 2009 23:43:54 +0000"/>
                            <attachment id="12407659" name="HBASE-1304-v2.patch" size="163450" author="streamy" created="Fri, 8 May 2009 20:29:09 +0000"/>
                            <attachment id="12407667" name="HBASE-1304-v3.patch" size="164304" author="streamy" created="Fri, 8 May 2009 21:45:02 +0000"/>
                            <attachment id="12407838" name="HBASE-1304-v4.patch" size="200341" author="streamy" created="Tue, 12 May 2009 02:07:02 +0000"/>
                            <attachment id="12407917" name="HBASE-1304-v5.patch" size="198674" author="streamy" created="Tue, 12 May 2009 20:37:52 +0000"/>
                            <attachment id="12408100" name="HBASE-1304-v6.patch" size="305249" author="streamy" created="Thu, 14 May 2009 05:02:36 +0000"/>
                            <attachment id="12408307" name="HBASE-1304-v7.patch" size="846409" author="streamy" created="Sat, 16 May 2009 04:52:08 +0000"/>
                            <attachment id="12410037" name="HBASE-1304.patch" size="1608916" author="ryanobjc" created="Fri, 5 Jun 2009 23:00:25 +0000"/>
                            <attachment id="12406407" name="hbase-1304-v1.patch" size="290757" author="erikholstad@gmail.com" created="Fri, 24 Apr 2009 22:31:13 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 28 Apr 2009 07:57:19 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>32084</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 28 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0hchz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>99287</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310192" key="com.atlassian.jira.plugin.system.customfieldtypes:textarea">
                        <customfieldname>Release Note</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>New API - Scan, Get.  New result class &amp;#39;Result&amp;#39;. &lt;br/&gt;
Some old API methods may have been removed.  &lt;br/&gt;
Old filters are semi-broken - any row-based filtering works, but complex column filtering options don&amp;#39;t.&lt;br/&gt;
</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>