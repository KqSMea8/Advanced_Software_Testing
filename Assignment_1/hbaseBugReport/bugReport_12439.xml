<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 20:33:03 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-12439/HBASE-12439.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-12439] Procedure V2</title>
                <link>https://issues.apache.org/jira/browse/HBASE-12439</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;Procedure v2 (aka Notification Bus) aims to provide a unified way to build:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;multi-steps procedure with a rollback/rollforward ability in case of failure (e.g. create/delete table)
	&lt;ul&gt;
		&lt;li&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12070&quot; title=&quot;Add an option to hbck to fix ZK inconsistencies&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12070&quot;&gt;&lt;del&gt;HBASE-12070&lt;/del&gt;&lt;/a&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;notifications across multiple machines (e.g. ACLs/Labels/Quotas cache updates)
	&lt;ul&gt;
		&lt;li&gt;Make sure that every machine has the grant/revoke/label&lt;/li&gt;
		&lt;li&gt;Enforce &quot;space limit&quot; quota across the namespace&lt;/li&gt;
		&lt;li&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10295&quot; title=&quot;Refactor the replication  implementation to eliminate permanent zk node&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10295&quot;&gt;HBASE-10295&lt;/a&gt; eliminate permanent replication zk node&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;procedures across multiple machines (e.g. Snapshots)&lt;/li&gt;
	&lt;li&gt;coordinated long-running procedures (e.g. compactions, splits, ...)&lt;/li&gt;
	&lt;li&gt;Synchronous calls, with the ability to see the state/result in case of failure.
	&lt;ul&gt;
		&lt;li&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-11608&quot; title=&quot;Add synchronous split&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-11608&quot;&gt;HBASE-11608&lt;/a&gt; sync split&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;still work in progress/initial prototype: &lt;a href=&quot;https://reviews.apache.org/r/27703/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/27703/&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="12753527">HBASE-12439</key>
            <summary>Procedure V2</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="mbertozzi">Matteo Bertozzi</assignee>
                                    <reporter username="mbertozzi">Matteo Bertozzi</reporter>
                        <labels>
                            <label>reliability</label>
                    </labels>
                <created>Thu, 6 Nov 2014 21:47:36 +0000</created>
                <updated>Mon, 12 Sep 2016 18:28:38 +0000</updated>
                                            <version>2.0.0</version>
                                    <fixVersion>2.0.0</fixVersion>
                                    <component>master</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>32</watches>
                                                                                                            <comments>
                            <comment id="14202666" author="stack" created="Fri, 7 Nov 2014 21:01:35 +0000"  >&lt;p&gt;Doc is great. When you have a chance, a few examples would help.&lt;/p&gt;</comment>
                            <comment id="14207125" author="ndimiduk" created="Tue, 11 Nov 2014 21:37:25 +0000"  >&lt;p&gt;This will be a huge feature for MTTR and online reliability &amp;#8211; why the Minor label?&lt;/p&gt;

&lt;p&gt;I&apos;m not clear on some of the abstractions. Please comment as to whether the below observations are true or false.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client submits a &quot;procedure&quot; that it&apos;s interested in observing through it&apos;s execution progress&lt;/li&gt;
	&lt;li&gt;a procedure is defined as a DAG of sub-procedures that are required to complete procedure execution&lt;/li&gt;
	&lt;li&gt;multiple sub-procedures can be executed in parallel&lt;/li&gt;
	&lt;li&gt;a sub-procedure can define an action that must be taken on multiple hosts&lt;/li&gt;
	&lt;li&gt;DAG execution progress is tracked through a storage system&lt;/li&gt;
	&lt;li&gt;procedure execution can be halted and reverted at any time&lt;/li&gt;
	&lt;li&gt;completed DAG sub-procedures must be able to roll-back in the event of procedure revert&lt;/li&gt;
	&lt;li&gt;procedure execution is tied to transitions through a persisted state machine&lt;/li&gt;
	&lt;li&gt;all procedures have the same set of states through which they can transition&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Why implement a separate store? Can we not use a system table for the procedure state store?&lt;/p&gt;</comment>
                            <comment id="14207164" author="mbertozzi" created="Tue, 11 Nov 2014 22:03:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;This will be a huge feature for MTTR and online reliability &#8211; why the Minor label?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;because it is probably off to a 1.x or 2.x, since there are a bunch of core changes (e.g. handlers, maybe assignment, ...)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;client submits a &quot;procedure&quot; that it&apos;s interested in observing through it&apos;s execution progress&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;correct, e.g. you call create table you get a procedure id that you can wait on, or check for a progress state if there is any exposed by the procedure.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;a procedure is defined as a DAG of sub-procedures that are required to complete procedure execution&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;correct&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;multiple sub-procedures can be executed in parallel&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;correct, the example in my mind here is Snapshot or EnableTable where the &quot;Enable Procedure&quot; spawn the sub-procedures for assigning each region and they can be executed in parallel.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;a sub-procedure can define an action that must be taken on multiple hosts&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;not sure to understand this one. a sub-procedure is an operation. it can be a simple &quot;write to meta&quot; or it can be &quot;send a snapshot request to the RS&quot;. If you are thinking about stuff like Snapshots or ACL cache updates you basically have two components a coordinator on the Master side and an Executor on the RS, so the Procedure on the master looks like &quot;send the operation to the RSs and wait on ACK do the finalization&quot;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;DAG execution progress is tracked through a storage system&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;correct, every time a procedure is executed we write the state out and we can resume from that point. So we are in the middle of a create table, the master goes down the backup master can start from stepN of that create table that was in progress&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;procedure execution can be halted and reverted at any time&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;yes, you send an abort() to the procedure and if it was started it is rolledback&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;completed DAG sub-procedures must be able to roll-back in the event of procedure revert&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;yes, each step should implement a rollback() and that is called when one of the steps failed or the user aborted&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;procedure execution is tied to transitions through a persisted state machine&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;correct. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;all procedures have the same set of states through which they can transition&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;not sure what you mean, but the framework has its own fixed set of state &quot;runnable/waiting/rollingback/failed/completed&quot; and the user code that implement the procedure doesn&apos;t care about this stuff. It just care about &quot;step1 -&amp;gt; step 2 -&amp;gt; step 3&quot;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Why implement a separate store? Can we not use a system table for the procedure state store?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The store is just an interface insert/remove, you can use what ever you want. &lt;br/&gt;
The main problem of using a table is that you end up with the chicken egg problem.&lt;br/&gt;
How can I create a table if I need a table to write the procedure state?&lt;br/&gt;
then I can say that if you use just a wal you can just drop the wal once there are no procedure running, so you can avoid the compaction overhead and so on.. but that is just an optimization the main problem is the startup loop.&lt;/p&gt;</comment>
                            <comment id="14301738" author="stack" created="Mon, 2 Feb 2015 19:23:53 +0000"  >&lt;p&gt;Suggest add JIRA number to doc. Suggest a sentence on how PV2 is NOT FATE.  Add the work &apos;idempotent&apos; in around this text &quot;...in a way that each step must be able to be executed multiple times (generating the same result) a...&quot; (although if a rollback, I suppose it not idempotent?).  The API is Admin.doOperation(). Should it be Admin.doProcedure?  (In doc., you start talking about &apos;operations&apos; when you were talking about &apos;procedures&apos; up to this).  This is good: &quot;The Region Server will not persist any state, retry or re&#173;execute any previously pending&lt;br/&gt;
operation on restart, everything is coordinated by the master&quot;.  &lt;/p&gt;

&lt;p&gt;On this, &quot;If the master does not receve a response within a timeout, or the region was reassigned, it will resend the execution request.&quot;, master will just retry for ever?&lt;/p&gt;

&lt;p&gt;For the TwoPhaseProcedure, would be good to draw out the steps as you have done for the OnePhaseProcedure procedure. Would help me figure if I get how this &apos;staging&apos; stuff works.&lt;/p&gt;

&lt;p&gt;What is this? &quot;(The sync&#173;client implementation...&quot;)&lt;/p&gt;

&lt;p&gt;Doc is excellent.&lt;/p&gt;

</comment>
                            <comment id="14301894" author="mbertozzi" created="Mon, 2 Feb 2015 20:48:17 +0000"  >&lt;blockquote&gt;&lt;p&gt;The API is Admin.doOperation(). Should it be Admin.doProcedure? (In doc., you start talking about &apos;operations&apos; when you were talking about &apos;procedures&apos; up to this).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;No, Procedure is the internal name for &quot;I&apos;m doing something&quot;.&lt;br/&gt;
Example: &quot;delete table&quot; maps to a procedure but &quot;snapshot&quot; may map to multiple procedures (depending on how you view the execution it may be the master part + the RS subprocs or it may be just the &quot;snapshot namespace&quot; with the table snapshots as subprocedures).&lt;br/&gt;
another example is create table, if you see &quot;create table operation&quot; as &quot;create procedure&quot; + &quot;assignment procedure&quot;. more in general I use &quot;operation&quot; because there may be more work than just call the procedure.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&quot;If the master does not receve a response within a timeout, or the region was reassigned, it will resend the execution request.&quot;, master will just retry for ever?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;It depends, e.g. if the procedure is &quot;assignment&quot; yes. if the procedure is &quot;snapshot&quot; it will timeout after Nsec.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;For the TwoPhaseProcedure, would be good to draw out the steps as you have done for the OnePhaseProcedure procedure. Would help me figure if I get how this &apos;staging&apos; stuff works.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;sure, still in progress&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;What is this? &quot;(The sync&#173;client implementation can be done for the 2.0 branch, but we can&#8217;t backport that to&lt;br/&gt;
keep the compatibility. New client methods can be added using the procedure)&quot;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;our Admin is not really sync, for example create table and similar depends on the order of the operation master-side. so if you change the code of the handler but not the client, the client will be async since the operation server side may not be completed.&lt;br/&gt;
With the procedure you are waiting on the proc to be completed, so you can change the server side as much as you want and the client don&apos;t care about it. and you also get the master failover for free. e.g. In the middle of Create Table the master goes down, the client is spinning on isDone(createProcId) the backup master complete the create table and the client receive the isDone() = true.&lt;/p&gt;</comment>
                            <comment id="14301960" author="stack" created="Mon, 2 Feb 2015 21:22:32 +0000"  >&lt;blockquote&gt;&lt;p&gt;No, Procedure is the internal name for &quot;I&apos;m doing something&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Its confusing swapping in Operation for Procedure when you&apos;ve done all this work talking up Procedures and of how Procedures are made of zero or more Sub-Procedures.&lt;/p&gt;

&lt;p&gt;Ok on the rest &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mbertozzi&quot; class=&quot;user-hover&quot; rel=&quot;mbertozzi&quot;&gt;Matteo Bertozzi&lt;/a&gt; Looks great.&lt;/p&gt;
</comment>
                            <comment id="14302746" author="enis" created="Tue, 3 Feb 2015 04:17:22 +0000"  >&lt;p&gt;Thanks Matteo. This is good. Similar to what has been discussed in other jiras, but with some implementation this time. &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Suggest add JIRA number to doc. Suggest a sentence on how PV2 is NOT FATE. Add the work &apos;idempotent&apos; in around this text &quot;...in a way that each step must be able to be executed multiple times (generating the same result) a...&quot; (although if a rollback, I suppose it not idempotent?)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The way I see it is that FATE execution is in stack, versus here is DAG. FATE calls the above &quot;adompotent&quot;, since the step can be in partially done or failed. So the step should work over the result of a partial execution from previous. For example, a step for creating a dir for the table in hdfs should not fail if the directory is already there. &lt;/p&gt;

&lt;p&gt;What is the diagram that talks about &quot;branch coordinators&quot;? Does not seem mentioned in the text. &lt;/p&gt;

&lt;p&gt;I think we should address fencing as a first level goal, and mention it in the state store implementation. If we make it explicit in store, alternative implementations if any has to take that into account. Fencing is really important because current master lacks it, and it is a potential cause for wracking havoc on the cluster. Proper fencing can only be achieved through the store, and only if active master does a state store operation for every action. For example, the master can do a &quot;register master&apos; procedure as a way to commit its state, and prevent the previous master to do any more operation. I could not see a use of fencing through wal (or recover lease, etc) in the patch. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The main problem of using a table is that you end up with the chicken egg problem.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This is easy to workaround. We can have two state store implementations. One is a smaller scale zk based one, for doing bootstrap. The other is for usual operations. However, I think we still do not need a table yet, but a state store can be implemented as a region opened in master. This way, we do not have to re-implement yet another wal, and custom in-memory data structures. Let me experiment with this approach on top of this patch. &lt;/p&gt;

&lt;p&gt;I&apos;ll take a more closer look at the patch as well. &lt;/p&gt;






</comment>
                            <comment id="14303017" author="mbertozzi" created="Tue, 3 Feb 2015 09:49:02 +0000"  >&lt;blockquote&gt;&lt;p&gt;FATE calls the above &quot;adompotent&quot;, since the step can be in partially done or failed. So the step should work over the result of a partial execution from previous. For example, a step for creating a dir for the table in hdfs should not fail if the directory is already there.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;here the logic is the same, once you execute a step if there is a non retryable code failure there will be a rollback step called.&lt;br/&gt;
the logic to revert partial step is responsibility of the execute()/rollback() implementation not of the framework, the framework only knows if a step is supposed to be executed or rollback, it has no knowledge about what you are doing.  &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think we should address fencing as a first level goal, and mention it in the state store implementation. If we make it explicit in store, alternative implementations if any has to take that into account.... &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;agreed, I&apos;m not yet at this point. I&apos;m still at making sure the execution/rollback was as expected.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;This is easy to workaround. We can have two state store implementations. One is a smaller scale zk based one, for doing bootstrap. The other is for usual operations. However, I think we still do not need a table yet, but a state store can be implemented as a region opened in master. This way, we do not have to re-implement yet another wal, and custom in-memory data structures. Let me experiment with this approach on top of this patch.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The reason I choose the wal was to support assignment, all the logged events will probably trigger to many flush and compactions. and we don&apos;t really need this data to be compacted. but maybe a simple tuning on the region to avoid compaction and relying on TTL may be just fine and avoid the problem. didn&apos;t look into it too much, if you have time to experiment with it feel free to post a patch or just suggestions on how to change it.&lt;/p&gt;</comment>
                            <comment id="14303025" author="mbertozzi" created="Tue, 3 Feb 2015 09:58:54 +0000"  >&lt;blockquote&gt;&lt;p&gt;What is the diagram that talks about &quot;branch coordinators&quot;? Does not seem mentioned in the text.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;yeah, in the text there is a passage line but nothing more: &quot;Assuming no other coordinator between the Master and the Region Server, the operation is sent down to the executor (Region Server) and the Master will be responsible to retry/resend the operation&quot;.&lt;br/&gt;
I was thinking at a multi-master case where each master (in the pic branch coordinator) is responsible for a set of RSs and the root-master (in the pic root coordinator) is doing coordination between the masters. but that&apos;s not important, it is just an implementation detail on how the &quot;first level&quot; of the procedure is implemented.&lt;/p&gt;</comment>
                            <comment id="14607551" author="syuanjiang" created="Tue, 30 Jun 2015 05:58:45 +0000"  >&lt;p&gt;As we completed the Phase 1 of PV2 in HBASE 1.1 release and made some enhancement in HBASE 1.2 release.  We are going to continue the Phase 2 of PV2 work in HBASE 1.3.  Attached the document with the list of items in the pipeline. &lt;/p&gt;</comment>
                            <comment id="14725701" author="syuanjiang" created="Tue, 1 Sep 2015 17:08:07 +0000"  >&lt;p&gt;Update the roadmap based on discussion between &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mbertozzi&quot; class=&quot;user-hover&quot; rel=&quot;mbertozzi&quot;&gt;Matteo Bertozzi&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=syuanjiang&quot; class=&quot;user-hover&quot; rel=&quot;syuanjiang&quot;&gt;Stephen Yuan Jiang&lt;/a&gt; and feedback from August dev meetup discussion.  Basically the focus would be on the upcoming 2.0 release to have new assignment manager using Proc-V2.  &lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310060">
                    <name>Container</name>
                                            <outwardlinks description="contains">
                                        <issuelink>
            <issuekey id="12860901">HBASE-14350</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12860903">HBASE-14351</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12982553">HBASE-16100</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12932920">HBASE-15141</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12860479">HBASE-14336</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12861059">HBASE-14353</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13004378">HBASE-16617</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12753557" name="Procedure v2 roadmap.pdf" size="116018" author="syuanjiang" created="Tue, 1 Sep 2015 17:04:55 +0000"/>
                            <attachment id="12679960" name="ProcedureV2.pdf" size="202719" author="mbertozzi" created="Thu, 6 Nov 2014 21:47:56 +0000"/>
                            <attachment id="12693273" name="Procedurev2Notification-Bus.pdf" size="301359" author="mbertozzi" created="Tue, 20 Jan 2015 09:30:19 +0000"/>
                    </attachments>
                <subtasks>
                            <subtask id="12781784">HBASE-13228</subtask>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 7 Nov 2014 21:01:35 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            1 year, 15 weeks, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i222uf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>