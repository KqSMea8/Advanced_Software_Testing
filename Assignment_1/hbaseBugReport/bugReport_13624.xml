<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 20:45:08 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-13624/HBASE-13624.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-13624] A few behavior issue with hbase checkandmutate</title>
                <link>https://issues.apache.org/jira/browse/HBASE-13624</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;There are several problems with checkandmutate behavior.&lt;/p&gt;

&lt;p&gt;1.  The results with comparators are reversed. &lt;br/&gt;
     For example, in a table we have a row like below      &lt;br/&gt;
     key=surow3 column=fam0:col0 timestamp=1430849691461 type=Put vlen=12 value=surow3-val00&lt;br/&gt;
     If we run checkandmutate on it with operator CompareOp.GREATER and input value &quot;surow2&quot;, checkandmuate does not apply the mutations, however, if we change the operator to CompareOp.LESS , it applies the mutation.&lt;br/&gt;
     Since the api has signature like &lt;br/&gt;
     checkAndMutate(row, family, qualifier, CompareOp, input_value, mutation)&lt;br/&gt;
     it should behave as &quot;if (value_in_table_of_given_row_family_qualifier &amp;gt; input_value), then apply mutations&quot;, however, in current implementation, the left-hand and right-hand side of the operator are reversed.&lt;/p&gt;

&lt;p&gt;2.  &quot;NOT_EQUAL with input value null&quot; should be interpreted as &quot;if column exists, apply mutations&quot;, instead of &quot;if column is missing, apply mutations&quot;&lt;br/&gt;
     In current implementation, as long as the input value is null, then checkandmutate applies the mutations if the column is missing, no matter what compareop is.&lt;br/&gt;
     However, for  &lt;br/&gt;
     checkAndMutate(row, family, qualifier, CompareOp.NOT_EQUAL, null, mutation)&lt;br/&gt;
     it should be interpreted as &quot;if that row:family:qualifier exists, apply the mutations&quot;.&lt;/p&gt;

&lt;p&gt;3. The mutations can be on a row which is different from the one in the check.&lt;br/&gt;
   For example, we have a table with the following two rows&lt;br/&gt;
   key=r0 column=f0:c0 timestamp=1430860202859 type=Put vlen=6 value=r0-v00&lt;br/&gt;
   key=r1 column=f0:c0 timestamp=1430860202879 type=Put vlen=6 value=r1-v00&lt;/p&gt;

&lt;p&gt;   If we run checkandmute with&lt;/p&gt;

&lt;p&gt;   RowMutations rm1 = new RowMutations(row1);&lt;br/&gt;
   rm1.add(...);&lt;br/&gt;
   checkAndMutate(Bytes.toByte(&quot;r0&quot;), Bytes.toByte(&quot;f0&quot;), Bytes.toByte(&quot;c0&quot;), CompareOp.EQUAL, Bytes.toByte(r0-v00), rm1)&lt;/p&gt;

&lt;p&gt;   The checkandmutate will apply the mutations on r1, which is NOT correct. checkandput/delete do not have this issue.&lt;/p&gt;
</description>
                <environment></environment>
        <key id="12827434">HBASE-13624</key>
            <summary>A few behavior issue with hbase checkandmutate</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.png">Critical</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="suchen">Su Chen</reporter>
                        <labels>
                    </labels>
                <created>Tue, 5 May 2015 21:19:04 +0000</created>
                <updated>Tue, 9 Jun 2015 03:43:24 +0000</updated>
                                            <version>2.0.0</version>
                    <version>0.98.9</version>
                    <version>1.0.1</version>
                    <version>1.1.0</version>
                                                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                <comments>
                            <comment id="14529721" author="srikanth235" created="Wed, 6 May 2015 01:24:22 +0000"  >&lt;blockquote&gt;&lt;p&gt;The results with comparators are reversed. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;If you look at the internals of checkAndXXX implementations, all use the same logic. I don&apos;t think this is specific to checkAndMutate.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&quot;NOT_EQUAL with input value null&quot; should be interpreted as &quot;if column exists, apply mutations&quot;, instead of &quot;if column is missing, apply mutations&quot;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;From the javadoc, &quot;If the passed value is null, the check is for the lack of column (ie: non-existence)&quot;. So, right now it doesn&apos;t care about comparator once the value is null. I believe the same is the case about other checkAndXXXX implementations.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The mutations can be on a row which is different from the one in the check.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The main intent behind introducing checkAndXXX methods is, you perform the check on the row and if it passes, then you operate on the &lt;b&gt;same&lt;/b&gt; row accordingly. From implementation pov, what happens is you obtain row lock , peform the check, operate if needed and close the row lock. IMHO, the api is getting abused, if you try to perform checks on one row and operate on another row.&lt;/p&gt;</comment>
                            <comment id="14578069" author="suchen" created="Mon, 8 Jun 2015 23:41:16 +0000"  >&lt;p&gt;Another smaller issue with null value as input.&lt;br/&gt;
If there exist a column with empty value &quot;byte&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;&quot;, and we call checkandmutate with value as null, the checkandmutate thinks this is a match, and applies the mutations.&lt;br/&gt;
And from the decription in the API, it looks like check should only return true when the column does not exist, if null is the value.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 6 May 2015 01:24:22 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_12310250" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10431"><![CDATA[Important]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            1 year, 27 weeks, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2ebrb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>