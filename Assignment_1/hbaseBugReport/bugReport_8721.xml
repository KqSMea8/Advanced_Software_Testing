<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:57:54 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-8721/HBASE-8721.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-8721] Deletes can mask puts that happen after the delete</title>
                <link>https://issues.apache.org/jira/browse/HBASE-8721</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;this fix aims for bug mentioned in &lt;a href=&quot;http://hbase.apache.org/book.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hbase.apache.org/book.html&lt;/a&gt; 5.8.2.1:&lt;/p&gt;

&lt;p&gt;&quot;Deletes mask puts, even puts that happened after the delete was entered. Remember that a delete writes a tombstone, which only disappears after then next major compaction has run. Suppose you do a delete of everything &amp;lt;= T. After this you do a new put with a timestamp &amp;lt;= T. This put, even if it happened after the delete, will be masked by the delete tombstone. Performing the put will not fail, but when you do a get you will notice the put did have no effect. It will start working again after the major compaction has run. These issues should not be a problem if you use always-increasing versions for new puts to a row. But they can occur even if you do not care about time: just do delete and put immediately after each other, and there is some chance they happen within the same millisecond.&quot;&lt;/p&gt;</description>
                <environment></environment>
        <key id="12651914">HBASE-8721</key>
            <summary>Deletes can mask puts that happen after the delete</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="2">Won&apos;t Fix</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="fenghh">Honghua Feng</reporter>
                        <labels>
                    </labels>
                <created>Sun, 9 Jun 2013 09:54:20 +0000</created>
                <updated>Mon, 6 Jun 2016 12:51:45 +0000</updated>
                            <resolved>Thu, 20 Jun 2013 18:44:03 +0000</resolved>
                                                                    <component>regionserver</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>18</watches>
                                                                <comments>
                            <comment id="13678994" author="fenghh" created="Sun, 9 Jun 2013 10:12:51 +0000"  >&lt;p&gt;This fix uses mvcc together with timestamp to determine if a put will be masked by a delete. So the put happened after a delete can&apos;t be masked by that delete though according to timestamp it will be masked(before this fix). In this theme mvcc will be kept intact unconditionally (not set to 0) when doing flush/compact, and furthermore mvcc also need to be serialized(and later unserialized) to HLog for possible replay, and max mvcc in recovered split HLog also need to be reflected in the recovered HRegion during its initializing phase.&lt;/p&gt;</comment>
                            <comment id="13678995" author="fenghh" created="Sun, 9 Jun 2013 10:15:18 +0000"  >&lt;p&gt;this patch is based on code downloaded from &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/branches/0.94&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/branches/0.94&lt;/a&gt; and all the unit-tests pass in my local environment&lt;/p&gt;</comment>
                            <comment id="13679043" author="apurtell" created="Sun, 9 Jun 2013 13:07:53 +0000"  >&lt;p&gt;This section of the book describes expected behavior. This is not a bug. &lt;/p&gt;</comment>
                            <comment id="13679046" author="apurtell" created="Sun, 9 Jun 2013 13:11:13 +0000"  >&lt;p&gt;Feel free to reopen and re-describe this as a possible enhancement if there is a particular compelling reason (use case) to change this behavior. &lt;/p&gt;</comment>
                            <comment id="13679339" author="fenghh" created="Mon, 10 Jun 2013 06:39:23 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=andrew.purtell%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;andrew.purtell@gmail.com&quot;&gt;Andrew Purtell&lt;/a&gt; Consider this scenario: first put a KV with timestamp T0, and then delete it with timestamp T1 (T1&amp;gt;T0), and then put that KV again with timestamp T0. Now whether a get/scan can read out KV depends on whether a major compact occurs between the delete and second put, if there is a major compact occurs during that time frame, the delete will be collected by the major compact, therefore the second put survives and can be read out by a get/scan, on contrary if no major compact occurs during that time frame the second put and the first put will both be masked by the delete and can&apos;t be read out by get/scan. This means by current delete handling mechanism data&apos;s visibility sometimes depends on if a major compact occurs during a tricky time frame, this behaviour is weird and unacceptable since major compact should be transparent to end users and should by no means have impact on data&apos;s visibility.&lt;br/&gt;
And the behaviour that a later put can be masked by a earlier delete itself is somewhat weird and can make end users confusing in many scenarios. Some HBase users in our company complain about this behaviour and claim this behaviour is unacceptable from their end users&apos; viewpoint. And I also noticed there is a same discussion on this issue by jira &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2256&quot; title=&quot;Delete row, followed quickly to put of the same row will sometimes fail.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2256&quot;&gt;HBASE-2256&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13679668" author="sershe" created="Mon, 10 Jun 2013 17:39:17 +0000"  >&lt;p&gt;&quot;It will start working again after the major compaction has run&quot; that is not actually correct afaik.&lt;br/&gt;
This will only be true if put is in memstore when major compaction is run, and that is a bug-ish behavior (compaction doesn&apos;t look at memstore).&lt;br/&gt;
If put is flushed out before major compaction, it will not reappear, regardless of seqnums.&lt;/p&gt;

&lt;p&gt;And yes the behavior where deletes masks later puts with the same ts is expected&lt;/p&gt;</comment>
                            <comment id="13680126" author="fenghh" created="Tue, 11 Jun 2013 01:31:39 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sershe&quot; class=&quot;user-hover&quot; rel=&quot;sershe&quot;&gt;Sergey Shelukhin&lt;/a&gt;/&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=apurtell&quot; class=&quot;user-hover&quot; rel=&quot;apurtell&quot;&gt;Andrew Purtell&lt;/a&gt; The scenario is refined as below:&lt;br/&gt;
1&amp;gt;. put a kv with timestamp T0, and flush;&lt;br/&gt;
2&amp;gt;. delete that kv with timestamp T1, and flush;&lt;br/&gt;
3&amp;gt;. a major compact occurs &lt;span class=&quot;error&quot;&gt;&amp;#91;or not&amp;#93;&lt;/span&gt;;&lt;br/&gt;
4&amp;gt;. put that kv again with timestamp T0;&lt;br/&gt;
5&amp;gt;. read that kv;&lt;/p&gt;

&lt;p&gt;a). if a major compact occurs at step 3&amp;gt;, then step 5&amp;gt; will get the put written at step 4&amp;gt;&lt;br/&gt;
b). if no major compact occurs at step 3&amp;gt;, then step 5&amp;gt; get nothing&lt;/p&gt;

&lt;p&gt;I think this is a BUG.&lt;/p&gt;

&lt;p&gt;And I also DON&apos;T think the behaviour where deletes masks later puts with the same ts is expected. In some real-world scenarios where timestamp is used NOT with time semantic but as another ordinary dimension of the kv&apos;s coordinate, user puts a kv, deletes it, and some time later puts that kv again, finds the write succeeds but can&apos;t read it out. Current delete behaviour limits such extended usage of timestamp dimension.&lt;/p&gt;

&lt;p&gt;Do we accept this incorrect/buggy behaviour as is just because it exists not fixed for a so long time?&lt;/p&gt;</comment>
                            <comment id="13680141" author="sershe" created="Tue, 11 Jun 2013 01:52:50 +0000"  >&lt;p&gt;Semantics of timestamp is time-based, that is by design. If you do two puts K1,CF1:C1,ts=2; K1,CF1:C1,ts=1, in that order, the first put will override the 2nd put even though it was performed earlier. Ts simply shouldn&apos;t be used if its values&apos; semantics is not time or time-like (i.e. some sort of version); in that case part of row key, or extra column, can be used...&lt;/p&gt;

&lt;p&gt;As for the effect of major compaction, it is indeed an unobvious behavior, however the only alternative is to keep the delete markers forever to apply them consistently, which may not be desirable...&lt;br/&gt;
I guess we could add config setting to enable it.&lt;/p&gt;</comment>
                            <comment id="13680323" author="fenghh" created="Tue, 11 Jun 2013 09:09:40 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sershe&quot; class=&quot;user-hover&quot; rel=&quot;sershe&quot;&gt;Sergey Shelukhin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If we want to keep the behaviour that delete can mask puts that happened after the delete, to fix the inconsistency issue caused by major compact, the only alternative is to keep the delete markers forever, as you said.&lt;/p&gt;

&lt;p&gt;But I think the inconsistency issue&apos;s root cause is the arguable behaviour that delete can mask puts that happened after the delete. A more intuitive and more reasonable behaviour is that a delete can only mask puts happened before it, and has no impact on puts happened after it. (This behaviour has nothing to do with another behaviour that timestamp determines which kv survives regarding version semantic.) And if we choose this adjusted behaviour, we can fix the inconsistency issue just with the help of mvcc, and collect the delete markers during major compact as before (no need to keep them forever to fix that inconsistency)&lt;/p&gt;

&lt;p&gt;A obvious, and ridiculous drawback of the behaviour that delete can mask puts that happened after the delete is that when an end user puts a kv, gets success response but it turns out that he can&apos;t read out that kv just because someone(maybe this someone is himself, but he can&apos;t realize this) ever made a delete that can mask this kv...this sounds really uncanny and weird.&lt;/p&gt;

&lt;p&gt;Turns back to scenarios that timestamp is used as another ordinary dimension without time semantic, in those cases we declare max(int) for the versions, and in that scheme timestamp isn&apos;t used to control version count but as an ordinary dimension to locate a cell. And each cell has a single version. So no problem.&lt;/p&gt;

&lt;p&gt;I agree we can introduce a config knob to enable the new behaviour.&lt;/p&gt;</comment>
                            <comment id="13680676" author="stack" created="Tue, 11 Jun 2013 21:04:53 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=fenghh&quot; class=&quot;user-hover&quot; rel=&quot;fenghh&quot;&gt;Honghua Feng&lt;/a&gt; On keeping deleted cells, it is an option I believe.  See &lt;a href=&quot;http://hbase.apache.org/book.html#cf.keep.deleted&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hbase.apache.org/book.html#cf.keep.deleted&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=fenghh&quot; class=&quot;user-hover&quot; rel=&quot;fenghh&quot;&gt;Honghua Feng&lt;/a&gt; Agree that the way delete works is uncanny where we could a put after a delete will go unseen.&lt;/p&gt;

&lt;p&gt;Thank you for looking into this.&lt;/p&gt;

&lt;p&gt;You are using mvcc when rather it should be sequenceid that you should be using?  Is that so?  mvcc is used cloaking memstore state doing a reveal only after all that makes up a transaction has been written across the row.  sequenceid is given when we add something to the WAL and it used ensuring ordering when doing WAL replays.&lt;/p&gt;</comment>
                            <comment id="13680744" author="sershe" created="Tue, 11 Jun 2013 22:01:12 +0000"  >&lt;blockquote&gt;&lt;p&gt;But I think the inconsistency issue&apos;s root cause is the arguable behaviour that delete can mask puts that happened after the delete. A more intuitive and more reasonable behaviour is that a delete can only mask puts happened before it, and has no impact on puts happened after it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This would be inconsistent with puts happening after puts being masked by earlier puts, depending on timestamp; as in my example above. Timestamp&apos;s express purpose is the version, by default if you don&apos;t set it, it will be taken from server time. If you are setting explicit timestamps, you are explicitly telling HBase that it should withhold judgement about versions because you know what happens logically before and after in your system. If you are using timestamp otherwise for some convenience, you are misusing it. &lt;br/&gt;
If this version semantic is removed, timestamp becomes simply a long tucked unto a KeyValue and should be removed, after all, we don&apos;t have a string or a boolean also added to KeyValue so that people could use them for their purposes. HBase already has columns and column families to do that. Timestamp has very explicit semantics and purpose right now. If you want time-based behavior then don&apos;t set timestamps and HBase will use time-based behavior.&lt;/p&gt;</comment>
                            <comment id="13680750" author="sershe" created="Tue, 11 Jun 2013 22:08:27 +0000"  >&lt;p&gt;(columns, or part of rowkey, as the case seems to be from your description)&lt;/p&gt;</comment>
                            <comment id="13681200" author="fenghh" created="Wed, 12 Jun 2013 13:08:19 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;&lt;br/&gt;
1. I also agree keeping deleted cells forever(even during major compact) can fix the inconsistency in the scenario I mentioned before. But that treatment will make the HFile size continuously grow without shrinking by collecting deleted cells and delete flags. This is an obvious drawback by keeping deleted cells(together with delete flags) which is not desirable by many users.&lt;br/&gt;
2. The behaviour &quot;delete can mask puts that happened after the delete&quot; is unacceptable for many users. When a user puts a kv to HBase, his intention is to ADD that kv to HBase and definitely he want to be able to retrieve that kv back using a Get/Scan operation without regard to whether or not there is a delete ever occurred. Why current behaviour is unacceptable for two reasons: a&amp;gt; When a user puts a kv, receives success response, and fails to read it out, he&apos;ll be confused why and it&apos;s hard for him to realize that the reason is someone or himself ever wrote a delete before; b&amp;gt; If delete can mask puts happened after that delete, this means once a delete is written to HBase(till it&apos;s collected by major compact), it can block that kv be added back to HBase again forever(by semantic) even though that kv can be added back to HBase successfully using &apos;put&apos; operation(by syntactic)&lt;br/&gt;
3. Yes, my fix is really to adjust the behaviour &quot;delete can mask puts that happened after the delete&quot; to the one that &quot;delete can only mask puts that happened before(or equal) the delete&quot;. With this behaviour adjustment the inconsistency caused by major compact doesn&apos;t appear again.&lt;br/&gt;
4. My fix is using mvcc together with timestamp to determine whether a delete can mask a put. This treatment doesn&apos;t break the original delete semantic defined by timestamp alone, but enforced with mvcc that define the real ordering of time-point that operations occur(timestamp can&apos;t). Why I don&apos;t use sequence-id: a&amp;gt; when flushed/compacted to HFile, sequence-id doesn&apos;t accompany kv any longer, but mvcc does; if we use seq-id, we can&apos;t handle kv in hfile for this purpose; b&amp;gt; Yes the seq-id defines persistence ordering of kv and the mvcc defines visibility ordering of kv, and they can interleave for two kvs, but it doesn&apos;t hurt the correctness of our adjustment behaviour in that when seq-id advances user can&apos;t see(read) that kv until its mvcc advances. visibility occurs after persistence(mvcc is after seq-id). seq-id is background implementation detail and user isn&apos;t aware of it while mvcc impacts data visibility and user is aware of it.&lt;/p&gt;</comment>
                            <comment id="13681204" author="fenghh" created="Wed, 12 Jun 2013 13:17:53 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sershe&quot; class=&quot;user-hover&quot; rel=&quot;sershe&quot;&gt;Sergey Shelukhin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This fix is not about timestamp as a role to control version, but whether the behaviour &apos;delete can mask puts that happened after the delete&quot; is reasonable/acceptable. I totally agree with you that timestamp is the only criterion to define/control version semantic, and this isn&apos;t broken by my fix. You can get what I mean by my above comment to Stack or by review and understand my patch. Thanks a lot&lt;/p&gt;</comment>
                            <comment id="13681333" author="apurtell" created="Wed, 12 Jun 2013 15:37:01 +0000"  >&lt;p&gt;Reopening. There&apos;s discussion continuing and a reasonable defense of the proposal. &lt;/p&gt;</comment>
                            <comment id="13681338" author="apurtell" created="Wed, 12 Jun 2013 15:41:45 +0000"  >&lt;p&gt;Not debating the merits at this time. I did change this to be an improvement, since this proposes changing behavior that the dev community has consensus on being acceptable (Feng disagrees), with a configuration toggle, if I read the above discussion correctly.&lt;/p&gt;</comment>
                            <comment id="13684091" author="lhofhansl" created="Sat, 15 Jun 2013 06:32:47 +0000"  >&lt;p&gt;The timestamp is part of the schema. A Put is masked by a newer delete. If we did not have that as-of-time queries would be broken and we would break the idempotent nature of operations in HBase.&lt;/p&gt;

&lt;p&gt;We have two &quot;happened-before&quot; relationships:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;the one defined by the timestamps&lt;/li&gt;
	&lt;li&gt;the one corresponding to the actual time when an operation hits a region server&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;The two only represent different relationship if client set timestamp do not represent the actual chronological order of things.&lt;/p&gt;

&lt;p&gt;HBase allows you to set the timestamps to influence the logical order in which things (are declared to have) happened.&lt;/p&gt;

&lt;p&gt;If you do not want strange behavior do not date Deletes into the future and Puts into the past. Period.&lt;/p&gt;

&lt;p&gt;-1 from me, unless there&apos;s more reasoning as why we need to break these nice properties of HBase.&lt;/p&gt;

&lt;p&gt;I&apos;d much rather introduce a config option for a Table or ColumnFamily that simply disallows client set timestamps. That way all these problems go away in nice fashion.&lt;/p&gt;</comment>
                            <comment id="13685655" author="fenghh" created="Mon, 17 Jun 2013 15:42:55 +0000"  >&lt;p&gt;Thanks guys for your feedback: &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=apurtell&quot; class=&quot;user-hover&quot; rel=&quot;apurtell&quot;&gt;Andrew Purtell&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sershe&quot; class=&quot;user-hover&quot; rel=&quot;sershe&quot;&gt;Sergey Shelukhin&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I summarize issues/proposals as below:&lt;/p&gt;

&lt;p&gt;A). We all agree this IS a bug:&lt;br/&gt;
  1&amp;gt; put a kv (timestamp = T0), and flush;&lt;br/&gt;
  2&amp;gt; delete that kv using a DeleteColumn type kv with timestamp T0 (or any timestamp &amp;gt;= T0), and flush;&lt;br/&gt;
  3&amp;gt; a major compact occurs &lt;span class=&quot;error&quot;&gt;&amp;#91;or not&amp;#93;&lt;/span&gt;;&lt;br/&gt;
  4&amp;gt; put that kv again (timestamp = T0);&lt;br/&gt;
  5&amp;gt; read that kv;&lt;/p&gt;

&lt;p&gt;  a) if a major compact occurs at step 3&amp;gt;, then step 5&amp;gt; will get the put written at step 4&amp;gt;&lt;br/&gt;
  b) if no major compact occurs at step 3&amp;gt;, then step 5&amp;gt; get nothing&lt;/p&gt;

&lt;p&gt;B). &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt; proposes to keep all deleted cells. This can be achieved either by turning on the KeepDeletedCells for ColumnFamilies or by degenerating major-compact to minor-compact (I guess you mean the former one). But these two options both result in a bigger data size than expectation.&lt;/p&gt;

&lt;p&gt;C). &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt; suggests to introduce a config for a Table/CF to disallow client to set timestamps when put. As a config, it means client still can create tables/CFs that allow him to explicitly set timestamps, and for these tables/CFs, bug of A) still exists.&lt;/p&gt;

&lt;p&gt;D). As &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt; said, timestamp is part of the Schema, it&apos;s visible to and can be set by client, hence it can be exploited by client for more general usage. For &apos;general&apos; I mean it&apos;s not limited for only &apos;time&apos; semantic, but as an ordinary dimension of a cell&apos;s coordinate. Such treatment can lead to many innovative schema design to address more complicated real-world problems. &lt;/p&gt;

&lt;p&gt;  Facebook uses msg-id as timestamp in their message search index CF. When using timestamp as an ordinary dimension of a cell&apos;s coordinate, that cell naturally has only one &apos;version&apos; in the app context, and the CF usually to set the MaxVersions in HBase context to the max-size for accommodate as many different cells as possible. The client who uses timestamp as such general usage takes care of all the subtlety derived from this semantic change.&lt;/p&gt;

&lt;p&gt;  Facebook&apos;s design details can be referred to in book &apos;HBase The Definitive Guide&apos; - Chapter 9 Advanced Usage - Search Integration (page 374) or blog: &lt;a href=&quot;http://www.facebook.com/notes/facebook-engineering/inside-facebook-messages-application-server/10150162742108920&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.facebook.com/notes/facebook-engineering/inside-facebook-messages-application-server/10150162742108920&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;  Disabling client set timestamps or limiting timestamp only with &apos;time&apos; semantic will prohibit such innovative usage of timestamp. As said, a good language/platform/product encourages and enables innovative extension/usage out of the original designer&apos;s imagination. We do expect HBase to be such a good platform/product, right?&lt;/p&gt;

&lt;p&gt;E). &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=apurtell&quot; class=&quot;user-hover&quot; rel=&quot;apurtell&quot;&gt;Andrew Purtell&lt;/a&gt; said: &quot;This section of the book describes expected behavior. This is not a bug.&quot;&lt;/p&gt;

&lt;p&gt;  I disagree. That section&apos;s title explicitly says it&apos;s &apos;current limitations&apos; and explains in details why. It is by nature not an acceptable behaviour. It&apos;s counter-common-sense and counter-intuition. It now seems an &apos;expected behaviour&apos; JUST because it exists from the very beginning.&lt;/p&gt;

&lt;p&gt;F). &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt; said: &quot;HBase allows you to set the timestamps to influence the logical order in which things (are declared to have) happened. If you do not want strange behavior do not date Deletes into the future and Puts into the past. Period.&quot;&lt;/p&gt;

&lt;p&gt;  As bug in A), strange behaviour occurs even dating Deletes/Puts into the same timestamp, but one the future and the other the past. (We allow setting timestamp, and we do set it) We get strange(buggy) behaviour when we &quot;put - delete - put - get&quot; that very same KV with that same timestamp. Isn&apos;t it weird?&lt;/p&gt;

&lt;p&gt;G). &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt; said: &quot;If we did not have that as-of-time queries would be broken and we would break the idempotent nature of operations in HBase&quot;&lt;/p&gt;

&lt;p&gt;  For &quot;idempotent nature of operations in HBase&quot;, my understanding is a series of Puts(or Deletes) for a same cell(exactly the same coordinate:value) will result in an eventually same result. But it&apos;s expected to be broken if interleaved by Deletes(Deletes interleaved by Puts). Such idempotent nature break is acceptable according to my opinion.&lt;br/&gt;
  Even we don&apos;t change the behaviour &apos;Deletes can mask puts that happen after the delete&quot;, scenario in A) still breaks the idempotent nature: we put that same cell multiple times, but the results can turn out to be different when interleaved by Deletes (with the effect of major compact together).&lt;/p&gt;

&lt;p&gt;H). Since HBase is modeled after BigTable, so it makes sense we align the Delete behaviour here with BigTable, right?&lt;/p&gt;

&lt;p&gt;I). At last, I think we need to have an open mind for this issue, not just suggesting a workaround at the cost of HBase&apos;s inherent flexibility.&lt;/p&gt;</comment>
                            <comment id="13685663" author="apurtell" created="Mon, 17 Jun 2013 15:53:46 +0000"  >&lt;blockquote&gt;&lt;p&gt;A). We all agree this IS a bug:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think that is a correct statement.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;&lt;p&gt;It is by nature not an acceptable behaviour. It&apos;s counter-common-sense and counter-intuition. It now seems an &apos;expected behaviour&apos; JUST because it exists from the very beginning.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Your point of view is well argued &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=fenghh&quot; class=&quot;user-hover&quot; rel=&quot;fenghh&quot;&gt;Honghua Feng&lt;/a&gt; but this assertion is your opinion. Strong opinions are fine by me, but they sometimes don&apos;t help with building consensus for change. For example, you exclude this possibility for moving forward to an outcome that would address your concerns (at least in part):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C). Lars Hofhansl suggests to introduce a config for a Table/CF to disallow client to set timestamps when put. As a config, it means client still can create tables/CFs that allow him to explicitly set timestamps, and for these tables/CFs, bug of A) still exists.&lt;/p&gt;&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;&lt;p&gt;Disabling client set timestamps or limiting timestamp only with &apos;time&apos; semantic will prohibit such innovative usage of timestamp.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This may be the crux of the distance between your position and some of the feedback here. As &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sershe&quot; class=&quot;user-hover&quot; rel=&quot;sershe&quot;&gt;Sergey Shelukhin&lt;/a&gt; summarized quite well:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you are setting explicit timestamps, you are explicitly telling HBase that it should withhold judgement about versions because you know what happens logically before and after in your system. If you are using timestamp otherwise for some convenience, you are misusing it. &lt;/p&gt;

&lt;p&gt;If this version semantic is removed, timestamp becomes simply a long tucked unto a KeyValue and should be removed, after all, we don&apos;t have a string or a boolean also added to KeyValue so that people could use them for their purposes. HBase already has columns and column families to do that. Timestamp has very explicit semantics and purpose right now. If you want time-based behavior then don&apos;t set timestamps and HBase will use time-based behavior.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Can you say a bit more about what exactly your clients are doing with timestamps?&lt;/p&gt;</comment>
                            <comment id="13685699" author="fenghh" created="Mon, 17 Jun 2013 16:46:00 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=apurtell&quot; class=&quot;user-hover&quot; rel=&quot;apurtell&quot;&gt;Andrew Purtell&lt;/a&gt; Sorry if I offend. And thanks for your patient comment again. All we need here is to clarify the issue and make HBase better.&lt;/p&gt;

&lt;p&gt;I don&apos;t think that is a correct statement.&lt;br/&gt;
==&amp;gt; You mean the behaviour of A) is correct and acceptable?&lt;/p&gt;

&lt;p&gt;Can you say a bit more about what exactly your clients are doing with timestamps?&lt;br/&gt;
==&amp;gt; We have a similar usage of timestamp as Facebook, I provide the link/reference describing how facebook use timestamp for their message search index. In short, msg-id is used as timestamp to provide a reverse-link for the term/token appeared in a msg to find its original msg. When a msg is deleted, all the kv of its related term/token will be deleted as well, and when user revoke the deleted msg from the deleted-folder, the term/token kvs will be inserted again, but with the current delete behaviour the re-inserting of term/token kvs for revoked msg can be inconsistent, the same scenario as A)&lt;/p&gt;

&lt;p&gt;For &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sershe&quot; class=&quot;user-hover&quot; rel=&quot;sershe&quot;&gt;Sergey Shelukhin&lt;/a&gt;&apos;s explanation:&lt;/p&gt;

&lt;p&gt;&quot;If you are setting explicit timestamps, you are explicitly telling HBase that it should withhold judgement about versions because you know what happens logically before and after in your system. If you are using timestamp otherwise for some convenience, you are misusing it.&quot;&lt;/p&gt;

&lt;p&gt;==&amp;gt; we set explicit timestamps and we don&apos;t want judgement about versions(refer to below description of our scenarios). but the behaviour &apos;Deletes mask puts that happen after the delete&apos; put us in a difficult situation.&lt;br/&gt;
  Actually if we set explicit timestamp, the timestamp can&apos;t be the &apos;current&apos; time when the put hit RS, so this timestamp can seldom has &apos;time&apos; semantic in this sense since it&apos;s inaccurate for time ordering. so &quot;If you are using timestamp otherwise for some convenience, you are misusing it&quot; almost equals to &quot;setting explicit timestamps is misusing it&quot;?&lt;/p&gt;

&lt;p&gt;&quot;If this version semantic is removed, timestamp becomes simply a long tucked unto a KeyValue and should be removed, after all, we don&apos;t have a string or a boolean also added to KeyValue so that people could use them for their purposes. HBase already has columns and column families to do that. Timestamp has very explicit semantics and purpose right now. If you want time-based behavior then don&apos;t set timestamps and HBase will use time-based behavior.&quot;&lt;/p&gt;

&lt;p&gt;==&amp;gt; another &apos;long&apos; tucked onto a KeyValue is not unneccessary, even HBase already has columns and column-families. In facebook message search index scenarios, using msg-id as timestamp is an innovative way to build the reverse lookup index atomically by leverage the row-transaction. Otherwise the reverse lookup index can&apos;t be built atomically since the msg and the msg-search-index of a given user can span multiple rows.&lt;/p&gt;</comment>
                            <comment id="13686302" author="fenghh" created="Tue, 18 Jun 2013 02:16:03 +0000"  >&lt;p&gt;Another some drawbacks for the config of disallowing client set timestamps explicitly from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;  1). No easy way to delete a specific version except the latest version: Client need to read all versions out, get the timestamp of the version he want to delete, then issue the deleteColumn(); The reason is client doesn&apos;t know the exact timestamps of each version when Put&lt;/p&gt;

&lt;p&gt;  2). Performance is poor for deleting a version (rather than all versions of that cell): All delete for version need to read the timestamp before deleting, the deleteColumn() without timestamp for deleting the latest version also need to read the latest timestamp in RS, though transparent to the client&lt;/p&gt;

&lt;p&gt;  3). If put without setting timestamp, multiple puts for the same KV (in perspective of the client it&apos;s the same) will get different timestamps when hitting RS and actually are not a same KV in perspective of HBase, they occupy multiple versions which knock out earlier &apos;real&apos; versions; different times of Puts of a &apos;same&apos; KV(without timestamp) from client can result in different &apos;version list&apos; of that cell in HBase. This is not idempotent in the strict sense.&lt;/p&gt;

&lt;p&gt;  4). Even disallowing explict set timestamp, strange behavior can still arise due to clock skew or timestamp&apos;s time granularity(Puts/Deletes can have a same timestamp in milli-second). &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2256&quot; title=&quot;Delete row, followed quickly to put of the same row will sometimes fail.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2256&quot;&gt;HBASE-2256&lt;/a&gt; is an example of the latter.&lt;/p&gt;</comment>
                            <comment id="13686327" author="fenghh" created="Tue, 18 Jun 2013 02:55:33 +0000"  >&lt;p&gt;  On the contrary, personally I think allowing client explicitly set timestamp is giving client the ability to EXACTLY control the versions semantic, without the impact from clock skew or &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2256&quot; title=&quot;Delete row, followed quickly to put of the same row will sometimes fail.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2256&quot;&gt;HBASE-2256&lt;/a&gt;. By explicitly setting timestmaps for each KVs he put, client know exactly at any time point which versions will survive without worrying about exceptional cases such as clock skew or &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2256&quot; title=&quot;Delete row, followed quickly to put of the same row will sometimes fail.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2256&quot;&gt;HBASE-2256&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;  Below are &apos;acceptable&apos; behaviors regarding delete/version from my point of view.&lt;/p&gt;

&lt;p&gt;  1&amp;gt; version is determined by &apos;timestamp&apos; only(same as current semantic), HBase(we) determines which version survive (in Scan/Compact etc.) only by timestamp.&lt;/p&gt;

&lt;p&gt;  2&amp;gt; delete can only mask puts happened before it(&apos;before&apos; here is measured by vector clock, mvcc in HBase, not by timestamp). All puts happened before a delete are candidates to be masked by that delete, but whether a candidate put will be actually masked by that delete further depends on whether the candidate put&apos;s timestamp is smaller than or equal to delete&apos;s timestamp. &lt;/p&gt;

&lt;p&gt;  So delete&apos;s semantic is: to delete an existing exact version (deleteColumn) or all existing smaller versions (deleteColumns / deleteFamily)&lt;/p&gt;

&lt;p&gt;  These two version/delete semantics/behaviors have no conflicts.&lt;/p&gt;</comment>
                            <comment id="13686862" author="fenghh" created="Tue, 18 Jun 2013 16:02:45 +0000"  >&lt;p&gt;Another benefit from behaviour &quot;delete can&apos;t mask puts happened after it&quot;(in essence mvcc also participates in delete handling): the &apos;delete latest version&apos;(deleteColumn() without timestamp) can have better performance by removing the read operation in RS which is to get the timestamp of the latest version and set to the delete.&lt;/p&gt;

&lt;p&gt;Below is the update process for &apos;delete latest version&apos; (under &apos;delete can&apos;t mask puts happened after it&apos; behaviour):&lt;/p&gt;

&lt;p&gt;  1. deleteColumn() (without timestamp) issued by client, its timestamp is set to an &apos;invalid&apos; value (0/-1 is a good candidate) to indicate &apos;delete the latest version&apos;. RS just puts this Delete type kv as other type deletes without read operation.&lt;/p&gt;

&lt;p&gt;  2. when Get/Scan, by timestamp=0/-1 we know this delete is to delete the latest version and check the kv it sees. And we know the first kv with mvcc &amp;lt; &apos;mvcc of this delete&apos; is the &apos;latest&apos; version when the delete enters RS. After delete(mask) this first kv (with mvcc checked) this &apos;delete latest version&apos; delete also need to be removed from the ScanDeleteTracker.&lt;/p&gt;

&lt;p&gt;  That&apos;s all.&lt;/p&gt;

&lt;p&gt;  Then why we can&apos;t achieve such light-weight(without read) &apos;delete latest version&apos; delete? The root cause is the &apos;delete can mask puts that happen after it&apos; behaviour, which doesn&apos;t use mvcc in delete handling.&lt;/p&gt;

&lt;p&gt;  When issuing &apos;delete latest version&apos;(deleteColumn() without timestamp), the real semantic is &apos;to delete the latest one of all the currently EXISTING versions&apos;, the EXISTING means the one happened BEFORE the delete enters RS, and BEFORE is a concept of operation happening order (indicated by mvcc), which can&apos;t be represented by timestamp.&lt;/p&gt;

&lt;p&gt;  Then why we can&apos;t handle &apos;delete latest version&apos; without a read, as above process? Because newer version can be put which has the bigger timestamp (later than the &apos;current&apos; latest when delete enters RS, by timestamp), and by behaviour &apos;delete can mask puts happened after delete&apos;(its essence is to determine whether a kv masked by a delete only by comparing their timestamps) a &apos;delete latest version&apos; delete can&apos;t tell whether the first version it sees is the latest version when itself hit RS (in fact it can use mvcc to get this information, but it doesn&apos;t)&lt;/p&gt;

&lt;p&gt;  Certainly we can use mvcc only for &apos;delete latest version&apos; to get the (remarkable) performance gain by removing the read operation, but it sounds inconsistent in that we handle deletes internally in different ways (one use mvcc, other don&apos;t)&lt;/p&gt;</comment>
                            <comment id="13687222" author="sershe" created="Tue, 18 Jun 2013 21:30:54 +0000"  >&lt;p&gt;Sorry for long time taken, I was out.&lt;/p&gt;

&lt;p&gt;I think we agree that influence of major compaction is a glitch. Technically you don&apos;t have to store all delete markers to prevent it, only latest for each key.&lt;br/&gt;
We can add a timeout for when delete markers are dropped; if that is set to high enough value, then you&apos;d drop them after a long time.&lt;br/&gt;
It&apos;s similar for TTL for deleted cells now, which allow you to do point-in-time scans on old data after it is deleted, but not forever, only for approx. column family TTL.&lt;/p&gt;

&lt;p&gt;For semantics:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;2. The behaviour &quot;delete can mask puts that happened after the delete&quot; is unacceptable for many users. When a user puts a kv to HBase, his intention is to ADD that kv to HBase and definitely he want to be able to retrieve that kv back using a Get/Scan operation without regard to whether or not there is a delete ever occurred. Why current behaviour is unacceptable for two reasons: a&amp;gt; When a user puts a kv, receives success response, and fails to read it out, he&apos;ll be confused why and it&apos;s hard for him to realize that the reason is someone or himself ever wrote a delete before; b&amp;gt; If delete can mask puts happened after that delete, this means once a delete is written to HBase(till it&apos;s collected by major compact), it can block that kv be added back to HBase again forever(by semantic) even though that kv can be added back to HBase successfully using &apos;put&apos; operation(by syntactic)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;But do you agree for this behavior for puts?&lt;br/&gt;
If I put row1,cf:c,ts=5,foo; and before, someone put row1,cf:c,ts=10,bar, when I read I will get &quot;bar&quot;, not &quot;foo&quot;.&lt;br/&gt;
It&apos;s just the same with deletes. One difference with deletes is that deletes always kill puts with the same ts.&lt;br/&gt;
I could see conflicts between deletes and puts with exact same ts be resolved by time instead, that would make sense.&lt;br/&gt;
But if TS is different semantics should hold, and glitches fixed separately &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;3. Yes, my fix is really to adjust the behaviour &quot;delete can mask puts that happened after the delete&quot; to the one that &quot;delete can only mask puts that happened before(or equal) the delete&quot;. With this behaviour adjustment the inconsistency caused by major compact doesn&apos;t appear again&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;It can still appear, right? If I put into memstore with ts=2, while the delete record is there with ts=3, delete record will hide the put; but if major compaction happens delete record disappears.&lt;br/&gt;
Also if I put ts=2 after major compaction it will be visible, which is also inconsistent, so one still needs to keep the latest marker forever to avoid that.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Actually if we set explicit timestamp, the timestamp can&apos;t be the &apos;current&apos; time when the put hit RS, so this timestamp can seldom has &apos;time&apos; semantic in this sense since it&apos;s inaccurate for time ordering. so &quot;If you are using timestamp otherwise for some convenience, you are misusing it&quot; almost equals to &quot;setting explicit timestamps is misusing it&quot;?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Not really; the appropriate usage of timestamp is just any kind of versioning that overrides time based versioning.&lt;br/&gt;
For example, if you are doing batch processing of some data, or loading logs etc., you could set source time as a timestamp, instead of load time.&lt;br/&gt;
Or maybe the data has some incremental event IDs that the source creates other than from time, you could use those.&lt;br/&gt;
Or ts could come from some external time oracle used for transactions or whatever.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;when Get/Scan, by timestamp=0/-1 we know this delete is to delete the latest version and check the kv it sees. And we know the first kv with mvcc &amp;lt; &apos;mvcc of this delete&apos; is the &apos;latest&apos; version when the delete enters RS. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This makes semantics of things inconsistent. Version for puts still uses timestamps but for deletes, MVCC is used, and latest MVCC might delete some put that is not latest by TS.&lt;/p&gt;

&lt;p&gt;In summary, the problem can be resolved as follows as far as I see.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2). Performance is poor for deleting a version (rather than all versions of that cell): All delete for version need to read the timestamp before deleting, the deleteColumn() without timestamp for deleting the latest version also need to read the latest timestamp in RS, though transparent to the client&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;1) Have API to delete specific version, and also delete latest version (by ts); the latter will find latest timestamp inside RS, just like increment/append/checkAndPut working on existing data.&lt;br/&gt;
2) Make sure delete markers and puts with exact same timestamp are resolved by mvcc or seqNum instead of delete always winning.&lt;/p&gt;

&lt;p&gt;The major compaction issue is mostly orthogonal to that and could be solved by TTL to keep delete markers (latest per row).&lt;/p&gt;</comment>
                            <comment id="13687271" author="lhofhansl" created="Tue, 18 Jun 2013 22:11:25 +0000"  >&lt;blockquote&gt;&lt;p&gt;We can add a timeout for when delete markers are dropped&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We have that: &quot;hbase.hstore.time.to.purge.deletes&quot;. That was added for replication, which can issue Deletes out of order.&lt;/p&gt;

&lt;p&gt;Also the patch has this in it:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-              &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (kv.getMemstoreTS() &amp;lt;= smallestReadPoint) {
-                kv.setMemstoreTS(0);
-              }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This requires to actually store the memstoreTS of all KV in all HFiles (currently except for the newest files the memstoreTS is dropped from the HFiles, because it can be assumed 0).&lt;/p&gt;</comment>
                            <comment id="13687724" author="yehangjun" created="Wed, 19 Jun 2013 07:29:11 +0000"  >&lt;p&gt;For Sergey Shelukhin&apos;s example:&lt;/p&gt;

&lt;p&gt; But do you agree for this behavior for puts?&lt;br/&gt;
 If I put row1,cf:c,ts=5,foo; and before, someone put row1,cf:c,ts=10,bar, when I read I will get &quot;bar&quot;, not &quot;foo&quot;.&lt;br/&gt;
 It&apos;s just the same with deletes.&lt;/p&gt;


&lt;p&gt;Actually that&apos;s the major reason why I personally think the current behavior of delete is confusing for users.&lt;br/&gt;
If I write a new value and want to make sure it appears (mask all previously written values ), I would firstly delete row1,cf:c,ts&amp;lt;=MAX_TIMESTAMP, and then put row1,cf:c,ts=5,foo.&lt;/p&gt;

&lt;p&gt;It might happen when people load data into hbase table (maybe from another table and user needs to keep original timestamps).&lt;br/&gt;
Possibly some old data have been already there and should be abandoned.&lt;br/&gt;
Instead of deleting the whole table (sometimes it&apos;s impossible), people might want to &quot;clear&quot; a cell before writing to it.&lt;br/&gt;
Issuing a delete with ts&amp;lt;=MAX_TIMESTAMP might be a intuitive way to resort to.&lt;/p&gt;

&lt;p&gt;But under current implementation, issuing such a delete (with ts&amp;lt;=MAX_TIMESTAMP) would mask all future puts (until major compaction).&lt;/p&gt;

&lt;p&gt;I think it would very nice if hbase could provide such a way to clear all old data of a cell easily.&lt;br/&gt;
Sounds limiting the semantics of delete to only mask previous puts is a feasible approach.&lt;/p&gt;</comment>
                            <comment id="13688227" author="sershe" created="Wed, 19 Jun 2013 18:00:53 +0000"  >&lt;blockquote&gt;&lt;p&gt;I would firstly delete row1,cf:c,ts&amp;lt;=MAX_TIMESTAMP, and then put row1,cf:c,ts=5,foo.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;As I said, this misuses timestamps as they stand. It uses timestamp and clock/mvcc at the same time... if you want later (in time) put to override earlier (in time) delete, then don&apos;t use explicit timestamps, and store the requisite value in a column or as part of row key. Allowing puts to be resolved one way and deletes the other way in the same table makes for confusing and inconsistent semantics for timestamps imo.&lt;br/&gt;
At this point we seem to be going in circles, my 2c are -0 on this feature.&lt;/p&gt;</comment>
                            <comment id="13688448" author="lhofhansl" created="Wed, 19 Jun 2013 20:58:58 +0000"  >&lt;p&gt;I already -1&apos;d this.&lt;br/&gt;
Puts and Deletes are timestamped. That timestamp defines a happened-before realionship.&lt;br/&gt;
With KEEP_DELETED_CELLS enabled for CF this allows for nice as-of-time queries as well as idempotent operations. We should not break that.&lt;/p&gt;</comment>
                            <comment id="13688845" author="yehangjun" created="Thu, 20 Jun 2013 03:56:30 +0000"  >&lt;p&gt;I got Sergey and Lars&apos; point...&lt;/p&gt;

&lt;p&gt;My personal point is tiemstamp is a logical version, which is often the same as the &quot;happened-before&quot; relationship inside hbase, but not necessarily have to be. User could assign any semantics to it since it has been exposed and user could set it explicitly.&lt;/p&gt;

&lt;p&gt;For example, Percolator/Megastore/Spanner used it to store transaction id.&lt;br/&gt;
A web search repository might use it to store the time when the page was fetched, instead of the time when the page was inserted into the repository (they are not necessarily the same one). Here the timestamp is also a kind of &quot;happened-before&quot; relationship, but it&apos;s defined &quot;outside&quot; the hbase, not &quot;inside&quot;.&lt;/p&gt;

&lt;p&gt;Conceptually decoupling the timestamp and the &quot;happened-before&quot; relationship inside hbase should give users more flexibility to decide how to use it.&lt;/p&gt;

&lt;p&gt;Lars said changing the semantics would break something, do you mean some users rely on the KEEP_DELETED_CELLS and want the feature &quot;Delete can mask puts that happen after the delete&quot;?&lt;/p&gt;

&lt;p&gt;If so, how about we introduce a new config to control whether &quot;Delete can mask puts that happen after the delete&quot; or not?&lt;/p&gt;

&lt;p&gt;The current behavior is problematic for our clients and they really don&apos;t want the delete masks future puts. Possibly some others have similar issue and we could let users choose what behavior they want.&lt;/p&gt;</comment>
                            <comment id="13689043" author="lhofhansl" created="Thu, 20 Jun 2013 09:19:23 +0000"  >&lt;p&gt;If your clients use the timestamp not as a timestamp, can they add whatever their values are to the rowkey?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;do you mean some users rely on the KEEP_DELETED_CELLS and want the feature &quot;Delete can mask puts that happen after the delete&quot;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Exactly. When KEEP_DELETED_CELLS is enabled you can do true time range queries in HBase. For example you get the exact state of your data as of last week, or an hour ago, etc; even when data was deleted via delete markers.&lt;/p&gt;

&lt;p&gt;I think adding a global or maybe column family config option to change this behavior is fine, as long as the code does not get too convoluted. In that case we need to make sure then that all other HBase features such as replication, WAL replay, as-of-time queries, bulk loading HFiles, etc still work as expected. Also need to check that the HFile metadata is still correct as the timerange of the included KVs is used to exclude HFile from scans in some situations (if if you put a Delete marker at MAX_LONG this HFile would not be excluded for queries on new data, unless we add some other special logic).&lt;/p&gt;

&lt;p&gt;Even in that case I&apos;d still be -0 on this (but I would no longer veto it with a -1) - this looks like a very app specific use case to me.&lt;br/&gt;
You would need to find one or two committers who are ready to +1 this feature and patch to get it committed.&lt;/p&gt;</comment>
                            <comment id="13689098" author="yehangjun" created="Thu, 20 Jun 2013 10:10:56 +0000"  >&lt;p&gt;Nice to know adding a config is acceptable at least!&lt;br/&gt;
You pointed out many features that we need to be careful not to break, we should do that as you suggested.&lt;/p&gt;

&lt;p&gt;Back to the feature of KEEP_DELETED_CELLS, my perception is even we disable &quot;Delete can mask puts that happen after the delete&quot; (whether by a config or by other ways), KEEP_DELETED_CELLS still works as you expect. Sounds they are basically independent features?&lt;/p&gt;</comment>
                            <comment id="13689160" author="fenghh" created="Thu, 20 Jun 2013 11:37:52 +0000"  >&lt;p&gt;I list some merits with behavior &apos;Delete can&apos;t mask puts that happen after the delete&apos;:&lt;/p&gt;

&lt;p&gt;1) Can avoid the inconsistency such as I mentioned above, with our patch, user can always read the put by 4&amp;gt;. It&apos;s more natural and intuitive:&lt;/p&gt;

&lt;p&gt;  1&amp;gt; put a kv (timestamp = T0), and flush;&lt;br/&gt;
  2&amp;gt; delete that kv using a DeleteColumn type kv with timestamp T0 (or any timestamp &amp;gt;= T0), and flush;&lt;br/&gt;
  3&amp;gt; a major compact occurs &lt;span class=&quot;error&quot;&gt;&amp;#91;or not&amp;#93;&lt;/span&gt;;&lt;br/&gt;
  4&amp;gt; put that kv again (timestamp = T0);&lt;br/&gt;
  5&amp;gt; read that kv;&lt;br/&gt;
  ===&amp;gt;&lt;br/&gt;
  a) if a major compact occurs at step 3&amp;gt;, then step 5&amp;gt; will get the put written at step 4&amp;gt;&lt;br/&gt;
  b) if no major compact occurs at step 3&amp;gt;, then step 5&amp;gt; get nothing&lt;/p&gt;

&lt;p&gt;2) Can provide strong guarantee for such operation: &quot;I don&apos;t know which/how-many versions in a cell, now I (by removing all existing ones) just want to put a new version into it and ensure only this new put in the cell regardless of the ts comparison with old existing ones&quot; (I think this operation/guarantee is useful in many scenarios). Current delete behavior can&apos;t provide such guarantee.&lt;/p&gt;

&lt;p&gt;3) &apos;delete latest version&apos;(deleteColumn() without ts) can be tuned to remove the read (latest version for its ts) during &apos;deleteColumn&apos;. Current delete behavior can&apos;t be tuned to remove the read operation during &apos;deleteColumn&apos;&lt;/p&gt;

&lt;p&gt;4) &apos;new put can&apos;t be masked (disappear) by old/existing delete&apos; itself is a merit for many use-cases / application since it&apos;s more natural and intuitive. I ever explained many times to different customers for the old semantics of version/delete and without exception all the first responses from them are &quot;weird... why so?&quot;&lt;/p&gt;

&lt;p&gt;Per my understanding, contrary to &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sershe&quot; class=&quot;user-hover&quot; rel=&quot;sershe&quot;&gt;Sergey Shelukhin&lt;/a&gt;, &apos;timestamp&apos; is just a long type to determine versions&apos; ordering using the rule of &apos;the bigger/later wins&apos;, and it happens the timestamp in &apos;time&apos; semantic is a long type and new put with its &apos;current&apos; timestamp has bigger timestamp, and in most cases new put versions knock out older ones. And for many use cases time-semantic for &apos;timestamp&apos; is enough for the real-world requirement, but by design it&apos;s not always the case, otherwise the timestamp won&apos;t be exposed for user to set it explicitly.&lt;/p&gt;

&lt;p&gt;In a word, as long as user knows &apos;timestamp&apos; is just only the dimension of long type to determine the version ordering using the rule &apos;the bigger wins&apos;, he can reason out the result of any operation sequences. In essence &apos;timestamp as a dimension for version ordering&apos; doesn&apos;t related to delete semantic.&lt;/p&gt;

&lt;p&gt;&amp;#8211; I know my understanding is arguable for many guys, since the old delete semantic and behavior has existed for so long and everybody has already taken it for granted (I mean no offence here)&lt;/p&gt;


&lt;p&gt;At last I also list the downside of proposed optional solutions I received:&lt;/p&gt;

&lt;p&gt;A&amp;gt; &apos;KEEP_DELETE_CELLS&apos; is definitely a nice feature, but many users don&apos;t need this feature (to time-travel or trace-back action history) and this feature prevent major-compact to shrink data-set by collecting.&lt;/p&gt;

&lt;p&gt;B&amp;gt; disallow user explicitly set timestamp, this treatment limits HBase&apos;s schema flexibility, and prohibit many innovative design such as facebook&apos;s message search index, and at last it can&apos;t guarantee unique timestamp hence can still lead to tricky / confusing behavior.&lt;/p&gt;</comment>
                            <comment id="13689435" author="lhofhansl" created="Thu, 20 Jun 2013 17:39:45 +0000"  >&lt;p&gt;KEEP_DELETED_CELLS would still work fine, but their main goal is to allow correct point-in-time-queries, which among others is important for consistent backups.&lt;/p&gt;

&lt;p&gt;Regarding all the points above. Let&apos;s please not go overboard. Now we&apos;re extending this to Puts as well, and are saying that a Put that hits the RegionServer later should be considered newer even if its TS is old, this opens another can of worms.&lt;/p&gt;

&lt;p&gt;It is unlikely that this will be changed as you have to a find committers to +1 this. All we got up to this points are a -1 unless it is configurable and a couple of -0s.&lt;/p&gt;</comment>
                            <comment id="13689509" author="apurtell" created="Thu, 20 Jun 2013 18:44:03 +0000"  >&lt;blockquote&gt;&lt;p&gt;It is unlikely that this will be changed as you have to a find committers to +1 this. All we got up to this points are a -1 unless it is configurable and a couple of -0s.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed, resolved as WONTFIX.&lt;/p&gt;

&lt;p&gt;Interested parties are encouraged to go to the followups &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8763&quot; title=&quot;Combine MVCC and SeqId&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8763&quot;&gt;&lt;del&gt;HBASE-8763&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8770&quot; title=&quot;deletes and puts with the same ts should be resolved according to mvcc/seqNum&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8770&quot;&gt;HBASE-8770&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13689717" author="sershe" created="Thu, 20 Jun 2013 21:45:38 +0000"  >&lt;p&gt;btw, HBase does support point version deletes as far as I see. So specific version can be deleted if desired. Should we add APIs to &quot;delete latest version&quot;? We can even add API to &quot;delete all existing versions&quot;, won&apos;t be very efficient with many versions (scan or get+bunch of deletes on server side), but it will work without changing internals&lt;/p&gt;</comment>
                            <comment id="13689935" author="fenghh" created="Fri, 21 Jun 2013 01:19:27 +0000"  >
&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt; Now we&apos;re extending this to Puts as well, and are saying that a Put that hits the RegionServer later should be considered newer even if its TS is old, this opens another can of worms&lt;/p&gt;

&lt;p&gt;  ===&amp;gt; Maybe you misunderstand me here, I never proposed &apos;a Put that hits the RegionServer later should be considered newer even if its TS is old&apos;. The sequence &apos;put T3, put T2, put T1&apos; (where T3&amp;gt;T2&amp;gt;T1) to a CF with max-version = 2 will result in (T3,T2) and T3 is the first version, though T1 is the last one hits RS, this is what I mean by &apos;timestamp is the only dimension which determines version ordering/survival by rule &apos;the bigger wins&apos;&apos;&lt;/p&gt;

&lt;p&gt;  ===&amp;gt; What I proposed is this (can via a config to provide customers the option if they want this behavior) : the delete masks (existing) puts with timestamps less than or equal to its (not changed); and customers can choose whether the delete can mask puts still not written to HBase (future puts) according their individual real-world application logic / requirement.&lt;/p&gt;


&lt;p&gt;  KEEP_DELETED_CELLS would still work fine, but their main goal is to allow correct point-in-time-queries, which among others is important for consistent backups&lt;/p&gt;

&lt;p&gt;  ===&amp;gt; KEEP_DELETED_CELLS indeed can prevent the inconsistency in the example scenario &apos;put - delete - (major-compact) - put - get&apos;, and it provides a consistent result of &apos;get nothing&apos;. But this result is also unacceptable for our customers since they expect the later &apos;put&apos; not masked by the earlier delete.&lt;/p&gt;</comment>
                            <comment id="13689938" author="fenghh" created="Fri, 21 Jun 2013 01:21:55 +0000"  >
&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=apurtell&quot; class=&quot;user-hover&quot; rel=&quot;apurtell&quot;&gt;Andrew Purtell&lt;/a&gt; / &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt;: Maybe I miss something here, is there -1 for providing config to the adjustment?&lt;/p&gt;</comment>
                            <comment id="13689947" author="fenghh" created="Fri, 21 Jun 2013 01:29:17 +0000"  >
&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sershe&quot; class=&quot;user-hover&quot; rel=&quot;sershe&quot;&gt;Sergey Shelukhin&lt;/a&gt; btw, HBase does support point version deletes as far as I see. So specific version can be deleted if desired. Should we add APIs to &quot;delete latest version&quot;? We can even add API to &quot;delete all existing versions&quot;, won&apos;t be very efficient with many versions (scan or get+bunch of deletes on server side), but it will work without changing internals&lt;/p&gt;

&lt;p&gt;  ===&amp;gt; Yes, I know what you mean. But what I mean is that the deleteColumn (without providing timestamp, AKA the &apos;delete latest version&apos;) is not efficient since it incurs a &apos;read&apos; in RS to get the timestamp of the latest version (and set it to the Delete type KV). This operation can be tuned by removing the &apos;read&apos; in RS. You can find the implementation detail in one of my above comments.&lt;/p&gt;</comment>
                            <comment id="13689962" author="sershe" created="Fri, 21 Jun 2013 01:54:00 +0000"  >&lt;p&gt;I don&apos;t think such a significant semantic change is worth gaining some perf in certain narrow scenarios. If you do it (delete latest/all versions) inside the regionserver, you don&apos;t pay cost of 2 rpcs; see checkAndPut for example, or increment - increment does get and put inside the server and is quite a viable API. &lt;br/&gt;
But as I said I&apos;m -0 not -1, esp. if it can be configured. So if some other people support it I am alright with implementation being there, with reasonable care for all the externalities (see Lars&apos; comment above), it can be done.&lt;/p&gt;</comment>
                            <comment id="13689975" author="fenghh" created="Fri, 21 Jun 2013 02:22:27 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sershe&quot; class=&quot;user-hover&quot; rel=&quot;sershe&quot;&gt;Sergey Shelukhin&lt;/a&gt; :&lt;/p&gt;

&lt;p&gt;It still need 10+ms, at best, for checkAndPut / increment when the KV read isn&apos;t in RS&apos;s block-cache and need access to HDFS, though this read in RS can save 2 rpcs. &lt;/p&gt;

&lt;p&gt;Actually two months ago one of our Xiaomi&apos;s internal customers gave up using checkAndPut since they can&apos;t afford the poor performance, though they did admit they love the atomicity checkAndPut provides.&lt;/p&gt;</comment>
                            <comment id="13690018" author="stack" created="Fri, 21 Jun 2013 04:37:16 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=andrew.purtell%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;andrew.purtell@gmail.com&quot;&gt;Andrew Purtell&lt;/a&gt; Mind if I reopen?  The lads are putting up a spirited fight and the args are quality?&lt;/p&gt;</comment>
                            <comment id="13690122" author="lhofhansl" created="Fri, 21 Jun 2013 08:20:50 +0000"  >&lt;p&gt;Who is going to sponsor this change with a +1? Doesn&apos;t look like anybody will.&lt;br/&gt;
We&apos;re going to increase HFile sizes, break all kinds of implicit assumptions, the use case is narrow, and we&apos;re already getting a version specific family delete marker, which should address some of the issues.&lt;/p&gt;</comment>
                            <comment id="13690464" author="apurtell" created="Fri, 21 Jun 2013 16:45:07 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt; Did that once before. Looking at votes, we have: Lars (-1), Sergey (-0), me (-0). If we tease this apart, we get &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8770&quot; title=&quot;deletes and puts with the same ts should be resolved according to mvcc/seqNum&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8770&quot;&gt;HBASE-8770&lt;/a&gt;, where looks like we have a way forward on addressing this part:&lt;/p&gt;

&lt;p&gt;Feng:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;User can always read the put by 4&amp;gt;. It&apos;s more natural and intuitive:&lt;br/&gt;
1&amp;gt; put a kv (timestamp = T0), and flush;&lt;br/&gt;
2&amp;gt; delete that kv using a DeleteColumn type kv with timestamp T0 (or any timestamp &amp;gt;= T0), and flush;&lt;br/&gt;
3&amp;gt; a major compact occurs &lt;span class=&quot;error&quot;&gt;&amp;#91;or not&amp;#93;&lt;/span&gt;;&lt;br/&gt;
4&amp;gt; put that kv again (timestamp = T0);&lt;br/&gt;
5&amp;gt; read that kv;&lt;br/&gt;
===&amp;gt;&lt;br/&gt;
a) if a major compact occurs at step 3&amp;gt;, then step 5&amp;gt; will get the put written at step 4&amp;gt;&lt;br/&gt;
b) if no major compact occurs at step 3&amp;gt;, then step 5&amp;gt; get nothing&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But for the other part of the argument, expressed by Hangjun:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;tiemstamp is a logical version, which is often the same as the &quot;happened-before&quot; relationship inside hbase, but not necessarily have to be. User could assign any semantics to it since it has been exposed and user could set it explicitly. &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt; Conceptually decoupling the timestamp and the &quot;happened-before&quot; relationship inside hbase should give users more flexibility to decide how to use it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;the discussion consensus reads to me as: users submitting their own timestamps have to actually produce happened-before relationships by issuing ops with &lt;em&gt;different&lt;/em&gt; timestamps, and not rely on HBase to also remember op arrival order internally for breaking ties when the ops have the same logical &quot;time&quot;. &lt;/p&gt;

&lt;p&gt;We have a standing firm -1 on changing that part. What do you think? Would you +1 it? Under what circumstances would Lars change his -1 to a +1? I don&apos;t see that but don&apos;t presume to speak for him.&lt;/p&gt;</comment>
                            <comment id="13690482" author="sershe" created="Fri, 21 Jun 2013 17:10:49 +0000"  >&lt;p&gt;note that there are two arguments here, one is for real glitch with major compactions removing the markers as described; and one for adding a delete with a semantic that will be internal sequence-based and ignore put timestamps completely (previous-in-sequence puts removed, next-in-sequence puts visible despite timestamps. By extension this delete semantic will obviously not have the major-compaction-related glitch, but this is a side-effect, not the main argument for such semantics.&lt;br/&gt;
Let&apos;s not conflate them...&lt;/p&gt;</comment>
                            <comment id="13690553" author="lhofhansl" created="Fri, 21 Jun 2013 18:22:42 +0000"  >&lt;p&gt;I would change the -1 to a -0 if:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;we make this configurable&lt;/li&gt;
	&lt;li&gt;the code the changes are not too messy (i.e. no if statements littered everywhere)&lt;/li&gt;
	&lt;li&gt;this is carefully tested with all features mentioned above&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Then we&apos;d have 3 -0&apos;s.&lt;/p&gt;

&lt;p&gt;Even the &quot;major compaction glitch&quot; is only an issue when the client messes with timestamps (or regions are moved between RSs and clocks that are wildly out of sync).&lt;br/&gt;
As mentioned above there is a proposed solution in form of a long TTL for delete markers, but that will only work if the timestamps represent wall clock time (otherwise &quot;TTL&quot; is meaning less).&lt;/p&gt;</comment>
                            <comment id="13690588" author="lhofhansl" created="Fri, 21 Jun 2013 18:48:37 +0000"  >&lt;p&gt;But of course we can leave this issue open to indicate that we&apos;re still discussing this.&lt;/p&gt;</comment>
                            <comment id="13690592" author="apurtell" created="Fri, 21 Jun 2013 18:51:51 +0000"  >&lt;p&gt;I closed this issue because I don&apos;t see us ending with a commit here as proposed, and there is follow up on the parts we seem to agree on at &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8770&quot; title=&quot;deletes and puts with the same ts should be resolved according to mvcc/seqNum&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8770&quot;&gt;HBASE-8770&lt;/a&gt;.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12653776">HBASE-8770</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12976049">HBASE-15968</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12586940" name="HBASE-8721-0.94-V0.patch" size="49195" author="fenghh" created="Sun, 9 Jun 2013 10:02:00 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sun, 9 Jun 2013 13:07:53 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>332238</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            3 years, 26 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1lbcn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>332567</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>