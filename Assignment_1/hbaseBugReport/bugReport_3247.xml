<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:08:38 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-3247/HBASE-3247.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-3247] Changes API: API for pulling edits from HBase</title>
                <link>https://issues.apache.org/jira/browse/HBASE-3247</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;Talking to Shay from Elastic Search, he was asking where the Changes API is in HBase.  Talking more &amp;#8211; there was a bit of beer involved so apologize up front &amp;#8211; he wants to be able to bootstrap an index and thereafter ask HBase for changes since time t.  We thought he could tie into the replication stream, but rather he wants to be able to pull rather than have it pushed to him (in case he crashes, etc. so on recovery he can start pulling again from last good edit received).  He could do the bootstrap with a Scan.  Thereafter, requests to pull from hbase would pass a marker of some  sort.  HBase would then give out edits that came in after this marker, in batches, along with an updated marker.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12480368">HBASE-3247</key>
            <summary>Changes API: API for pulling edits from HBase</summary>
                <type id="3" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/task.png">Task</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="8">Not A Problem</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="stack">stack</reporter>
                        <labels>
                    </labels>
                <created>Thu, 18 Nov 2010 19:43:06 +0000</created>
                <updated>Sat, 19 Jul 2014 00:29:29 +0000</updated>
                            <resolved>Sat, 19 Jul 2014 00:29:29 +0000</resolved>
                                                                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                <comments>
                            <comment id="12934192" author="stevenn" created="Sat, 20 Nov 2010 21:12:58 +0000"  >&lt;p&gt;If this is really about robust (and distributed) pulling, wouldn&apos;t the RowLog mechanism as implemented in Lily would be a more solid approach - to the point that RowLog would leave in-row-process-status data in a non-user-visible column?&lt;/p&gt;

&lt;p&gt;I&apos;m wondering, as I&apos;m seeing a proliferation of alternative yet overlapping approaches to a certain number of issues (secondary indexes, change listening) which in the end could confuse new users.&lt;/p&gt;</comment>
                            <comment id="12935055" author="stack" created="Tue, 23 Nov 2010 21:34:11 +0000"  >&lt;p&gt;@Steven Yes, we should start with RowLog (&lt;a href=&quot;http://www.lilyproject.org/maven-site/0.1/apidocs/org/lilycms/rowlog/api/RowLog.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.lilyproject.org/maven-site/0.1/apidocs/org/lilycms/rowlog/api/RowLog.html&lt;/a&gt;).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I&apos;m wondering, as I&apos;m seeing a proliferation of alternative yet overlapping approaches to a certain number of issues (secondary indexes, change listening) which in the end could confuse new users.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;-1 to proliferation of alternate yet overlapping... things&lt;/p&gt;

&lt;p&gt;What you fellas suggest for bootstrapping system &amp;#8211; doing a fat bulk load into the search index &amp;#8211; and then cutting over to rowlog for incremental updates?  Doesn&apos;t there have to exact transition so followers do not miss edits?  You fellas have ideas for how to do that?&lt;/p&gt;</comment>
                            <comment id="12935552" author="stevenn" created="Wed, 24 Nov 2010 22:41:47 +0000"  >&lt;p&gt;Well, we&apos;re doing mapreduce for initial SOLR population, which might be a bit too involved compared with soemthing like a Changes API. I reckon our Indexer could be made configurable to connect to ES as well. i&apos;ll have Evert look into this issue, and comment to it, he just did a writeup on the Rowlog on our blog today: &lt;a href=&quot;http://outerthought.org/blog/449-ot.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://outerthought.org/blog/449-ot.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The thing I would object to if I were a non-Lily person, would be that we need tracking/status data in user-visible columns.&lt;/p&gt;</comment>
                            <comment id="12935553" author="ryanobjc" created="Wed, 24 Nov 2010 22:44:15 +0000"  >&lt;p&gt;why can&apos;t timestamp based scanning do this?  Is it because of the&lt;br/&gt;
missing deletes?  Could there be a scan option to give more raw data?&lt;br/&gt;
Not really a new API, but still kind of a half API.&lt;/p&gt;</comment>
                            <comment id="12935574" author="streamy" created="Wed, 24 Nov 2010 23:35:23 +0000"  >&lt;p&gt;Scanning requires you to look at all the data (or at least, more than just the data you need).  I think that would prove far to inefficient for something like keeping a search index up to date which you expect to be as &quot;realtime&quot; as possible.&lt;/p&gt;

&lt;p&gt;This is about only needing to see the deltas.&lt;/p&gt;</comment>
                            <comment id="12935712" author="evertot" created="Thu, 25 Nov 2010 10:37:02 +0000"  >&lt;p&gt;@stack&lt;br/&gt;
With the Rowlog you can register a subscription and then all messages that are put on the rowlog will be kept for that subscription. If you then also register a listener (cfr RowLogMessageListener) on that subscription, the rowlog processor will start feeding the messages to the listener.&lt;br/&gt;
If you can make a bulk load that only processes data that was changed before a certain point in time, you can let that run and in the meanwhile let the rowlog record all changes that are done after that point.&lt;/p&gt;

&lt;p&gt;Looking a bit further at how the Indexer in Lily uses the rowlog (&lt;a href=&quot;http://docs.outerthought.org/lily-docs-current/415-lily.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://docs.outerthought.org/lily-docs-current/415-lily.html&lt;/a&gt;) :&lt;br/&gt;
When the indexer recieves a message it will use the record&apos;s current data and put that data in the index (IndexUpdater is the listener that is registered on the rowlog).&lt;br/&gt;
An index rebuild will use map reduce to go over all the data again and update the index.&lt;br/&gt;
It is allowed for both the bulk index rebuild and the index updater through the rowlog to run in parallel. Both will look at the current data of the record and put that in the index. So there is no need for a transition point from bulk to incremental.&lt;br/&gt;
The indexer is written specifically to put Lily records into a Solr index. It is not designed yet to plug-in another index. But it should be do-able to use this same framework to have something non-Lily on the one hand and a non-Solr index on the other. If we look at the classes in the framework : the IndexUpdater is the implementation of the RowLogMessageListener which has knowledge about lily-records and decides &apos;what&apos; to index. The Indexer class is responsible for mapping the Lily-schema onto the Solr-schema and maintains the communication with Solr.&lt;/p&gt;</comment>
                            <comment id="12964400" author="stack" created="Sat, 27 Nov 2010 15:45:48 +0000"  >&lt;p&gt;Thanks @Evert.  BTW, how do we get documentation that is as fancy as yours?&lt;/p&gt;</comment>
                            <comment id="14067280" author="apurtell" created="Sat, 19 Jul 2014 00:29:29 +0000"  >&lt;p&gt;Steven and crew ended up using replication to achieve this aim. Could also be done by implementing a RegionObserver coprocessor that writes to Kafka etc.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 20 Nov 2010 21:12:58 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>32959</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            2 years, 21 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0hle7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>100728</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>