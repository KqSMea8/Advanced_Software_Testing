<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:05:39 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-2893/HBASE-2893.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-2893] Table metacolumns</title>
                <link>https://issues.apache.org/jira/browse/HBASE-2893</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;Some features like TTLs or access control lists have use cases that call for per-value configurability. &lt;/p&gt;

&lt;p&gt;Currently in HBase TTLs are set per column family. This leads to potentially awkward &quot;bucketing&quot; of values into column families set up to accommodate the common desired TTLs for all values within &amp;#8211; an unnecessarily wide schema, with resulting unnecessary reduction in I/O locality in access patterns, more store files than otherwise, and so on.&lt;/p&gt;

&lt;p&gt;Over in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1697&quot; title=&quot;Discretionary access control&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1697&quot;&gt;&lt;del&gt;HBASE-1697&lt;/del&gt;&lt;/a&gt; we&apos;re considering setting ACLs on column families. However, we are aware of other BT-like systems which support per-value ACLs. This allows for multitenancy in a single table as opposed to really requiring tables for each customer (or, at least column families). The scale out properties for a single table are better than alternatives. I think supporting per-row ACLs would be generally sufficient: customer ID could be part of the row key. We can still plan to maintain column-family level ACLs. We would therefore not have to bloat the store with per-row ACLs for the normal case &amp;#8211; but it would be highly useful to support overrides for particular rows. So how to do that?&lt;/p&gt;

&lt;p&gt;I propose to introduce &lt;em&gt;metacolumns&lt;/em&gt;. &lt;/p&gt;

&lt;p&gt;A &lt;em&gt;metacolumn&lt;/em&gt; would be a column family intrinsic to every table, created by the system at table create time.  It would be accessible like any other column family, but we expect a default ACL that only allows access by the system and operator principals, and would function like any other, except administrative actions such as renaming or deletion would not be allowed.  Into the metacolumn would be stored per-row overrides for such things as ACLs and TTLs. The metacolumn therefore would be as sparse as possible; no storage would required for any overrides if a value is committed with defaults. A reasonably sparse metacolumn for a region may fit entirely within blockcache. It may be possible for all metacolumns on a RS to fit within blockcache without undue pressure on other users. We can aim design effort at this target. &lt;/p&gt;

&lt;p&gt;The scope of changes required to support this is:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Introduce metacolumn concept in the code and into the security model (default ACL): A flag in HCD, a default ACL, and a few additional checks for rejecting disallowed administrative actions.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Automatically create metacolumns at table create time.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Consult metacolumn as part of processing reads or mutations, perhaps using a bloom filter to shortcut lookups for rows with no metaentries, and apply configuration or security policy overrides if found.&lt;/li&gt;
&lt;/ul&gt;

</description>
                <environment></environment>
        <key id="12470574">HBASE-2893</key>
            <summary>Table metacolumns</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="7">Later</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="apurtell">Andrew Purtell</reporter>
                        <labels>
                    </labels>
                <created>Sat, 31 Jul 2010 18:28:10 +0000</created>
                <updated>Sat, 11 Apr 2015 01:32:09 +0000</updated>
                            <resolved>Sat, 11 Apr 2015 01:32:09 +0000</resolved>
                                                                    <component>Coprocessors</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>9</watches>
                                                                <comments>
                            <comment id="12894387" author="streamy" created="Sun, 1 Aug 2010 15:17:53 +0000"  >&lt;p&gt;This sounds really interesting andy.  I&apos;m a little concerned that this would be rather disruptive to the code but used by a very small portion of users.&lt;/p&gt;

&lt;p&gt;So the default behavior would be to always create the metacolumn family and the read path will always have these checks in it?  Maybe this feature itself should be a table-level setting and should try to get all the logic related to this into new classes with just a hook or two into the existing read-time checks.&lt;/p&gt;

&lt;p&gt;The current QueryMatcher/Tracker code paths are starting to get a little messy and I&apos;m a little worried about adding a bunch of new checks to every KV for this or any other feature (there&apos;s some work going into some of the seek/reseek optimizations and it&apos;s hard to move it forward because adding another couple row checks can be significant if done on every kv).&lt;/p&gt;

&lt;p&gt;In addition, this would break with the pattern of each family able to be processed in isolation.  Now, reading of each family will require an additional scanner against the metacolumn family.  So, if reading from a 5 family table (+1 for meta), you&apos;d end up reading the metacolumn 5 times, once for each user family?  Things like the bloom filter check would have to happen during the read, so at a different level than it&apos;s currently done.&lt;/p&gt;

&lt;p&gt;Would this check be first, last, or scattered throughout the read checks?  I would guess first but not sure if there are other things desired besides TTL and ACLs that might require some of the existing checks first.  I&apos;m not quite sure I understand the TTL use case, this seems like an extremely rare use case where you&apos;d have TTLs applied at row granularity?  I suppose this kind of fine-grained policy setting is desirable but I guess it&apos;s less clear why you couldn&apos;t break stuff up into separate tables for varied TTLs or multi-tenancy.  Or if you have these very specific and fine-grained settings like variable TTL you would implement them in your application.&lt;/p&gt;

&lt;p&gt;When do you set this stuff?  Would inserts be augmented?  Would there be special types of KVs that you could write at the same time you insert the actual data?  Above description addresses where it is stored and when it is looked up, but not how it is set.  Would Put be extended with per-row setTTL, setACL methods now?&lt;/p&gt;

&lt;p&gt;Out of curiosity, which BT-like systems support per-value ACLs?  I don&apos;t think I&apos;ve seen this in any DBs I&apos;ve worked with.&lt;/p&gt;</comment>
                            <comment id="12894418" author="apurtell" created="Sun, 1 Aug 2010 19:29:00 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m a little concerned that this would be rather disruptive to the code but used by a very small portion of users.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We anticipate that access control will be a widely used feature if available. &lt;/p&gt;

&lt;p&gt;Impetus for this issue started with considerations for implementing access control. &lt;/p&gt;

&lt;p&gt;However, the adjustable TTL case comes for free if metacolumns are implemented in a more general manner, and is something that would make life easier for some dev groups I am working with.&lt;/p&gt;

&lt;p&gt;One way to address concerns regarding disruption would be to build this &amp;#8211; therefore perhaps much of security (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1697&quot; title=&quot;Discretionary access control&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1697&quot;&gt;&lt;del&gt;HBASE-1697&lt;/del&gt;&lt;/a&gt; and subtasks) &amp;#8211; on top of coprocessor-style server side extensions (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2000&quot; title=&quot;Coprocessors&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2000&quot;&gt;&lt;del&gt;HBASE-2000&lt;/del&gt;&lt;/a&gt; and subtasks). I have been considering this approach. It is compelling to consider pulling up all of the functional and performance impact to an extension which can be dynamically loaded per table. The core code is only touched by coprocessor framework changes and the user has full choice in the matter when taking on anything else. On the other hand, support is more challenging, perhaps a lot more. First question: &quot;What extensions do you have loaded, in what combination?&quot; So on balance I recommend &lt;em&gt;if we agree&lt;/em&gt; that &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1697&quot; title=&quot;Discretionary access control&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1697&quot;&gt;&lt;del&gt;HBASE-1697&lt;/del&gt;&lt;/a&gt; is a core concern, then it and related changes such as this issue should be in core, not an extension. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;this would break with the pattern of each family able to be processed in isolation&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ack.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So, if reading from a 5 family table (+1 for meta), you&apos;d end up reading the metacolumn 5 times, once for each user family?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No, only one time, anything in the metacolumn for the row retrieved in one read.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Things like the bloom filter check would have to happen during the read, so at a different level than it&apos;s currently done.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;At the Region level, yes, for the metacolumn case. So an access to a row in the Region would trigger a read of the metacolumn and then caching of the result to be passed around. Exactly how this would be passed around is unsettled. One option is thread locals. &lt;/p&gt;

&lt;p&gt;This is part of a larger issue related to the security work, that of creating a context (for access control) and then referencing it wherever an authoritative decision must be made. We have been debating if to use JAAS or instead sprinkle around access checks by hand. The issue of building context and passing it around must be dealt with to implement security. If we have it, then passing around KVs read from metacolumns is straightforward. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Or if you have these very specific and fine-grained settings like variable TTL you would implement them in your application.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;... and then lose a feature &amp;#8211; automatic TTL based expiration and garbage collection with single-table scale out properties &amp;#8211; that makes use of HBase compelling as opposed to something else. (Not sure what, if anything, that something else would be.)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I guess it&apos;s less clear why you couldn&apos;t break stuff up into separate tables for varied TTLs or multi-tenancy.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, that&apos;s the problem. Single table multitenancy has better scale out properties than per-user tables, and in the HBase case, 1M+ tables for 1M+ users is not tenable. &lt;/p&gt;

&lt;p&gt;For the variable TTL case, consider an event logging application designed to archive data for long periods of time, but the different event types have different lifetimes, and lifetimes may be adjusted over time (updated system design). If a bunch of tables, this requires a join, which HBase does not support. So what you would do is set up column families to each serve as a TTL bucket (&quot;join&quot; over column families). Events could only have the TTL of one of the buckets. Application would store into appropriate column family according to TTL. But this then results in a wide schema, with resulting unnecessary reduction in I/O locality in access patterns, more store files than otherwise, and so on. Design changes require adding or modifying column families, taking the table offline, at least for now. Not necessarily a fatal problem if we can avoid taking the table offline &lt;em&gt;ever&lt;/em&gt; after the master rewrite, but if we already have per-row overrides for ACLs then this straightforwardly extends to the TTL case (at least) and that&apos;s enough I think to make this problem go away. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Would Put be extended with per-row setTTL, setACL methods now?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I would recommend that, yes. The metacolumn is a column family like any other; to set stuff, put values as KVs into the Put to be stored directly. Convenience functions on Put are desirable so the user doesn&apos;t have to learn about the value formatting for various overrides. &lt;/p&gt;

&lt;p&gt;So add to this:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It would be accessible like any other column family, but we expect a default ACL that only allows access by the system and operator principals&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;and any principal the table creator adds to the ACL. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Out of curiosity, which BT-like systems support per-value ACLs?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s a rumor. I&apos;ll try to find out more. &lt;/p&gt;</comment>
                            <comment id="12894420" author="streamy" created="Sun, 1 Aug 2010 19:46:16 +0000"  >&lt;p&gt;I would be for trying to get this and stuff like it into a coprocessor-style implementation where we have a constant overhead moving forward to check for the existence of these things, but then any overhead introduced by these new features does not impact non-users.&lt;/p&gt;

&lt;p&gt;I&apos;m sure DAC is something people will use, just like it&apos;s something people use in mysql, but I imagine it will be used less-so than it is in that context (given how many applications are not multi-tenant or user-facing).  And then with those users that do take advantage, I doubt they will have 1M users or will need this granularity of security.  So while I definitely see lots of value in DAC I don&apos;t necessarily see this specific feature as a requirement for most of that value to most users.  Having said that, I think this is cool and worth exploring, just seems significantly more disruptive to implement DAC via metacolumns than just through family meta data.&lt;/p&gt;

&lt;p&gt;Would the plan be to do the DAC/ACL stuff without this and then add it?  Or would this be a required piece of any implementation?&lt;/p&gt;</comment>
                            <comment id="12894424" author="apurtell" created="Sun, 1 Aug 2010 21:50:15 +0000"  >&lt;blockquote&gt;&lt;p&gt;I would be for trying to get this and stuff like it into a coprocessor-style implementation&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I do like that idea too, if &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1697&quot; title=&quot;Discretionary access control&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1697&quot;&gt;&lt;del&gt;HBASE-1697&lt;/del&gt;&lt;/a&gt; is not a core concern. It sounds like that is your opinion, that &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1697&quot; title=&quot;Discretionary access control&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1697&quot;&gt;&lt;del&gt;HBASE-1697&lt;/del&gt;&lt;/a&gt; is not, correct?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It just seems significantly more disruptive to implement DAC via metacolumns than just through family meta data.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Would be both implementing DAC via metacolumns and via family meta data, so the metacolumn can be sparse as possible, empty for the normal case, at least providing this to the designer.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Would the plan be to do the DAC/ACL stuff without this and then add it? Or would this be a required piece of any implementation?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not required if  maintaining ACLs on column families only. Not required if maintaining current situation with per-column family TTLs. Something like this would be necessary for per-row granularity I think. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I doubt they will have 1M users&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not just 1M users, I can envision probable applications with 100M+ users, actually. Can&apos;t have 100M tables, can&apos;t have 100M column families. &lt;/p&gt;</comment>
                            <comment id="12894433" author="streamy" created="Sun, 1 Aug 2010 23:59:54 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1697&quot; title=&quot;Discretionary access control&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1697&quot;&gt;&lt;del&gt;HBASE-1697&lt;/del&gt;&lt;/a&gt; is not a core concern for me personally.  But I definitely want to see this stuff and I think it would be awesome if HBase could support DAC for 100M+ users... I just don&apos;t think these use cases are necessarily core concerns.  I&apos;m a bit worried about this touching a lot of code if done one-off.&lt;/p&gt;

&lt;p&gt;Coprocessors can give us the opportunity to create all of the necessary hooks for these types of applications and then not have to deal with mucking up core server code every time we want to add features.  We might actually be able to re-introduce contrib modules if we had a versioned coprocessor API they could hook into.&lt;/p&gt;

&lt;p&gt;Similarly to this, right now on the read side of things, once we get the seek/reseek optimizations in place we are going to add a new method to the filter interface so that any filter can pass seeking hints in.  We have a few very specific queries that we want to build specialized filters for but don&apos;t want to keep touching core code.  I think this is a good pattern.  I could see adding another hook to the filter to get the metacolumn data at the start of each row as well &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The combination of persisted, row-level meta data and coprocessors is a pretty awesome one.&lt;/p&gt;

&lt;p&gt;I have a few other high-pri items I need to finish up but I&apos;m hoping to get my hands dirty with coprocessors soon.  These metacolumns could be used for all sorts of stuff and I&apos;d definitely be interested in helping out on this.&lt;/p&gt;</comment>
                            <comment id="12894437" author="tlipcon" created="Mon, 2 Aug 2010 00:40:57 +0000"  >&lt;p&gt;I agree with Jonathan&apos;s sentiment that we should try to fit this kind of thing into a framework rather than core if possible.&lt;/p&gt;

&lt;p&gt;Regarding the use case of per-cell ACLs, it is a requirement for a lot of government users, where each piece of information may have a different security clearance, and clearance is very granularly controlled. I could see implementing this, though, by using a coprocessor which intercepts all reads/writes and for every column cf:foo first checks a cf:_acl_foo before returning results or passing through the write&lt;/p&gt;

&lt;p&gt;Regarding the multitenancy use case, I imagine an infrastructure-as-a-service deployment of HBase would probably be going through some intermediary layer anyway to give users the illusion that they aren&apos;t on a shared deployment. EG any access would have &quot;user_foo_&quot; prepended to all row keys. Having security integration is important to authenticate the user, but per-row ACLs seems expensive for that use case.&lt;/p&gt;</comment>
                            <comment id="12894445" author="apurtell" created="Mon, 2 Aug 2010 02:48:39 +0000"  >&lt;blockquote&gt;&lt;p&gt;Regarding the multitenancy use case, I imagine an infrastructure-as-a-service deployment of HBase would probably be going through some intermediary layer anyway to give users the illusion that they aren&apos;t on a shared deployment. EG any access would have &quot;user_foo_&quot; prepended to all row keys. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, this is what &quot;multiuser mode&quot; in Stargate (the version up on GitHub) does, for example.&lt;/p&gt;

&lt;p&gt;Looking at some hypothetical IaaS use case may be overly limiting.&lt;/p&gt;

&lt;p&gt;For example, we (as an &quot;enterprise&quot; HBase user) would like to consider multitenancy in our own private infrastructure with direct (Java) API access for performance &amp;#8211; secure RPC, of course. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Having security integration is important to authenticate the user, but per-row ACLs seems expensive for that use case.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Per-row &lt;em&gt;overrides&lt;/em&gt;. And not just of ACLs.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I could see implementing this, though, by using a coprocessor which intercepts all reads/writes and for every column cf:foo first checks a cf:_acl_foo before returning results or passing through the write&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I wouldn&apos;t want to mix metadata with data in the same CF so as to not limit application keyspace, but that&apos;s just a personal design preference of mine.&lt;/p&gt;
</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12382716">HBASE-47</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12431322">HBASE-1697</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12558151">HBASE-6098</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12441373">HBASE-2000</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12558146">HBASE-6096</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sun, 1 Aug 2010 15:17:53 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>32822</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            6 years, 20 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0d49j:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>74467</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>