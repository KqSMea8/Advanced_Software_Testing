<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 20:18:58 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-10974/HBASE-10974.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-10974] Improve DBEs read performance by avoiding byte array deep copies for key[] and value[]</title>
                <link>https://issues.apache.org/jira/browse/HBASE-10974</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;As part of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10801&quot; title=&quot;Ensure DBE interfaces can work with Cell&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10801&quot;&gt;&lt;del&gt;HBASE-10801&lt;/del&gt;&lt;/a&gt;, we  tried to reduce the copy of the value [] in forming the KV from the DBEs. &lt;br/&gt;
The keys required copying and this was restricting us in using Cells and always wanted to copy to be done.&lt;br/&gt;
The idea here is to replace the key byte[] as ByteBuffer and create a consecutive stream of the keys (currently the same byte[] is used and hence the copy).  Use offset and length to track this key bytebuffer.&lt;br/&gt;
The copy of the encoded format to normal Key format is definitely needed and can&apos;t be avoided but we could always avoid the deep copy of the bytes to form a KV and thus use cells effectively. Working on a patch, will post it soon.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12708331">HBASE-10974</key>
            <summary>Improve DBEs read performance by avoiding byte array deep copies for key[] and value[]</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="ram_krish">ramkrishna.s.vasudevan</assignee>
                                    <reporter username="ram_krish">ramkrishna.s.vasudevan</reporter>
                        <labels>
                    </labels>
                <created>Mon, 14 Apr 2014 18:24:10 +0000</created>
                <updated>Sat, 18 Jun 2016 01:42:30 +0000</updated>
                                            <version>0.99.0</version>
                                    <fixVersion>2.0.0</fixVersion>
                    <fixVersion>1.4.0</fixVersion>
                                    <component>Scanners</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>10</watches>
                                                                <comments>
                            <comment id="13969713" author="ram_krish" created="Tue, 15 Apr 2014 16:43:56 +0000"  >&lt;p&gt;This patch also has the getCell() change replacing getKeyValue().  &lt;br/&gt;
TestProcedureManager generally fails when i run the test suite. Is it really under the small tests category? Or should it be medium tests?  Because we are starting a cluster there.&lt;br/&gt;
Need to find a way to allocate a buffer for the key which is sufficient in length so that unnecessary copy does not happen.  Running to get a hadoopQA run.  &lt;br/&gt;
Large tests are running in my machine.&lt;/p&gt;</comment>
                            <comment id="13969730" author="hadoopqa" created="Tue, 15 Apr 2014 16:53:23 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12640294/HBASE-10972.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12640294/HBASE-10972.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision .&lt;br/&gt;
  ATTACHMENT ID: 12640294&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 3 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 patch&lt;/font&gt;.  The patch command could not apply the patch.&lt;/p&gt;

&lt;p&gt;Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9292//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9292//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="13969770" author="ram_krish" created="Tue, 15 Apr 2014 17:20:41 +0000"  >&lt;p&gt;Attached the wrong patch.&lt;/p&gt;</comment>
                            <comment id="13969945" author="hadoopqa" created="Tue, 15 Apr 2014 19:19:32 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12640301/HBASE-10974_1.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12640301/HBASE-10974_1.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision .&lt;br/&gt;
  ATTACHMENT ID: 12640301&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 21 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javadoc&lt;/font&gt;.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 findbugs&lt;/font&gt;.  The patch appears to introduce 3 new Findbugs (version 1.3.9) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 lineLengths&lt;/font&gt;.  The patch introduces the following lines longer than 100:&lt;br/&gt;
    +    // WE will create a keyBuffer equivalent to currentBuffer and keep it valid till the block is read&lt;br/&gt;
+    List&amp;lt;DataBlockEncoder.EncodedSeeker&amp;gt; encodedSeekers = new ArrayList&amp;lt;DataBlockEncoder.EncodedSeeker&amp;gt;();&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;     &lt;font color=&quot;red&quot;&gt;-1 core tests&lt;/font&gt;.  The patch failed these unit tests:&lt;br/&gt;
                       org.apache.hadoop.hbase.io.encoding.TestBufferedDataBlockEncoder&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/9294//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="13970005" author="stack" created="Tue, 15 Apr 2014 20:13:18 +0000"  >
&lt;blockquote&gt;&lt;p&gt;The idea here is to replace the key byte[] as ByteBuffer and create a consecutive stream of the keys (currently the same byte[] is used and hence the copy).  Use offset and length to track this key bytebuffer.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Can you give an example of what is being implemented here &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ram_krish&quot; class=&quot;user-hover&quot; rel=&quot;ram_krish&quot;&gt;ramkrishna.s.vasudevan&lt;/a&gt;?  How the savings are being made? Thanks.&lt;/p&gt;</comment>
                            <comment id="13970445" author="ram_krish" created="Wed, 16 Apr 2014 05:26:49 +0000"  >&lt;p&gt;In the existing code&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] keyBuffer = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[INITIAL_KEY_BUFFER_SIZE];
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;A key buffer is created and for every KV that needed to be decoded is filled up in this array.  (same byte[] is getting used).&lt;br/&gt;
For eg, see the decodeNext() in PrefixKeyDeltaEncoder.&lt;br/&gt;
So except for the common bytes the remaining bytes are copied for every next().&lt;br/&gt;
Now for every keyvalue that needs to be retrieved using getKeyValue()(either for comparison on the upper layer or for returning a KV) we are doing a deep copy of the above formed key bytes[] and also the value bytes[].&lt;br/&gt;
Now here in this patch we would create a long keyBuffer, and keep adding the keys once the decoding is done and form a continuous buffer of keys. (this will have to copy the common part from the previous key formed too). When we try to use Cells here we don&apos;t need to do a deep copy of the keys and also the value part can still refer to the common buffer.(See &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10801&quot; title=&quot;Ensure DBE interfaces can work with Cell&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10801&quot;&gt;&lt;del&gt;HBASE-10801&lt;/del&gt;&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;The other advantage that you get here is later if we go with Cells backed by offheap BB or BRs, we will never need to copy the key[] to the on heap for the comparison and retrievals (atleast in the StoreScanner layer and below).&lt;/p&gt;

&lt;p&gt;If there is a Kv with 100 bytes for Key and 500 bytes for Value and among that 50 bytes of key are common&lt;/p&gt;

&lt;p&gt;Existing code will only get 50 bytes - the uncommon part from the common buffer.  But later while doing getKeyValue copies the whole 100 bytes to a new kv Buffer.&lt;br/&gt;
It also tries to copy the value part of 500 bytes that can be avoided with Cells anyway.&lt;/p&gt;

&lt;p&gt;With the patch the Key buffer copies the 50 uncommon bytes and also the 50 common bytes from previous KV but while doing getKeyValue there is no copy at all.&lt;br/&gt;
So in case 1 there is 150 bytes copy that happens and in the case 2 only 100 bytes copy happens.&lt;br/&gt;
Now in cases where the common part is even lesser then we tend to benefit more out of this incases where the row changes.&lt;/p&gt;

&lt;p&gt;Regarding the comparison that happens inside BufferedDataBlockEncoder, thats still works with the old logic using the common prefix among the formed Key&lt;br/&gt;
buffer except that the offset of that changes.&lt;/p&gt;</comment>
                            <comment id="13970454" author="ram_krish" created="Wed, 16 Apr 2014 05:40:03 +0000"  >&lt;p&gt;Retrieving a single KV&lt;br/&gt;
======================&lt;br/&gt;
If i need the last Kv in a block and in all of them there are 50 common bytes then (assume 1000 keys)&lt;br/&gt;
(50 * 1000 = 50000) + 50 = 50050&lt;/p&gt;

&lt;p&gt;But with the latest code&lt;br/&gt;
(100 * 1000 = 10000) will happen&lt;/p&gt;

&lt;p&gt;Scans&lt;br/&gt;
=====&lt;br/&gt;
But in case of scans, if i need to retrieve the 1000 keys from the block&lt;br/&gt;
(50 * 1000 = 50000) + (100 * 1000 = 100000) = 150000. Because a deep copy will also happen&lt;br/&gt;
With latest code&lt;br/&gt;
(100 * 1000 = 10000)&lt;/p&gt;</comment>
                            <comment id="13973832" author="ram_krish" created="Fri, 18 Apr 2014 06:44:42 +0000"  >&lt;p&gt;See latest comment in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10801&quot; title=&quot;Ensure DBE interfaces can work with Cell&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10801&quot;&gt;&lt;del&gt;HBASE-10801&lt;/del&gt;&lt;/a&gt;.  One problem faced while checking the performance is that we need to determine a value to determine the key buffer&apos;s initial size.  If not there is always a chance that the key needs to be copied.&lt;br/&gt;
We could first get BASe-10801 in and then work on this.&lt;/p&gt;</comment>
                            <comment id="13974186" author="yuzhihong@gmail.com" created="Fri, 18 Apr 2014 16:05:25 +0000"  >&lt;p&gt;Ram:&lt;br/&gt;
In the example, 50 bytes of key are common and 50 bytes are not common.&lt;br/&gt;
It would be more readable if the common and uncommon parts have different lengths.&lt;/p&gt;</comment>
                            <comment id="13974706" author="mcorgan" created="Sat, 19 Apr 2014 03:30:05 +0000"  >&lt;p&gt;&lt;blockquote&gt;&lt;p&gt;One problem faced while checking the performance is that we need to determine a value to determine the key buffer&apos;s initial size.&lt;/p&gt;&lt;/blockquote&gt;it&apos;s probably too late to add this now, but prefix-tree calculates things like this during encoding and stores them in a block header&lt;/p&gt;

&lt;p&gt;overall, this seems like a cool strategy to save some copying, but with a complexity cost.  would this be necessary if you can fix the preemptive hfs.next() call?  if so, then seems like it has merit, but if the underlying problem can be fixed then would this problem go away?&lt;/p&gt;</comment>
                            <comment id="13975057" author="stack" created="Sun, 20 Apr 2014 04:16:38 +0000"  >&lt;blockquote&gt;&lt;p&gt;... if you can fix the preemptive hfs.next() call?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Is this possible?  (&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt; you have any input here boss?)&lt;/p&gt;</comment>
                            <comment id="13975058" author="stack" created="Sun, 20 Apr 2014 04:34:05 +0000"  >&lt;blockquote&gt;&lt;p&gt;TestProcedureManager generally fails when i run the test suite. Is it really under the small tests category? Or should it be medium tests? Because we are starting a cluster there.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The &quot;16.7.2.2. Medium Tests&quot; in refguide has medium tests taking &amp;lt; 50 seconds.  FYI.&lt;/p&gt;

&lt;p&gt;Looking at decodeNext, what in particular am I looking at?  The ensureSpaceForKey?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So except for the common bytes the remaining bytes are copied for every next().&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I just see us copying the full key, not the difference.  Am I looking in the wrong place boss?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Existing code will only get 50 bytes - the uncommon part from the common buffer.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;... where is this going on? (Sorry for being dense)&lt;/p&gt;

&lt;p&gt;How do I interpret your math?  The new code is &apos;worse&apos; if doing a get but better when scanning?&lt;/p&gt;

&lt;p&gt;Thanks Ram.&lt;/p&gt;


</comment>
                            <comment id="13975059" author="lhofhansl" created="Sun, 20 Apr 2014 04:42:15 +0000"  >&lt;p&gt;There are two places where this happens:&lt;br/&gt;
StoreFilescanner.next() and KeyValueHeap.next(). The issue is that we support peek() and seek() and the seek() contract is that that next() returns what we seeked to. That said, it might be possible to express this logic without eagerly calling next().&lt;/p&gt;

&lt;p&gt;The key is, I suppose, that the entire scanner stack above StoreFileScanner always uses exactly one KV (the current one). If that were the case we could allocate and reuse a single KV object. Do I understand this correctly &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mcorgan&quot; class=&quot;user-hover&quot; rel=&quot;mcorgan&quot;&gt;Matt Corgan&lt;/a&gt;?&lt;/p&gt;</comment>
                            <comment id="13975267" author="mcorgan" created="Sun, 20 Apr 2014 20:26:36 +0000"  >&lt;p&gt;&lt;blockquote&gt;&lt;p&gt;The key is, I suppose, that the entire scanner stack above StoreFileScanner always uses exactly one KV (the current one). If that were the case we could allocate and reuse a single KV object. Do I understand this correctly Matt Corgan?&lt;/p&gt;&lt;/blockquote&gt;Yes, that&apos;s my understanding too.&lt;/p&gt;

&lt;p&gt;&lt;blockquote&gt;&lt;p&gt;the entire scanner stack above StoreFileScanner always uses exactly one KV (the current one)&lt;/p&gt;&lt;/blockquote&gt;Well, there &lt;b&gt;may&lt;/b&gt; be exceptions where we may need to &quot;buffer&quot; a standalone KV/Cell, but it could be done lazily in the upper layers with KeyValueUtils.ensureKeyValue(cell) that does a deep-copy if needed.  It may be possible to filter out many cells before they need to be deep-copied.  On the other hand, maybe there are no exceptions.&lt;/p&gt;

&lt;p&gt;Looking at StoreFilescanner.next()&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Cell next() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
    Cell retKey = cur;

    &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
      &lt;span class=&quot;code-comment&quot;&gt;// only seek &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; we aren&apos;t at the end. cur == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; implies &apos;end&apos;.
&lt;/span&gt;      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (cur != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
        hfs.next();
        cur = hfs.getKeyValue();
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (hasMVCCInfo)
          skipKVsNewerThanReadpoint();
      }
    } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt;(IOException e) {
      &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IOException(&lt;span class=&quot;code-quote&quot;&gt;&quot;Could not iterate &quot;&lt;/span&gt; + &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;, e);
    }
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; retKey;
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;it looks like we&apos;re calling hfs.next() and then returning the result, which should be ok unless I&apos;m missing something (which is likely).  Ram said he had a problem here.&lt;/p&gt;

&lt;p&gt;but in KeyValueHeap.next()&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Cell next()  &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.current == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
    }
    Cell kvReturn = &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.current.next();
    Cell kvNext = &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.current.peek();
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (kvNext == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
      &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.current.close();
      &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.current = pollRealKV();
    } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
      KeyValueScanner topScanner = &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.heap.peek();
      &lt;span class=&quot;code-comment&quot;&gt;// no need to add current back to the heap &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; it is the only scanner left
&lt;/span&gt;      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (topScanner != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.comparator.compare(kvNext, topScanner.peek()) &amp;gt;= 0) {
        &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.heap.add(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.current);
        &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.current = pollRealKV();
      }
    }
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; kvReturn;
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;i get confused.  We are simultaneously holding a reference to kvReturn and kvNext which would not be allowed.  This definitely looks like a problem - maybe it&apos;s possible to do this lazily.&lt;/p&gt;</comment>
                            <comment id="13975391" author="ram_krish" created="Mon, 21 Apr 2014 04:59:21 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mcorgan&quot; class=&quot;user-hover&quot; rel=&quot;mcorgan&quot;&gt;Matt Corgan&lt;/a&gt;&lt;br/&gt;
Yes Matt.  The below code in KeyValueHeap.next(), &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Cell next()  &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.current == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
    }
    Cell kvReturn = &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.current.next();
    Cell kvNext = &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.current.peek();
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (kvNext == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
      &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.current.close();
      &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.current = pollRealKV();
    } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
      KeyValueScanner topScanner = &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.heap.peek();
      &lt;span class=&quot;code-comment&quot;&gt;// no need to add current back to the heap &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; it is the only scanner left
&lt;/span&gt;      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (topScanner != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.comparator.compare(kvNext, topScanner.peek()) &amp;gt;= 0) {
        &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.heap.add(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.current);
        &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.current = pollRealKV();
      }
    }
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; kvReturn;
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Would internally use StoreFileScanner.next().  There you could see we are holding a reference to the current &apos;cur&apos; in &apos;retKey&apos; and the &apos;cur&apos; gets changed and we return &apos;retKey&apos;. But the KeyValueHeap.next() would need the retKey and also the new &apos;cur&apos; stored as kvNext. See the this.current.next() is kvReturn but the peek() actually returns the next() value. Lazily doing the deep clone is definitely beneficial in places where we need to do the comparisons before fetching the next KV. &lt;br/&gt;
In cases without DBEs, there is already no deep copying happening because we are referring to the same internal BB except for the offset and lengths changed.  Only for DBE&apos;s read code path we have this issue.&lt;/p&gt;</comment>
                            <comment id="13975400" author="ram_krish" created="Mon, 21 Apr 2014 05:14:29 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The &quot;16.7.2.2. Medium Tests&quot; in refguide has medium tests taking &amp;lt; 50 seconds. FYI.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Okie.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;So except for the common bytes the remaining bytes are copied for every next().&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I mentioned this in my comment in relation to the current code that is existing. &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I just see us copying the full key, not the difference. Am I looking in the wrong place boss?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;In the current patch we do copy the full key.  But existing code does not.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
current.ensureSpaceForKey();
        currentBuffer.get(current.keyBuffer, current.lastCommonPrefix,
            current.keyLength - current.lastCommonPrefix);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;See here.  The current.keyBuffer is filled up from the offset marked by current.lastCommonPrefix.  which means if there are 25 bytes in common with the previous KV, we do not get those 25 bytes from the current buffer.(because it would not have that) and so the current.keyBuffer does not get filled up with those common 25 bytes.  It starts filling up from 26th byte onwards. &lt;br/&gt;
Same you could see with the other encoders also.&lt;br/&gt;
The &apos;math&apos; that i saw was definitely better for scanning in case of &apos;gets&apos; it is having impacts.  But the main advantage is that you can work with Cells without having to copy the values in cases where the values are significantly higher in terms of number of bytes than the keys.&lt;/p&gt;</comment>
                            <comment id="13976405" author="lhofhansl" created="Tue, 22 Apr 2014 05:22:44 +0000"  >&lt;p&gt;I love the idea of pushing the decision to make a copy to the upper layers. That way we can delay extra copies to the point where they are actually needed (and maybe avoid the copies in some cases).&lt;/p&gt;</comment>
                            <comment id="14005849" author="ram_krish" created="Thu, 22 May 2014 12:00:25 +0000"  >&lt;p&gt;Can we have the existing way of comparison during gets and for scans take the new code.  We could try creating an interface that gets instantiated based on get/scan.&lt;/p&gt;</comment>
                            <comment id="14104116" author="ram_krish" created="Wed, 20 Aug 2014 16:54:11 +0000"  >&lt;p&gt;This one would be an important one in case we need to do Cell offheap. Will come up with an update soon.&lt;/p&gt;</comment>
                            <comment id="14160792" author="stack" created="Mon, 6 Oct 2014 19:29:30 +0000"  >&lt;p&gt;Where are we w/ this issue?&lt;/p&gt;</comment>
                            <comment id="14161646" author="ram_krish" created="Tue, 7 Oct 2014 08:47:57 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt;&lt;br/&gt;
This patch tries to avoid repeated key[] to be copied.  But for this patch to proceed we may have to find what could be the actual key length in that block so that we could create a key[] of that size and copy key to it.&lt;br/&gt;
Currently the copy happens to a 512 bytes size byte[] and this expands if needed. (Here a copy happens again).&lt;/p&gt;</comment>
                            <comment id="14162339" author="stack" created="Tue, 7 Oct 2014 19:14:07 +0000"  >&lt;blockquote&gt;&lt;p&gt;... what could be the actual key length in that block so that we could create a key[] of that size and copy key to it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Maybe we should write this out as metadata per block?&lt;/p&gt;

&lt;p&gt;Any reason for swap form byte [] to ByteBuffer?&lt;/p&gt;
</comment>
                            <comment id="14166209" author="ram_krish" created="Fri, 10 Oct 2014 03:01:45 +0000"  >&lt;blockquote&gt;&lt;p&gt;Maybe we should write this out as metadata per block?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes we need to.  But it should be the KV length before encoding.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Any reason for swap form byte [] to ByteBuffer?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Sorry am not getting this?  Which one you mean here?&lt;/p&gt;</comment>
                            <comment id="14166211" author="ram_krish" created="Fri, 10 Oct 2014 03:03:19 +0000"  >&lt;p&gt;Ok I got it. You mean in the patch?  Just wanted to create a buffer type of thing like we had an actual buffer in case of normal KV without encoding.  But that is not much important we can still go with a byte[].&lt;/p&gt;</comment>
                            <comment id="14172499" author="anoop.hbase" created="Wed, 15 Oct 2014 15:52:29 +0000"  >&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
       currentBuffer = buffer;
+      &lt;span class=&quot;code-comment&quot;&gt;// Allocate every time we get a &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; block
&lt;/span&gt;+      &lt;span class=&quot;code-comment&quot;&gt;// Would be great &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; from the block we know how much is key part and how
&lt;/span&gt;+      &lt;span class=&quot;code-comment&quot;&gt;// much is &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; value part(the unencoded one). If &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; value exceeds we
&lt;/span&gt;+      &lt;span class=&quot;code-comment&quot;&gt;// may need to &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; a copy
&lt;/span&gt;+      &lt;span class=&quot;code-comment&quot;&gt;// TODO : Get the unencoded key length from the hfileblock
&lt;/span&gt;+      current.keyBuffer = ByteBuffer.allocate(currentBuffer.capacity() * 16);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;We allocate a very big size buffer for the key? &apos;currentBuffer&apos; is the buffer containing the whole block data and we allocate 16 times bigger buffer! Not getting why you want this Ram.&lt;/p&gt;</comment>
                            <comment id="14516343" author="anoop.hbase" created="Tue, 28 Apr 2015 04:43:28 +0000"  >&lt;blockquote&gt;&lt;p&gt;The idea here is to replace the key byte[] as ByteBuffer and create a consecutive stream of the keys (currently the same byte[] is used and hence the copy). Use offset and length to track this key bytebuffer.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;That means the key buffer will grow always right? I think some sort of copy and reconstruction is needed in the key part and we can not avoid that.  &lt;/p&gt;</comment>
                            <comment id="14516379" author="ram_krish" created="Tue, 28 Apr 2015 05:08:02 +0000"  >&lt;p&gt;With all these large memory coming in - if we really know how much was the exact bytes that was encoded we could create those many BBs offheap, then we could move the decoded key bytes to this offheap in a consecutive manner rather than have to use the same byte[] which internally leads to do a deep copy when ever we want to use it in a getKeyValue() call.&lt;/p&gt;</comment>
                            <comment id="14516446" author="anoop.hbase" created="Tue, 28 Apr 2015 06:02:10 +0000"  >&lt;blockquote&gt;&lt;p&gt;if we really know how much was the exact bytes that was encoded we could create those many BBs offheap,&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;You mean create one BB of that much size I believe.   Then that will be too much of memory consumption no? You are doubling (in fact more that double) the memory need for the scan.  I think that will be a problem.&lt;/p&gt;</comment>
                            <comment id="14516468" author="ram_krish" created="Tue, 28 Apr 2015 06:15:14 +0000"  >&lt;p&gt;Ya that is true.  But with large memories coming up we will be able to do that? And ensure it is always offheap, something like that?  Anyway for that to be done we need to have an info on the Hfileblock.  &lt;/p&gt;</comment>
                            <comment id="14516488" author="anoop.hbase" created="Tue, 28 Apr 2015 06:26:07 +0000"  >&lt;p&gt;IMO creating a BB of size equal to sum of all keys is an overkill.  May be some optimizations which we can do in this area is proper sizing of the key temp byte[].  If we know the max key size in advance, we are sure we wont make a much bigger key temp byte[] and also no need for grow when size is not enough and no size limit checks..    IMO those are worth trying improvements.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12724166">HBASE-11425</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12702557">HBASE-10801</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12640301" name="HBASE-10974_1.patch" size="72333" author="ram_krish" created="Tue, 15 Apr 2014 17:20:41 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 15 Apr 2014 16:53:23 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>386654</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            1 year, 33 weeks, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1ulwv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>386918</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>