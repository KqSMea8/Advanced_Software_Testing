<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 18:57:37 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-1938/HBASE-1938.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-1938] Make in-memory table scanning faster</title>
                <link>https://issues.apache.org/jira/browse/HBASE-1938</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;This issue is about profiling hbase to see if I can make hbase scans run faster when all is up in memory.  Talking to some users, they are seeing about 1/4 million rows a second.  It should be able to go faster than this (Scanning an array of objects, they can do about 4-5x this).&lt;/p&gt;</description>
                <environment></environment>
        <key id="12439129">HBASE-1938</key>
            <summary>Make in-memory table scanning faster</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.png">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="nkeywal">Nicolas Liochon</assignee>
                                    <reporter username="stack">stack</reporter>
                        <labels>
                    </labels>
                <created>Tue, 27 Oct 2009 00:08:42 +0000</created>
                <updated>Fri, 20 Nov 2015 13:01:33 +0000</updated>
                            <resolved>Wed, 27 Jul 2011 17:51:54 +0000</resolved>
                                                    <fixVersion>0.90.4</fixVersion>
                    <fixVersion>0.92.0</fixVersion>
                                    <component>Performance</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>16</watches>
                                                                <comments>
                            <comment id="12774415" author="stack" created="Fri, 6 Nov 2009 21:29:01 +0000"  >&lt;p&gt;Some reputable lads have been looking at in-memory scanning and have turned up some interesting observations:&lt;/p&gt;

&lt;p&gt;+ Getting values out of the block cache is way faster than getting them out of MemStore &amp;#8211; even though the values are prefabricated as KVs in MemStore and have to be instantiated when pulling from the block cache.&lt;br/&gt;
+ Getting values out of the block cache is way faster than getting values out of preloaded custom-MemStore that sits in front of our current MemStore &amp;#8211; with its handling of snapshot.&lt;br/&gt;
+ Getting values out of the block cache is faster than getting values from a plain Set of KVs (!!!)&lt;/p&gt;

&lt;p&gt;&quot;I&apos;ve noticed that the MemStoreScanner implementation is very inefficient: it basically does a search for each row since it calls tailSet. IMO this should be changed - memstore snapshots should be handles as a special case and not slow down all scans.&quot;&lt;/p&gt;

&lt;p&gt;Getting rid of the tailsetting &amp;#8211; keeping the tailset for life of scan &amp;#8211; improved MemStore performance by 40%.&lt;/p&gt;

&lt;p&gt;Other observations:&lt;/p&gt;

&lt;p&gt;+ We copy row out of KV to do compares more than once during processing of a Scan (Add a counter to see for sure). Maybe we can avoid above by using a Comparator that can do the compare in place?&lt;br/&gt;
+ Looking for equality, it might be faster comparing from end to start rather than from start to end since more often, its in the tail the difference is:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
   &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; equals(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; [] left, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; [] right) {
     &lt;span class=&quot;code-comment&quot;&gt;// Could use Arrays.equals?
&lt;/span&gt;-    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; left == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; right == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;? &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;:
-      (left == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; || right == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; || (left.length != right.length))? &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;:
-        compareTo(left, right) == 0;
+    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( left == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; right == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;? &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;:
+      (left == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; || right == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; || (left.length != right.length))? &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;: &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;) {
+    &lt;span class=&quot;code-comment&quot;&gt;// compre from end to start since we usually compare &apos;close&apos; bytes
&lt;/span&gt;+    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; last = left.length-1;
+    &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i=last; i&amp;gt;=0; i--){
+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (left[i] != right[i]) {
+        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
+      }
+    }
+      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
+    }
+    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
   }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="12776201" author="stack" created="Wed, 11 Nov 2009 00:50:55 +0000"  >&lt;p&gt;A little test that loads up a MemStore then does a Scan.  For profiling.&lt;/p&gt;</comment>
                            <comment id="12778529" author="stack" created="Mon, 16 Nov 2009 20:59:50 +0000"  >&lt;p&gt;Profiling in-memory scanning of MemStore:&lt;/p&gt;

&lt;p&gt;+ All time is in cacheNextRow as you&apos;d expect.  41% of CPU is doing SortedSet#first, 24% in making an Iterator, and 22% doing the isEmpty test (which calls the #first method).   Each of these methods end up in KVComparator.compare.  All our scanning time is doing compares.  Alot of time is spent making up ints and longs out of bytes; e.g. getKeyLength and getRowLength.  I can see that some of these constructions &amp;#8211; e.g. getKeyLength &amp;#8211; happen multiple times in a single scan for a single KV (imagine if multiple concurrent scans).  This would seem to argue that we cache the construction of lengths but there&apos;d be an associated memory cost.... maybe do it for just a few of these lengths?  Key length?  For example, calculating keylength once on construction would seem to make scanning near 30% faster in simple test.&lt;/p&gt;

&lt;p&gt;Without caching of KeyLength:&lt;/p&gt;

&lt;p&gt;Loaded&lt;br/&gt;
Scan: 2406&lt;br/&gt;
Scan: 1685&lt;br/&gt;
Scan: 1656&lt;br/&gt;
Scan: 1655&lt;br/&gt;
Scan: 1646&lt;br/&gt;
Scan: 1647&lt;br/&gt;
Scan: 1646&lt;/p&gt;


&lt;p&gt;With caching of KeyLength:&lt;br/&gt;
Loaded&lt;br/&gt;
Scan: 1970&lt;br/&gt;
Scan: 1282&lt;br/&gt;
Scan: 1292&lt;br/&gt;
Scan: 1252&lt;br/&gt;
Scan: 1273&lt;br/&gt;
Scan: 1272&lt;br/&gt;
Scan: 1284&lt;br/&gt;
Scan: 1220&lt;br/&gt;
..&lt;/p&gt;

&lt;p&gt;Let me attach patches that have amended test and the change I made to KV.&lt;/p&gt;

&lt;p&gt;+ The &quot;reputable lads&quot; mentioned above think our getting tailSet for each cache of row content is wasteful, that we should be able do to better &amp;#8211; say take out iterator once and keep it for life of the Scanner.  On snapshot, we&apos;d have to poke all outstanding Scanners to readjust themselves.  Looking at the numbers, though actually taking a tailset is surprisingly inexpensive, the tests for isEmpty and creation of Iterator each time are bulk of CPU.  Let me play with changing the MemStoreScanner implementation to be just a set.&lt;/p&gt;</comment>
                            <comment id="12778534" author="stack" created="Mon, 16 Nov 2009 21:01:39 +0000"  >&lt;p&gt;Small change to KV.  Uses 8 bytes more memory to cache Key Length.&lt;/p&gt;</comment>
                            <comment id="12778535" author="stack" created="Mon, 16 Nov 2009 21:02:15 +0000"  >&lt;p&gt;My little perpetual scanning test.&lt;/p&gt;</comment>
                            <comment id="12867005" author="stack" created="Thu, 13 May 2010 04:41:40 +0000"  >&lt;p&gt;Moved from 0.21 to 0.22 just after merge of old 0.20 branch into TRUNK.&lt;/p&gt;</comment>
                            <comment id="13009374" author="stack" created="Mon, 21 Mar 2011 20:55:07 +0000"  >&lt;p&gt;Moved out of 0.92 (It looks like Andrew Purtell and Dhruba have revived interest in this issue &amp;#8211; let them bring it back in if its same thing).&lt;/p&gt;</comment>
                            <comment id="13069626" author="nkeywal" created="Fri, 22 Jul 2011 17:14:52 +0000"  >&lt;p&gt;I modified the unit test to make it work with the trunk as it is today (new file attached). It worth reviewing, I set a magic value for setThreadReadPoint, I don&apos;t know if it is the right thing to do.&lt;/p&gt;

&lt;p&gt;I also added a loop on the list size to make visible any exponential cost.&lt;/p&gt;

&lt;p&gt;On a scan the &quot;next()&quot; part, the hbase currently compare the value of two internals iterators. In this test, the second list is always empty, hence the cost on comparator is lowered vs. real life. I don&apos;t know if it is a side effect of my modifications.&lt;/p&gt;

&lt;p&gt;There is a trival optimization in the &quot;seek&quot; function.&lt;br/&gt;
      KeyValue lowest = getLowest();&lt;br/&gt;
      return lowest != null;&lt;/p&gt;

&lt;p&gt;Could be replaced by:&lt;br/&gt;
return (kvsetNextRow != null || snapshotNextRow != null);&lt;/p&gt;

&lt;p&gt;But I don&apos;t think it worth a patch just for this (it should be included in a bigger patch hoewever). If you think differently, I can do it.&lt;/p&gt;
</comment>
                            <comment id="13070067" author="stack" created="Sat, 23 Jul 2011 22:21:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;I modified the unit test to make it work with the trunk as it is today (new file attached).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thanks.&lt;/p&gt;

&lt;p&gt;Reviewing it, one thing you might want to do is study classes in hbase so get gist of the hadoop/hbase style.  Notice how they have two spaces for tabs, ~80 chars a line.  But thats for future.  Not important here.&lt;/p&gt;

&lt;p&gt;You just need to make sure your KVs have a readPoint that is less than the current readPoint.  It looks like you are making KVs w/o setting memstorets.  Default then is used and its zero.   The default read point is zero.  The compare is &amp;lt;= so it looks like you don&apos;t need to set the read point at all.  What you have should be no harm.&lt;/p&gt;

&lt;p&gt;Your new test class seems fine.  Would be nice to add more tests.  As memstore data structure grows, all slows.&lt;/p&gt;

&lt;p&gt;Another issue is about hacking on the concurrentskiplistset that is memstore to make it more suited to our accesses and perhaps to make it go faster (its public domain when you dig down into the java src).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;On a scan the &quot;next()&quot; part, the hbase currently compare the value of two internals iterators. In this test, the second list is always empty, hence the cost on comparator is lowered vs. real life.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What is this that you are referring too?  Is it this? KeyValue kv = scanner.next();&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But I don&apos;t think it worth a patch just for this (it should be included in a bigger patch hoewever).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Up to you but yes, the above is probably the way to go.&lt;/p&gt;

&lt;p&gt;Thanks N.&lt;/p&gt;</comment>
                            <comment id="13070371" author="vams" created="Mon, 25 Jul 2011 08:46:43 +0000"  >&lt;p&gt;Hi stack, how can we perform lookup/scanning in HBase? can we use Distributed Hashing (DHT) for that? I want to implement scalable data structure i.e DHT in HBase, for how can i proceed? please help me..Thank you&lt;/p&gt;</comment>
                            <comment id="13070458" author="nkeywal" created="Mon, 25 Jul 2011 12:23:10 +0000"  >&lt;p&gt;Hello Stack,&lt;/p&gt;

&lt;p&gt;accesses and perhaps to make it go faster.&lt;br/&gt;
I will have a look at it, I see as well in this test and in the global&lt;br/&gt;
profiling that a lot of time is spent on it.&lt;/p&gt;


&lt;p&gt;scanner.next();&lt;/p&gt;

&lt;p&gt;There are two iterators in the class(kvsetIt and snapshotIt), and getLowest&lt;br/&gt;
compare the two to return the lowest. However, in this test, one of the list&lt;br/&gt;
is empty, so the value is null, and hence the real comparison on byte[] is&lt;br/&gt;
not executed.&lt;/p&gt;

&lt;p&gt;On this subject, there is a possible optimisation on the function &quot;peek&quot;,&lt;br/&gt;
that will repeat the comparison: if peek is called multiple time, of if we&lt;br/&gt;
often have peek() then next(), we can save the redundant comparisons. To me,&lt;br/&gt;
it makes sense to precalculate the value returned by &quot;peek&quot;, and reuse it in&lt;br/&gt;
next().&lt;/p&gt;



&lt;p&gt;The profiling (method: sampling, java inlining desactivated) says something&lt;br/&gt;
interesting:&lt;/p&gt;

&lt;p&gt;Name;     total time spent&lt;br/&gt;
org.apache.hadoop.hbase.regionserver.MemStore$MemStoreScanner.next()    100%&lt;br/&gt;
org.apache.hadoop.hbase.regionserver.MemStore$MemStoreScanner.getNext(Iterator)&lt;br/&gt;
88%&lt;br/&gt;
org.apache.hadoop.hbase.regionserver.KeyValueSkipListSet$MapEntryIterator.next()&lt;br/&gt;
44%&lt;br/&gt;
java.util.concurrent.ConcurrentSkipListMap$SubMap$SubMapEntryIterator.next()&lt;br/&gt;
36%&lt;br/&gt;
org.apache.hadoop.hbase.regionserver.ReadWriteConsistencyControl.getThreadReadPoint()&lt;br/&gt;
26%&lt;br/&gt;
java.lang.ThreadLocal.get()    21%&lt;br/&gt;
org.apache.hadoop.hbase.regionserver.KeyValueSkipListSet$MapEntryIterator.hasNext()&lt;br/&gt;
8%&lt;br/&gt;
org.apache.hadoop.hbase.regionserver.MemStore$MemStoreScanner.getLowest()&lt;br/&gt;
7%&lt;br/&gt;
java.util.concurrent.ConcurrentSkipListMap$SubMap$SubMapIter.hasNext()    3%&lt;br/&gt;
org.apache.hadoop.hbase.regionserver.MemStore$MemStoreScanner.getLower(KeyValue,&lt;br/&gt;
KeyValue)    3%&lt;br/&gt;
java.lang.Long.longValue()    2%&lt;/p&gt;



&lt;p&gt;So we&apos;re spending 26% of the time on this:&lt;br/&gt;
org.apache.hadoop.hbase.regionserver.ReadWriteConsistencyControl.getThreadReadPoint()&lt;br/&gt;
26%&lt;/p&gt;

&lt;p&gt;And in this getThreadReadPoint(), the actual time is spent in:&lt;br/&gt;
java.lang.ThreadLocal.get()    21%&lt;/p&gt;

&lt;p&gt;It&apos;s a TLS, so we can expect a system call to get the thread id. It would be&lt;br/&gt;
great to save this system call in a next().&lt;/p&gt;

&lt;p&gt;There is at least an improvement for the case when one of the list is done:&lt;br/&gt;
don&apos;t get the data getThreadReadPoint(). That would not change the behaviour&lt;br/&gt;
at all, but would already be interesting (may be 10% in this test).&lt;br/&gt;
Another option is to share getThreadReadPoint() value for the two iterators,&lt;br/&gt;
i.e. read the value in the next() function, and give it as a parameter to&lt;br/&gt;
getNext(). In fact, as this value seems to be a TLS, I don&apos;t see how it&lt;br/&gt;
could change during the execution of next(). What do you think?&lt;br/&gt;
Last question on this: what is the use case when the getThreadReadPoint()&lt;br/&gt;
will change during the whole scan (i.e.: between next)?&lt;/p&gt;


&lt;p&gt;Most of the public methods (except reseek) are &quot;synchronized&quot;, it implies&lt;br/&gt;
that the scanner can be shared between threads?&lt;/p&gt;


&lt;p&gt;At the end, it seems that there are 3 possible things to do:&lt;br/&gt;
1) Replacement of KeyValue lowest = getLowest();&lt;br/&gt;
2) theNext precalculation for peek() and next()&lt;br/&gt;
3) Depending on your feedback, one of the options above on&lt;br/&gt;
getThreadReadPoint().&lt;/p&gt;

&lt;p&gt;This should give 5 to 15% increase in performances, not a &quot;problem solved&quot;&lt;br/&gt;
stuff, but could justify a first patch. I can do it (with the hbase&lt;br/&gt;
indenting &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;



&lt;p&gt;On Sun, Jul 24, 2011 at 12:23 AM, stack (JIRA) &amp;lt;jira@apache.org&amp;gt; wrote:&lt;/p&gt;
</comment>
                            <comment id="13070819" author="stack" created="Mon, 25 Jul 2011 22:20:55 +0000"  >&lt;blockquote&gt;&lt;p&gt;To me, it makes sense to precalculate the value returned by &quot;peek&quot;, and reuse it in next().&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If there is no chance of the value changing between the peek and next, it sounds good (I&apos;ve not looked at this code in a while).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It would be great to save this system call in a next().&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes (I like how you figure there&apos;s a system call doing thread local get).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In fact, as this value seems to be a TLS, I don&apos;t see how it could change during the execution of next(). What do you think?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;(I&apos;m being lazy.  I&apos;ve not looked at the code).  The updates to RWCC happen at well-defined points so should be easy enough to elicit if there is a problem w/ your presumption above.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Last question on this: what is the use case when the getThreadReadPoint() will change during the whole scan (i.e.: between next)?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;IIRC, we want to let the scan see the most up-to-date view on a row though our guarantees are less than this (See &lt;a href=&quot;http://hbase.apache.org/acid-semantics.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hbase.apache.org/acid-semantics.html&lt;/a&gt;).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Most of the public methods (except reseek) are &quot;synchronized&quot;, it implies that the scanner can be shared between threads?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That seems like a valid deduction to make.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1) Replacement of KeyValue lowest = getLowest();&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You mean in MemStore#reseek?  What would you put in its place (Sorry if I&apos;m not following the bouncing ball properly).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;...don&apos;t get the data getThreadReadPoint()&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So, we&apos;d just hold to the current read point for how long?  The full scan?  That might be possible given our lax guarantees above though it would be nice to not have to give up on up to the millisecond views on rows.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Another option is to share getThreadReadPoint() value for the two iterators, i.e. read the value in the next() function, and give it as a parameter to getNext()&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What are the &apos;two iterators&apos; here?&lt;/p&gt;

&lt;p&gt;Sorry N, I don&apos;t have my head as deep in this stuff as you do currently so my questions and answers above may be off.  Please compensate appropriately.&lt;/p&gt;</comment>
                            <comment id="13070829" author="yuzhihong@gmail.com" created="Mon, 25 Jul 2011 22:35:39 +0000"  >&lt;blockquote&gt;&lt;p&gt;1) Replacement of KeyValue lowest = getLowest();&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;It is in the &quot;seek&quot; function&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Another option is to share getThreadReadPoint() value for the two iterators&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;N was talking about the following code in MemStore.next():&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (theNext == kvsetNextRow) {
        kvsetNextRow = getNext(kvsetIt);
      } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
        snapshotNextRow = getNext(snapshotIt);
      }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The initiative was to save the system call.&lt;/p&gt;</comment>
                            <comment id="13070987" author="nkeywal" created="Tue, 26 Jul 2011 08:12:10 +0000"  >&lt;p&gt;I will write the patch, that will be simpler &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;What is yet not clear to me is what we can expect when there are multiple threads using the same scanner, as the &quot;readPoint&quot; is a TLS. However, the patch will not change the current behavior.&lt;/p&gt;
</comment>
                            <comment id="13071196" author="nkeywal" created="Tue, 26 Jul 2011 16:19:22 +0000"  >&lt;p&gt;I have an improvement that could make a real difference.&lt;/p&gt;

&lt;p&gt;In Hbase, there is an iterator called MapEntryIterator, that acts in reality as a ValueIterator&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;static class MapEntryIterator implements Iterator&amp;lt;KeyValue&amp;gt;
    private final Iterator&amp;lt;Map.Entry&amp;lt;KeyValue, KeyValue&amp;gt;&amp;gt; iterator;

    public KeyValue next() {
      return this.iterator.next().getValue();
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt; 

&lt;p&gt;However, with the current implementation of the JDK, there is an important difference between an iterator on values and an iterator on entries. From java.util.concurrent we can see:&lt;/p&gt;


&lt;p&gt;The ValueIterator is straighforward:&lt;/p&gt;
    &lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;final class ValueIterator extends Iter&amp;lt;V&amp;gt; {
        public V next() {
            V v = nextValue;
            advance();
            return v;
        }
    }&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;While there is some defensive programming taking place for the EntryIterator, with the creation of an immutable object. &lt;/p&gt;
    &lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;final class EntryIterator extends Iter&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; {
        public Map.Entry&amp;lt;K,V&amp;gt; next() {
            Node&amp;lt;K,V&amp;gt; n = next;
            V v = nextValue;
            advance();
            return new AbstractMap.SimpleImmutableEntry&amp;lt;K,V&amp;gt;(n.key, v);
        }
    }&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt; 

&lt;p&gt;As a consequence, there is at least one object creation for every line in the hbase scanner. This creation is actually useless as we throw away the object immediatly. So, during the test several GC occur. I modified the MapEntryIterator implementation to iterate on the values.&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;static class MapEntryIterator implements Iterator&amp;lt;KeyValue&amp;gt; {
    private final Iterator&amp;lt;KeyValue&amp;gt; iterator;

    public KeyValue next() {
      return this.iterator.next();
    }&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The scan time is divided by 3 on the test. It can obviously be put to any arbitrary improvement ratio as it&apos;s driven by the GC execution, but it should be valuable in production as well.&lt;/p&gt;

&lt;p&gt;I am currently running the unit tests, I will add the patch if the execution is ok.&lt;/p&gt;
</comment>
                            <comment id="13071209" author="stack" created="Tue, 26 Jul 2011 16:40:21 +0000"  >&lt;p&gt;@nkeywal nice one!&lt;/p&gt;</comment>
                            <comment id="13071227" author="stack" created="Tue, 26 Jul 2011 17:13:50 +0000"  >&lt;p&gt;@nkeywal I&apos;m not as lazy this morning as I was yesterday so took a look at the java src.  Indeed that looks like a nice optimization.  Great stuff.&lt;/p&gt;</comment>
                            <comment id="13071363" author="nkeywal" created="Tue, 26 Jul 2011 21:09:38 +0000"  >&lt;p&gt;Thanks Stack! It could be considered as a JDK bug, as it makes the EntryIterator useless when you manipulate large lists. From a HBase point of view, there is anyway no need to use an EntryIterator so it&apos;s simpler.&lt;/p&gt;

&lt;p&gt;Here is the patch.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;20110726_1938_KeyValueSkipListSet.patch : Use the native ValueIterator instead of a wrapper on EntryIterator, suppression an object creation for each call to the iterator.&lt;/li&gt;
	&lt;li&gt;20110726_1938_MemStoreScanPerformance.java : Simple test case to measure scan performances&lt;/li&gt;
	&lt;li&gt;20110726_1938_MemStore.patch : multiple small performance improvements on MemStoreScanner&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;It&apos;s obviously worth a review, especially the last one... Unit tests run fine.&lt;/p&gt;</comment>
                            <comment id="13071367" author="nkeywal" created="Tue, 26 Jul 2011 21:11:29 +0000"  >&lt;p&gt;    20110726_1938_KeyValueSkipListSet.patch : Use the native ValueIterator instead of a wrapper on EntryIterator, suppression an object creation for each call to the iterator.&lt;br/&gt;
    20110726_1938_MemStoreScanPerformance.java : Simple test case to measure scan performances&lt;br/&gt;
    20110726_1938_MemStore.patch : multiple small performance improvements on MemStoreScanner&lt;/p&gt;</comment>
                            <comment id="13071484" author="stack" created="Wed, 27 Jul 2011 02:08:35 +0000"  >&lt;p&gt;On 20110726_1938_MemStore.patch:&lt;/p&gt;

&lt;p&gt;FYI, in future, just remove code rather than commment it out: i.e. +      //long readPoint = ReadWriteConsistencyControl.getThreadReadPoint();&lt;/p&gt;

&lt;p&gt;The &apos;thenext&apos; data member looks fine to me.  Worst that could happen is that we lag the read point slightly though unlikely (&apos;theNext&apos; ain&apos;t best name but I see you are just taking the old local variable name so not your malnaming... no worries).&lt;/p&gt;

&lt;p&gt;Any chance of our calling a &apos;next&apos; without doing a &apos;seek&apos; first (or a reseek)?  Am worried we&apos;d trip on a null theNext.&lt;/p&gt;

&lt;p&gt;If seek has a synchronized, yeah, reseek should too &amp;#8211; good one.&lt;/p&gt;

&lt;p&gt;I&apos;m good with committing this.  We have a bunch of tests that should vomit if stuff comes back out of order or not what we expect (If this does prove to break things, then we are lacking key coverage and lets address it then).&lt;/p&gt;

&lt;p&gt;I&apos;ll let it hang out a day.  Someone else might have an opinion in here.&lt;/p&gt;</comment>
                            <comment id="13071486" author="stack" created="Wed, 27 Jul 2011 02:10:35 +0000"  >&lt;p&gt;+1 on 20110726_1938_KeyValueSkipListSet.patch  It looks great.  Will commit when commit On 20110726_1938_MemStore.patch so can then close this issue.  Nice work nkeywal.&lt;/p&gt;</comment>
                            <comment id="13071487" author="stack" created="Wed, 27 Jul 2011 02:14:01 +0000"  >&lt;p&gt;Assigning nkeywal. Marking patch available against 0.92.&lt;/p&gt;</comment>
                            <comment id="13071842" author="nkeywal" created="Wed, 27 Jul 2011 16:33:46 +0000"  >
&lt;blockquote&gt;&lt;p&gt;Any chance of our calling a &apos;next&apos; without doing a &apos;seek&apos; first (or a reseek)? Am worried we&apos;d trip on a null theNext.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I compared with the previous version, the new implementation behaves as the previous one and returns a nice &quot;null&quot;. &lt;/p&gt;
</comment>
                            <comment id="13071890" author="stack" created="Wed, 27 Jul 2011 17:51:54 +0000"  >&lt;p&gt;Committed to TRUNK.  Nice one nkeywal (I closed this issue.  Lets open new ones if you find new stuff).&lt;/p&gt;</comment>
                            <comment id="13071973" author="hudson" created="Wed, 27 Jul 2011 20:18:58 +0000"  >&lt;p&gt;Integrated in HBase-TRUNK #2056 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-TRUNK/2056/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-TRUNK/2056/&lt;/a&gt;)&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1938&quot; title=&quot;Make in-memory table scanning faster&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1938&quot;&gt;&lt;del&gt;HBASE-1938&lt;/del&gt;&lt;/a&gt; Make in-memory table scanning faster&lt;/p&gt;

&lt;p&gt;stack : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/trunk/CHANGES.txt&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/MemStore.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/KeyValueSkipListSet.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13071991" author="apurtell" created="Wed, 27 Jul 2011 20:41:31 +0000"  >&lt;p&gt;20110726_1938* apply cleanly to 0.90 as well. I&apos;ve applied them and am investigating. Will commit to branch if the results test clean and there seems to be a benefit.&lt;/p&gt;</comment>
                            <comment id="13072025" author="tlipcon" created="Wed, 27 Jul 2011 21:23:57 +0000"  >&lt;p&gt;The iterator one seems like a no-brainer for branch... the bits that change the read-point seem a little scary for branch since they can affect subtle consistency bugs&lt;/p&gt;</comment>
                            <comment id="13072046" author="apurtell" created="Wed, 27 Jul 2011 21:55:22 +0000"  >&lt;blockquote&gt;&lt;p&gt;the bits that change the read-point seem a little scary for branch since they can affect subtle consistency bugs&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree and my testing seems to show a small performance loss in most runs with the MemStore changes applied. So only the iterator change and the benchmark will go in.&lt;/p&gt;</comment>
                            <comment id="13072051" author="apurtell" created="Wed, 27 Jul 2011 22:06:29 +0000"  >&lt;p&gt;Applied 20110726_1938_KeyValueSkipListSet and 20110726_1938_MemStoreScanPerformance to 0.90 branch.&lt;/p&gt;
</comment>
                            <comment id="13072052" author="nkeywal" created="Wed, 27 Jul 2011 22:09:17 +0000"  >&lt;p&gt;Ok, that&apos;s strange. This patch includes multiple small modifications. One of&lt;br/&gt;
them must be have a side effect on something. Is there any test on which the&lt;br/&gt;
loss is more visible?&lt;/p&gt;

&lt;p&gt;What would be the scenario with a change on the consistency?&lt;/p&gt;

&lt;p&gt;On Wed, Jul 27, 2011 at 11:57 PM, Andrew Purtell (JIRA)&lt;br/&gt;
&amp;lt;jira@apache.org&amp;gt;wrote:at&lt;/p&gt;
</comment>
                            <comment id="13072057" author="apurtell" created="Wed, 27 Jul 2011 22:16:04 +0000"  >&lt;p&gt;I ran 3 consecutive tests with MemStore changes applied, or not. Then after seeing results I did not expect &amp;#8211; longer run times for both loading and scanning with the MemStore changes applied and higher per-op latencies (e.g. 38 ms vs 44 ms) &amp;#8211; I ran another set of 5 runs. The results of all but one were consistent. This was not a rigorous test I suppose, I didn&apos;t try it on another server, because I was already skeptical of the wisdom of changing how the read point is done on branch.&lt;/p&gt;</comment>
                            <comment id="13072058" author="stack" created="Wed, 27 Jul 2011 22:19:46 +0000"  >&lt;p&gt;Let me back out application of MemStore patch till we figure whats up.&lt;/p&gt;</comment>
                            <comment id="13072061" author="stack" created="Wed, 27 Jul 2011 22:21:46 +0000"  >&lt;p&gt;Reverted 20110726_1938_MemStore.patch for now on TRUNK (left iterator in place)&lt;/p&gt;</comment>
                            <comment id="13072064" author="nkeywal" created="Wed, 27 Jul 2011 22:27:09 +0000"  >&lt;p&gt;Yes, I can provide a patch with all the changes except the one on readPoint.&lt;br/&gt;
(I will test it first) Andrew, when you&apos;re saying there is a loss on your&lt;br/&gt;
test, are you running all the unit tests, only the ones on region server,&lt;br/&gt;
only the one on scan performance, or another set?&lt;/p&gt;

</comment>
                            <comment id="13072073" author="apurtell" created="Wed, 27 Jul 2011 22:37:16 +0000"  >&lt;p&gt;This is a representative test with 0.90 branch.&lt;/p&gt;

&lt;p&gt;With 20110726_1938_MemStore.patch:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;JUnit version 4.8.1
.Loaded in 1158 ms
Scan with size 50000: 61 ms
Scan with size 50000: 91 ms
Scan with size 50000: 35 ms
Scan with size 50000: 23 ms
Scan with size 50000: 24 ms
Scan with size 50000: 22 ms
Scan with size 50000: 22 ms
Scan with size 50000: 23 ms
Scan with size 50000: 22 ms
Scan with size 50000: 23 ms
Loaded in 1709 ms
Scan with size 75000: 31 ms
Scan with size 75000: 30 ms
Scan with size 75000: 30 ms
Scan with size 75000: 29 ms
Scan with size 75000: 30 ms
Scan with size 75000: 30 ms
Scan with size 75000: 30 ms
Scan with size 75000: 30 ms
Scan with size 75000: 29 ms
Scan with size 75000: 29 ms
Loaded in 2099 ms
Scan with size 100000: 36 ms
Scan with size 100000: 38 ms
Scan with size 100000: 38 ms
Scan with size 100000: 35 ms
Scan with size 100000: 35 ms
Scan with size 100000: 34 ms
Scan with size 100000: 35 ms
Scan with size 100000: 34 ms
Scan with size 100000: 34 ms
Scan with size 100000: 38 ms
Loaded in 2813 ms
Scan with size 125000: 45 ms
Scan with size 125000: 44 ms
Scan with size 125000: 53 ms
Scan with size 125000: 44 ms
Scan with size 125000: 44 ms
Scan with size 125000: 44 ms
Scan with size 125000: 44 ms
Scan with size 125000: 44 ms
Scan with size 125000: 44 ms
Scan with size 125000: 45 ms
Loaded in 3456 ms
Scan with size 150000: 54 ms
Scan with size 150000: 51 ms
Scan with size 150000: 50 ms
Scan with size 150000: 50 ms
Scan with size 150000: 50 ms
Scan with size 150000: 52 ms
Scan with size 150000: 50 ms
Scan with size 150000: 50 ms
Scan with size 150000: 51 ms
Scan with size 150000: 50 ms
Total load time: 11235 ms (i.e:11 seconds)
Total scan time: 1959 ms (i.e:1 seconds)
Rows scanned per seconds: 2552322
Rows loaded per seconds: 445037

Time: 13.515

OK (1 test)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Without 20110726_1938_MemStore.patch:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;JUnit version 4.8.1
.Loaded in 1197 ms
Scan with size 50000: 51 ms
Scan with size 50000: 119 ms
Scan with size 50000: 21 ms
Scan with size 50000: 22 ms
Scan with size 50000: 22 ms
Scan with size 50000: 22 ms
Scan with size 50000: 21 ms
Scan with size 50000: 22 ms
Scan with size 50000: 22 ms
Scan with size 50000: 22 ms
Loaded in 1496 ms
Scan with size 75000: 31 ms
Scan with size 75000: 32 ms
Scan with size 75000: 29 ms
Scan with size 75000: 29 ms
Scan with size 75000: 30 ms
Scan with size 75000: 30 ms
Scan with size 75000: 37 ms
Scan with size 75000: 30 ms
Scan with size 75000: 30 ms
Scan with size 75000: 30 ms
Loaded in 2160 ms
Scan with size 100000: 33 ms
Scan with size 100000: 32 ms
Scan with size 100000: 33 ms
Scan with size 100000: 32 ms
Scan with size 100000: 32 ms
Scan with size 100000: 33 ms
Scan with size 100000: 32 ms
Scan with size 100000: 33 ms
Scan with size 100000: 32 ms
Scan with size 100000: 34 ms
Loaded in 2720 ms
Scan with size 125000: 42 ms
Scan with size 125000: 51 ms
Scan with size 125000: 41 ms
Scan with size 125000: 42 ms
Scan with size 125000: 41 ms
Scan with size 125000: 42 ms
Scan with size 125000: 42 ms
Scan with size 125000: 41 ms
Scan with size 125000: 41 ms
Scan with size 125000: 43 ms
Loaded in 3518 ms
Scan with size 150000: 49 ms
Scan with size 150000: 49 ms
Scan with size 150000: 50 ms
Scan with size 150000: 49 ms
Scan with size 150000: 50 ms
Scan with size 150000: 49 ms
Scan with size 150000: 49 ms
Scan with size 150000: 50 ms
Scan with size 150000: 49 ms
Scan with size 150000: 49 ms
Total load time: 11091 ms (i.e:11 seconds)
Total scan time: 1895 ms (i.e:1 seconds)
Rows scanned per seconds: 2638522
Rows loaded per seconds: 450815

Time: 13.375

OK (1 test)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13072085" author="nkeywal" created="Wed, 27 Jul 2011 22:57:09 +0000"  >&lt;p&gt;Thank you. It&apos;s interesting because the tests with 150000 entries are very&lt;br/&gt;
consistent. All the time ~49ms without the patch and ~51ms with the patch.&lt;br/&gt;
Could be hotspot related. Or not. I will have a look at this.&lt;/p&gt;

</comment>
                            <comment id="13072091" author="apurtell" created="Wed, 27 Jul 2011 23:07:13 +0000"  >&lt;p&gt;I see the same type of results with either Sun Java 1.6.0_26 or OpenJDK 1.6.0_22.&lt;/p&gt;</comment>
                            <comment id="13072284" author="nkeywal" created="Thu, 28 Jul 2011 10:22:14 +0000"  >&lt;p&gt;Ok, I understand what&apos;s going on.&lt;/p&gt;

&lt;p&gt;The enhancement on readPoint aims at calling a TLS once instead of twice by call to next().&lt;/p&gt;

&lt;p&gt;This should work well when the kvset and snapshot lists are not empty. However, in the unit test, the snapshot list is empty, so we were already calling the TLS only once before.&lt;/p&gt;

&lt;p&gt;I will write a second test to highlight the difference.&lt;/p&gt;


&lt;p&gt;This said, as Andrew and Todd think that a modification on readPoint could change the consistency behavior, I don&apos;t think it&apos;s worth doing the modification.  &lt;/p&gt;

&lt;p&gt;So if you aggree, I will:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;write a test with a non empty snapshot&lt;/li&gt;
	&lt;li&gt;provide a patch on MemStore with all the changes except the readPoint&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;With the iterator change, that makes a big boost on the scan perf already.&lt;/p&gt;</comment>
                            <comment id="13072402" author="stack" created="Thu, 28 Jul 2011 15:39:30 +0000"  >&lt;p&gt;Sounds great nkeywal.  Thanks for digging in here.&lt;/p&gt;</comment>
                            <comment id="13078369" author="nkeywal" created="Tue, 2 Aug 2011 19:05:13 +0000"  >&lt;p&gt;Test added to show the impact when the snapshot is not empty.&lt;/p&gt;

&lt;p&gt;Patch on MemStore.java, to optimize the &quot;peek()&quot; function by precalculating the next value. Improve the performances by 25% on the test above (i.e. when the two lists are not empty), by saving a call on the comparator.&lt;/p&gt;

&lt;p&gt;&quot;reseek&quot; is now synchronized, + minor modifications (@overide added, private added, ...).&lt;/p&gt;</comment>
                            <comment id="13078377" author="nkeywal" created="Tue, 2 Aug 2011 19:14:51 +0000"  >&lt;p&gt;For any future modification on this part: on jdk 1.6.24, it seems that this code:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    protected KeyValue getLower(KeyValue first, KeyValue second) {
      if (first == null &amp;amp;&amp;amp; second == null) {
        return null;
      }
      if (first != null &amp;amp;&amp;amp; second != null) {
        int compare = comparator.compare(first, second);
        return (compare &amp;lt;= 0 ? first : second);
      }
      return (first != null ? first : second);
    }&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;performs better than this one:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    protected KeyValue getLower(KeyValue first, KeyValue second) {
      if (first == null) {
        return second ;
      }
      if (second == null) {
        return first ;
      }

      int compare = comparator.compare(first, second);
      return (compare &amp;lt;= 0 ? first : second);
    }&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There is a lot of variances in the result, but the average goes for the first one. &lt;br/&gt;
The first one is the current implementation; so I kept it (this is a difference with the previous patch). The second one is actually used in the same file for a similar problem, in MemStore#getLowest, nevertheless, I kept it as well.&lt;/p&gt;</comment>
                            <comment id="13082002" author="stack" created="Tue, 9 Aug 2011 23:53:07 +0000"  >&lt;p&gt;@nkeywal What you need me to do here?  Should I try 20110802_MemStore.patch and see if it still has issue Andrew identified.  You added synchronize of reseek.  We&apos;re having consistency issues elsewhere &amp;#8211; hbase-3855 &amp;#8211; so do you think it could be because of the lack of sync?&lt;/p&gt;</comment>
                            <comment id="13082435" author="nkeywal" created="Wed, 10 Aug 2011 16:17:52 +0000"  >&lt;p&gt;Yes, I believe Andy&apos;s issue was cause by:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the improvement was actually not used in the test case&lt;/li&gt;
	&lt;li&gt;may be the point in the getLower implementation mentionned above.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I fixed both points, so I believe it can be integrated.&lt;/p&gt;

&lt;p&gt;I also added the synchronized because it was strange to have all other public methods synchronized except this one, but I didn&apos;t check if some test case were actually calling them in //. I will have a look at &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3855&quot; title=&quot;Performance degradation of memstore because reseek is linear&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3855&quot;&gt;&lt;del&gt;HBASE-3855&lt;/del&gt;&lt;/a&gt; and come back to you if I find something.&lt;/p&gt;</comment>
                            <comment id="15017833" author="lars_francke" created="Fri, 20 Nov 2015 13:01:33 +0000"  >&lt;p&gt;This issue was closed as part of a bulk closing operation on 2015-11-20. All issues that have been resolved and where all fixVersions have been released have been closed (following discussions on the mailing list).&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12487897" name="20110726_1938_KeyValueSkipListSet.patch" size="2048" author="nkeywal" created="Tue, 26 Jul 2011 21:11:29 +0000"/>
                            <attachment id="12487898" name="20110726_1938_MemStore.patch" size="6036" author="nkeywal" created="Tue, 26 Jul 2011 21:11:29 +0000"/>
                            <attachment id="12487899" name="20110726_1938_MemStoreScanPerformance.java" size="2899" author="nkeywal" created="Tue, 26 Jul 2011 21:11:29 +0000"/>
                            <attachment id="12489104" name="20110802_MemStore.patch" size="2807" author="nkeywal" created="Tue, 2 Aug 2011 19:05:13 +0000"/>
                            <attachment id="12489103" name="MemStoreScanPerformance.java" size="3259" author="nkeywal" created="Tue, 2 Aug 2011 19:05:13 +0000"/>
                            <attachment id="12487452" name="MemStoreScanPerformance.java" size="2462" author="nkeywal" created="Fri, 22 Jul 2011 17:16:04 +0000"/>
                            <attachment id="12425139" name="MemStoreScanPerformance.java" size="1564" author="stack" created="Mon, 16 Nov 2009 21:02:15 +0000"/>
                            <attachment id="12425138" name="caching-keylength-in-kv.patch" size="1342" author="stack" created="Mon, 16 Nov 2009 21:01:39 +0000"/>
                            <attachment id="12424543" name="test.patch" size="1850" author="stack" created="Wed, 11 Nov 2009 00:50:55 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 22 Jul 2011 17:14:52 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>32320</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310191" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Hadoop Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10343"><![CDATA[Reviewed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            1 year, 4 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0hfxj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>99843</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>