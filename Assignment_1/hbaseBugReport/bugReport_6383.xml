<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:36:16 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-6383/HBASE-6383.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-6383] Investigate using 2Q for block cache</title>
                <link>https://issues.apache.org/jira/browse/HBASE-6383</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;Currently we use a basic version of LRU to handle block caching. LRU is know to be very susceptible to scan thrashing (not scan resistant), which is a common operation in HBase. 2Q is an efficient caching algorithm that emulates the effectivness of LRU/2 (eviction based not on the last access, but rather the access before the last), but is O(1), rather than O(lg&amp;#40;n)) in complexity.&lt;/p&gt;

&lt;p&gt;JD has long been talking about investigating 2Q as it may be far better for HBase than LRU and has been shown to be incredibly useful for traditional database caching on production systems.&lt;/p&gt;

&lt;p&gt;One would need to implement 2Q (though the pseudocode in the paper is quite explicit) and then test against the existing cache implementation.&lt;/p&gt;

&lt;p&gt;The link to the original paper is here: www.vldb.org/conf/1994/P439.PDF&lt;/p&gt;

&lt;p&gt;A short overview of 2Q:&lt;br/&gt;
2Q uses two queues (hence the name) and a list of pointers to keep track of cached blocks. The first queue is for new, hot items (Ain). If an item is accessed that isn&apos;t in Ain, the coldest block is evicted from Ain and the new item replaces it. Anything accessed in Ain is already stored in memory and kept in Ain.&lt;/p&gt;

&lt;p&gt;When a block is evicted from Ain, it is moved to Aout &lt;em&gt;as a pointer&lt;/em&gt;. If Aout is full, the oldest element is evicted and replaced with the new pointer.&lt;/p&gt;

&lt;p&gt;The key to 2Q comes in that when you access something in Aout, it is reloaded into memory and stored in queue B. If B becomes full, then the coldest block is evicted. &lt;/p&gt;

&lt;p&gt;This essentially makes Aout a filter for long-term hot items, based on the size of Aout. The original authors found that while you can tune Aout, it generally performs very well at at &quot;50% of the number of pages as would fit into the buffer&quot;, but can be tuned as low as 5% at only a slight cost to responsiveness to changes.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12598588">HBASE-6383</key>
            <summary>Investigate using 2Q for block cache</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="jesse_yates">Jesse Yates</reporter>
                        <labels>
                    </labels>
                <created>Thu, 12 Jul 2012 17:46:25 +0000</created>
                <updated>Fri, 8 Aug 2014 18:37:23 +0000</updated>
                                            <version>0.95.2</version>
                                                    <component>BlockCache</component>
                    <component>Performance</component>
                    <component>regionserver</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>15</watches>
                                                                <comments>
                            <comment id="13413047" author="zhihyu@ebaysf.com" created="Thu, 12 Jul 2012 18:28:02 +0000"  >&lt;p&gt;Found this: &lt;a href=&quot;http://code.google.com/p/custard-cache/source/browse/trunk/custard-cache-policies/src/main/java/com/custardsource/cache/policy/twoq/TwoQCacheManager.java?r=38&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://code.google.com/p/custard-cache/source/browse/trunk/custard-cache-policies/src/main/java/com/custardsource/cache/policy/twoq/TwoQCacheManager.java?r=38&lt;/a&gt;&lt;br/&gt;
custard-cache is Apache License 2.0&lt;/p&gt;</comment>
                            <comment id="13413054" author="jesse_yates" created="Thu, 12 Jul 2012 18:33:20 +0000"  >&lt;p&gt;@zhihong: nice find! Though it would have been fun to implement it from scratch.&lt;/p&gt;</comment>
                            <comment id="13413243" author="stack" created="Thu, 12 Jul 2012 21:29:33 +0000"  >&lt;p&gt;I think he&apos;s done it.  He&apos;s on vacation at moment so need to wait a few days for him to respond.&lt;/p&gt;</comment>
                            <comment id="13415548" author="jdcryans" created="Mon, 16 Jul 2012 19:15:29 +0000"  >&lt;p&gt;I have a barebones 2Q implementation that I&apos;m pasting here. It often performs better than our &quot;LRU&quot; even when I tweaked it to use all the available memory instead of the default max 85%. It&apos;s main deficiency is that it can double cache a block (just like the DoubleBlockCache).&lt;/p&gt;

&lt;p&gt;I also added a ghost cache to our LRU to see how it&apos;s performing and it seems to be worse most of the time but not by a few (eg less than 0.010%).&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  /**
   * This 2Q implementation uses 3 CacheBuilder-generated maps to hold am, aIn and aOut
   * It uses the &lt;span class=&quot;code-keyword&quot;&gt;default&lt;/span&gt; sizes from the paper: 75% &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; am, 25% &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; aIn and 50% &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;
   * the ghost cache aOut.
   * am and aIn use an eviction listener in order to move their block keys to aOut
   */
  &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; class TwoQueueCache &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; BlockCache {

    &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; CacheStats cacheStats = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; CacheStats();
    &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;BlockCacheKey, Cacheable&amp;gt; am;
    &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;BlockCacheKey, Cacheable&amp;gt; aIn;
    &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;BlockCacheKey, BlockCacheKey&amp;gt; aOut;

    TwoQueueCache(&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; size) {
      am = CacheBuilder.newBuilder().removalListener(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; EvictionListener()).maximumWeight((&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt;) (size * 0.75)).weigher(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; CacheWeigher()).&amp;lt;BlockCacheKey, Cacheable&amp;gt;build().asMap();
      aIn = CacheBuilder.newBuilder().removalListener(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; EvictionListener()).maximumWeight((&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt;)(size * 0.25)).weigher(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; CacheWeigher()).&amp;lt;BlockCacheKey, Cacheable&amp;gt;build().asMap();
      aOut = CacheBuilder.newBuilder().maximumWeight((&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt;)(size * 0.25)).weigher(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; DummyWeigher()).&amp;lt;BlockCacheKey, BlockCacheKey&amp;gt;build().asMap();
    }

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void cacheBlock(BlockCacheKey cacheKey, Cacheable buf, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; inMemory) {
      &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; aOutKey = aOut.remove(cacheKey);
      &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; aInKey = aOut.remove(cacheKey);
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(aOutKey != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; || aInKey != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; || inMemory) am.put(cacheKey, buf);
      &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; aIn.put(cacheKey, buf);
    }

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void cacheBlock(BlockCacheKey cacheKey, Cacheable buf) {
      &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.cacheBlock(cacheKey, buf, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;);
    }

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Cacheable getBlock(BlockCacheKey cacheKey, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; caching) {
      Cacheable block = am.get(cacheKey);
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (block == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
        block = aIn.remove(cacheKey);
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (block == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) cacheStats.miss(caching);
        &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
          cacheStats.hit(caching);
          am.put(cacheKey, block);
        }
      } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; cacheStats.hit(caching);

      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; block;
    }

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; evictBlock(BlockCacheKey cacheKey) {&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;; }

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; evictBlocksByHfileName(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; hfileName) {&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; 0; }

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; CacheStats getStats() {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; cacheStats;
    }

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void shutdown() {  }

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; size() { &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; 0; }

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; getFreeSize() { &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; 0; }

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; getCurrentSize() { &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; 0; }

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; getEvictedCount() { &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; 0; }

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; getBlockCount() { &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; 0; }

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;BlockCacheColumnFamilySummary&amp;gt; getBlockCacheColumnFamilySummaries(Configuration conf) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
    }

    class EvictionListener &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; RemovalListener&amp;lt;BlockCacheKey, Cacheable&amp;gt; {

      @Override
      &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void onRemoval(RemovalNotification&amp;lt;BlockCacheKey, Cacheable&amp;gt; notification) {
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!notification.wasEvicted()) {
          &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
        }
        aOut.put(notification.getKey(), notification.getKey());
      }
    }
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13416444" author="jesse_yates" created="Tue, 17 Jul 2012 18:50:28 +0000"  >&lt;blockquote&gt;
&lt;p&gt;It&apos;s main deficiency is that it can double cache a block (just like the DoubleBlockCache).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Which it? 2Q shouldn&apos;t be double caching (and from the quick read through of your impl its not).&lt;/p&gt;


&lt;p&gt;Do you have any stats as to how much better it performs, e.g. mean, percentile, etc read times? &lt;/p&gt;

&lt;p&gt;good stuff J.D.&lt;/p&gt;</comment>
                            <comment id="13416556" author="jdcryans" created="Tue, 17 Jul 2012 20:21:05 +0000"  >&lt;blockquote&gt;&lt;p&gt;Which it? 2Q shouldn&apos;t be double caching (and from the quick read through of your impl its not).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ah sorry I forgot that I&apos;m using Todd&apos;s &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5898&quot; title=&quot;Consider double-checked locking for block cache lock&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5898&quot;&gt;&lt;del&gt;HBASE-5898&lt;/del&gt;&lt;/a&gt; and it happens in that case because not all the reads are protected with the lock. In the current code base it&apos;s fine.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Do you have any stats as to how much better it performs, e.g. mean, percentile, etc read times?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I do, except that I have a ton of raw data to analyze (it&apos;s for my Masters). FWIW the timings are about the same, the difference is in nanoseconds (as you would expect from reading from memory).&lt;/p&gt;
</comment>
                            <comment id="13416584" author="jesse_yates" created="Tue, 17 Jul 2012 20:50:58 +0000"  >&lt;blockquote&gt;&lt;p&gt;the difference is in nanoseconds (as you would expect from reading from memory).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t know how much I would expect that - in theory under &apos;regular&apos; workload (depending on the number of scans) I would expect the times to be increasingly separate as the queue becomes more efficient (scan resistant) compared to the regular block cache, which would have to go to disk.&lt;/p&gt;

&lt;p&gt;Sounds like its not worth it overall, but maybe for some workloads? I&apos;d like to do some testing on our cluster too, but probably don&apos;t have time for a bit.&lt;/p&gt;</comment>
                            <comment id="13416597" author="jdcryans" created="Tue, 17 Jul 2012 21:04:42 +0000"  >&lt;blockquote&gt;&lt;p&gt;I don&apos;t know how much I would expect that - in theory under &apos;regular&apos; workload (depending on the number of scans) I would expect the times to be increasingly separate as the queue becomes more efficient (scan resistant) compared to the regular block cache, which would have to go to disk.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I meant the read time for a single access to the block cache is in the nanoseconds, the total runtime for the tests doesn&apos;t make much sense since it&apos;s mostly skewed by the time it takes to generate a block (or read from disk) in order to cache it.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Sounds like its not worth it overall, but maybe for some workloads? I&apos;d like to do some testing on our cluster too, but probably don&apos;t have time for a bit.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry I mislead you, there is a difference and the best way to measure it is the hit ratio (unless it takes too long to read from the cache, to a point where it would affect latency). In some cases a saw a difference of a few percent which in the caching domain is a big deal.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 12 Jul 2012 18:28:02 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>256598</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 years, 22 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0huwn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>102269</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>