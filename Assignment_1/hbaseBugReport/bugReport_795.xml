<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 18:47:35 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-795/HBASE-795.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-795] More Table operation in TableHandler for REST interface</title>
                <link>https://issues.apache.org/jira/browse/HBASE-795</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;In the current implementation, only the metadata query of table allowed. It&apos;s not convinent to use the REST interface to write a third-party client library. I think the functionality of REST interface should be similar with the hbase shell. So user can create/show/update/delate/enable/disable the table.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12401663">HBASE-795</key>
            <summary>More Table operation in TableHandler for REST interface</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="sishen">sishen.freecity</reporter>
                        <labels>
                    </labels>
                <created>Tue, 5 Aug 2008 00:10:27 +0000</created>
                <updated>Sun, 13 Sep 2009 22:33:29 +0000</updated>
                            <resolved>Tue, 12 Aug 2008 22:08:17 +0000</resolved>
                                                    <fixVersion>0.18.0</fixVersion>
                                    <component>REST</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                    <timeoriginalestimate seconds="3600">1h</timeoriginalestimate>
                            <timeestimate seconds="3600">1h</timeestimate>
                                        <comments>
                            <comment id="12619751" author="sishen" created="Tue, 5 Aug 2008 00:11:54 +0000"  >&lt;p&gt;The patch of REST table operations.&lt;/p&gt;</comment>
                            <comment id="12619752" author="sishen" created="Tue, 5 Aug 2008 00:17:11 +0000"  >&lt;p&gt;The main changes of this patch:&lt;/p&gt;

&lt;p&gt;1. add create/delete/update/disable/enable method of TableHandler&lt;br/&gt;
2. create a new RowHandler to handle row-oriented operation.&lt;/p&gt;


&lt;p&gt;The table usecase:&lt;/p&gt;

&lt;p&gt;1. create a table  :  curl -T test_table.xml &lt;a href=&quot;http://localhost:60050/api/tables&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:60050/api/tables&lt;/a&gt;&lt;br/&gt;
    sample data: &lt;br/&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;br/&gt;
&amp;lt;table&amp;gt;&lt;br/&gt;
  &amp;lt;name&amp;gt;users&amp;lt;/name&amp;gt;&lt;br/&gt;
  &amp;lt;columnfamilies&amp;gt;&lt;br/&gt;
    &amp;lt;columnfamily&amp;gt;&lt;br/&gt;
      &amp;lt;name&amp;gt;subscription&amp;lt;/name&amp;gt;&lt;br/&gt;
      &amp;lt;max-versions&amp;gt;4&amp;lt;/max-versions&amp;gt;&lt;br/&gt;
      &amp;lt;compression&amp;gt;NONE&amp;lt;/compression&amp;gt;&lt;br/&gt;
      &amp;lt;in-memory&amp;gt;false&amp;lt;/in-memory&amp;gt;&lt;br/&gt;
      &amp;lt;block-cache&amp;gt;true&amp;lt;/block-cache&amp;gt;&lt;br/&gt;
    &amp;lt;/columnfamily&amp;gt;&lt;br/&gt;
  &amp;lt;/columnfamilies&amp;gt;&lt;br/&gt;
&amp;lt;/table&amp;gt;&lt;/p&gt;

&lt;p&gt;2. update table : curl -X PUT -T - &lt;a href=&quot;http://localhost:60050/api/tables/users&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:60050/api/tables/users&lt;/a&gt;&lt;br/&gt;
    sample data :  &lt;br/&gt;
    &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;table&amp;gt;&amp;lt;columnfamilies&amp;gt;&amp;lt;columnfamily&amp;gt;&amp;lt;name&amp;gt;subscription&amp;lt;/name&amp;gt;&amp;lt;max-versions&amp;gt;6&amp;lt;/max-versions&amp;gt;&amp;lt;/columnfamily&amp;gt;&amp;lt;/columnfamilies&amp;gt;&amp;lt;/table&amp;gt;&lt;/p&gt;

&lt;p&gt;3. disable table : curl -X POST &lt;a href=&quot;http://localhost:60050/api/tables/users/disable&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:60050/api/tables/users/disable&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4. enable table : curl -X POST &lt;a href=&quot;http://localhost:60050/api/tables/users/enable&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:60050/api/tables/users/enable&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5. delete table : curl -X DELETE &lt;a href=&quot;http://localhost:60050/api/tables/users&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://localhost:60050/api/tables/users&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12619754" author="sishen" created="Tue, 5 Aug 2008 00:19:39 +0000"  >&lt;p&gt;Index: src/java/org/apache/hadoop/hbase/rest/MetaHandler.java&lt;br/&gt;
===================================================================&lt;br/&gt;
&amp;#8212; src/java/org/apache/hadoop/hbase/rest/MetaHandler.java	(revision 682229)&lt;br/&gt;
+++ src/java/org/apache/hadoop/hbase/rest/MetaHandler.java	(working copy)&lt;br/&gt;
@@ -35,7 +35,7 @@&lt;/p&gt;

&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;MetaHandler fields all requests for metadata at the instance level. At the&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* momment this is only GET requests to /.&lt;br/&gt;
+ * moment this is only GET requests to /.&lt;br/&gt;
  */&lt;br/&gt;
 public class MetaHandler extends GenericHandler {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Index: src/java/org/apache/hadoop/hbase/rest/TableHandler.java&lt;br/&gt;
===================================================================&lt;br/&gt;
&amp;#8212; src/java/org/apache/hadoop/hbase/rest/TableHandler.java	(revision 682229)&lt;br/&gt;
+++ src/java/org/apache/hadoop/hbase/rest/TableHandler.java	(working copy)&lt;br/&gt;
@@ -21,12 +21,6 @@&lt;/p&gt;

&lt;p&gt; import java.io.IOException;&lt;br/&gt;
 import java.io.PrintWriter;&lt;br/&gt;
-import java.net.URLDecoder;&lt;br/&gt;
-import java.util.Collection;&lt;br/&gt;
-import java.util.HashSet;&lt;br/&gt;
-import java.util.Map;&lt;br/&gt;
-import java.util.Set;&lt;br/&gt;
-import java.util.TreeMap;&lt;/p&gt;

&lt;p&gt; import javax.servlet.ServletException;&lt;br/&gt;
 import javax.servlet.http.HttpServletRequest;&lt;br/&gt;
@@ -36,14 +30,11 @@&lt;/p&gt;

&lt;p&gt; import org.apache.hadoop.hbase.HBaseConfiguration;&lt;br/&gt;
 import org.apache.hadoop.hbase.HColumnDescriptor;&lt;br/&gt;
-import org.apache.hadoop.hbase.HConstants;&lt;br/&gt;
 import org.apache.hadoop.hbase.HTableDescriptor;&lt;br/&gt;
+import org.apache.hadoop.hbase.HColumnDescriptor.CompressionType;&lt;br/&gt;
 import org.apache.hadoop.hbase.client.HBaseAdmin;&lt;br/&gt;
 import org.apache.hadoop.hbase.client.HTable;&lt;br/&gt;
-import org.apache.hadoop.hbase.io.BatchUpdate;&lt;br/&gt;
-import org.apache.hadoop.hbase.io.Cell;&lt;br/&gt;
 import org.apache.hadoop.hbase.util.Bytes;&lt;br/&gt;
-import org.apache.hadoop.io.Text;&lt;br/&gt;
 import org.w3c.dom.Document;&lt;br/&gt;
 import org.w3c.dom.Element;&lt;br/&gt;
 import org.w3c.dom.Node;&lt;br/&gt;
@@ -57,7 +48,9 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;this handler.&lt;br/&gt;
  */&lt;br/&gt;
 public class TableHandler extends GenericHandler {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;p&gt;+  public static final String DISABLE = &quot;disable&quot;;&lt;br/&gt;
+  public static final String ENABLE = &quot;enable&quot;;&lt;br/&gt;
+  &lt;br/&gt;
   public TableHandler(HBaseConfiguration conf, HBaseAdmin admin) &lt;br/&gt;
   throws ServletException&lt;/p&gt;
{
     super(conf, admin);
@@ -76,10 +69,6 @@
         // get a region list
         getTableRegions(table, request, response);
       }&lt;/li&gt;
	&lt;li&gt;else if (pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;.toLowerCase().equals(ROW)) 
{
-        // get a row
-        getRow(table, request, response, pathSegments);
-      }
&lt;p&gt;       else&lt;/p&gt;
{
         doNotFound(response, &quot;Not handled in TableHandler&quot;);
       }
&lt;p&gt;@@ -89,255 +78,34 @@&lt;br/&gt;
   public void doPost(HttpServletRequest request, HttpServletResponse response, &lt;br/&gt;
     String[] pathSegments)&lt;br/&gt;
   throws ServletException, IOException {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;putRow(request, response, pathSegments);&lt;br/&gt;
+    if (pathSegments.length == 1) 
{
+      // if it&apos;s a creation operation
+      putTable(request, response, pathSegments);
+    }
&lt;p&gt; else &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+      // if it&amp;#39;s a disable operation or enable operation+      String tableName = pathSegments[1];      +      if (pathSegments[2].toLowerCase().equals(DISABLE)) {
+        admin.disableTable(tableName);
+      } else if (pathSegments[2].toLowerCase().equals(ENABLE)) {
+        admin.enableTable(tableName);
+      }+      response.setStatus(202);+    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;   }&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
   public void doPut(HttpServletRequest request, HttpServletResponse response, &lt;br/&gt;
     String[] pathSegments)&lt;br/&gt;
   throws ServletException, IOException &lt;/p&gt;
{
-    doPost(request, response, pathSegments);
+    updateTable(request, response, pathSegments);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   public void doDelete(HttpServletRequest request, HttpServletResponse response, &lt;br/&gt;
     String[] pathSegments)&lt;br/&gt;
   throws ServletException, IOException &lt;/p&gt;
{
-    deleteRow(request, response, pathSegments);
+    deleteTable(request, response, pathSegments);
   }
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;/*&lt;/li&gt;
	&lt;li&gt;* @param request&lt;/li&gt;
	&lt;li&gt;* @param response&lt;/li&gt;
	&lt;li&gt;* @param pathSegments info path split on the &apos;/&apos; character.  First segment&lt;/li&gt;
	&lt;li&gt;* is the tablename, second is &apos;row&apos;, and third is the row id.&lt;/li&gt;
	&lt;li&gt;* @throws IOException&lt;/li&gt;
	&lt;li&gt;* Retrieve a row in one of several output formats.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;private void getRow(HTable table, final HttpServletRequest request,&lt;/li&gt;
	&lt;li&gt;final HttpServletResponse response, final String [] pathSegments)&lt;/li&gt;
	&lt;li&gt;throws IOException {&lt;/li&gt;
	&lt;li&gt;// pull the row key out of the path&lt;/li&gt;
	&lt;li&gt;String row = URLDecoder.decode(pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;, HConstants.UTF8_ENCODING);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;String timestampStr = null;&lt;/li&gt;
	&lt;li&gt;if (pathSegments.length == 4) {&lt;/li&gt;
	&lt;li&gt;// A timestamp has been supplied.&lt;/li&gt;
	&lt;li&gt;timestampStr = pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;3&amp;#93;&lt;/span&gt;;&lt;/li&gt;
	&lt;li&gt;if (timestampStr.equals(&quot;timestamps&quot;)) 
{
-        // Not supported in hbase just yet. TODO
-        doMethodNotAllowed(response, &quot;Not yet supported by hbase&quot;);
-        return;
-      }&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;String[] columns = request.getParameterValues(COLUMN);&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;if (columns == null || columns.length == 0) {&lt;/li&gt;
	&lt;li&gt;// They want full row returned.&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Presumption is that this.table has already been focused on target table.&lt;/li&gt;
	&lt;li&gt;Map&amp;lt;byte [], Cell&amp;gt; result = timestampStr == null ?&lt;/li&gt;
	&lt;li&gt;table.getRow(Bytes.toBytes(row))&lt;/li&gt;
	&lt;li&gt;: table.getRow(Bytes.toBytes(row), Long.parseLong(timestampStr));&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;if (result == null || result.size() == 0) 
{
-        doNotFound(response, &quot;Row not found!&quot;);
-      } else {&lt;br/&gt;
-        switch (ContentType.getContentType(request.getHeader(ACCEPT))) {
-        case XML:
-          outputRowXml(response, result);
-          break;
-        case MIME:
-        default:
-          doNotAcceptable(response, &quot;Unsupported Accept Header Content: &quot; +
-            request.getHeader(CONTENT_TYPE));
-        }&lt;br/&gt;
-      }&lt;br/&gt;
-    } else {&lt;br/&gt;
-      Map&amp;lt;byte [], Cell&amp;gt; prefiltered_result = table.getRow(Bytes.toBytes(row));&lt;br/&gt;
-    &lt;br/&gt;
-      if (prefiltered_result == null || prefiltered_result.size() == 0) {
-        doNotFound(response, &quot;Row not found!&quot;);
-      }
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// create a Set from the columns requested so we can&lt;/li&gt;
	&lt;li&gt;// efficiently filter the actual found columns&lt;/li&gt;
	&lt;li&gt;Set&amp;lt;String&amp;gt; requested_columns_set = new HashSet&amp;lt;String&amp;gt;();&lt;/li&gt;
	&lt;li&gt;for(int i = 0; i &amp;lt; columns.length; i++)
{
-          requested_columns_set.add(columns[i]);
-        }&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;// output map that will contain the filtered results&lt;/li&gt;
	&lt;li&gt;Map&amp;lt;byte [], Cell&amp;gt; m =&lt;/li&gt;
	&lt;li&gt;new TreeMap&amp;lt;byte [], Cell&amp;gt;(Bytes.BYTES_COMPARATOR);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// get an array of all the columns retrieved&lt;/li&gt;
	&lt;li&gt;Set&amp;lt;byte []&amp;gt; columns_retrieved = prefiltered_result.keySet();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// copy over those cells with requested column names&lt;/li&gt;
	&lt;li&gt;for(byte [] current_column: columns_retrieved) {&lt;/li&gt;
	&lt;li&gt;if (requested_columns_set.contains(Bytes.toString(current_column))) 
{
-            m.put(current_column, prefiltered_result.get(current_column));            
-          }&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;switch (ContentType.getContentType(request.getHeader(ACCEPT))) 
{
-          case XML:
-            outputRowXml(response, m);
-            break;
-          case MIME:
-          default:
-            doNotAcceptable(response, &quot;Unsupported Accept Header Content: &quot; +
-              request.getHeader(CONTENT_TYPE));
-        }&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;   /*&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;* Output a row encoded as XML.&lt;/li&gt;
	&lt;li&gt;* @param response&lt;/li&gt;
	&lt;li&gt;* @param result&lt;/li&gt;
	&lt;li&gt;* @throws IOException&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;private void outputRowXml(final HttpServletResponse response,&lt;/li&gt;
	&lt;li&gt;final Map&amp;lt;byte [], Cell&amp;gt; result)&lt;/li&gt;
	&lt;li&gt;throws IOException 
{
-    setResponseHeader(response, result.size() &amp;gt; 0? 200: 204,
-        ContentType.XML.toString());
-    XMLOutputter outputter = getXMLOutputter(response.getWriter());
-    outputter.startTag(ROW);
-    outputColumnsXml(outputter, result);
-    outputter.endTag();
-    outputter.endDocument();
-    outputter.getWriter().close();
-  }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;/*&lt;/li&gt;
	&lt;li&gt;* @param response&lt;/li&gt;
	&lt;li&gt;* @param result&lt;/li&gt;
	&lt;li&gt;* Output the results contained in result as a multipart/related response.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;// private void outputRowMime(final HttpServletResponse response,&lt;/li&gt;
	&lt;li&gt;//     final Map&amp;lt;Text, Cell&amp;gt; result)&lt;/li&gt;
	&lt;li&gt;// throws IOException 
{
-  //   response.setStatus(result.size() &amp;gt; 0? 200: 204);
-  //   // This code ties me to the jetty server.
-  //   MultiPartResponse mpr = new MultiPartResponse(response);
-  //   // Content type should look like this for multipart:
-  //   // Content-type: multipart/related;start=&quot;&amp;lt;rootpart*94ebf1e6-7eb5-43f1-85f4-2615fc40c5d6@example.jaxws.sun.com&amp;gt;&quot;;type=&quot;application/xop+xml&quot;;boundary=&quot;uuid:94ebf1e6-7eb5-43f1-85f4-2615fc40c5d6&quot;;start-info=&quot;text/xml&quot;
-  //   String ct = ContentType.MIME.toString() + &quot;;charset=\&quot;UTF-8\&quot;;boundary=\&quot;&quot; +
-  //     mpr.getBoundary() + &quot;\&quot;&quot;;
-  //   // Setting content type is broken.  I&apos;m unable to set parameters on the
-  //   // content-type; They get stripped.  Can&apos;t set boundary, etc.
-  //   // response.addHeader(&quot;Content-Type&quot;, ct);
-  //   response.setContentType(ct);
-  //   outputColumnsMime(mpr, result);
-  //   mpr.close();
-  // }&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;/*&lt;/li&gt;
	&lt;li&gt;* @param request&lt;/li&gt;
	&lt;li&gt;* @param response&lt;/li&gt;
	&lt;li&gt;* @param pathSegments&lt;/li&gt;
	&lt;li&gt;* Do a put based on the client request.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;private void putRow(final HttpServletRequest request,&lt;/li&gt;
	&lt;li&gt;final HttpServletResponse response, final String [] pathSegments)&lt;/li&gt;
	&lt;li&gt;throws IOException, ServletException {&lt;/li&gt;
	&lt;li&gt;HTable table = getTable(pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// pull the row key out of the path&lt;/li&gt;
	&lt;li&gt;String row = URLDecoder.decode(pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;, HConstants.UTF8_ENCODING);&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;switch(ContentType.getContentType(request.getHeader(CONTENT_TYPE))) 
{
-      case XML:
-        putRowXml(table, row, request, response, pathSegments);
-        break;
-      case MIME:
-        doNotAcceptable(response, &quot;Don&apos;t support multipart/related yet...&quot;);
-        break;
-      default:
-        doNotAcceptable(response, &quot;Unsupported Accept Header Content: &quot; +
-          request.getHeader(CONTENT_TYPE));
-    }&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/*&lt;/li&gt;
	&lt;li&gt;* @param request&lt;/li&gt;
	&lt;li&gt;* @param response&lt;/li&gt;
	&lt;li&gt;* @param pathSegments&lt;/li&gt;
	&lt;li&gt;* Decode supplied XML and do a put to Hbase.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;private void putRowXml(HTable table, String row,&lt;/li&gt;
	&lt;li&gt;final HttpServletRequest request, final HttpServletResponse response,&lt;/li&gt;
	&lt;li&gt;final String [] pathSegments)&lt;/li&gt;
	&lt;li&gt;throws IOException, ServletException{&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;DocumentBuilderFactory docBuilderFactory&lt;/li&gt;
	&lt;li&gt;= DocumentBuilderFactory.newInstance();&lt;/li&gt;
	&lt;li&gt;//ignore all comments inside the xml file&lt;/li&gt;
	&lt;li&gt;docBuilderFactory.setIgnoringComments(true);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;DocumentBuilder builder = null;&lt;/li&gt;
	&lt;li&gt;Document doc = null;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;String timestamp = pathSegments.length &amp;gt;= 4 ? pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;3&amp;#93;&lt;/span&gt; : null;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;try
{
-      builder = docBuilderFactory.newDocumentBuilder();
-      doc = builder.parse(request.getInputStream());
-    }
&lt;p&gt; catch (javax.xml.parsers.ParserConfigurationException e) &lt;/p&gt;
{
-      throw new ServletException(e);
-    } catch (org.xml.sax.SAXException e){
-      throw new ServletException(e);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;BatchUpdate batchUpdate;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;try{&lt;/li&gt;
	&lt;li&gt;// start an update&lt;/li&gt;
	&lt;li&gt;batchUpdate = timestamp == null ?&lt;/li&gt;
	&lt;li&gt;new BatchUpdate(row) : new BatchUpdate(row, Long.parseLong(timestamp));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// set the columns from the xml&lt;/li&gt;
	&lt;li&gt;NodeList columns = doc.getElementsByTagName(&quot;column&quot;);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;for(int i = 0; i &amp;lt; columns.getLength(); i++){&lt;/li&gt;
	&lt;li&gt;// get the current column element we&apos;re working on&lt;/li&gt;
	&lt;li&gt;Element column = (Element)columns.item&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// extract the name and value children&lt;/li&gt;
	&lt;li&gt;Node name_node = column.getElementsByTagName(&quot;name&quot;).item(0);&lt;/li&gt;
	&lt;li&gt;String name = name_node.getFirstChild().getNodeValue();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;Node value_node = column.getElementsByTagName(&quot;value&quot;).item(0);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;byte[] value = new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;// for some reason there&apos;s no value here. probably indicates that&lt;/li&gt;
	&lt;li&gt;// the consumer passed a null as the cell value.&lt;/li&gt;
	&lt;li&gt;if(value_node.getFirstChild() != null &amp;amp;&amp;amp;&lt;/li&gt;
	&lt;li&gt;value_node.getFirstChild().getNodeValue() != null)
{
-          // decode the base64&apos;d value
-          value = org.apache.hadoop.hbase.util.Base64.decode(
-            value_node.getFirstChild().getNodeValue());
-        }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// put the value&lt;/li&gt;
	&lt;li&gt;batchUpdate.put(name, value);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// commit the update&lt;/li&gt;
	&lt;li&gt;table.commit(batchUpdate);&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;// respond with a 200&lt;/li&gt;
	&lt;li&gt;response.setStatus(200);&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;catch(Exception e)
{
-      throw new ServletException(e);
-    }&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/*&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Return region offsets.&lt;/li&gt;
	&lt;li&gt;@param request&lt;/li&gt;
	&lt;li&gt;@param response&lt;br/&gt;
@@ -438,41 +206,158 @@&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/*&lt;/li&gt;
	&lt;li&gt;* @param request&lt;/li&gt;
	&lt;li&gt;* @param response&lt;/li&gt;
	&lt;li&gt;* @param pathSegments&lt;/li&gt;
	&lt;li&gt;* Delete some or all cells for a row.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;private void deleteRow(final HttpServletRequest request,&lt;/li&gt;
	&lt;li&gt;final HttpServletResponse response, final String [] pathSegments)&lt;br/&gt;
+  private void putTable(HttpServletRequest request,&lt;br/&gt;
+    HttpServletResponse response, String[] pathSegments) &lt;br/&gt;
   throws IOException, ServletException {&lt;/li&gt;
	&lt;li&gt;// grab the table we&apos;re operating on&lt;/li&gt;
	&lt;li&gt;HTable table = getTable(getTableName(pathSegments));&lt;br/&gt;
+    switch(ContentType.getContentType(request.getHeader(CONTENT_TYPE))) 
{
+      case XML:
+        putTableXml(request, response, pathSegments);
+        break;
+      case MIME:
+        doNotAcceptable(response, &quot;Don&apos;t support multipart/related yet...&quot;);
+        break;
+      default:
+        doNotAcceptable(response, &quot;Unsupported Accept Header Content: &quot; +
+            request.getHeader(CONTENT_TYPE));
+    }
&lt;p&gt;+  } &lt;br/&gt;
+  &lt;br/&gt;
+  private void updateTable(HttpServletRequest request,&lt;br/&gt;
+    HttpServletResponse response, String[] pathSegments) &lt;br/&gt;
+  throws IOException, ServletException &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+    switch(ContentType.getContentType(request.getHeader(CONTENT_TYPE))) {
+      case XML:
+        updateTableXml(request, response, pathSegments);
+        break;
+      case MIME:
+        doNotAcceptable(response, &quot;Don&apos;t support multipart/related yet...&quot;);
+        break;
+      default:
+        doNotAcceptable(response, &quot;Unsupported Accept Header Content: &quot; +
+            request.getHeader(CONTENT_TYPE));
+    }+  }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+  &lt;br/&gt;
+  private void deleteTable(HttpServletRequest request,&lt;br/&gt;
+      HttpServletResponse response, String[] pathSegments) throws IOException &lt;/p&gt;
{
+    String tableName = pathSegments[1];
+    admin.deleteTable(tableName);
+    response.setStatus(202);
+  }
&lt;p&gt;  &lt;br/&gt;
+  &lt;br/&gt;
+  private void putTableXml(HttpServletRequest &lt;br/&gt;
+    request, HttpServletResponse response, String[] pathSegments)&lt;br/&gt;
+  throws IOException, ServletException &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory+        .newInstance();+    // ignore all comments inside the xml file+    docBuilderFactory.setIgnoringComments(true);++    DocumentBuilder builder = null;+    Document doc = null;++    try {
+      builder = docBuilderFactory.newDocumentBuilder();
+      doc = builder.parse(request.getInputStream());
+    } catch (javax.xml.parsers.ParserConfigurationException e) {
+      throw new ServletException(e);
+    } catch (org.xml.sax.SAXException e) {
+      throw new ServletException(e);
+    }&lt;br/&gt;
     &lt;br/&gt;
-    // pull the row key out of the path&lt;br/&gt;
-    String row = URLDecoder.decode(pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;, HConstants.UTF8_ENCODING);&lt;br/&gt;
+    try {&lt;br/&gt;
+      Node name_node = doc.getElementsByTagName(&quot;name&quot;).item(0);&lt;br/&gt;
+      String table_name = name_node.getFirstChild().getNodeValue();&lt;br/&gt;
+      &lt;br/&gt;
+      HTableDescriptor htd = new HTableDescriptor(table_name);&lt;br/&gt;
+      NodeList columnfamily_nodes = doc.getElementsByTagName(&quot;columnfamily&quot;);&lt;br/&gt;
+      for (int i = 0; i &amp;lt; columnfamily_nodes.getLength(); i++) {
+        Element columnfamily = (Element)columnfamily_nodes.item(i);
+        htd.addFamily(putColumnFamilyXml(columnfamily));
+      }&lt;br/&gt;
+      admin.createTable(htd);      &lt;br/&gt;
+    } catch (Exception e) {
+      throw new ServletException(e);
+    }&lt;br/&gt;
+  }&lt;br/&gt;
 &lt;br/&gt;
-    String[] columns = request.getParameterValues(COLUMN);&lt;br/&gt;
-        &lt;br/&gt;
-    // hack - we&apos;ll actually test for the presence of the timestamp parameter&lt;br/&gt;
-    // eventually&lt;br/&gt;
-    boolean timestamp_present = false;&lt;br/&gt;
-    if(timestamp_present){ // do a timestamp-aware delete&lt;br/&gt;
-      doMethodNotAllowed(response, &quot;DELETE with a timestamp not implemented!&quot;);&lt;br/&gt;
+  private void updateTableXml(HttpServletRequest request,&lt;br/&gt;
+      HttpServletResponse response, String[] pathSegments) throws IOException,&lt;br/&gt;
+      ServletException {&lt;br/&gt;
+    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory&lt;br/&gt;
+        .newInstance();&lt;br/&gt;
+    // ignore all comments inside the xml file&lt;br/&gt;
+    docBuilderFactory.setIgnoringComments(true);&lt;br/&gt;
+&lt;br/&gt;
+    DocumentBuilder builder = null;&lt;br/&gt;
+    Document doc = null;&lt;br/&gt;
+&lt;br/&gt;
+    try {
+      builder = docBuilderFactory.newDocumentBuilder();
+      doc = builder.parse(request.getInputStream());
+    } catch (javax.xml.parsers.ParserConfigurationException e) {
+      throw new ServletException(e);
+    } catch (org.xml.sax.SAXException e) {
+      throw new ServletException(e);
     }&lt;br/&gt;
-    else{ // ignore timestamps&lt;br/&gt;
-      if(columns == null || columns.length == 0){
-        // retrieve all the columns
-        doMethodNotAllowed(response,
-          &quot;DELETE without specified columns not implemented!&quot;);
-      } else{&lt;br/&gt;
-        // delete each column in turn      &lt;br/&gt;
-        for(int i = 0; i &amp;lt; columns.length; i++){
-          table.deleteAll(row, columns[i]);
-        }&lt;br/&gt;
+&lt;br/&gt;
+    try {&lt;br/&gt;
+      String tableName = pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+&lt;br/&gt;
+      NodeList columnfamily_nodes = doc.getElementsByTagName(&quot;columnfamily&quot;);&lt;br/&gt;
+      for (int i = 0; i &amp;lt; columnfamily_nodes.getLength(); i++) {
+        Element columnfamily = (Element) columnfamily_nodes.item(i);
+        HColumnDescriptor hcd = putColumnFamilyXml(columnfamily);
+        admin.modifyColumn(tableName, hcd.getNameAsString(), hcd);
       }&lt;br/&gt;
-      response.setStatus(202);&lt;br/&gt;
+    } catch (Exception e) {
+      throw new ServletException(e);
     }&lt;br/&gt;
-  } &lt;br/&gt;
+  }&lt;br/&gt;
+  &lt;br/&gt;
+  private HColumnDescriptor putColumnFamilyXml(Element columnfamily) {&lt;br/&gt;
+    Node name_node = columnfamily.getElementsByTagName(&quot;name&quot;).item(0);&lt;br/&gt;
+    String colname = name_node.getFirstChild().getNodeValue();&lt;br/&gt;
+    &lt;br/&gt;
+    if (colname.indexOf(&quot;:&quot;) == -1) {
+      colname += &quot;:&quot;;
+    }&lt;br/&gt;
+    &lt;br/&gt;
+    int max_versions = HColumnDescriptor.DEFAULT_VERSIONS;&lt;br/&gt;
+    NodeList max_versions_list = columnfamily.getElementsByTagName(&quot;max-versions&quot;);&lt;br/&gt;
+    if (max_versions_list.getLength() &amp;gt; 0) {
+      max_versions = Integer.parseInt(max_versions_list.item(0).getFirstChild().getNodeValue());
+    }&lt;br/&gt;
+    CompressionType compression = HColumnDescriptor.DEFAULT_COMPRESSION;&lt;br/&gt;
+    NodeList compression_list = columnfamily.getElementsByTagName(&quot;compression&quot;);&lt;br/&gt;
+    if (compression_list.getLength() &amp;gt; 0) {
+      compression = CompressionType.valueOf(compression_list.item(0).getFirstChild().getNodeValue());
+    }&lt;br/&gt;
+    boolean in_memory = HColumnDescriptor.DEFAULT_IN_MEMORY;&lt;br/&gt;
+    NodeList in_memory_list = columnfamily.getElementsByTagName(&quot;in-memory&quot;);&lt;br/&gt;
+    if (in_memory_list.getLength() &amp;gt; 0) {
+      in_memory = Boolean.valueOf(in_memory_list.item(0).getFirstChild().getNodeValue());
+    }&lt;br/&gt;
+    boolean block_cache = HColumnDescriptor.DEFAULT_BLOCKCACHE;&lt;br/&gt;
+    NodeList block_cache_list = columnfamily.getElementsByTagName(&quot;block-cache&quot;);&lt;br/&gt;
+    if (block_cache_list.getLength() &amp;gt; 0) {
+      block_cache = Boolean.valueOf(block_cache_list.item(0).getFirstChild().getNodeValue());
+    }&lt;br/&gt;
+    int max_cell_size = HColumnDescriptor.DEFAULT_LENGTH;&lt;br/&gt;
+    NodeList max_cell_size_list = columnfamily.getElementsByTagName(&quot;max-cell-size&quot;);&lt;br/&gt;
+    if (max_cell_size_list.getLength() &amp;gt; 0) {
+      max_cell_size = Integer.valueOf(max_cell_size_list.item(0).getFirstChild().getNodeValue());
+    }&lt;br/&gt;
+    int ttl = HColumnDescriptor.DEFAULT_TTL;&lt;br/&gt;
+    NodeList ttl_list = columnfamily.getElementsByTagName(&quot;time-to-live&quot;);&lt;br/&gt;
+    if (ttl_list.getLength() &amp;gt; 0) {
+      ttl = Integer.valueOf(ttl_list.item(0).getFirstChild().getNodeValue());
+    }&lt;br/&gt;
+    boolean bloomfilter = HColumnDescriptor.DEFAULT_BLOOMFILTER;&lt;br/&gt;
+    NodeList bloomfilter_list = columnfamily.getElementsByTagName(&quot;bloomfilter&quot;);&lt;br/&gt;
+    if (bloomfilter_list.getLength() &amp;gt; 0) {
+      bloomfilter = Boolean.valueOf(bloomfilter_list.item(0).getFirstChild().getNodeValue());
+    }&lt;br/&gt;
+    return new HColumnDescriptor(Bytes.toBytes(colname), max_versions, compression, in_memory, block_cache, max_cell_size, ttl, bloomfilter);&lt;br/&gt;
+  }&lt;br/&gt;
 }&lt;br/&gt;
Index: src/java/org/apache/hadoop/hbase/rest/RowHandler.java&lt;br/&gt;
===================================================================&lt;br/&gt;
&amp;#8212; src/java/org/apache/hadoop/hbase/rest/RowHandler.java	(revision 0)&lt;br/&gt;
+++ src/java/org/apache/hadoop/hbase/rest/RowHandler.java	(revision 0)&lt;br/&gt;
@@ -0,0 +1,333 @@&lt;br/&gt;
+package org.apache.hadoop.hbase.rest;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.net.URLDecoder;&lt;br/&gt;
+import java.util.HashSet;&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+import java.util.Set;&lt;br/&gt;
+import java.util.TreeMap;&lt;br/&gt;
+&lt;br/&gt;
+import javax.servlet.ServletException;&lt;br/&gt;
+import javax.servlet.http.HttpServletRequest;&lt;br/&gt;
+import javax.servlet.http.HttpServletResponse;&lt;br/&gt;
+import javax.xml.parsers.DocumentBuilder;&lt;br/&gt;
+import javax.xml.parsers.DocumentBuilderFactory;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.hadoop.hbase.HBaseConfiguration;&lt;br/&gt;
+import org.apache.hadoop.hbase.HConstants;&lt;br/&gt;
+import org.apache.hadoop.hbase.client.HBaseAdmin;&lt;br/&gt;
+import org.apache.hadoop.hbase.client.HTable;&lt;br/&gt;
+import org.apache.hadoop.hbase.io.BatchUpdate;&lt;br/&gt;
+import org.apache.hadoop.hbase.io.Cell;&lt;br/&gt;
+import org.apache.hadoop.hbase.util.Bytes;&lt;br/&gt;
+import org.w3c.dom.Document;&lt;br/&gt;
+import org.w3c.dom.Element;&lt;br/&gt;
+import org.w3c.dom.Node;&lt;br/&gt;
+import org.w3c.dom.NodeList;&lt;br/&gt;
+import org.znerd.xmlenc.XMLOutputter;&lt;br/&gt;
+&lt;br/&gt;
+public class RowHandler extends GenericHandler {&lt;br/&gt;
+&lt;br/&gt;
+	public RowHandler(HBaseConfiguration conf, HBaseAdmin admin)&lt;br/&gt;
+	throws ServletException {
+		super(conf, admin);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	public void doGet(HttpServletRequest request, HttpServletResponse response,&lt;br/&gt;
+      String[] pathSegments) throws ServletException, IOException {&lt;br/&gt;
+	  HTable table = getTable(pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
+	  if (pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;.toLowerCase().equals(ROW)) {
+      // get a row
+      getRow(table, request, response, pathSegments);
+    } else {
+      doNotFound(response, &quot;Not handled in RowHandler&quot;);
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  public void doPost(HttpServletRequest request, HttpServletResponse response,&lt;br/&gt;
+      String[] pathSegments) throws ServletException, IOException {
+    putRow(request, response, pathSegments);
+  }&lt;br/&gt;
+&lt;br/&gt;
+  public void doPut(HttpServletRequest request, HttpServletResponse response,&lt;br/&gt;
+      String[] pathSegments) throws ServletException, IOException {
+    doPost(request, response, pathSegments);
+  }&lt;br/&gt;
+&lt;br/&gt;
+  public void doDelete(HttpServletRequest request,&lt;br/&gt;
+      HttpServletResponse response, String[] pathSegments)&lt;br/&gt;
+      throws ServletException, IOException {
+    deleteRow(request, response, pathSegments);
+  }&lt;br/&gt;
+    &lt;br/&gt;
+  /*&lt;br/&gt;
+   * @param request&lt;br/&gt;
+   * @param response&lt;br/&gt;
+   * @param pathSegments info path split on the &apos;/&apos; character.  First segment&lt;br/&gt;
+   * is the tablename, second is &apos;row&apos;, and third is the row id.&lt;br/&gt;
+   * @throws IOException&lt;br/&gt;
+   * Retrieve a row in one of several output formats.&lt;br/&gt;
+   */&lt;br/&gt;
+  private void getRow(HTable table, final HttpServletRequest request,&lt;br/&gt;
+    final HttpServletResponse response, final String [] pathSegments)&lt;br/&gt;
+  throws IOException {&lt;br/&gt;
+    // pull the row key out of the path&lt;br/&gt;
+    String row = URLDecoder.decode(pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;, HConstants.UTF8_ENCODING);&lt;br/&gt;
+&lt;br/&gt;
+    String timestampStr = null;&lt;br/&gt;
+    if (pathSegments.length == 4) {&lt;br/&gt;
+      // A timestamp has been supplied.&lt;br/&gt;
+      timestampStr = pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;3&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+      if (timestampStr.equals(&quot;timestamps&quot;)) {
+        // Not supported in hbase just yet. TODO
+        doMethodNotAllowed(response, &quot;Not yet supported by hbase&quot;);
+        return;
+      }&lt;br/&gt;
+    }&lt;br/&gt;
+    &lt;br/&gt;
+    String[] columns = request.getParameterValues(COLUMN);&lt;br/&gt;
+        &lt;br/&gt;
+    if (columns == null || columns.length == 0) {&lt;br/&gt;
+      // They want full row returned. &lt;br/&gt;
+&lt;br/&gt;
+      // Presumption is that this.table has already been focused on target table.&lt;br/&gt;
+      Map&amp;lt;byte [], Cell&amp;gt; result = timestampStr == null ? &lt;br/&gt;
+        table.getRow(Bytes.toBytes(row)) &lt;br/&gt;
+        : table.getRow(Bytes.toBytes(row), Long.parseLong(timestampStr));&lt;br/&gt;
+        &lt;br/&gt;
+      if (result == null || result.size() == 0) {
+        doNotFound(response, &quot;Row not found!&quot;);
+      } else {&lt;br/&gt;
+        switch (ContentType.getContentType(request.getHeader(ACCEPT))) {
+        case XML:
+          outputRowXml(response, result);
+          break;
+        case MIME:
+        default:
+          doNotAcceptable(response, &quot;Unsupported Accept Header Content: &quot; +
+            request.getHeader(CONTENT_TYPE));
+        }&lt;br/&gt;
+      }&lt;br/&gt;
+    } else {&lt;br/&gt;
+      Map&amp;lt;byte [], Cell&amp;gt; prefiltered_result = table.getRow(Bytes.toBytes(row));&lt;br/&gt;
+    &lt;br/&gt;
+      if (prefiltered_result == null || prefiltered_result.size() == 0) {
+        doNotFound(response, &quot;Row not found!&quot;);
+      } else {&lt;br/&gt;
+        // create a Set from the columns requested so we can&lt;br/&gt;
+        // efficiently filter the actual found columns&lt;br/&gt;
+        Set&amp;lt;String&amp;gt; requested_columns_set = new HashSet&amp;lt;String&amp;gt;();&lt;br/&gt;
+        for(int i = 0; i &amp;lt; columns.length; i++){
+          requested_columns_set.add(columns[i]);
+        }&lt;br/&gt;
+  &lt;br/&gt;
+        // output map that will contain the filtered results&lt;br/&gt;
+        Map&amp;lt;byte [], Cell&amp;gt; m =&lt;br/&gt;
+          new TreeMap&amp;lt;byte [], Cell&amp;gt;(Bytes.BYTES_COMPARATOR);&lt;br/&gt;
+&lt;br/&gt;
+        // get an array of all the columns retrieved&lt;br/&gt;
+        Set&amp;lt;byte []&amp;gt; columns_retrieved = prefiltered_result.keySet();&lt;br/&gt;
+&lt;br/&gt;
+        // copy over those cells with requested column names&lt;br/&gt;
+        for(byte [] current_column: columns_retrieved) {&lt;br/&gt;
+          if (requested_columns_set.contains(Bytes.toString(current_column))) {
+            m.put(current_column, prefiltered_result.get(current_column));            
+          }&lt;br/&gt;
+        }&lt;br/&gt;
+        &lt;br/&gt;
+        switch (ContentType.getContentType(request.getHeader(ACCEPT))) {
+          case XML:
+            outputRowXml(response, m);
+            break;
+          case MIME:
+          default:
+            doNotAcceptable(response, &quot;Unsupported Accept Header Content: &quot; +
+              request.getHeader(CONTENT_TYPE));
+        }&lt;br/&gt;
+      }&lt;br/&gt;
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+  &lt;br/&gt;
+  /*&lt;br/&gt;
+   * Output a row encoded as XML.&lt;br/&gt;
+   * @param response&lt;br/&gt;
+   * @param result&lt;br/&gt;
+   * @throws IOException&lt;br/&gt;
+   */&lt;br/&gt;
+  private void outputRowXml(final HttpServletResponse response,&lt;br/&gt;
+      final Map&amp;lt;byte [], Cell&amp;gt; result)&lt;br/&gt;
+  throws IOException {
+    setResponseHeader(response, result.size() &amp;gt; 0? 200: 204,
+        ContentType.XML.toString());
+    XMLOutputter outputter = getXMLOutputter(response.getWriter());
+    outputter.startTag(ROW);
+    outputColumnsXml(outputter, result);
+    outputter.endTag();
+    outputter.endDocument();
+    outputter.getWriter().close();
+  }&lt;br/&gt;
+  &lt;br/&gt;
+  /*&lt;br/&gt;
+   * @param response&lt;br/&gt;
+   * @param result&lt;br/&gt;
+   * Output the results contained in result as a multipart/related response.&lt;br/&gt;
+   */&lt;br/&gt;
+  // private void outputRowMime(final HttpServletResponse response,&lt;br/&gt;
+  //     final Map&amp;lt;Text, Cell&amp;gt; result)&lt;br/&gt;
+  // throws IOException {
+  //   response.setStatus(result.size() &amp;gt; 0? 200: 204);
+  //   // This code ties me to the jetty server.
+  //   MultiPartResponse mpr = new MultiPartResponse(response);
+  //   // Content type should look like this for multipart:
+  //   // Content-type: multipart/related;start=&quot;&amp;lt;rootpart*94ebf1e6-7eb5-43f1-85f4-2615fc40c5d6@example.jaxws.sun.com&amp;gt;&quot;;type=&quot;application/xop+xml&quot;;boundary=&quot;uuid:94ebf1e6-7eb5-43f1-85f4-2615fc40c5d6&quot;;start-info=&quot;text/xml&quot;
+  //   String ct = ContentType.MIME.toString() + &quot;;charset=\&quot;UTF-8\&quot;;boundary=\&quot;&quot; +
+  //     mpr.getBoundary() + &quot;\&quot;&quot;;
+  //   // Setting content type is broken.  I&apos;m unable to set parameters on the
+  //   // content-type; They get stripped.  Can&apos;t set boundary, etc.
+  //   // response.addHeader(&quot;Content-Type&quot;, ct);
+  //   response.setContentType(ct);
+  //   outputColumnsMime(mpr, result);
+  //   mpr.close();
+  // }&lt;br/&gt;
+  &lt;br/&gt;
+  /*&lt;br/&gt;
+   * @param request&lt;br/&gt;
+   * @param response&lt;br/&gt;
+   * @param pathSegments&lt;br/&gt;
+   * Do a put based on the client request.&lt;br/&gt;
+   */&lt;br/&gt;
+  private void putRow(final HttpServletRequest request,&lt;br/&gt;
+    final HttpServletResponse response, final String [] pathSegments)&lt;br/&gt;
+  throws IOException, ServletException {&lt;br/&gt;
+    HTable table = getTable(pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
+&lt;br/&gt;
+    // pull the row key out of the path&lt;br/&gt;
+    String row = URLDecoder.decode(pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;, HConstants.UTF8_ENCODING);&lt;br/&gt;
+    &lt;br/&gt;
+    switch(ContentType.getContentType(request.getHeader(CONTENT_TYPE))) {
+      case XML:
+        putRowXml(table, row, request, response, pathSegments);
+        break;
+      case MIME:
+        doNotAcceptable(response, &quot;Don&apos;t support multipart/related yet...&quot;);
+        break;
+      default:
+        doNotAcceptable(response, &quot;Unsupported Accept Header Content: &quot; +
+          request.getHeader(CONTENT_TYPE));
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  /*&lt;br/&gt;
+   * @param request&lt;br/&gt;
+   * @param response&lt;br/&gt;
+   * @param pathSegments&lt;br/&gt;
+   * Decode supplied XML and do a put to Hbase.&lt;br/&gt;
+   */&lt;br/&gt;
+  private void putRowXml(HTable table, String row, &lt;br/&gt;
+    final HttpServletRequest request, final HttpServletResponse response, &lt;br/&gt;
+    final String [] pathSegments)&lt;br/&gt;
+  throws IOException, ServletException{&lt;br/&gt;
+&lt;br/&gt;
+    DocumentBuilderFactory docBuilderFactory &lt;br/&gt;
+      = DocumentBuilderFactory.newInstance();  &lt;br/&gt;
+    //ignore all comments inside the xml file&lt;br/&gt;
+    docBuilderFactory.setIgnoringComments(true);&lt;br/&gt;
+&lt;br/&gt;
+    DocumentBuilder builder = null;&lt;br/&gt;
+    Document doc = null;&lt;br/&gt;
+    &lt;br/&gt;
+    String timestamp = pathSegments.length &amp;gt;= 4 ? pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;3&amp;#93;&lt;/span&gt; : null;&lt;br/&gt;
+    &lt;br/&gt;
+    try{
+      builder = docBuilderFactory.newDocumentBuilder();
+      doc = builder.parse(request.getInputStream());
+    } catch (javax.xml.parsers.ParserConfigurationException e) {
+      throw new ServletException(e);
+    } catch (org.xml.sax.SAXException e){
+      throw new ServletException(e);
+    }&lt;br/&gt;
+&lt;br/&gt;
+    BatchUpdate batchUpdate;&lt;br/&gt;
+    &lt;br/&gt;
+    try{&lt;br/&gt;
+      // start an update&lt;br/&gt;
+      batchUpdate = timestamp == null ? &lt;br/&gt;
+        new BatchUpdate(row) : new BatchUpdate(row, Long.parseLong(timestamp));&lt;br/&gt;
+&lt;br/&gt;
+      // set the columns from the xml&lt;br/&gt;
+      NodeList columns = doc.getElementsByTagName(&quot;column&quot;);&lt;br/&gt;
+&lt;br/&gt;
+      for(int i = 0; i &amp;lt; columns.getLength(); i++){&lt;br/&gt;
+        // get the current column element we&apos;re working on&lt;br/&gt;
+        Element column = (Element)columns.item&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;br/&gt;
+&lt;br/&gt;
+        // extract the name and value children&lt;br/&gt;
+        Node name_node = column.getElementsByTagName(&quot;name&quot;).item(0);&lt;br/&gt;
+        String name = name_node.getFirstChild().getNodeValue();&lt;br/&gt;
+&lt;br/&gt;
+        Node value_node = column.getElementsByTagName(&quot;value&quot;).item(0);&lt;br/&gt;
+&lt;br/&gt;
+        byte[] value = new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+        &lt;br/&gt;
+        // for some reason there&apos;s no value here. probably indicates that&lt;br/&gt;
+        // the consumer passed a null as the cell value.&lt;br/&gt;
+        if(value_node.getFirstChild() != null &amp;amp;&amp;amp; &lt;br/&gt;
+          value_node.getFirstChild().getNodeValue() != null){
+          // decode the base64&apos;d value
+          value = org.apache.hadoop.hbase.util.Base64.decode(
+            value_node.getFirstChild().getNodeValue());
+        }&lt;br/&gt;
+&lt;br/&gt;
+        // put the value&lt;br/&gt;
+        batchUpdate.put(name, value);&lt;br/&gt;
+      }&lt;br/&gt;
+&lt;br/&gt;
+      // commit the update&lt;br/&gt;
+      table.commit(batchUpdate);&lt;br/&gt;
+      &lt;br/&gt;
+      // respond with a 200&lt;br/&gt;
+      response.setStatus(200);      &lt;br/&gt;
+    }&lt;br/&gt;
+    catch(Exception e){
+      throw new ServletException(e);
+    }+  }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+  &lt;br/&gt;
+  /*&lt;br/&gt;
+   * @param request&lt;br/&gt;
+   * @param response&lt;br/&gt;
+   * @param pathSegments&lt;br/&gt;
+   * Delete some or all cells for a row.&lt;br/&gt;
+   */&lt;br/&gt;
+   private void deleteRow(final HttpServletRequest request,&lt;br/&gt;
+    final HttpServletResponse response, final String [] pathSegments)&lt;br/&gt;
+   throws IOException, ServletException {&lt;br/&gt;
+    // grab the table we&apos;re operating on&lt;br/&gt;
+    HTable table = getTable(getTableName(pathSegments));&lt;br/&gt;
+    &lt;br/&gt;
+    // pull the row key out of the path&lt;br/&gt;
+    String row = URLDecoder.decode(pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;, HConstants.UTF8_ENCODING);&lt;br/&gt;
+&lt;br/&gt;
+    String[] columns = request.getParameterValues(COLUMN);&lt;br/&gt;
+        &lt;br/&gt;
+    // hack - we&apos;ll actually test for the presence of the timestamp parameter&lt;br/&gt;
+    // eventually&lt;br/&gt;
+    boolean timestamp_present = false;&lt;br/&gt;
+    if(timestamp_present)&lt;/p&gt;
{ // do a timestamp-aware delete
+      doMethodNotAllowed(response, &quot;DELETE with a timestamp not implemented!&quot;);
+    }
&lt;p&gt;+    else{ // ignore timestamps&lt;br/&gt;
+      if(columns == null || columns.length == 0)&lt;/p&gt;
{
+        // retrieve all the columns
+        doMethodNotAllowed(response,
+          &quot;DELETE without specified columns not implemented!&quot;);
+      }
&lt;p&gt; else&lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+        // delete each column in turn      +        for(int i = 0; i &amp;lt; columns.length; i++){
+          table.deleteAll(row, columns[i]);
+        }+      }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+      response.setStatus(202);&lt;br/&gt;
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+}&lt;br/&gt;
Index: src/java/org/apache/hadoop/hbase/rest/Dispatcher.java&lt;br/&gt;
===================================================================&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;src/java/org/apache/hadoop/hbase/rest/Dispatcher.java	(revision 682229)&lt;br/&gt;
+++ src/java/org/apache/hadoop/hbase/rest/Dispatcher.java	(working copy)&lt;br/&gt;
@@ -22,7 +22,6 @@&lt;br/&gt;
 import java.io.IOException;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import javax.servlet.ServletException;&lt;br/&gt;
-import javax.servlet.http.HttpServlet;&lt;br/&gt;
 import javax.servlet.http.HttpServletRequest;&lt;br/&gt;
 import javax.servlet.http.HttpServletResponse;&lt;/p&gt;

&lt;p&gt;@@ -63,8 +62,10 @@&lt;br/&gt;
   private static final Log LOG = LogFactory.getLog(Dispatcher.class.getName());&lt;br/&gt;
   private MetaHandler metaHandler;&lt;br/&gt;
   private TableHandler tableHandler;&lt;br/&gt;
+  private RowHandler rowHandler;&lt;br/&gt;
   private ScannerHandler scannerHandler;&lt;/p&gt;

&lt;p&gt;+  private static final String TABLES = &quot;tables&quot;;&lt;br/&gt;
   private static final String SCANNER = &quot;scanner&quot;;&lt;br/&gt;
   private static final String ROW = &quot;row&quot;;&lt;/p&gt;

&lt;p&gt;@@ -85,6 +86,7 @@&lt;br/&gt;
       admin = new HBaseAdmin(conf);&lt;br/&gt;
       metaHandler = new MetaHandler(conf, admin);&lt;br/&gt;
       tableHandler = new TableHandler(conf, admin);&lt;br/&gt;
+      rowHandler = new RowHandler(conf, admin);&lt;br/&gt;
       scannerHandler = new ScannerHandler(conf, admin);&lt;br/&gt;
     } catch(Exception e)&lt;/p&gt;
{
       throw new ServletException(e);
@@ -100,9 +102,14 @@
       // the entire instance.
       metaHandler.doGet(request, response, pathSegments);
     }
&lt;p&gt; else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// otherwise, it must be a GET request suitable for the&lt;/li&gt;
	&lt;li&gt;// table handler.&lt;/li&gt;
	&lt;li&gt;tableHandler.doGet(request, response, pathSegments);&lt;br/&gt;
+      if (pathSegments.length &amp;gt;= 2 &amp;amp;&amp;amp; pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.length() &amp;gt; 0 &amp;amp;&amp;amp; pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;.toLowerCase().equals(ROW)) 
{
+        // if it has table name and row path segments
+        rowHandler.doGet(request, response, pathSegments);
+      }
&lt;p&gt; else &lt;/p&gt;
{
+        // otherwise, it must be a GET request suitable for the
+        // table handler.
+        tableHandler.doGet(request, response, pathSegments);
+      }
&lt;p&gt;     }&lt;br/&gt;
   }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -110,15 +117,26 @@&lt;br/&gt;
   throws IOException, ServletException {&lt;br/&gt;
     String [] pathSegments = getPathSegments(request);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// there should be at least two path segments (table name and row or scanner)&lt;/li&gt;
	&lt;li&gt;if (pathSegments.length &amp;gt;= 2 &amp;amp;&amp;amp; pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.length() &amp;gt; 0) {&lt;/li&gt;
	&lt;li&gt;if (pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;.toLowerCase().equals(SCANNER) &amp;amp;&amp;amp;&lt;/li&gt;
	&lt;li&gt;pathSegments.length &amp;gt;= 2) 
{
-        scannerHandler.doPost(request, response, pathSegments);
-        return;
-      }
&lt;p&gt; else if (pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;.toLowerCase().equals(ROW) &amp;amp;&amp;amp; pathSegments.length &amp;gt;= 3) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;tableHandler.doPost(request, response, pathSegments);&lt;/li&gt;
	&lt;li&gt;return;&lt;br/&gt;
+    if (pathSegments.length == 1 &amp;amp;&amp;amp; pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.toLowerCase().equals(TABLES)) 
{
+      tableHandler.doPost(request, response, pathSegments);
+      return;
+    }
&lt;p&gt; else {&lt;br/&gt;
+      // there should be at least two path segments (table name and row or&lt;br/&gt;
+      // scanner)&lt;br/&gt;
+      if (pathSegments.length &amp;gt;= 2 &amp;amp;&amp;amp; pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.length() &amp;gt; 0) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+        if (pathSegments[1].toLowerCase().equals(SCANNER)+            &amp;amp;&amp;amp; pathSegments.length &amp;gt;= 2) {
+          scannerHandler.doPost(request, response, pathSegments);
+          return;
+        } else if (pathSegments[1].toLowerCase().equals(ROW)+            &amp;amp;&amp;amp; pathSegments.length &amp;gt;= 3) {
+          rowHandler.doPost(request, response, pathSegments);
+          return;
+        } else if (pathSegments[0].toLowerCase().equals(TABLES) &amp;amp;&amp;amp; pathSegments[1].length() &amp;gt; 0 +            &amp;amp;&amp;amp; (pathSegments[2].toLowerCase().equals(TableHandler.DISABLE) || pathSegments[2].toLowerCase().equals(TableHandler.ENABLE))) {
+          tableHandler.doPost(request, response, pathSegments);
+          return;
+        }       }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -130,7 +148,13 @@&lt;br/&gt;
   protected void doPut(HttpServletRequest request, HttpServletResponse response)&lt;br/&gt;
   throws ServletException, IOException {&lt;br/&gt;
     // Equate PUT with a POST.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;doPost(request, response);&lt;br/&gt;
+    String [] pathSegments = getPathSegments(request);&lt;br/&gt;
+    &lt;br/&gt;
+    if (pathSegments.length == 2 &amp;amp;&amp;amp; pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.toLowerCase().equals(TABLES) &amp;amp;&amp;amp; pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;.length() &amp;gt; 0) 
{
+      tableHandler.doPut(request, response, pathSegments);
+    }
&lt;p&gt; else &lt;/p&gt;
{
+      doPost(request, response);
+    }
&lt;p&gt;   }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   protected void doDelete(HttpServletRequest request,&lt;br/&gt;
@@ -138,18 +162,21 @@&lt;br/&gt;
   throws IOException, ServletException {&lt;br/&gt;
     String [] pathSegments = getPathSegments(request);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// must be at least two path segments (table name and row or scanner)&lt;/li&gt;
	&lt;li&gt;if (pathSegments.length &amp;gt;= 2 &amp;amp;&amp;amp; pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.length() &amp;gt; 0) {&lt;/li&gt;
	&lt;li&gt;// DELETE to a scanner requires at least three path segments&lt;br/&gt;
+    if (pathSegments.length == 2 &amp;amp;&amp;amp; pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.toLowerCase().equals(TABLES) &amp;amp;&amp;amp; pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;.length() &amp;gt; 0) 
{
+      tableHandler.doDelete(request, response, pathSegments);
+      return;
+    }
&lt;p&gt; else if (pathSegments.length &amp;gt;= 3 &amp;amp;&amp;amp; pathSegments&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.length() &amp;gt; 0) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+      // must be at least two path segments (table name and row or scanner)       if (pathSegments[1].toLowerCase().equals(SCANNER) &amp;amp;&amp;amp;           pathSegments.length == 3 &amp;amp;&amp;amp; pathSegments[2].length() &amp;gt; 0) {
+        // DELETE to a scanner requires at least three path segments
         scannerHandler.doDelete(request, response, pathSegments);
         return;
       } else if (pathSegments[1].toLowerCase().equals(ROW) &amp;amp;&amp;amp;           pathSegments.length &amp;gt;= 3) {
-        tableHandler.doDelete(request, response, pathSegments);
+        rowHandler.doDelete(request, response, pathSegments);
         return;
-      } +      }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     // if we reach this point, then no handler exists for this request.&lt;br/&gt;
Index: src/java/org/apache/hadoop/hbase/rest/GenericHandler.java&lt;br/&gt;
===================================================================&lt;br/&gt;
&amp;#8212; src/java/org/apache/hadoop/hbase/rest/GenericHandler.java	(revision 682229)&lt;br/&gt;
+++ src/java/org/apache/hadoop/hbase/rest/GenericHandler.java	(working copy)&lt;br/&gt;
@@ -55,6 +55,7 @@&lt;br/&gt;
   protected static final String CONTENT_TYPE = &quot;content-type&quot;;&lt;br/&gt;
   protected static final String ROW = &quot;row&quot;;&lt;br/&gt;
   protected static final String REGIONS = &quot;regions&quot;;&lt;br/&gt;
+  protected static final String TABLES = &quot;tables&quot;;&lt;/p&gt;

&lt;p&gt;   protected final Log LOG = LogFactory.getLog(this.getClass());&lt;/p&gt;</comment>
                            <comment id="12622003" author="stack" created="Tue, 12 Aug 2008 22:06:33 +0000"  >&lt;p&gt;This is a nice patch.  Applies fine.  I took it for a spin doing the prescription outlined above.  All works nicely.   Only issues I see is what if there exists already a table named &apos;tables&apos; and the lack of documentation of REST in general (not your fault).  &lt;/p&gt;

&lt;p&gt;Maybe you should rename the &apos;tables&apos; switch to be a name you know is illegal as a legit tablename: e.g. _tables or some such (See HTableDescriptor.isLegalTableName for rules).&lt;/p&gt;

&lt;p&gt;Meantime, I&apos;m going to apply this since it adds nice functionality.  If you get a chance, add package doc. to REST, if only to point back at the wiki page, and fix the &apos;tables&apos; issue if you come up w/ an idea better than mine above.&lt;/p&gt;</comment>
                            <comment id="12622005" author="stack" created="Tue, 12 Aug 2008 22:08:17 +0000"  >&lt;p&gt;Committed to TRUNK.  Thanks for the patch Sishen.&lt;/p&gt;</comment>
                            <comment id="12622048" author="yedingding@gmail.com" created="Wed, 13 Aug 2008 00:38:46 +0000"  >&lt;p&gt;Thanks for the work, stack. I&apos;m glad it&apos;s helpful.&lt;/p&gt;

&lt;p&gt;I&apos;ll take care of the work you mentioned today. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Best regards.&lt;/p&gt;

&lt;p&gt;sishen&lt;/p&gt;

</comment>
                            <comment id="12622321" author="yedingding@gmail.com" created="Wed, 13 Aug 2008 19:09:42 +0000"  >&lt;p&gt;Stack reported that if there is a table named tables, my previous patch will have a name collision.  So i deleted all the prefix &quot;/tables&quot; in this new version of patch.&lt;/p&gt;

&lt;p&gt;Now the interface are:&lt;/p&gt;

&lt;p&gt;Create table :  POST /&lt;br/&gt;
Update table : PUT /&lt;br/&gt;
Delete table: DELETE /&lt;span class=&quot;error&quot;&gt;&amp;#91;table_name&amp;#93;&lt;/span&gt;&lt;br/&gt;
Disable table: POST /&lt;span class=&quot;error&quot;&gt;&amp;#91;table_name&amp;#93;&lt;/span&gt;/disable&lt;br/&gt;
Enable table: POST /&lt;span class=&quot;error&quot;&gt;&amp;#91;table_name&amp;#93;&lt;/span&gt;/enable&lt;/p&gt;

&lt;p&gt;For the details and examples, please visit &lt;a href=&quot;http://wiki.apache.org/hadoop/Hbase/HbaseRest&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://wiki.apache.org/hadoop/Hbase/HbaseRest&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="12622445" author="yedingding@gmail.com" created="Thu, 14 Aug 2008 05:44:05 +0000"  >&lt;p&gt;improve my first patch&lt;/p&gt;</comment>
                            <comment id="12622448" author="yedingding@gmail.com" created="Thu, 14 Aug 2008 05:58:46 +0000"  >&lt;p&gt;Hi, stack. Sorry to trouble you directly.&lt;/p&gt;

&lt;p&gt;I have sumbit another patch to the issue 795 directly instead of opening a&lt;br/&gt;
new issue.&lt;br/&gt;
However, since the resolution is fixed now and maybe you will skip it. So&lt;br/&gt;
just want to&lt;br/&gt;
make a confirmation.  Thanks for your time.&lt;/p&gt;

&lt;p&gt;Best regards.&lt;/p&gt;

&lt;p&gt;sishen&lt;/p&gt;


</comment>
                            <comment id="12623238" author="stack" created="Sun, 17 Aug 2008 22:55:01 +0000"  >&lt;p&gt;Sishen: I committed this as part 2 of hbase-795 to TRUNK.   Thanks for the improvement and the update of the wiki page (I like your trick where can type in on STDIN using curl).  In future, would suggest you open a new JIRA rather than attach new patch to old issue.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12387529" name="795.trunk.rest_table.patch" size="38330" author="sishen" created="Tue, 5 Aug 2008 00:11:54 +0000"/>
                            <attachment id="12388174" name="795.trunk.rest_table_v2.patch" size="6260" author="yedingding@gmail.com" created="Wed, 13 Aug 2008 19:09:42 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 12 Aug 2008 22:06:33 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>31853</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 18 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0h9hr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>98800</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>