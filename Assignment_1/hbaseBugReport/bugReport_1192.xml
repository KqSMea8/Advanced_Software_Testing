<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 18:51:30 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-1192/HBASE-1192.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-1192] LRU-style map for the block cache</title>
                <link>https://issues.apache.org/jira/browse/HBASE-1192</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;We need to decide what structure to use to back the block cache.  The primary decision is whether to continue using SoftReferences or to build our own structure.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12414411">HBASE-1192</key>
            <summary>LRU-style map for the block cache</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.png">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="ryanobjc">ryan rawson</assignee>
                                    <reporter username="streamy">Jonathan Gray</reporter>
                        <labels>
                    </labels>
                <created>Mon, 9 Feb 2009 18:23:02 +0000</created>
                <updated>Thu, 2 May 2013 02:29:20 +0000</updated>
                            <resolved>Sun, 31 May 2009 23:42:21 +0000</resolved>
                                    <version>0.20.0</version>
                                    <fixVersion>0.20.0</fixVersion>
                                    <component>regionserver</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12671957" author="streamy" created="Mon, 9 Feb 2009 18:47:17 +0000"  >&lt;p&gt;My proposal is to build upon the work being done in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1186&quot; title=&quot;Memory-aware Maps with LRU eviction for Cell Cache&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1186&quot;&gt;&lt;del&gt;HBASE-1186&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1188&quot; title=&quot;Memory size of Java Objects - Make cacheable objects implement HeapSize&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1188&quot;&gt;&lt;del&gt;HBASE-1188&lt;/del&gt;&lt;/a&gt; to create our own LRU-style Map specialized for the block cache.&lt;/p&gt;

&lt;p&gt;A few points as to why I think we should move away from SoftReferences and manage everything ourselves:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The defined loose constraints and observed non-uniform behavior of SoftReferences&lt;/li&gt;
	&lt;li&gt;We&apos;re already &quot;managing&quot; heap usage for Memcache.  Using softrefs for block cache, we&apos;ll have something that&apos;s almost a black box and trying to use all available memory.  This could make the memcache flush out itself because the RS is under heap pressure.  We won&apos;t have much control over fairness between memcaches, indexes, and the block cache if using softrefs.  I propose we build something very similar to the MemcacheFlusher thread that would deal with fairness between the different elements of the RS that uses significant heap (memcaches, indexes, block cache, cell cache, in-memory families, blooms, etc...).  As with the new file format, there&apos;s going to be more parameters in hbase 0.20 in order to optimize for your use case.  Like the file format, we&apos;ll have to come up with reasonable defaults and write more documentation about the effects of the different settings.  Do we want to divide up the total available heap on startup between the different memory consumers, do we want to leave it wide open for memcaches/indexes/blocks until we&apos;re under heap pressure and then make a decision about how to flush or evict fairly?&lt;/li&gt;
	&lt;li&gt;Ability to implement in-memory families as described in the bigtable paper very easily by adding priority into the eviction algorithm&lt;/li&gt;
	&lt;li&gt;Full table scans can thrash the cache (for Streamy, we do this only for MR jobs not user-facing stuff).  With our own structure, we can use a modified LRU algorithm that is resistant to table scans (i&apos;m a fan of ARC but there&apos;s license issues; it&apos;s fairly simple to implement this if you manually configure... ARC is cool because it self-tunes).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Those are my main points.  The primary reason to not go in this direction is simplicity.  However, I think what we&apos;ve learned in the past couple releases from OOME hell, we must (and already are) be in the business of heap management.  Streamy guys have done the research and development to do memory management in java as best as it seems it can be done (based on other open source java caching apps), so I&apos;m confident we can be correct, efficient, and accurate enough to prevent oome issues and get optimal performance.&lt;/p&gt;

&lt;p&gt;Erik will post his findings from his work experimenting with softref behavior.&lt;/p&gt;</comment>
                            <comment id="12671960" author="erikholstad@gmail.com" created="Mon, 9 Feb 2009 19:00:19 +0000"  >&lt;p&gt;In the instructions for SoftReferences you can find:&lt;br/&gt;
&quot;All soft references to softly-reachable objects are guaranteed to have been cleared before the virtual machine throws an OutOfMemoryError. Otherwise no constraints are placed upon the time at which a soft reference will be cleared or the order in which a set of such references to different objects will be cleared. Virtual machine implementations are, however, encouraged to bias against clearing recently-created or recently-used soft references.&quot;&lt;/p&gt;

&lt;p&gt;Which would mean that the behavior would change from JVM to JVM, so the Lruness of the system is clearly questionable.&lt;/p&gt;


&lt;p&gt;Ran a test where I used SoftSortedValueMap and inserted 10M entries into it, all entries were the same size.&lt;br/&gt;
i is the entry currently inserted&lt;/p&gt;

&lt;p&gt;size of map before 1285540&lt;br/&gt;
size of deletes 1285537&lt;br/&gt;
size of map after 3&lt;br/&gt;
i 1285540&lt;/p&gt;

&lt;p&gt;size of map before 1287469&lt;br/&gt;
size of deletes 443&lt;br/&gt;
size of map after 1287026&lt;br/&gt;
i 2573006&lt;/p&gt;

&lt;p&gt;size of map before 1287027&lt;br/&gt;
size of deletes 2075&lt;br/&gt;
size of map after 1284952&lt;br/&gt;
i 2573007&lt;/p&gt;

&lt;p&gt;size of map before 1284953&lt;br/&gt;
size of deletes 692&lt;br/&gt;
size of map after 1284261&lt;br/&gt;
i 2573008&lt;/p&gt;

&lt;p&gt;size of map before 1284262&lt;br/&gt;
size of deletes 624&lt;br/&gt;
size of map after 1283638&lt;br/&gt;
i 2573009&lt;/p&gt;

&lt;p&gt;size of map before 1283639&lt;br/&gt;
size of deletes 650&lt;br/&gt;
size of map after 1282989&lt;br/&gt;
i 2573010&lt;/p&gt;

&lt;p&gt;size of map before 1282990&lt;br/&gt;
size of deletes 672&lt;br/&gt;
size of map after 1282318&lt;br/&gt;
i 2573011&lt;/p&gt;

&lt;p&gt;size of map before 1282319&lt;br/&gt;
size of deletes 632&lt;br/&gt;
size of map after 1281687&lt;br/&gt;
i 2573012&lt;/p&gt;

&lt;p&gt;size of map before 1281688&lt;br/&gt;
size of deletes 1281679&lt;br/&gt;
size of map after 9&lt;br/&gt;
i 2573013&lt;/p&gt;

&lt;p&gt;size of map before 1285424&lt;br/&gt;
size of deletes 1285423&lt;br/&gt;
size of map after 1&lt;br/&gt;
i 3858428&lt;/p&gt;

&lt;p&gt;size of map before 1286746&lt;br/&gt;
size of deletes 1286745&lt;br/&gt;
size of map after 1&lt;br/&gt;
i 5145173&lt;/p&gt;

&lt;p&gt;size of map before 1285660&lt;br/&gt;
size of deletes 1285659&lt;br/&gt;
size of map after 1&lt;br/&gt;
i 6430832&lt;/p&gt;

&lt;p&gt;size of map before 1286804&lt;br/&gt;
size of deletes 1286802&lt;br/&gt;
size of map after 2&lt;br/&gt;
i 7717635&lt;/p&gt;

&lt;p&gt;size of map before 1286745&lt;br/&gt;
size of deletes 1286744&lt;br/&gt;
size of map after 1&lt;br/&gt;
i 9004378&lt;/p&gt;

&lt;p&gt;So one can see that sometimes it evicts a some 100 entries for every insert and other times&lt;br/&gt;
it basically empties the whole map, but waits long in between.&lt;/p&gt;</comment>
                            <comment id="12671963" author="streamy" created="Mon, 9 Feb 2009 19:10:05 +0000"  >&lt;p&gt;All objects involved with the block cache must implement HeapSize&lt;/p&gt;</comment>
                            <comment id="12671971" author="jdcryans" created="Mon, 9 Feb 2009 19:26:26 +0000"  >&lt;p&gt;+1 for the nifty LRU map.&lt;/p&gt;</comment>
                            <comment id="12671975" author="stack" created="Mon, 9 Feb 2009 19:41:17 +0000"  >&lt;p&gt;Great work lads. +1 on the direction.&lt;/p&gt;</comment>
                            <comment id="12671982" author="jimk" created="Mon, 9 Feb 2009 19:48:16 +0000"  >&lt;p&gt;Looks good so far.&lt;/p&gt;</comment>
                            <comment id="12672082" author="streamy" created="Tue, 10 Feb 2009 00:34:20 +0000"  >&lt;p&gt;This takes the baseline LruHashMap from &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1186&quot; title=&quot;Memory-aware Maps with LRU eviction for Cell Cache&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1186&quot;&gt;&lt;del&gt;HBASE-1186&lt;/del&gt;&lt;/a&gt; and wraps it in a LruBlockCache class which implements both HeapSize and the new HFile interface BlockCache.&lt;/p&gt;

&lt;p&gt;The code is not well tested but wanted to get something up asap to start tinkering.&lt;/p&gt;

&lt;p&gt;As discussed on IRC, block caching is no longer optional across the board.&lt;/p&gt;

&lt;p&gt;Note:  this patch creates the necessary files in the working directory and not the hbase src tree because we&apos;re still doing file format testing outside of trunk&lt;/p&gt;</comment>
                            <comment id="12672858" author="apurtell" created="Thu, 12 Feb 2009 02:17:17 +0000"  >&lt;p&gt;+1&lt;/p&gt;</comment>
                            <comment id="12674401" author="streamy" created="Tue, 17 Feb 2009 23:47:18 +0000"  >&lt;p&gt;Built from latest LruHashMap, this is a specialized version that only works for &amp;lt;String,ByteBuffer&amp;gt;&lt;/p&gt;

&lt;p&gt;This is so we don&apos;t have to have wrapping classes that implement HeapSize for the key and val (req for LruHashMap).&lt;/p&gt;

&lt;p&gt;Needs testing but is expected to work, very few changes.&lt;/p&gt;

&lt;p&gt;This patch has a dependency of latest HeapSize as posted in most recent &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1186&quot; title=&quot;Memory-aware Maps with LRU eviction for Cell Cache&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1186&quot;&gt;&lt;del&gt;HBASE-1186&lt;/del&gt;&lt;/a&gt; v4 patch.&lt;/p&gt;</comment>
                            <comment id="12676450" author="streamy" created="Tue, 24 Feb 2009 23:24:18 +0000"  >&lt;p&gt;This patch moves LruBlockCache into .io.hfile package and it also now implements the BlockCache interface&lt;/p&gt;</comment>
                            <comment id="12689333" author="apurtell" created="Thu, 26 Mar 2009 02:09:01 +0000"  >&lt;p&gt;This is what I get when I try to apply and compile the v3 patch:
&lt;br class=&quot;atl-forced-newline&quot; /&gt;
&lt;br class=&quot;atl-forced-newline&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    [javac] /usr/src/Hadoop/hbase-trunk/src/java/org/apache/hadoop/hbase/io/hfile/LruBlockCache.java:210: cannot find symbol
    [javac] symbol  : variable blockNum
    [javac] location: class org.apache.hadoop.hbase.io.hfile.LruBlockCache
    [javac]     put(blockNum,buf);
    [javac]         ^
    [javac] /usr/src/Hadoop/hbase-trunk/src/java/org/apache/hadoop/hbase/io/hfile/LruBlockCache.java:1140: cannot find symbol
    [javac] symbol  : variable STRING
    [javac] location: &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; org.apache.hadoop.hbase.io.HeapSize
    [javac]       &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; HeapSize.STRING + alignSize(s.length()*2);
    [javac]                      ^
    [javac] /usr/src/Hadoop/hbase-trunk/src/java/org/apache/hadoop/hbase/io/hfile/LruBlockCache.java:1140: incompatible types
    [javac] found   : &amp;lt;nulltype&amp;gt;
    [javac] required: &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt;
    [javac]       &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; HeapSize.STRING + alignSize(s.length()*2);
    [javac]                              ^
    [javac] /usr/src/Hadoop/hbase-trunk/src/java/org/apache/hadoop/hbase/io/hfile/LruBlockCache.java:1148: cannot find symbol
    [javac] symbol  : variable BYTEBUFFER
    [javac] location: &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; org.apache.hadoop.hbase.io.HeapSize
    [javac]       &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; HeapSize.BYTEBUFFER + alignSize(b.capacity());
    [javac]                      ^
    [javac] /usr/src/Hadoop/hbase-trunk/src/java/org/apache/hadoop/hbase/io/hfile/LruBlockCache.java:1148: incompatible types
    [javac] found   : &amp;lt;nulltype&amp;gt;
    [javac] required: &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt;
    [javac]       &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; HeapSize.BYTEBUFFER + alignSize(b.capacity());
    [javac]                                  ^
    [javac] 5 errors
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="12705114" author="shalinmangar" created="Fri, 1 May 2009 20:52:56 +0000"  >&lt;p&gt;Can someone elaborate on why a custom implementation of an LRUCache is being made? I guess you can achieve memory-awareness by extending or wrapping a LinkedHashMap.&lt;/p&gt;

&lt;p&gt;Also, is the synchronized get/put alright for this use-case? Solr had some issues with synchronized LRUCache when the cache was hit thousands of times per second. &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-667&quot; title=&quot;Alternate LRUCache implementation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-667&quot;&gt;&lt;del&gt;SOLR-667&lt;/del&gt;&lt;/a&gt; has a good implementation that you can look at.&lt;/p&gt;

&lt;p&gt;I do not have the complete background so I may have missed something.&lt;/p&gt;</comment>
                            <comment id="12705118" author="streamy" created="Fri, 1 May 2009 21:10:01 +0000"  >&lt;p&gt;Shalin,&lt;/p&gt;

&lt;p&gt;On the inside, it is very similar to a LinkedHashMap, just customized to be memory-aware making use of our HeapSize interface.  It turned out to be much easier and more efficient to work with the data structures directly.&lt;/p&gt;

&lt;p&gt;It is possible we will run in to contention issues.  If we saw issues, my plan was to add buckets a la ConcurrentHashMap.&lt;/p&gt;

&lt;p&gt;Looking at the solr implementation, that looks like what you guys did!  Very cool.&lt;/p&gt;

&lt;p&gt;I will read up on the issue and patch.  Thanks Shalin!&lt;/p&gt;</comment>
                            <comment id="12705242" author="shalinmangar" created="Sat, 2 May 2009 08:48:17 +0000"  >&lt;p&gt;Thanks Jonathan.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;On the inside, it is very similar to a LinkedHashMap, just customized to be memory-aware making use of our HeapSize interface. It turned out to be much easier and more efficient to work with the data structures directly.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sure, if you find it easier that way, that&apos;s fine.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It is possible we will run in to contention issues. If we saw issues, my plan was to add buckets a la ConcurrentHashMap.&lt;/p&gt;

&lt;p&gt;Looking at the solr implementation, that looks like what you guys did! Very cool.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is what Solr has in trunk right now:&lt;br/&gt;
&lt;a href=&quot;http://svn.apache.org/viewvc/lucene/solr/trunk/src/common/org/apache/solr/common/util/ConcurrentLRUCache.java?view=markup&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/viewvc/lucene/solr/trunk/src/common/org/apache/solr/common/util/ConcurrentLRUCache.java?view=markup&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Also see &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-1082&quot; title=&quot;Refactor caching layer to be JCache compliant (jsr-107). In particular, consider using ehcache implementation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SOLR-1082&quot;&gt;&lt;del&gt;SOLR-1082&lt;/del&gt;&lt;/a&gt; where an ehcache based implementation was also discussed.&lt;/p&gt;</comment>
                            <comment id="12705343" author="stack" created="Sat, 2 May 2009 23:27:29 +0000"  >&lt;p&gt;@Shalin&lt;/p&gt;

&lt;p&gt;Thank you for the pointer to the rich lode on lock-free cache.&lt;/p&gt;

&lt;p&gt;@Jon&lt;/p&gt;

&lt;p&gt;What you think?  Thread scheduler is not fair in java.  Synchronizations could make for thread pile-ups with some left out in the cold never getting a look-in (the &apos;bottlenecks&apos;, I presume, referenced in the issue).  Could push out our 99.5th percentile.&lt;/p&gt;</comment>
                            <comment id="12705458" author="streamy" created="Sun, 3 May 2009 22:05:12 +0000"  >&lt;p&gt;Hopefully we do see this much concurrency on the block cache.  I read all the solr code, it looks solid.  I&apos;d like to try to keep our initial implementation as simple as we can, so will probably take hints from their implementation but write our own.&lt;/p&gt;

&lt;p&gt;I am going to be working on HBase stuff second half of this week.  I will take their code for a spin and do some benchmarking/tests.  I think we should back the block cache with a concurrenthashmap, will try to get a patch up by friday.&lt;/p&gt;</comment>
                            <comment id="12705540" author="noble.paul" created="Mon, 4 May 2009 09:38:59 +0000"  >&lt;blockquote&gt;&lt;p&gt;. I&apos;d like to try to keep our initial implementation as simple as we can, so will probably take hints from their implementation but write our own. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;hi Jon, I am co-author of the Solr cache implementation . The code is slightly complex because it is written for efficiency. But you can easily copy the java file as is and make small modifications to suit your needs.&lt;/p&gt;</comment>
                            <comment id="12706283" author="ryanobjc" created="Wed, 6 May 2009 02:08:18 +0000"  >&lt;p&gt;integrates jgray&apos;s previous LRU class and make it work and integrated with hfile.&lt;/p&gt;</comment>
                            <comment id="12714938" author="stack" created="Sun, 31 May 2009 23:42:21 +0000"  >&lt;p&gt;Thanks for the patch Ryan and Jon.  SOLR suggested improvements have been moved to &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1460&quot; title=&quot;Concurrent LRU Block Cache&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1460&quot;&gt;&lt;del&gt;HBASE-1460&lt;/del&gt;&lt;/a&gt;.  Will take up my issues w/ the current patch over there.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12386229">HBASE-61</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12415531">HBASE-1218</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                            <outwardlinks description="depends upon">
                                        <issuelink>
            <issuekey id="12414263">HBASE-1188</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12407307" name="HBASE-1192-ryan.patch" size="53348" author="ryanobjc" created="Wed, 6 May 2009 02:08:18 +0000"/>
                            <attachment id="12399870" name="hbase-1192-v1.patch" size="40779" author="streamy" created="Tue, 10 Feb 2009 00:34:20 +0000"/>
                            <attachment id="12400364" name="hbase-1192-v2.patch" size="34405" author="streamy" created="Tue, 17 Feb 2009 23:47:18 +0000"/>
                            <attachment id="12400891" name="hbase-1192-v3.patch" size="35326" author="streamy" created="Tue, 24 Feb 2009 23:24:18 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 9 Feb 2009 19:00:19 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>32031</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310191" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Hadoop Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10343"><![CDATA[Reviewed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 29 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0hbvj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>99186</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>