<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 20:05:43 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-9578/HBASE-9578.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-9578] Client side cell encryption</title>
                <link>https://issues.apache.org/jira/browse/HBASE-9578</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-7544&quot; title=&quot;Transparent table/CF encryption&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-7544&quot;&gt;&lt;del&gt;HBASE-7544&lt;/del&gt;&lt;/a&gt; will protect key and value data on the server from accidental leakage by way of improperly disposed disks, improper direct filesystem access, or incorrect HDFS permissions. There are also use cases where sensitive data stored in a table or column family by a given user or application should be protected from all others, and the combination of transparent server-side storage encryption and transport security (SASL auth-conf) is still not sufficient. These instances call for a client side per-cell encryption feature, given the following additional observations:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The scope of transmission, distribution, and storage of private key material should be as limited as possible. The server is a centralized target (even in the case of an HBase cluster) where the scope of damage from a compromise is magnified if user key material also resides there or can be intercepted after compromise. Where keys are stored in hardware devices, e.g. smartcards, getting the keys to the server may be not possible anyway.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;A client system is far more likely than a contended shared server resource to have necessary available CPU cycles for per-operation cryptographic overheads.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;For some cases we might not care so much about the second item, but the first is very important.&lt;/p&gt;

&lt;p&gt;I have an implementation of per cell client side encryption as an encrypting HTable wrapper which I could contribute if there is interest.&lt;/p&gt;

&lt;p&gt;This JIRA is also about brainstorming how to do better than that.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12669369">HBASE-9578</key>
            <summary>Client side cell encryption</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="apurtell">Andrew Purtell</reporter>
                        <labels>
                    </labels>
                <created>Wed, 18 Sep 2013 23:47:10 +0000</created>
                <updated>Fri, 4 Oct 2013 15:35:33 +0000</updated>
                                                                                <due></due>
                            <votes>0</votes>
                                    <watches>14</watches>
                                                                <comments>
                            <comment id="13771415" author="apurtell" created="Wed, 18 Sep 2013 23:53:31 +0000"  >&lt;p&gt;First, a HTable wrapper but definition must be explicitly used by an application. It is an easy solution to implement but is not transparent to the end user. Before HBase 0.95/0.96, with its new RPC codecs, a wrapper was the only implementation choice that avoids invasive changes to the client library. After 0.95/0.96, RPC codecs offer an interesting option for adding client side value encryption (and/or compression) in a more transparent way.&lt;/p&gt;

&lt;p&gt;Second, HBase is completely agnostic about value data but not so about keys. Traditional encryption if applied to key data as well would destroy data locality and scan semantics. There are some &quot;deterministic encryption&quot; schemes which would maintain a sort ordering but at the price of increased exposure to successful cryptanalysis. &lt;/p&gt;

&lt;p&gt;Next, and related to the trouble with keys and sorting, if all cryptographic transformations are performed entirely on the client side, as a consequence the encrypted data cannot be transformed into plaintext on the server, so several HBase API operations become impossible: append, increment, checkAndPut, checkAndDelete, and any scan filter that wants to examine cell values. For analytical workloads (short scans with highly selective filters, aggregating coprocessors) in particular this requires transferring much more data to the client for processing there than would otherwise be needed.&lt;/p&gt;

&lt;p&gt;We could consider sending private key material over in the RPC to work around this problem, but it is risky to ship private key material over the network ever, never mind frequently. So let&apos;s consider what can be done on the server as much as practical without sending over user private key material.&lt;/p&gt;

&lt;p&gt;A naive option would be to implement a fully homomorphic encryption scheme. In theory, any operation on the server over encrypted data would be possible. Unfortunately fully homomorphic encryption in practice imposes overheads on the order of 10^9. There are however some practical but more limited schemes which may be useful.&lt;/p&gt;

&lt;p&gt;At VLDB 2013, MIT CSAIL presented the paper &quot;Processing Analytical Queries over Encrypted Data&quot; which describes a research prototype, based on Postgres, capable of mixed operations over encrypted data client and server side. They employ encryption schemes applicable as well for restoring the HBase API operations mentioned above. &quot;Deterministic encryption&quot; with AES would make equality tests possible, restoring checkAndX operations, if we accept the leakage resulting from duplicates. Deterministic transformations also restore Append. OPE encryption can restore range scanning semantics, but with greater leakage leading to practical partial plaintext recovery. Maybe for some that would be an acceptable tradeoff. More interesting, Paillier homomorphic encryption supports addition, therefore summation, and could restore Increments and aggregating coprocessor functions like sum(). We might support some subset of scanning with filters by rewriting the filters passed in for a Scan with encryption-aware substitutions.&lt;/p&gt;

&lt;p&gt;Of course, there is the problem of encrypting the data at the client with the correct scheme for the wanted semantics. The full design burden could be pushed to the user. Better, the mentioned paper describes a table designer executed at data import time to choose the optimal physical layout for the desired schema. Something like that could be developed for HBase as well leveraging the typed data library.&lt;/p&gt;</comment>
                            <comment id="13786114" author="lmccay" created="Fri, 4 Oct 2013 12:56:50 +0000"  >&lt;p&gt;Hi Andrew - I missed this JIRA until now. It is interesting. I am curious how you would approach this from the REST client perspective. &lt;br/&gt;
It seems to me that the client perspective would actually move to Stargate in this case.&lt;br/&gt;
I think that that will introduce some additional nuances such as:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;how does stargate know what to encrypt and how&lt;/li&gt;
	&lt;li&gt;obviously the keying material acquisition as you already note is an issue but is also inline with what needs to be done for Hive table and col level encryption&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;we could provide an alias based scheme that gets resolved by some library (and optionally key mgt server).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;this won&apos;t protect it over the wire as the CLI usecase would as a side effect but that&apos;s what SSL is for in REST&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13786122" author="apurtell" created="Fri, 4 Oct 2013 13:13:14 +0000"  >&lt;p&gt;Hi Larry, if you are interested in discussing encryption options in/for the HBase REST gateway, it&apos;s probably best to open another JIRA. Sounds like you are contemplating having the client send plaintext to the REST server and then REST acting further on behalf of the client. That&apos;s not the use case here, but it could be useful for other ones.&lt;/p&gt;

&lt;p&gt;Having private keys available on the server side - REST in this case - is considered dangerous because compromise of a common location that aggregates user activity can be used to collect private key material. The keys used to encrypt the value data at the client should stay on the client and encryption and decryption should happen there. It&apos;s also worth thinking what can be done on the server, but the server side (including REST) remains untrusted and should not be able to actually decrypt data. Given this kind of approach, REST would need no modifications or further considerations, it would just pass through value data already encrypted by the client and .&lt;/p&gt;

&lt;p&gt;It&apos;s true that every client could run a REST gateway, but that would not be common I suspect, people generally would deploy it in a gateway type architecture.&lt;/p&gt;</comment>
                            <comment id="13786168" author="lmccay" created="Fri, 4 Oct 2013 14:09:29 +0000"  >&lt;p&gt;I see. Well, I mostly wanted to see what your sense was for REST clients.&lt;br/&gt;
So, you see REST clients as having to do the encryption however is appropriate for each particular client.&lt;br/&gt;
I assume that the HTable wrapper that you talk about is a client side thing available to client application development - correct?&lt;/p&gt;

&lt;p&gt;We could potentially build something into the Knox DSL for REST client access to HBase - if this were to be a desirable feature for REST - but of course that is but one potential REST client.&lt;/p&gt;

&lt;p&gt;Just trying to make sure we have REST on par with CLI.&lt;/p&gt;</comment>
                            <comment id="13786196" author="lmccay" created="Fri, 4 Oct 2013 14:37:16 +0000"  >&lt;p&gt;Just a high level follow up question here: I certainly understand the premise here but I sort of feel like client machines are probably more easily compromised than server - no?&lt;/p&gt;

&lt;p&gt;Especially, REST client machines/phones/tablets, etc.&lt;/p&gt;

&lt;p&gt;Perhaps, this is a reason for REST to be treated differently and this protection put into a gateway like stargate or Knox (though that would only protect it through that channel)?&lt;/p&gt;</comment>
                            <comment id="13786256" author="apurtell" created="Fri, 4 Oct 2013 15:35:33 +0000"  >&lt;blockquote&gt;&lt;p&gt;I sort of feel like client machines are probably more easily compromised than server - no?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The difference is as far as leaking secrets a client compromise affects one user or application, while a server compromise can affect them all. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So, you see REST clients as having to do the encryption however is appropriate for each particular client.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, but more like I see REST as really suitable for layering - do the basic data access protocol in something like Stargate, and then do caching, access control, and data security on top with specialist components. For a RESTful stack that&apos;s the way to go. &lt;/p&gt;

&lt;p&gt;Also, there is the OP on this JIRA and then that rather long winded follow up comment. If pursuing the bulk of the latter, then there would be a fair amount of tooling needed that could be used for doing something for REST and Thrift clients as well as the Java API. &lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12627246">HBASE-7544</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 4 Oct 2013 12:56:50 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>349301</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            3 years, 11 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1o89r:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>349599</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>