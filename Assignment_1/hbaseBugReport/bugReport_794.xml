<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 18:47:34 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-794/HBASE-794.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-794] Language neutral IPC as a first class component of HBase architecture</title>
                <link>https://issues.apache.org/jira/browse/HBASE-794</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;This issue considers making a language neutral IPC mechanism and wire format a first class component of HBase architecture. Clients could talk to the master and regionserver using this protocol instead of HRPC at their option.&lt;/p&gt;

&lt;p&gt;Options for language neutral IPC include:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Thrift: &lt;a href=&quot;http://incubator.apache.org/thrift/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://incubator.apache.org/thrift/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Protocol buffers: &lt;a href=&quot;http://code.google.com/p/protobuf/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://code.google.com/p/protobuf/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;XDR: &lt;a href=&quot;http://en.wikipedia.org/wiki/External_Data_Representation&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://en.wikipedia.org/wiki/External_Data_Representation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <environment></environment>
        <key id="12401641">HBASE-794</key>
            <summary>Language neutral IPC as a first class component of HBase architecture</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="7">Later</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="apurtell">Andrew Purtell</reporter>
                        <labels>
                    </labels>
                <created>Mon, 4 Aug 2008 19:10:25 +0000</created>
                <updated>Thu, 2 May 2013 02:29:19 +0000</updated>
                            <resolved>Thu, 19 Nov 2009 14:39:25 +0000</resolved>
                                                                    <component>Client</component>
                    <component>IPC/RPC</component>
                    <component>master</component>
                    <component>regionserver</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>8</watches>
                                                                <comments>
                            <comment id="12655196" author="apurtell" created="Wed, 10 Dec 2008 13:17:45 +0000"  >&lt;p&gt;Refactored issue to make it more general in focus. &lt;/p&gt;</comment>
                            <comment id="12662546" author="apurtell" created="Fri, 9 Jan 2009 22:40:19 +0000"  >&lt;p&gt;Up on IRC stack mentions Hadoop work in this area for their 0.20.0. Investigate. &lt;/p&gt;</comment>
                            <comment id="12663996" author="apurtell" created="Thu, 15 Jan 2009 04:35:03 +0000"  >&lt;p&gt;Need a bake off between Thrift and Google protobufs. Evaluate given several criteria:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;performance&lt;/li&gt;
	&lt;li&gt;wire format economy&lt;/li&gt;
	&lt;li&gt;ease of use / expressiveness of IDL&lt;/li&gt;
	&lt;li&gt;extensibility, future proofing&lt;/li&gt;
	&lt;li&gt;support for binary data&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Use the latest SVN checkout from both projects and also apply the patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-110&quot; title=&quot;A more compact format &quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-110&quot;&gt;&lt;del&gt;THRIFT-110&lt;/del&gt;&lt;/a&gt; (TDenseProtocol) before evaluating Thrift.&lt;/p&gt;</comment>
                            <comment id="12664237" author="stack" created="Thu, 15 Jan 2009 20:16:03 +0000"  >&lt;p&gt;And don&apos;t forget buffered transport when checking thrift.&lt;/p&gt;</comment>
                            <comment id="12664251" author="bryanduxbury" created="Thu, 15 Jan 2009 20:35:25 +0000"  >&lt;p&gt;Don&apos;t use buffered transport - use FramedTransport. More efficient, and dovetails with the NonblockingServer implementation in Thrift, if you decide to use that.&lt;/p&gt;</comment>
                            <comment id="12664308" author="apurtell" created="Thu, 15 Jan 2009 22:49:29 +0000"  >&lt;p&gt;So for Thrift, that&apos;s DenseProtocol with FramedTransport for transport and NonblockingServer on the HBase side, got it. &lt;/p&gt;</comment>
                            <comment id="12664311" author="bryanduxbury" created="Thu, 15 Jan 2009 22:54:59 +0000"  >&lt;p&gt;Close - use TCompactProtocol, FramedTransport, and THsHaServer (since you probably want nonblocking with multithreading).&lt;/p&gt;</comment>
                            <comment id="12664314" author="apurtell" created="Thu, 15 Jan 2009 23:02:27 +0000"  >&lt;p&gt;Thanks Bryan. &lt;/p&gt;</comment>
                            <comment id="12664564" author="carlos.valiente" created="Fri, 16 Jan 2009 16:55:28 +0000"  >&lt;blockquote&gt;&lt;p&gt;Close - use TCompactProtocol, FramedTransport, and THsHaServer (since you probably want nonblocking with multithreading). &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&apos;grep -r CompactProtocol .&apos; does not return anything on my Thrift source tree - Which protocol is that, Bryan?&lt;/p&gt;</comment>
                            <comment id="12664575" author="bryanduxbury" created="Fri, 16 Jan 2009 17:28:43 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-110&quot; title=&quot;A more compact format &quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-110&quot;&gt;&lt;del&gt;THRIFT-110&lt;/del&gt;&lt;/a&gt; contains a patch that has a beta version CompactProtocol implementation. If you want to be more &quot;official&quot; you can use TBinaryProtocol, but that takes up noticeably more space on the wire.&lt;/p&gt;</comment>
                            <comment id="12695294" author="apurtell" created="Fri, 3 Apr 2009 08:37:36 +0000"  >&lt;p&gt;AVRO may be an option.&lt;/p&gt;

&lt;p&gt;From &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1015?focusedCommentId=12695265&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12695265&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-1015?focusedCommentId=12695265&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12695265&lt;/a&gt; :&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
http:&lt;span class=&quot;code-comment&quot;&gt;//people.apache.org/~cutting/avro.git/
&lt;/span&gt;
To learn more:

git clone http:&lt;span class=&quot;code-comment&quot;&gt;//people.apache.org/~cutting/avro.git/ avro
&lt;/span&gt;cat avro/README.txt
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="12695483" author="bryanduxbury" created="Fri, 3 Apr 2009 16:38:03 +0000"  >&lt;p&gt;Did you guys ever experiment with Thrift to any interesting outcome?&lt;/p&gt;</comment>
                            <comment id="12695486" author="apurtell" created="Fri, 3 Apr 2009 16:42:20 +0000"  >&lt;p&gt;Not yet. I updated to Thrift trunk the other day and put together a stripped down service definition for bulk benchmarking because I see 110 went in. &lt;/p&gt;

&lt;p&gt;I&apos;ve been holding off due to private communication that Cutting had something in the works. Now I think we can proceed. &lt;/p&gt;</comment>
                            <comment id="12695806" author="apurtell" created="Sun, 5 Apr 2009 03:20:37 +0000"  >&lt;p&gt;From Ryan Rawson on hbase-user@:&lt;br/&gt;
&amp;gt; Avro isnt language independent yet. &lt;/p&gt;
</comment>
                            <comment id="12703725" author="stack" created="Tue, 28 Apr 2009 16:52:32 +0000"  >&lt;p&gt;Shall we move these out of 0.20.0 Andrew?  You think they&apos;ll be done in next week or two?&lt;/p&gt;</comment>
                            <comment id="12703908" author="apurtell" created="Wed, 29 Apr 2009 00:27:43 +0000"  >&lt;p&gt;Yes I can get this done in that time.&lt;/p&gt;</comment>
                            <comment id="12704823" author="apurtell" created="Thu, 30 Apr 2009 22:34:31 +0000"  >&lt;p&gt;No release depends on this issue, which is advisory only. I will get this in for the 0.20 timeframe so we can settle the question, but removed &quot;fix version&quot;.&lt;/p&gt;</comment>
                            <comment id="12705156" author="ryanobjc" created="Fri, 1 May 2009 22:26:01 +0000"  >&lt;p&gt;+1 on protobufs.  Generally:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;extremely stable, used extensively within google&lt;/li&gt;
	&lt;li&gt;well tested, good test suite, etc.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;One small aspect I dislike about Thrift RPC is the inability to return null objects.  This means that the thrift protocol for hbase must throw exceptions when a key is not found.  For clients that dont like that, they have to write wrappers around the thrift API.  I looked into it, the reason is the C++ binding returns objects, not pointers, thus you cannot have a &apos;null&apos; object.  Obviously the fix it to change the C++ API, but that seems like a bit much within the context of &apos;fix HBASE&apos;s RPC method&apos;.&lt;/p&gt;


&lt;p&gt;We absolutely &lt;em&gt;require&lt;/em&gt; a non-versioned RPC protocol.  We need to be able to peacemeal upgrade our clusters.  I would like to avoid ever using bin/stop-hbase.sh moving forward.&lt;/p&gt;</comment>
                            <comment id="12705219" author="cwalters" created="Sat, 2 May 2009 04:01:02 +0000"  >&lt;p&gt;I am biased here since I have worked on and backed Thrift extensively but I am in favor of sticking with Thrift.&lt;/p&gt;

&lt;p&gt;I&apos;ll grant you that Thrift isn&apos;t as mature as protocol buffers but it has a lot of useful features that protocol buffers lacks. Protocol buffers isn&apos;t a complete enough solution for my tastes &amp;#8211; no RPC, lacks many languages that Thrift supports, etc.&lt;/p&gt;

&lt;p&gt;One of the great efficiencies of C++ is the fact that you can have objects as values in stead of references. You probably won&apos;t make too much traction suggesting that that be pulled out of Thrift altogether although you could probably argue for the addition of type annotations that would allow for C++ to have references instead of values for some fields. Then you could introduce nulls. This is actually a feature I would very much like to see in Thrift. The lack of nulls can be worked around in other ways as well.&lt;/p&gt;

&lt;p&gt;Definitely follow Bryan&apos;s suggestion of testing out the CompactBinaryProtocol as well as the default BinaryProtocol.&lt;/p&gt;

</comment>
                            <comment id="12705220" author="ryanobjc" created="Sat, 2 May 2009 04:08:17 +0000"  >&lt;p&gt;Perhaps you can outline exactly how you can work around lack of NULLs in thrift that does &lt;em&gt;not&lt;/em&gt; involve exceptions?  I think it should not be required to use exceptions during non-exceptional events - many systems have lower performance under thrown exceptions, and the code path is complex.&lt;/p&gt;

&lt;p&gt;I just wish that compact binary protocols wasn&apos;t a late addition.  It doesn&apos;t give me confidence by the late addition of what should have been there from day one.&lt;/p&gt;</comment>
                            <comment id="12705222" author="ryanobjc" created="Sat, 2 May 2009 04:24:43 +0000"  >&lt;p&gt;one last comment, protobuf has an RPC framework, it just requires one to provide a transport.&lt;/p&gt;</comment>
                            <comment id="12705223" author="cwalters" created="Sat, 2 May 2009 04:27:50 +0000"  >&lt;p&gt;&amp;gt;I just wish that compact binary protocols wasn&apos;t a late addition. It doesn&apos;t give me&lt;br/&gt;
&amp;gt;confidence by the late addition of what should have been there from day one.&lt;/p&gt;

&lt;p&gt;I think you are assuming a lot of things with this statement. I suggested testing both protocols out &amp;#8211; the performance characteristics are different, not necessarily monotonically better one way or another. It&apos;s not like the original Thrift writers didn&apos;t consider more compact protocols &amp;#8211; they were just optimizing for a particular performance space. At least they had the foresight to allow for different protocol implementations (albeit not without some restrictions and wrinkles). I suspect that you might not find much difference between the two for HBase&apos;s needs but I am curious to see what you come up with.&lt;/p&gt;

&lt;p&gt;&amp;gt;Perhaps you can outline exactly how you can work around lack of NULLs in thrift&lt;br/&gt;
&amp;gt;that does not involve exceptions? I think it should not be required to use exceptions&lt;br/&gt;
&amp;gt;during non-exceptional events - many systems have lower performance under thrown&lt;br/&gt;
&amp;gt;exceptions, and the code path is complex.&lt;/p&gt;

&lt;p&gt;Haven&apos;t thought about it too deeply and it&apos;s late on Friday so here is are some extremely off-the-cuff answers:&lt;/p&gt;

&lt;p&gt;1. Return a struct that has a two fields &amp;#8211; a required boolean and an optional field of the object type. Certainly not ideal but could be used in the hopefully limited cases where you really want to be able to return null sometimes.&lt;/p&gt;

&lt;p&gt;2. Return a flag object somehow outside the range of valid responses that indicates null. Not possible in all cases if all values are valid but certainly viable in some.&lt;/p&gt;

&lt;p&gt;I am sure we could come up with more if need be. That said, and like I said before, please go ahead and contribute a &quot;nulllable&quot; type annotation for Thrift.&lt;/p&gt;</comment>
                            <comment id="12705224" author="apurtell" created="Sat, 2 May 2009 04:38:33 +0000"  >&lt;p&gt;Interesting head to head testing results here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.eishay.com/2009/03/more-on-benchmarking-java-serialization.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.eishay.com/2009/03/more-on-benchmarking-java-serialization.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;But, I want retest using the latest trunk from both the protobuf and Thrift trees (I have that also), using Bryan&apos;s recommendations for Thrift: TCompactProtocol, FramedTransport, and THsHaServer. Also, comparisons for the HBase antcipiated use case of first class integration, which in this context means all IPC/RPC between master, regionservers, and clients, not just as a client access option:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Insert of single BatchUpdate&lt;/li&gt;
	&lt;li&gt;Insert of a batch of BatchUpdate&lt;/li&gt;
	&lt;li&gt;Fetch single RowResult (equiv to scan with batching of 1 RowResult)&lt;/li&gt;
	&lt;li&gt;Scan with batching of 30 RowResult&lt;/li&gt;
	&lt;li&gt;Transactional table / secondary index transactions&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This is why this issue lingers. We should either make a simulator or do direct addition of test code on the master, regionservers, and client library that supports real actions. My feeling is ultimately the latter option is the better one. Recently I had been waiting for all of the architectural changes to the regionserver &amp;#8211; e.g. KeyValue &amp;#8211; to settle, and have otherwise not had the available personal time. Both of those considerations have now changed. &lt;/p&gt;</comment>
                            <comment id="12705226" author="ryanobjc" created="Sat, 2 May 2009 04:44:07 +0000"  >&lt;p&gt;we also need to verify exactly how much garbage serialization/deserialization does.  Our initial thought with the KeyValue patches (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1234&quot; title=&quot;Change HBase StoreKey format&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1234&quot;&gt;&lt;del&gt;HBASE-1234&lt;/del&gt;&lt;/a&gt;) is to use a raw protocol that is totally custom and wouldnt require copying data over and over inside the server.   My own tests show that GC overhead is a significant part of HBase, it would be nice to do a data recv() then not copy that and use KeyValue instead of object conversion.  Stack notes that in this profiling, a substantial amount of CPU time goes into marshall/demarshall code.  &lt;/p&gt;</comment>
                            <comment id="12705227" author="apurtell" created="Sat, 2 May 2009 04:58:39 +0000"  >&lt;p&gt;So should we open another issue for prototyping async I/O into and out of bytebuffers from the IPC handler and use the buffers to back internal data structures as is done currently for storefile I/O? Should 794 be tabled in favor of a raw/custom protocol?&lt;/p&gt;</comment>
                            <comment id="12705325" author="stack" created="Sat, 2 May 2009 19:49:38 +0000"  >&lt;p&gt;1. Could we do our own thrift protocol, one that uses protobufs so protobufs uses thrift as its rpc?&lt;br/&gt;
2. Protobufs is more compact that the new thrift binary? (Important when keys and values are small)&lt;br/&gt;
3. Anyone comment on the quality of the java rpc in thrift?  (Bryan making it nio was the last I heard).&lt;br/&gt;
4. The comparison that Andrew posts is interesting; protobufs does slightly better usually but is way worse doing object creation.&lt;br/&gt;
5. The lack of null is a pain; otherwise, I&apos;d think it wouldn&apos;t take much hacking up a thrift IDL to do the client/regionserver back and forth to drop in thrift in place of what we have; its only a few methods.  Absence of null means client code has to be modified to handle whatever the null replacement is (if its exceptions, that&apos;d make thrift look bad performance-wise).&lt;br/&gt;
6. Regards opening a new issue to do a raw RPC, wistfully, I&apos;d love it if we didn&apos;t have to.  Would be cool if we could do this issue  I&apos;d rather not have to write our own RPC (And while on the wishful thinking, ignoring for a sec. the issues raised above, I wish we could just use thrift-- Its open, there is expertise to hand, and we&apos;d get help from the community).&lt;/p&gt;</comment>
                            <comment id="12705350" author="apurtell" created="Sun, 3 May 2009 00:13:34 +0000"  >&lt;p&gt;Re 1. Stacking pbufs on Thrift means two IDLs, two marshalling/unmarshalling layers, and glue. HBase would be dependent on both Thrift and protobuf toolchains. In my opinion that&apos;s not the way to go.&lt;/p&gt;

&lt;p&gt;Re 2. Based on the eishay.com results, Thrift is competitive with protobufs, but I can&apos;t say if the new thrift compact binary protocol was used. Will insure this is the case in our tests.&lt;/p&gt;

&lt;p&gt;Re 5. We could do what Chad suggested and handle interfaces within Thrift that return null with a boolean plus optional value.&lt;/p&gt;

&lt;p&gt;Re 6. Nod. I&apos;ll move forward with putting in test pbuf and Thrift RPC on the master, regionserver, and clients for supporting insert, get, and scan ops. &lt;/p&gt;</comment>
                            <comment id="12705355" author="ryanobjc" created="Sun, 3 May 2009 00:25:29 +0000"  >&lt;p&gt;Scanning isn&apos;t always 30 rows small - I personally set my scanner caching to 1000 rows. &lt;/p&gt;

&lt;p&gt;I would set my performance targets at 30-50k ops/sec (what I currently get on my systems). Given the other perf graphs, its probably a question of &quot;will any serialization be fast enough&quot;. It&apos;d be nice to get a kb/op measure of garbage gen activity.&lt;/p&gt;

&lt;p&gt;With the cms with capped parnew as a stock gc setup, we need to keep garbage gen as low as possible. &lt;/p&gt;</comment>
                            <comment id="12705356" author="cwalters" created="Sun, 3 May 2009 00:28:42 +0000"  >&lt;p&gt;Re 1: Agreed with Andrew &amp;#8211; not a good way to go&lt;/p&gt;

&lt;p&gt;Re 2 and 4: Looking at the test code at &lt;a href=&quot;http://code.google.com/p/thrift-protobuf-compare&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://code.google.com/p/thrift-protobuf-compare&lt;/a&gt; it&apos; clear the TBinaryProtocol was used for the tests, not TCompactBinaryProtocol. They also used TIOStreamTransport &amp;#8211; can&apos;t speak to the quality of this transport one way or another although I gotta think that wrapping it with TFramedTransport would likely reduce some overhead.&lt;/p&gt;

&lt;p&gt;Re 3: No idea. I gotta imagine that some work is needed here since the Java stuff is less mature than the C++ stuff. Is Bryan watching this ticket? He&apos;s the guy to ask for sure.&lt;/p&gt;

&lt;p&gt;Re 5: We should look at where we really want nulls and see if this is too onerous.&lt;/p&gt;

&lt;p&gt;Re 6: Let&apos;s please not go down the route of custom RPC &amp;#8211; let&apos;s leverage something reasonable such that the RPC isn&apos;t really part of the problem.&lt;/p&gt;</comment>
                            <comment id="12705357" author="cwalters" created="Sun, 3 May 2009 00:31:16 +0000"  >&lt;p&gt;Frankly I am a little puzzled by a lot of the data produced posted at that site. Thrift and protobufs are both slower than json? More investigation is needed (as I noted on the thrift-dev list).&lt;/p&gt;</comment>
                            <comment id="12705358" author="cwalters" created="Sun, 3 May 2009 00:34:50 +0000"  >&lt;p&gt;&amp;gt; I would set my performance targets at 30-50k ops/sec (what I currently get on my systems). &amp;gt;Given the other perf graphs, its probably a question of &quot;will any serialization be fast enough&quot;. &lt;br/&gt;
&amp;gt;It&apos;d be nice to get a kb/op measure of garbage gen activity.&lt;/p&gt;

&lt;p&gt;Ryan, can you elaborate a little further on these numbers? I&apos;d love to understand your application usage patterns a little more fully. Also, when you say &quot;will any serialization be fast enough&quot; what are you comparing against?&lt;/p&gt;</comment>
                            <comment id="12705360" author="ryanobjc" created="Sun, 3 May 2009 00:53:39 +0000"  >&lt;p&gt;my system currently does 25-30k ops/sec undere high load. the current system really cranks through a lot of garbage generation. i would want to see a system that meets several performance characteristics:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;overall throughput&lt;/li&gt;
	&lt;li&gt;low per request latency&lt;/li&gt;
	&lt;li&gt;low garbage gen&lt;/li&gt;
	&lt;li&gt;works with the 0 copy system currently in place&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;to me, performance is the most important thing. &lt;/p&gt;</comment>
                            <comment id="12705362" author="cwalters" created="Sun, 3 May 2009 00:56:53 +0000"  >&lt;p&gt;25-30k ops/sec total across how many machines?&lt;/p&gt;</comment>
                            <comment id="12705374" author="apurtell" created="Sun, 3 May 2009 03:03:37 +0000"  >&lt;p&gt;On the list Ryan indicates the target is 25-30K ops/sec per machine.&lt;/p&gt;</comment>
                            <comment id="12705375" author="apurtell" created="Sun, 3 May 2009 03:14:13 +0000"  >&lt;p&gt;Chad, I agree that the eishay.com numbers are interesting but are not sufficient to make a decision here. This is why I propose to move ahead with actually trying to put pbufs and Thrift into a running system as replacements for HRPC and see what happens given several use cases. So far we have a suite of repeated runs of:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Insert of single BatchUpdate&lt;/li&gt;
	&lt;li&gt;Insert of a batch of BatchUpdate, let&apos;s do 1000&lt;/li&gt;
	&lt;li&gt;Fetch single RowResult (equiv to scan with batching of 1 RowResult)&lt;/li&gt;
	&lt;li&gt;Scan with batching of 30 RowResult&lt;/li&gt;
	&lt;li&gt;Scan with batching of 1000 RowResult&lt;/li&gt;
	&lt;li&gt;Transactional table / secondary index transaction&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If someone thinks the above would not capture enough information in some way, please advise. &lt;/p&gt;</comment>
                            <comment id="12705377" author="stack" created="Sun, 3 May 2009 03:23:17 +0000"  >&lt;p&gt;On 3. above, I asked Bryan (On 1., no thanks to double IDLing and thanks Chad for digging in on eisahy.com).&lt;/p&gt;

&lt;p&gt;@Andrew&lt;/p&gt;

&lt;p&gt;Looks great.  Drop transactional table test from your list. Not necessary to our figuring whats better.  You going to work on this now Andrew?  I can help w/ where to make the cuts for the graft.&lt;/p&gt;</comment>
                            <comment id="12705378" author="apurtell" created="Sun, 3 May 2009 03:26:35 +0000"  >&lt;p&gt;I&apos;m sitting in the lounge now in Taipei waiting to get on the plane, back on 5/4 with time for this. Pointers on graft points most welcome.&lt;/p&gt;</comment>
                            <comment id="12705388" author="bryanduxbury" created="Sun, 3 May 2009 07:03:24 +0000"  >&lt;p&gt;Wow, guess I really should have been watching this issue. I&apos;ll try and address some things.&lt;/p&gt;

&lt;p&gt;Returning null: Thrift methods can&apos;t return null &lt;b&gt;directly&lt;/b&gt;, but they can return a non-null struct with none of its fields set, or a non-null struct with a flag set. This isn&apos;t anything new necessarily, but I should note that we do this all over the place at Rapleaf to get around this restriction. You definitely do not need to use exceptions to communicate &quot;null&quot;. Moreover, using exceptions this way is probably worse than you think, as I &lt;b&gt;think&lt;/b&gt; returning an exception causes the connection to close, at least in some libraries. Also, it might be possible to allow null to be returned by Thrift methods &lt;em&gt;in general&lt;/em&gt;, just for C++ to be unable to return null. If this is a do-or-die issue, please help us out by opening a ticket over on the Thrift JIRA so we can discuss solutions.&lt;/p&gt;

&lt;p&gt;Thrift&apos;s Java RPC layer: I did in fact write a bunch of the server layer to use native Java NIO. This code lives in TNonblockingServer (single threaded) and THsHaServer (thread pool) respectively. Both server implementations also add some nice stuff like fixed total read buffer size (to protect server from overload). It&apos;s been very robust in our use of the code at Rapleaf so far. I would recommend it on the strength of my experiences. &lt;/p&gt;

&lt;p&gt;Garbage/instantiation cost: Thrift objects are probably a little more memory inefficient than they need to be right now due to some slightly naive implementation decisions, but I&apos;ve taken some steps to reducing the overhead of an object. Additionally, you could probably reuse some instances of objects at the top level with almost no work. With a little work in the library, you could probably reuse most objects all the way down your instance&apos;s object tree, saving you memory. If you are more interested in this bullet, shoot me an email and we can talk about it in more detail.&lt;/p&gt;

&lt;p&gt;Zero copy system: Right now, Thrift is not zero-copy. I think it would be very cool, though, to create the framework to make that happen. We&apos;d probably only need to make a few transport interface changes. Maybe we should open a ticket?&lt;/p&gt;

&lt;p&gt;Framed Transport: This is very effective at improving the performance of the Thrift IO stuff, especially if you&apos;re doing real IO without a buffer somewhere in between. It&apos;s also mandatory for using the nonblocking servers.&lt;/p&gt;

&lt;p&gt;Custom protocols: Certainly, if you wanted to, you could write your own Thrift protocol. However, I would say this defeats the purpose of Thrift, in giving you a respectable cross-platform library out of the box. Further, protobuf as a Thrift protocol has been proposed before, and the two systems are not trivially compatible.&lt;/p&gt;

&lt;p&gt;&quot;Raw&quot; RPC: If your goal is to avoid deserializing some stuff, Chad has previously suggested having the ability to specify that you don&apos;t want certain fields deserialized. I don&apos;t know if this is your objective. If your keys and values are actually just byte arrays on either side, then there isn&apos;t any serialization to speak of, beyond the byte[] copy off the wire. I could imagine doing something to make this a non-copy operation, though. (See comment above on zero-copy architecture.)&lt;/p&gt;

&lt;p&gt;I think Andrew&apos;s idea of making a simulator is a great idea. Otherwise it&apos;s going to mean a ton of work and a subjective evaluation. &lt;/p&gt;

&lt;p&gt;I also want to say that there are few things I would like to improve as much as Thrift performance. Thrift is a cornerstone at Rapleaf, so anything we can do to make it faster is a big win. I am eager and willing to work with anyone who can show me use cases that identify slowness in Thrift so that I can erase the problem. &lt;/p&gt;</comment>
                            <comment id="12705390" author="ryanobjc" created="Sun, 3 May 2009 07:21:39 +0000"  >&lt;p&gt;As for the API of HBase, there are a number of special cases:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;get()/scanner()/next() return null values all the time, or 0 length arrays (in the case of next()).&lt;/li&gt;
	&lt;li&gt;nearly all the data is simple, byte[]. Big wins by not copying the same bytes around a dozen times.&lt;/li&gt;
	&lt;li&gt;Our internal 0-copy systems are called KeyValue, and allow many many values to share the same underlying bytes (reading from a hfile) or reducing the number of copies from the RPC -&amp;gt; IO with HDFS.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The actual implementation of a new RPC is a 0.21 task, so we are still just evaluating things.  &lt;/p&gt;

&lt;p&gt;One thing we will not do in the future is serializing trees to the RPC and back again.  Our new API may be mostly arrays of KeyValues.  Since a client has to be smart, there is no problems with pushing detailed knowledge of how we store columns/values to the client.&lt;/p&gt;

&lt;p&gt;I&apos;m still not sure how much gain we are going to get by pooling/reusing objects in Java... Outsmarting the GC tends to bite you hard.&lt;/p&gt;</comment>
                            <comment id="12705457" author="streamy" created="Sun, 3 May 2009 21:59:36 +0000"  >&lt;p&gt;There are two instances where it would be helpful to have an RPC call that we could access the received byte[] directly.&lt;/p&gt;

&lt;p&gt;Sending of PUTS and receiving of GETS.  This is being changed in 880 to being List&amp;lt;KeyValue&amp;gt; (does not require serializiation/deserialization).  I believe, by far, the biggest improvement we could make to help with our GC woes during imports is doing this for writes.&lt;/p&gt;

&lt;p&gt;Just thought we should keep this in mind as we explore rpc stuff.&lt;/p&gt;

&lt;p&gt;Right now, we allocate data for writes &lt;b&gt;at least 3 times&lt;/b&gt; on the way in to the memcache.  The last two times, it is at the individual keyval level (lots of small allocations).  Using KeyValue, we could read the entire buffer into a single byte[] and pass around KeyValue pointers all the way to the Memcache.  These would be grouped by row in the case of batching.&lt;/p&gt;

&lt;p&gt;I do not think we need to go down the path of pooling.  Changes like above, and moving away from Trees wherever possible as we&apos;re working on now, should help tremendously.  If we do end up needing more improvements, the optimizations would be isolated to the data structure backing Memcache.  I think it&apos;d be a fun project...  but i agree that it can bite you hard with a GC and we should avoid it at all costs (short of rewrites in c)  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12705936" author="apurtell" created="Tue, 5 May 2009 07:31:15 +0000"  >&lt;p&gt;In a related issue (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1367&quot; title=&quot;get rid of thrift exception &amp;#39;NotFound&amp;#39;&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1367&quot;&gt;&lt;del&gt;HBASE-1367&lt;/del&gt;&lt;/a&gt;), Stack posted this comment:&lt;/p&gt;

&lt;p&gt;On the convertions from Cell and Cell [] to Lists of TCells, I suppose there is no way to avoid this, even in the new stuff where we have lists of KeyValue (though KeyValue is nothing but a byte [] really). If we could have KeyValue subclass &quot;byte []&quot; then we could pass the list of KeyValues to thrift - but its not possible subclassing byte []. I suppose no way to have thrift use KeyValue lists directly - treat them as containers of byte []?&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1367?focusedCommentId=12705881&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12705881&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-1367?focusedCommentId=12705881&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12705881&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="12705940" author="ryanobjc" created="Tue, 5 May 2009 07:58:39 +0000"  >&lt;p&gt;KeyValue isn&apos;t a subclass of byte [] and never will be...&lt;/p&gt;

&lt;p&gt;This is because a KeyValue isnt just a wrapper over byte [], it is designed to reference a larger byte buffer.  One will always need to use an array offset and length when accessing sub parts of a KeyValue.&lt;/p&gt;</comment>
                            <comment id="12706079" author="bryanduxbury" created="Tue, 5 May 2009 15:53:05 +0000"  >&lt;p&gt;I&apos;m not sure that this will work out for you, but you &lt;b&gt;could&lt;/b&gt; make Cell inherit from TCell. If you did that, then the Thrift serialization code would be the same, but you could have additional methods on Cell that implemented all your domain specific logic. Obviously, this won&apos;t work if Cell needs to extend some other class.&lt;/p&gt;

&lt;p&gt;I have also been thinking if it would be possible for Thrift to take either native byte[] or some sort of buffer and offset/length structure, which is what KeyValue sounds like (correct me if I&apos;m wrong).&lt;/p&gt;</comment>
                            <comment id="12706082" author="stack" created="Tue, 5 May 2009 16:02:37 +0000"  >&lt;p&gt;@Ryan True.  I should have thought of that.&lt;/p&gt;

&lt;p&gt;@Bryan Not inherit but maybe it could have a TCell but then thrift is all over our application, not just at the porch.  Thrift should take a byte array, offset and length; copying is a waste.&lt;/p&gt;</comment>
                            <comment id="12706096" author="bryanduxbury" created="Tue, 5 May 2009 16:51:45 +0000"  >&lt;p&gt;Composition might be just fine, but I was suggesting that approach so that you &lt;b&gt;never&lt;/b&gt; had to copy stuff around - it&apos;d already be there. &lt;/p&gt;

&lt;p&gt;I&apos;ll open a ticket with Thrift for buf/off/len approach to byte arrays.&lt;/p&gt;</comment>
                            <comment id="12706112" author="apurtell" created="Tue, 5 May 2009 17:18:28 +0000"  >&lt;p&gt;@Bryan: Thanks. If I understand correctly, we&apos;d like to hold on to the byte buffers into which frames were read from the wire, and build some very lightweight structures which index individual KeyValues contained within. We&apos;d also want to avoid any unmarshalling overhead as the data type is plain byte[]. This is like exposing some middle layer of the Thrift stack. (A data stream.) I think it would also be useful if structured data could be mixed inline. (A control stream.) So maybe we&apos;d have some convenient structured metadata at the start of a transaction which can be processed using functions at the top of the Thrift stack, followed by a lot of instances of a KeyValue type, which we could drop down to slice up the backing byte buffer for zero copy from there. I don&apos;t know how feasible this is, just thinking out loud here. &lt;/p&gt;</comment>
                            <comment id="12706118" author="bryanduxbury" created="Tue, 5 May 2009 17:28:42 +0000"  >&lt;p&gt;I think it&apos;d be simpler than what you suggest. My thinking is that when we encounter a binary on the wire, if we&apos;re set up to do so (right server, right compiler options, etc), then we just capture the offset and length from the underlying buffer. We change the Thrift object API slightly to have the option of returning the buf/off/len object, so that you can do the only copy when you&apos;re finally writing it out to wherever it&apos;s going. There shouldn&apos;t be any &quot;overhead&quot; to operating on binaries. However, for the non-data portion of the stream (the so-called control stream), we&apos;ll still have to do things like unpack ints from bytes and the like. Without digging in too much deeper, I think that only binary and &lt;b&gt;maybe&lt;/b&gt; strings could benefit from this approach. I&apos;d strongly advise against using strings in your Thrift objects, though, if you care about performance, since UTF-8 en/decoding seems to be a real dog at times.&lt;/p&gt;</comment>
                            <comment id="12708949" author="apurtell" created="Wed, 13 May 2009 14:44:34 +0000"  >&lt;p&gt;Posting on the AVRO list shows it is better than them all &amp;#8211; somehow. Matt Massie @ Cloudera is making C bindings. Chad @ Powerset is trying to get code to dig in. &lt;/p&gt;</comment>
                            <comment id="12780005" author="apurtell" created="Thu, 19 Nov 2009 14:39:25 +0000"  >&lt;p&gt;Prevailing project opinion is to wait until Avro is ready and use it. Closing this issue. Reopen if this changes. &lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12431633">HADOOP-6170</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12424473">HBASE-1367</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12424619">THRIFT-484</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                                                <inwardlinks description="is depended upon by">
                                        <issuelink>
            <issuekey id="12409017">HBASE-1015</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 15 Jan 2009 20:16:03 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>31852</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 5 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0h9hj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>98799</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>