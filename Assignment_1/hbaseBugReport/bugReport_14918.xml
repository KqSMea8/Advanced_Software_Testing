<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 20:57:44 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-14918/HBASE-14918.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-14918] In-Memory MemStore Flush and Compaction</title>
                <link>https://issues.apache.org/jira/browse/HBASE-14918</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;A memstore serves as the in-memory component of a store unit, absorbing all updates to the store. From time to time these updates are flushed to a file on disk, where they are compacted (by eliminating redundancies) and compressed (i.e., written in a compressed format to reduce their storage size).&lt;/p&gt;

&lt;p&gt;We aim to speed up data access, and therefore suggest to apply in-memory memstore flush. That is to flush the active in-memory segment into an intermediate buffer where it can be accessed by the application. Data in the buffer is subject to compaction and can be stored in any format that allows it to take up smaller space in RAM. The less space the buffer consumes the longer it can reside in memory before data is flushed to disk, resulting in better performance.&lt;br/&gt;
Specifically, the optimization is beneficial for workloads with medium-to-high key churn which incur many redundant cells, like persistent messaging. &lt;/p&gt;

&lt;p&gt;We suggest to structure the solution as 4 subtasks (respectively, patches). &lt;br/&gt;
(1) Infrastructure - refactoring of the MemStore hierarchy, introducing segment (StoreSegment) as first-class citizen, and decoupling memstore scanner from the memstore implementation;&lt;br/&gt;
(2) Adding StoreServices facility at the region level to allow memstores update region counters and access region level synchronization mechanism;&lt;br/&gt;
(3) Implementation of a new memstore (CompactingMemstore) with non-optimized immutable segment representation, and &lt;br/&gt;
(4) Memory optimization including compressed format representation and off heap allocations.&lt;/p&gt;

&lt;p&gt;This Jira continues the discussion in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-13408&quot; title=&quot;HBase In-Memory Memstore Compaction&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-13408&quot;&gt;&lt;del&gt;HBASE-13408&lt;/del&gt;&lt;/a&gt;.&lt;br/&gt;
Design documents, evaluation results and previous patches can be found in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-13408&quot; title=&quot;HBase In-Memory Memstore Compaction&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-13408&quot;&gt;&lt;del&gt;HBASE-13408&lt;/del&gt;&lt;/a&gt;. &lt;/p&gt;</description>
                <environment></environment>
        <key id="12917935">HBASE-14918</key>
            <summary>In-Memory MemStore Flush and Compaction</summary>
                <type id="14" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/genericissue.png">Umbrella</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="eshcar">Eshcar Hillel</assignee>
                                    <reporter username="eshcar">Eshcar Hillel</reporter>
                        <labels>
                    </labels>
                <created>Thu, 3 Dec 2015 09:11:40 +0000</created>
                <updated>Fri, 28 Oct 2016 12:54:27 +0000</updated>
                                            <version>2.0.0</version>
                                                        <due></due>
                            <votes>0</votes>
                                    <watches>23</watches>
                                                                                                            <comments>
                            <comment id="15037817" author="eshcar" created="Thu, 3 Dec 2015 14:04:52 +0000"  >&lt;p&gt;Submitted patch for first sub-task &lt;/p&gt;</comment>
                            <comment id="15070913" author="eshcar" created="Thu, 24 Dec 2015 11:31:24 +0000"  >&lt;p&gt;Patches are available for task 1 and task 2.&lt;/p&gt;</comment>
                            <comment id="15072127" author="eshcar" created="Sun, 27 Dec 2015 11:52:57 +0000"  >&lt;p&gt;Both patches got +1 overall in QA.&lt;br/&gt;
Happy Holidays to those who celebrate - waiting to make progress when you return.&lt;/p&gt;</comment>
                            <comment id="15110274" author="eshcar" created="Thu, 21 Jan 2016 08:34:21 +0000"  >&lt;p&gt;I submitted a patch in task 1 two days ago but didn&apos;t receive any QA report since.&lt;br/&gt;
Any problems with the QA system?&lt;/p&gt;</comment>
                            <comment id="15110790" author="eshcar" created="Thu, 21 Jan 2016 15:35:53 +0000"  >&lt;p&gt;I went through the code in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10713&quot; title=&quot;A MemStore implementation with in memory flushes to CellBlocks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10713&quot;&gt;&lt;del&gt;HBASE-10713&lt;/del&gt;&lt;/a&gt;, and it seems we can come up with a design for task #4 of a compacted memstore which stores the data in a flat format (in the issue they are called CellBlocks) instead of in java skip-list. &lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt; would you be interested to collaborate on this? If you are, we can schedule an off-list chat to discuss the details of the design.&lt;/p&gt;</comment>
                            <comment id="15112950" author="stack" created="Fri, 22 Jan 2016 19:46:36 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt; You see above sir? We want CellBlocks right? Not HFile blocks? Do we need to relate the two? Should an HFile block be CellBlock?&lt;/p&gt;</comment>
                            <comment id="15113555" author="anoop.hbase" created="Sat, 23 Jan 2016 04:45:10 +0000"  >&lt;p&gt;I dont know why when the name is being referred, am not getting any mail notify from Jira!  I used to get that..&lt;/p&gt;

&lt;p&gt;Let me get to this.  Also doing a pass over the other 2 patches.&lt;/p&gt;</comment>
                            <comment id="15119183" author="eshcar" created="Wed, 27 Jan 2016 12:49:29 +0000"  >&lt;p&gt;Attached an initial suggestion for the design of a CellBlocks segment, where &lt;br/&gt;
Cells are stored in a flat format.&lt;/p&gt;

&lt;p&gt;Any comments are welcomed.&lt;/p&gt;

&lt;p&gt;Note that at this point the segment does not support compression, but I assume the format of cell blocks is ``compression-friendly&apos;&apos;.  &lt;/p&gt;</comment>
                            <comment id="15119208" author="anoop.hbase" created="Wed, 27 Jan 2016 13:15:06 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=eshcar&quot; class=&quot;user-hover&quot; rel=&quot;eshcar&quot;&gt;Eshcar Hillel&lt;/a&gt;  In one of the subtask (infrastructure refactor I guess) , I have added a comment that may be we should move the MSLAB copy stuff out of Memstore impl.  Now in the patch it is moved to the Abstract base impl of Memstore and Allocator stuff passed through the Segment also. (I think I read it that way.. not remembering)..    actually this MSLAB stuff should be moved to HStore level. (This is not a Memstore impl detail)..   Not your patch issue. It was this way from begin and when Memstore is made interface impl way, I missed that too..    wdyt?  I can see how we can move it.  (Am already half way in that patch)&lt;/p&gt;

&lt;p&gt;Let me have a go at the attached pdf&lt;/p&gt;</comment>
                            <comment id="15121094" author="eshcar" created="Thu, 28 Jan 2016 09:29:46 +0000"  >&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt;.&lt;br/&gt;
I don&apos;t see how you can move MSLAB to the HStore level.&lt;br/&gt;
In the first patch MSLAB is used in the segment to allocate the byte range (in maybeCloneWithAllocator()), and it also does bookkeeping of scanners which access the MSLAB (with inc/decScannersCount()) so it can manage the deallocation of buffers when no scanners can access them.&lt;br/&gt;
This is also the case in master but there the methods are in the scope of DefaultMemStore and the MemStoreScanner.&lt;br/&gt;
How would you suggest to move it to HStore? Why do you think it is better there and not inside the segment?&lt;/p&gt;</comment>
                            <comment id="15121121" author="anoop.hbase" created="Thu, 28 Jan 2016 09:47:02 +0000"  >&lt;p&gt;As per the present trunk code, we can move it out.. I have done also..  But am not sure whether we need it inside the new Memstore impl, (with internal flush to pipeline and flush as CellBlock).. So I did not raise a Jira.&lt;/p&gt;

&lt;p&gt;Why I say to move out is this work of copying the Cell data into a MSLAB area is not a Memstore impl detail.  Whatever be the Memstore impl (current or new) we need this.  Also I have done a patch for avoiding garbage what we create in write path (See HBASE015180) when MSLAB is on.  That is why I thought to make it an upper layer work than at the Memstore impl.   &lt;br/&gt;
I need to see how my patch can satisfy the need of new memstore impls&lt;/p&gt;</comment>
                            <comment id="15121203" author="eshcar" created="Thu, 28 Jan 2016 10:43:24 +0000"  >&lt;p&gt;ok.&lt;br/&gt;
But even in the  &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15180&quot; title=&quot;Reduce garbage created while reading Cells from Codec Decoder&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15180&quot;&gt;&lt;del&gt;HBASE-15180&lt;/del&gt;&lt;/a&gt; patch DefaultMemStore still have the attributes&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;volatile&lt;/span&gt; MemStoreLAB allocator;
  &lt;span class=&quot;code-keyword&quot;&gt;volatile&lt;/span&gt; MemStoreLAB snapshotAllocator;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and MemStoreScanner still have the attributes&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;volatile&lt;/span&gt; MemStoreLAB allocatorAtCreation;
    &lt;span class=&quot;code-keyword&quot;&gt;volatile&lt;/span&gt; MemStoreLAB snapshotAllocatorAtCreation;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;So either I&apos;m missing something or we talk on two different things.&lt;/p&gt;</comment>
                            <comment id="15121216" author="anoop.hbase" created="Thu, 28 Jan 2016 10:52:42 +0000"  >&lt;p&gt;No in those patch I have not done this move.  I was saying that, working on that made me think more strongly towards that. Get me?&lt;br/&gt;
I have that moving patch..  Can just attach here for your ref may be.&lt;/p&gt;</comment>
                            <comment id="15121222" author="anoop.hbase" created="Thu, 28 Jan 2016 10:54:15 +0000"  >&lt;p&gt;Just for ref.  Not much tested..  Just to show the idea.  Again am not sure whether this move can support all needs of new Memstore impl. The current one (DefaultMemstore) can work with this&lt;/p&gt;</comment>
                            <comment id="15121231" author="anoop.hbase" created="Thu, 28 Jan 2016 11:02:52 +0000"  >&lt;blockquote&gt;&lt;p&gt;Each block is a PositionedByteRange (essentially encapsulating byte array), and the list is manifested as an array of PositionedByteRange&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;That means we can not keep these Cells (in CellBlock) in an off heap memory area?  We are trying to make the write flow also to support off heap&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cell &#8203;maybeCloneWithAllocator(Cell &#8203;cell) &#173; If the segment has a memory allocator the&lt;br/&gt;
cell is being cloned to this space, and returned&#894; otherwise the given cell is returned&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I think doing this in these lower layers of memstore impl is not good.. That is one more reason why the thinking on moving the MSLAB copy.  Can we do the copy stuff in HStore and only pass the allocator ref to Memstore for doing the inc/dec scanner things etc?  Again I did not do any deep study on that. You know better.&lt;/p&gt;</comment>
                            <comment id="15121385" author="eshcar" created="Thu, 28 Jan 2016 13:04:05 +0000"  >&lt;p&gt;I reviewed the mslab-move patch. Software-engineering-wise I am not at all convinced that the right place for mslab is in HStore level.&lt;br/&gt;
The compacting memstore is an example in which cells are allocated at the memstore level and not the store level.&lt;/p&gt;

&lt;p&gt;But more important is what you say about off-heap memory. I have no experience with off-heaping.&lt;br/&gt;
Can you please elaborate why the suggested design cannot be off-heap, and what is needed to allow it be off-heap?&lt;br/&gt;
In addition, you refer to the write-path, but actually the write-path goes through mutable-segment that stores the data in a CSLM format.&lt;br/&gt;
Only reads and scans access the cell block.&lt;/p&gt;

&lt;p&gt;It is good we have this discussion at this point since it relates to the design of task #4, and can also affect task #3.&lt;br/&gt;
However, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;, is there anything that prevents committing the patch of task #1. Is it not committed due to the MSLAB issue?&lt;br/&gt;
IMO, the mslab is orthogonal to task #1. If it is decided that it needs to move, then it is possible to do so even after the patch.&lt;/p&gt;</comment>
                            <comment id="15121402" author="anoop.hbase" created="Thu, 28 Jan 2016 13:20:22 +0000"  >&lt;p&gt;Ya I said it already, with the new Memstore impls it might be really possible for the move.  My only point was that the copy to MSLAB is not a memstore impl thing at all..Or else it has to be a duty of all of the memstore impls.   And I strongly think that for the new memstore impl, this movement may be problematic. (I mean the flush to cellblock one).   Once the flush to cellblock area happens, we dont need this allocator and can have a new one. (It is like normal flush)..   And this in memory flush happens within memstore impl.. So we might not be able to handle these if allocator is moved out..     That patch I attached just for ref.&lt;/p&gt;

&lt;p&gt;Commit of task-1 has nothing to do with this movement.&lt;/p&gt;</comment>
                            <comment id="15156756" author="anastas" created="Mon, 22 Feb 2016 10:44:22 +0000"  >&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;We are now starting to progress with the CellBlocksSegment implementation for the CompactedMemStore.&lt;br/&gt;
As explained in the attached design, CellBlocksSegment is a flat layout for the immutable segments (those which were flushed-in-memory).&lt;br/&gt;
The suggestion is to implement CellBlocksSegment as long ordered array and to use binary search for the navigation inside the array.&lt;br/&gt;
The array is the data structure that suits us best, because (1) the data is immutable (no insertions/deletions), (2) the data is already ordered before being written to array, (3) minimal memory overhead for any pointers, (4) most easily serializable.&lt;br/&gt;
The HFile instance (with all its great possibilities) seams like something too complex for this simple task of storing the data flat.&lt;/p&gt;

&lt;p&gt;Clearly, a long array need to be partitioned into sub-array with bounded size. So down to earth, we will have an array of arrays.&lt;br/&gt;
After once again looking on MSLAB and the memory management around, it looks like those arrays can be the chunks from MSLAB.&lt;br/&gt;
So in an elegant way all memory allocations remains through MSLAB.&lt;/p&gt;

&lt;p&gt;Even more than that, it appears that MSLAB may be arranged to allocate chunks off-heap (with some little adjustment, of course).&lt;br/&gt;
This can be used later if needed. Another discussion is required to understand the off-heap possibilities in MemStore.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt; and everybody, what do you think?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Anastasia&lt;/p&gt;</comment>
                            <comment id="15157510" author="stack" created="Mon, 22 Feb 2016 19:12:47 +0000"  >&lt;p&gt;Sounds great Anastasia.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The HFile instance (with all its great possibilities) seams like something too complex for this simple task of storing the data flat.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agree.&lt;/p&gt;

&lt;p&gt;You looked at CellBlocks?&lt;/p&gt;

&lt;p&gt;Allocations offheap take time. You looked at bytebufferpool?  Could allocate a bunch up front and then do reuse?&lt;/p&gt;
</comment>
                            <comment id="15158983" author="anastas" created="Tue, 23 Feb 2016 14:46:40 +0000"  >&lt;p&gt;Thank you for your immediate attention &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Of course, we looked on CellBlock from &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10713&quot; title=&quot;A MemStore implementation with in memory flushes to CellBlocks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10713&quot;&gt;&lt;del&gt;HBASE-10713&lt;/del&gt;&lt;/a&gt;&lt;br/&gt;
The code there is very well written with comments and thus possible to understand from just reading the patch. Kudos &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt; &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; !&lt;br/&gt;
(At least I hope that I understand it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt; please correct me if I am wrong.)&lt;/p&gt;

&lt;p&gt;Alongside with some restructuring and refactoring (partially issued by &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-14919&quot; title=&quot;Infrastructure refactoring for In-Memory Flush&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-14919&quot;&gt;&lt;del&gt;HBASE-14919&lt;/del&gt;&lt;/a&gt;), the CellBlocks suggests to use ArrayList of PositionedByteRange as the underlying data structure.&lt;br/&gt;
PositionedByteRange and SimplePositionedByteRange are allocated simply from JVM heap.&lt;br/&gt;
The code treats many details and also provides a very important CellBlockScanner to scan the new data structure.&lt;br/&gt;
In light of the recent MemStore refactoring, the CellBlock patch clearly can not be used as is.&lt;br/&gt;
However, the most important and deep parts of the code are very valuable and definitely can be reused.&lt;/p&gt;

&lt;p&gt;Thus we suggest CellBlocksSegment, which fits into new Segments structure of MemStore and inherits from ImmutableSegment.&lt;br/&gt;
Underneath, CellBlocksSegment has the same idea of CellBlock. &lt;br/&gt;
Just striving to use an array of arrays, instead of list of arrays, in order to enjoy the binary search and less memory overhead.&lt;br/&gt;
Taking in consideration the earlier &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt;&apos;s comments about MSLAB (and a simple common sense) we suggest to use MSLAB for allocating any sequence of bytes.&lt;br/&gt;
Please note that MSLAB is very suitable also because it issues the reference counting for chunk scans and thus the deallocation of the chunks per segment.&lt;br/&gt;
As far as for now MSLAB doesn&apos;t support off-heap allocation, the PositionedByteRange can be replaced by ByteRange/Chunk currently returned by MSLAB. Also little more tuning is required.&lt;/p&gt;

&lt;p&gt;As completely orthogonal, but related issue we also see a possibility of enhancing the MSLAB and adding it an ability to allocate its Chunks on- and off-heap.&lt;br/&gt;
It is probably issue for sub-task number 5 of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-14918&quot; title=&quot;In-Memory MemStore Flush and Compaction&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-14918&quot;&gt;HBASE-14918&lt;/a&gt; &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
Obviously, this requires some redesign of MemStoreLAB, HeapMemStoreLab.Chunk, and some other classes around the memory allocation.&lt;br/&gt;
In particular, the implementation of HeapMemStoreLab.Chunk with &quot;byte[] field&quot; and the usage of ByteRange, can be replaced with (for example) ByteBuffer.&lt;br/&gt;
(ByteBufferArray from hbase-common/org.apache.hadoop.hbase.util also looks very interesting &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;)&lt;br/&gt;
I agree that it is better to pre-allocate the off-heap Chunks, for that we can probably enhance the MemStoreChunkPool.&lt;br/&gt;
I took a look on the BoundedByteBufferPool, which I found only in hbase-client code. It also looks very suitable, however in different component.&lt;/p&gt;

&lt;p&gt;Sorry for this long monolog &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;, everybody, what do you think?&lt;br/&gt;
I am thrilled to hear your insightful comments! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;)))))&lt;br/&gt;
Thanks!&lt;/p&gt;</comment>
                            <comment id="15163424" author="stack" created="Wed, 24 Feb 2016 17:58:06 +0000"  >&lt;blockquote&gt;&lt;p&gt;....the CellBlocks suggests to use ArrayList of PositionedByteRange as the underlying data structure.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You thinking this still the case &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt; given where offheaping of read path is going? Should base type be ByteBuff so can do onheap/offheap?&lt;/p&gt;


&lt;p&gt;bq, Thus we suggest CellBlocksSegment, which fits into new Segments structure of MemStore and inherits from ImmutableSegment.&lt;/p&gt;

&lt;p&gt;High-level, sounds good.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Underneath, CellBlocksSegment has the same idea of CellBlock. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;One question; what happens when a CellBlockSegment runs into a HFileBlock? How will the marshalling from CBS to HFB run?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Just striving to use an array of arrays, instead of list of arrays, in order to enjoy the binary search and less memory overhead.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;A noble goal.&lt;/p&gt;

&lt;p&gt;So, an array of CellBlocks? You&apos;d allocate CellBlocks with MSLAB?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;As far as for now MSLAB doesn&apos;t support off-heap allocation, the PositionedByteRange can be replaced by ByteRange/Chunk currently returned by MSLAB. Also little more tuning is required.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok. Sorry for the plethora of types. We seem to be settling on a few now we know more.&lt;/p&gt;

&lt;p&gt;There also means of allocation. MSLAB, BucketCache allocator.&lt;/p&gt;

&lt;p&gt;We can move BBBP no problem.&lt;/p&gt;

&lt;p&gt;Yeah, lets align what you are doing here with the offheaping of the write path work @anastasia.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Sorry for this long monolog &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Keep going. It is good stuff.&lt;/p&gt;</comment>
                            <comment id="15166843" author="anoop.hbase" created="Thu, 25 Feb 2016 07:10:35 +0000"  >&lt;p&gt;So the underlying data structure is array of Cells or array of PBRs?&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10713&quot; title=&quot;A MemStore implementation with in memory flushes to CellBlocks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10713&quot;&gt;&lt;del&gt;HBASE-10713&lt;/del&gt;&lt;/a&gt;, I considered the in memory flushed CellBlock to have a plain byte[] representation as we can see in HFile data blocks.  An array&apos;s overhead seems not that much compared to as CSLM.  So array is ok. Ya it helps with a binary search and things looks much simpler.&lt;/p&gt;

&lt;p&gt;Regarding PBR return type from MSLAB, this will create issue with off heap MSLAB.  So we try to change this to BB.  Java ByteBuffer type is enough not our ByteBuff.  Our ByteBuff adds one unwanted wrap. We dont want multiple BB backing for return for each of the allocate call to MSLAB, FYI &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15166882" author="ram_krish" created="Thu, 25 Feb 2016 07:57:43 +0000"  >&lt;blockquote&gt;&lt;p&gt;Yeah, lets align what you are doing here with the offheaping of the write path work&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;+1 here. &lt;br/&gt;
Was waiting for Anoop to reply over here.  The MSLAB should not be working with ByteRange or its forms rather it should be with a datastructure that can work with offheap also. So ByteBuffer is the ideal choice here. &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Should base type be ByteBuff so can do onheap/offheap?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Bytebuffs are wrappers on Bytebbuffers so unless we need something like multiple buffers we need not go with ByteBuffs. &lt;/p&gt;</comment>
                            <comment id="15167347" author="anastas" created="Thu, 25 Feb 2016 15:58:56 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ram_krish&quot; class=&quot;user-hover&quot; rel=&quot;ram_krish&quot;&gt;ramkrishna.s.vasudevan&lt;/a&gt; and everybody, I have just replied on &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-14921&quot; title=&quot;Inmemory Compaction Optimizations; Segment Structure&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-14921&quot;&gt;&lt;del&gt;HBASE-14921&lt;/del&gt;&lt;/a&gt; because the discussion is about task#4.&lt;br/&gt;
Please take a look there.&lt;/p&gt;</comment>
                            <comment id="15167496" author="stack" created="Thu, 25 Feb 2016 17:31:52 +0000"  >&lt;blockquote&gt;&lt;p&gt;Our ByteBuff adds one unwanted wrap. We dont want multiple BB backing for return for each of the allocate call to MSLAB&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt; Ok. ByteBuff type is ONLY for case where we need to span BBs as in spanning BucketCache buckets? Or you see other uses for it Anoop?  What about the fate f ByteRange et al. Seems like we want to move away from ByteRange since it only knows of onheap. If so, lets start a campaign to purge or at least post an edict that ByteRange and subclasses are deprecated.&lt;/p&gt;</comment>
                            <comment id="15167497" author="stack" created="Thu, 25 Feb 2016 17:32:52 +0000"  >&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ram_krish&quot; class=&quot;user-hover&quot; rel=&quot;ram_krish&quot;&gt;ramkrishna.s.vasudevan&lt;/a&gt; See my comment above to &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt; on campaign to purge/deprecate other types. What you think?&lt;/p&gt;</comment>
                            <comment id="15167514" author="anoop.hbase" created="Thu, 25 Feb 2016 17:42:11 +0000"  >&lt;p&gt;Ya as BR can only handle on heap, we may have to move away from it. It is heavily used in prefix-tree area.&lt;/p&gt;</comment>
                            <comment id="15168669" author="ram_krish" created="Fri, 26 Feb 2016 08:46:41 +0000"  >&lt;p&gt;Since BR is used heavily in the prefix-tree area, that is one reason why still Prefix-Tree read path does not work completely with offheap. We have to rewrite the logic in prefix-tree replacing BR with BBs. &lt;/p&gt;</comment>
                            <comment id="15169406" author="stack" created="Fri, 26 Feb 2016 17:48:51 +0000"  >&lt;p&gt;Move ByteRange into the prefix-tree module? If prefix-tree is enabled, just warn that offheaping will not work at same time and that we&apos;ll be making copies everywhere. Add a warning?&lt;/p&gt;

&lt;p&gt;We&apos;d do this because the handling in Prefix-tree is involved and exotic, hard to get right. Prefix-tree is also not widely used (topic of another discussion). Meantime it should not slow down general improvement. We might consider moving this module out of core.&lt;/p&gt;</comment>
                            <comment id="15170410" author="ram_krish" created="Sat, 27 Feb 2016 07:13:14 +0000"  >&lt;p&gt;Yes we could move that to PRefixtree module once we complete the write path offheaping work so that we are sure that we got rid of all the ByteRange ref in the core areas.&lt;/p&gt;</comment>
                            <comment id="15203266" author="eshcar" created="Sun, 20 Mar 2016 12:20:57 +0000"  >&lt;p&gt;New patch is attached to task &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-14920&quot; title=&quot;Compacting Memstore&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-14920&quot;&gt;&lt;del&gt;HBASE-14920&lt;/del&gt;&lt;/a&gt; - new compacting memstore implementation. The patch is not small &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; please review.&lt;/p&gt;</comment>
                            <comment id="15429728" author="ebortnik" created="Sun, 21 Aug 2016 13:47:37 +0000"  >&lt;p&gt;We&apos;ve just attached a proposed simplified spec for in-memory flush configuration on &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16417&quot; title=&quot;In-Memory MemStore Policy for Flattening and Compactions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16417&quot;&gt;HBASE-16417&lt;/a&gt;, please take a look and speak up (smile).&lt;/p&gt;</comment>
                            <comment id="15451498" author="anoop.hbase" created="Wed, 31 Aug 2016 07:52:41 +0000"  >&lt;p&gt;Which jira# tracks the CellChunkMap and related stuff (sub tasks) - &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ram_krish&quot; class=&quot;user-hover&quot; rel=&quot;ram_krish&quot;&gt;ramkrishna.s.vasudevan&lt;/a&gt;?  Pls move all related jiras under this umbrella.  &lt;/p&gt;</comment>
                            <comment id="15451505" author="ebortnik" created="Wed, 31 Aug 2016 07:56:51 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16421&quot; title=&quot;Introducing the CellChunkMap as a new additional index variant in the MemStore&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16421&quot;&gt;HBASE-16421&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15451584" author="ram_krish" created="Wed, 31 Aug 2016 08:30:33 +0000"  >&lt;p&gt;I think it was already raised as another umbrella JIRa. Not sure if that can  be moved under this. It was raised by &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anastas&quot; class=&quot;user-hover&quot; rel=&quot;anastas&quot;&gt;Anastasia Braginsky&lt;/a&gt; only. I just added subtasks under that so that we could attach smaller patches.&lt;/p&gt;</comment>
                            <comment id="15611907" author="eshcar" created="Thu, 27 Oct 2016 13:34:01 +0000"  >&lt;p&gt;Attaching this here until I can attach files in the &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16417&quot; title=&quot;In-Memory MemStore Policy for Flattening and Compactions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16417&quot;&gt;HBASE-16417&lt;/a&gt; sub-task.&lt;/p&gt;</comment>
                            <comment id="15611957" author="anoop.hbase" created="Thu, 27 Oct 2016 13:54:33 +0000"  >&lt;p&gt;Good work.&lt;br/&gt;
In last fig, &apos;default&apos; means Default memstore?  Or is this case with compacting memstore with &lt;b&gt;NO&lt;/b&gt; index merge at all?&lt;/p&gt;</comment>
                            <comment id="15612053" author="eshcar" created="Thu, 27 Oct 2016 14:30:10 +0000"  >&lt;p&gt;It is default memstore.&lt;/p&gt;</comment>
                            <comment id="15612079" author="anoop.hbase" created="Thu, 27 Oct 2016 14:40:19 +0000"  >&lt;p&gt;So no tests with NO index merge at all?&lt;br/&gt;
When the # merges less, we will end up flushing smaller sized files which might impact compaction I think.  So we are working on a change which allows to flush whole segments to be flushed together to disk.  With that we can better test the with diff policy. ie. #segments needed for a merge.&lt;br/&gt;
What we want to reach is that Compacting memstore is not degraded from Default memstore.&lt;/p&gt;</comment>
                            <comment id="15614268" author="stack" created="Fri, 28 Oct 2016 04:31:59 +0000"  >&lt;p&gt;12 virtual or physical cores?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&quot;For data compaction we do not use MSLABs&#8203; to avoid the inherent space and computation overhead of copying data during compaction.&quot;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=eshcar&quot; class=&quot;user-hover&quot; rel=&quot;eshcar&quot;&gt;Eshcar Hillel&lt;/a&gt; We avoid copying for the data case? Is that unreal?&lt;/p&gt;

&lt;p&gt;Thanks for running the compare. Interesting that you can saturate with 10 threads only. I should look into that. What do you conclude &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=eshcar&quot; class=&quot;user-hover&quot; rel=&quot;eshcar&quot;&gt;Eshcar Hillel&lt;/a&gt;? Or this is just exploratory work? Thanks.&lt;/p&gt;</comment>
                            <comment id="15614309" author="ram_krish" created="Fri, 28 Oct 2016 04:59:47 +0000"  >&lt;p&gt;Thanks for the results. Looks great.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;We run index compaction with varying number of segments in the pipeline before merging the&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;index: greater than 1 (ic1), greater than 2 (ic2), greater than 3 (ic3). &lt;br/&gt;
So some where you have ensured that every segment while moving into the pipeline you do flattening and then merge them when the count is 3. Can you just try what happens when you don&apos;t merge it?&lt;/p&gt;</comment>
                            <comment id="15614715" author="anoop.hbase" created="Fri, 28 Oct 2016 08:13:24 +0000"  >&lt;blockquote&gt;&lt;p&gt;&quot;For data compaction we do not use MSLABs&#8203; to avoid the inherent space and computation overhead of copying data during compaction.&quot;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;No fully getting.  During writes the cells data might have been copied to MSLAB.  So when u do say 2 segments data compaction, u will not do any data copy?  Or u mean u will do copy of the surviving cells but not to a chunk got from MSLAB. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  WHy so?  ANy way u r releasing the old segments MSLAB chunks. So temp there will be duplicate of the data (while copying) so u dont want to overuse the MSLAB pool chunks?&lt;/p&gt;</comment>
                            <comment id="15615304" author="ebortnik" created="Fri, 28 Oct 2016 12:53:43 +0000"  >&lt;p&gt;Let&apos;s focus the discussion on &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16417&quot; title=&quot;In-Memory MemStore Policy for Flattening and Compactions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16417&quot;&gt;HBASE-16417&lt;/a&gt;, that is the right context. &lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                            <outwardlinks description="incorporates">
                                        <issuelink>
            <issuekey id="12997549">HBASE-16421</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12788345">HBASE-13408</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12699803">HBASE-10713</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12784629" name="CellBlocksSegmentDesign.pdf" size="136381" author="eshcar" created="Wed, 27 Jan 2016 12:49:29 +0000"/>
                            <attachment id="12835588" name="HBASE-16417-benchmarkresults.pdf" size="406774" author="eshcar" created="Thu, 27 Oct 2016 13:34:01 +0000"/>
                            <attachment id="12784895" name="MSLABMove.patch" size="30883" author="anoop.hbase" created="Thu, 28 Jan 2016 10:54:15 +0000"/>
                    </attachments>
                <subtasks>
                            <subtask id="12917937">HBASE-14919</subtask>
                            <subtask id="12923248">HBASE-15016</subtask>
                            <subtask id="12945460">HBASE-15359</subtask>
                            <subtask id="12917939">HBASE-14920</subtask>
                            <subtask id="12917940">HBASE-14921</subtask>
                            <subtask id="12946076">HBASE-15380</subtask>
                            <subtask id="12997265">HBASE-16417</subtask>
                            <subtask id="13004092">HBASE-16608</subtask>
                            <subtask id="13012514">HBASE-16849</subtask>
                            <subtask id="13012515">HBASE-16850</subtask>
                            <subtask id="13012626">HBASE-16851</subtask>
                            <subtask id="13020296">HBASE-17081</subtask>
                            <subtask id="13027382">HBASE-17294</subtask>
                            <subtask id="13028033">HBASE-17316</subtask>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 22 Jan 2016 19:46:36 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2p8ev:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>