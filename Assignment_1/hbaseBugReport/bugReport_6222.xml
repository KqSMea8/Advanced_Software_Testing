<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:34:51 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-6222/HBASE-6222.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-6222] Add per-KeyValue Security</title>
                <link>https://issues.apache.org/jira/browse/HBASE-6222</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;Saw an interesting article: &lt;a href=&quot;http://www.fiercegovernmentit.com/story/sasc-accumulo-language-pro-open-source-say-proponents/2012-06-14&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.fiercegovernmentit.com/story/sasc-accumulo-language-pro-open-source-say-proponents/2012-06-14&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&quot;The  Senate Armed Services Committee version of the fiscal 2013 national defense authorization act (S. 3254) would require DoD agencies to foreswear the Accumulo NoSQL database after Sept. 30, 2013, unless the DoD CIO certifies that there exists either no viable commercial open source database with security features comparable to &lt;span class=&quot;error&quot;&gt;&amp;#91;Accumulo&amp;#93;&lt;/span&gt; (such as the HBase or Cassandra databases)...&quot;&lt;/p&gt;

&lt;p&gt;Not sure what a &apos;commercial open source database&apos; is, and I&apos;m not sure whats going on in the article, but tra-la-la&apos;ing, if we had per-KeyValue &apos;security&apos; like Accumulo&apos;s, we might put ourselves in the running for federal contributions?&lt;/p&gt;</description>
                <environment></environment>
        <key id="12560859">HBASE-6222</key>
            <summary>Add per-KeyValue Security</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="stack">stack</reporter>
                        <labels>
                    </labels>
                <created>Sat, 16 Jun 2012 05:30:10 +0000</created>
                <updated>Fri, 20 Nov 2015 11:53:38 +0000</updated>
                            <resolved>Thu, 9 Jan 2014 18:46:40 +0000</resolved>
                                                    <fixVersion>0.98.0</fixVersion>
                                    <component>security</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>58</watches>
                                                                                                            <comments>
                            <comment id="13296117" author="apurtell" created="Sat, 16 Jun 2012 06:34:58 +0000"  >&lt;p&gt;It&apos;s rather shocking to see congressional level discussion about  NoSQL winners and losers. &lt;/p&gt;</comment>
                            <comment id="13296151" author="larsgeorge" created="Sat, 16 Jun 2012 14:00:20 +0000"  >&lt;p&gt;I was thinking about this as well a while back when Accumulo came up. In that context I thought it might be good to have the option to add &quot;tags&quot; to each KV. This can be used for security or other purposes, like replication or transactional support. Another use case is filtering as these tags could have special features like caching or indexes. &lt;/p&gt;</comment>
                            <comment id="13296177" author="apurtell" created="Sat, 16 Jun 2012 16:42:09 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4477&quot; title=&quot;Ability for an application to store metadata into the transaction log&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4477&quot;&gt;&lt;del&gt;HBASE-4477&lt;/del&gt;&lt;/a&gt; could transmit tags in the WAL. &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2893&quot; title=&quot;Table metacolumns&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2893&quot;&gt;&lt;del&gt;HBASE-2893&lt;/del&gt;&lt;/a&gt; Is one way to manage them in the store. &lt;/p&gt;

&lt;p&gt;Revisit those issues?&lt;/p&gt;

&lt;p&gt;Others? New approaches?&lt;/p&gt;</comment>
                            <comment id="13296182" author="jmhsieh" created="Sat, 16 Jun 2012 16:58:41 +0000"  >&lt;p&gt;Here&apos;s a good link with high level semantics of their implementation.  &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://accumulo.apache.org/1.4/user_manual/Security.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://accumulo.apache.org/1.4/user_manual/Security.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I&apos;ve spent a few hours looking at the accumulo code.  Internally it is:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;an extra visibility/tags field in their cell Key which supports AND, OR, NOT boolean operators.&lt;/li&gt;
	&lt;li&gt;an always on visibility filter on the tablet/regionserver side.&lt;/li&gt;
	&lt;li&gt;a constraint policy option that determines behavior if a users attempts to write to labels they do not have read access to:
	&lt;ul&gt;
		&lt;li&gt;allow&lt;/li&gt;
		&lt;li&gt;throw security exceptions&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;authentication credentials and authorization plumbing&lt;/li&gt;
&lt;/ul&gt;


</comment>
                            <comment id="13296184" author="apurtell" created="Sat, 16 Jun 2012 17:07:21 +0000"  >&lt;p&gt;@Jon we could do it that way but then the changes are core  . A big concern when This first came up is the impact increasing the size of every KV would have for something that won&apos;t be the common case. &lt;/p&gt;</comment>
                            <comment id="13296186" author="jxiang" created="Sat, 16 Jun 2012 17:25:51 +0000"  >&lt;p&gt;We can put some attribute on the table level to control if the feature is enabled for a table.  So that in normal case, the KV is not affected.&lt;br/&gt;
We can also put such information in a system table.&lt;/p&gt;</comment>
                            <comment id="13305339" author="apurtell" created="Sat, 16 Jun 2012 17:42:47 +0000"  >&lt;p&gt;@Jimmy Such a proposal must address the impact on code. So is that a subclass of KV? Or a bunch of conditional code wherever KVs are handled?&lt;/p&gt;</comment>
                            <comment id="13393356" author="jmhsieh" created="Sat, 16 Jun 2012 17:58:29 +0000"  >&lt;p&gt;@Andy I&apos;m not proposing we necessarily do it the way accumulo does it &amp;#8211; the more important point is that we mimic it&apos;s semantics to make it easier for users to eventually port to HBase. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;/p&gt;

&lt;p&gt;The meta column idea you describe in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2893&quot; title=&quot;Table metacolumns&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2893&quot;&gt;&lt;del&gt;HBASE-2893&lt;/del&gt;&lt;/a&gt; and its use cases seems to also argue for  restoring the distinction between locality groups and column families from original bigtable paper. (these are conflated in HBase).  &lt;/p&gt;

&lt;p&gt;Using a meta column for cell-granularity visibility seems like a reasonable hbase implementation option.  I&apos;m not convinced why this approach would save significantly more space.  I do think  the not changing core argument is more compelling hbase-specific constraint.&lt;/p&gt;

&lt;p&gt;The accumulo implementation has a default case that would make it cost the tags cost extra only on cells with non-default behavior (e.g. only the highly-sensitive or cols with sensitivity varying cells).  They delta encode their keys (including the visiblity tags) like we do in 0.94.&lt;/p&gt;

&lt;p&gt;As a straw man, a core-changing HBase version that modified KV&apos;s wouldn&apos;t necessarily incur more space &amp;#8211; we could use a new KeyValue.Type (TaggedPut?) that had visibility settings, and use the old Put type that used the default tags. &lt;/p&gt;</comment>
                            <comment id="13393360" author="larsgeorge" created="Sat, 16 Jun 2012 18:44:54 +0000"  >&lt;p&gt;I am thinking of moving the tags between the key and the value of the KV. The existence would need to be tracked somehow, so we could add a single byte as a bit field to flag the presence. Or add a new type value like PUT_WITH_TAGS or some such. That would leave existing KVs the same and only the code needs to be enhanced to enable the actual security layer - which would be a system level coprocessor I presume. &lt;/p&gt;</comment>
                            <comment id="13393361" author="larsgeorge" created="Sat, 16 Jun 2012 18:46:00 +0000"  >&lt;p&gt;Oh, and that approach would also leave all the comparators etc. untouched. That sounds like a good thing. &lt;/p&gt;</comment>
                            <comment id="13393374" author="apurtell" created="Sat, 16 Jun 2012 19:31:31 +0000"  >&lt;p&gt;Thus far we have various hooks and a proposal for an out of band approach: &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2893&quot; title=&quot;Table metacolumns&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2893&quot;&gt;&lt;del&gt;HBASE-2893&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4477&quot; title=&quot;Ability for an application to store metadata into the transaction log&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4477&quot;&gt;&lt;del&gt;HBASE-4477&lt;/del&gt;&lt;/a&gt;, API object attributes (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3811&quot; title=&quot;Allow adding attributes to Scan&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3811&quot;&gt;&lt;del&gt;HBASE-3811&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3921&quot; title=&quot;Allow adding arbitrary blobs to Put&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3921&quot;&gt;&lt;del&gt;HBASE-3921&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3931&quot; title=&quot;Allow adding attributes to Get&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3931&quot;&gt;&lt;del&gt;HBASE-3931&lt;/del&gt;&lt;/a&gt;, etc.). The impetus (as I understand it) for an out of band approach is the special nature of KV and the desire to avoid adding additional conditionals/complexity in code wherever it touches KV. That is balanced by the problems an out of band approach causes for minimizing overheads when tags are present, as Jon mentions, without locality groups (a significant change) there is extra IO. I see this as a more conservative approach that won&apos;t perturb performance sensitive members of our community, because there is zero overhead unless configuration is toggled on, coprocessors are loaded, and such.&lt;/p&gt;

&lt;p&gt;However I am not arguing for or against any particular approach. The suggestions by Jon, Lars, and Jimmy are the start of a design proposal but should be pulled together into an actual proposal (as another JIRA?). This is my point. Adding even only one byte to every KV has a very significant effect on storage and IO when the data set is large. Adding a new type avoids that but what is the impact in the code? And it wouldn&apos;t be one new type right, there would be a tagged analogue for every mutator? A convincing exploration of these issues would go a long way here IMHO.&lt;/p&gt;</comment>
                            <comment id="13393377" author="larsgeorge" created="Sat, 16 Jun 2012 20:09:41 +0000"  >&lt;p&gt;I agree with the need of discussing what the objective is and how to get there with the least amount of impact on existing code. That is why I like the idea of reusing the type field. &lt;/p&gt;

&lt;p&gt;I would only add one more type (the one mentioned) and that, together with a global switch, would trigger the code to parse the tags located after the key but before the value (or maybe after the value as it is length prefixed). That tags once parsed can be access then by the coprocessor to do the filtering etc.&lt;/p&gt;

&lt;p&gt;So we would need a way to attach tags to a KV as well as access them once they are parsed out. Seems reasonable?&lt;/p&gt;</comment>
                            <comment id="13393380" author="mcorgan" created="Sat, 16 Jun 2012 20:48:47 +0000"  >&lt;p&gt;DataBlockEncoding gives us the opportunity to add features to a KeyValue interface but create different implementations that have the option of ignoring some of the features.  For &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4676&quot; title=&quot;Prefix Compression - Trie data block encoding&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4676&quot;&gt;&lt;del&gt;HBASE-4676&lt;/del&gt;&lt;/a&gt; (PrefixTrie), I need to create an interface so that I can store the different parts of a KeyValue in different backing arrays: &lt;a href=&quot;https://github.com/hotpads/hbase-prefix-trie/blob/master/src/org/apache/hadoop/hbase/cell/HCell.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/hotpads/hbase-prefix-trie/blob/master/src/org/apache/hadoop/hbase/cell/HCell.java&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This discussion reminds me of the memstoreTS in the current KeyValue which is more of an afterthought and has negative performance implications.  With DataBlockEncoding I&apos;m able to treat it as a first class citizen when it is needed and encode it away when it&apos;s not needed.  I suppose there is a small cpu cost, but really small relative to what else is happening.&lt;/p&gt;

&lt;p&gt;In the future, I think we&apos;re going to want to treat the legacy KeyValue and legacy LinkedList&amp;lt;KeyValue&amp;gt; style data blocks as just another DataBlockEncoding (DataBlockEncoding.NONE), and instead do most operations through a KeyValue interface.  After a lot of benchmarking and research on compiler optimizations, I&apos;m pretty sure we are far away from any performance issues with an interface if people are worried about that... i can comment more on that later if anyone wants.&lt;/p&gt;</comment>
                            <comment id="13393390" author="jmhsieh" created="Sat, 16 Jun 2012 21:11:14 +0000"  >&lt;p&gt;Do we think of the goal of faithfully mimicking accumulo&apos;s is reasonable?  (my first impression is yes). If so, I think we&apos;d need to define those semantics and to do that we&apos;d need bring up an accumulo cluster (or spend more time in the code) to see what its semantics are.  &lt;/p&gt;

&lt;p&gt;Here&apos;s the accumulo api.  (ColumnVisibility is tag expression)&lt;br/&gt;
&lt;a href=&quot;http://accumulo.apache.org/1.4/apidocs/org/apache/accumulo/core/data/Mutation.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://accumulo.apache.org/1.4/apidocs/org/apache/accumulo/core/data/Mutation.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You can see that delete mutations in accumulo also have visibility expressions &amp;#8211; and I&apos;m not actually sure what the semantics are.  Let&apos;s say you have a &quot;public&quot; put on row A, and then a &quot;sensitive&quot; delete of the entire row A.  Does someone with the only the &quot;public&quot; authorizations see the old row A, or no row A?  If it was no row A, would they be able to do a versioned query and get the old row A (and could then infer out that there was a sensitive delete?)...&lt;/p&gt;

&lt;p&gt;Also, I didn&apos;t see atomic increment operator in accumulo.  If it doesn&apos;t exist we&apos;d have to define that behavior. Some options:&lt;br/&gt;
1) No visibility settings on hbase increment mutation operations, thus only keep only one value always readable by all&lt;br/&gt;
2) Add some mechanism to set counter visibility so we could to require authorization to read. &lt;br/&gt;
3) Keep one counter for each visibility tag on a particular cell... (yuck).&lt;/p&gt;</comment>
                            <comment id="13393395" author="apurtell" created="Sat, 16 Jun 2012 21:47:20 +0000"  >&lt;p&gt;@Matt So attributes carry in information and we use a new encoding type to store tags adjacent to KVs if they are labelled?&lt;/p&gt;

&lt;p&gt;@Jon For counters definitely not 1, option 2 seems better. &lt;/p&gt;</comment>
                            <comment id="13393450" author="stack" created="Sun, 17 Jun 2012 05:21:59 +0000"  >&lt;p&gt;@Lars When you say &quot;...I thought it might be good to have the option to add &quot;tags&quot; to each KV&quot;, what would a tag look like?  A bit set?  Or some name/values within the KV?&lt;/p&gt;

&lt;p&gt;I like Jon&apos;s suggestion that &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2893&quot; title=&quot;Table metacolumns&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2893&quot;&gt;&lt;del&gt;HBASE-2893&lt;/del&gt;&lt;/a&gt; could be less onerous if we implemented Locality groups (the meta-cf would be co-mingled w/ the data its meta for).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;They delta encode their keys (including the visiblity tags) like we do in 0.94.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Should we turn the above on as default?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;As a straw man, a core-changing HBase version that modified KV&apos;s wouldn&apos;t necessarily incur more space &#8211; we could use a new KeyValue.Type (TaggedPut?) that had visibility settings, and use the old Put type that used the default tags.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;KVs are also versioned so we should be able to up the version and add new in-key facility (A while back I messed w/ doing this adding a sequenceid beside the timestamp... I did it as &quot;conditional code&quot; rather than as subclass which for sure compounded the complexity of the already-complex KeyValue &amp;#8211; unfortunately, hopefully there is a better route &amp;#8211; but it seemed possible making different KV types float in same scanner merge....).  If we add a ColumnVisibility-like expression into the KV, we&apos;d have to update Comparators to exclude this portion from inclusion in sort.&lt;/p&gt;

&lt;p&gt;On making KV an Interface, that&apos;d be cool.  Todd had a go at it a while back but the ripple turned into an avalanche of code changes IIRC so he suggested we do it piecemeal.  It&apos;d be sweet though.&lt;/p&gt;

&lt;p&gt;+1 on Andrew&apos;s proposal first.  We need a driver?&lt;/p&gt;

&lt;p&gt;On faithful mimicking of Accumulo&apos;s implementation, that makes sense in the absence of an actual customer who needs this stuff (Jon? You have one?)?  Maybe the Accumulo implementation is far from what is wanted &amp;#8211; these &apos;expression&apos;s are passed in the clear &amp;#8211; and a superior implementation might not be that much of a stretch? &lt;/p&gt;</comment>
                            <comment id="13393488" author="larsgeorge" created="Sun, 17 Jun 2012 08:09:11 +0000"  >&lt;blockquote&gt;&lt;p&gt;@Lars When you say &quot;...I thought it might be good to have the option to add &quot;tags&quot; to each KV&quot;, what would a tag look like? A bit set? Or some name/values within the KV?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I would assume the latter, a map of key values for each tag. &lt;/p&gt;

&lt;p&gt;Please note that I would like for these tags NOT just being used for security, but also as something we can use in a broader sense. Like the per KV memstoreTS idea. They can be optionally attached to the KVs when needed. The approach does not change the existing KVs nor any comparator code. Maybe the above is not a good example as that seems something that is eventually needed for all KVs and would warrant for a more tighten terrain into the key and comparators. But I am hoping you get the idea?&lt;/p&gt;

&lt;p&gt;So far the other approaches (if discussed on that level yet at all) are trying to store the security in collateral places, which I think is not good enough to be compared with Accumulo. But I might be wrong. I personally think that having the ACLs outside the KV asks for situations where the info is lost. I think the data is so important, it should be part of the KV itself. Just thinking out loud. &lt;/p&gt;</comment>
                            <comment id="13393492" author="larsgeorge" created="Sun, 17 Jun 2012 08:19:25 +0000"  >&lt;blockquote&gt;&lt;p&gt;If we add a ColumnVisibility-like expression into the KV, we&apos;d have to update Comparators to exclude this portion from inclusion in sort.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That is the whole point of my proposal up top, using the new type and attaching the tag bag &lt;b&gt;after&lt;/b&gt; the key, the default code path stays untouched. &lt;/p&gt;

&lt;p&gt;Sure this needs some extra conditional statements, but is easy to test for. The rest of the tests need no overhaul. All the other approaches strike me as overkill - although they might be worthwhile in their own right. So the question is, what weapon do we choose, so that we solve one problem and hopefully get the most collateral benefit?&lt;/p&gt;

&lt;p&gt;Converting KVs into an interface and subclassing them, as you say, seems as well as a major overhaul of the code base. Do we really want this right now? And what does it give us besides the basis for the problem at hand?&lt;/p&gt;</comment>
                            <comment id="13393496" author="larsgeorge" created="Sun, 17 Jun 2012 08:27:01 +0000"  >&lt;p&gt;@Matt If you need to add this anyways, then I would prefer to do this for your problem as well as this one. This kills two issues with one stone. It would also address the future extensibility that adding the KV interface was trying to address anyways.&lt;/p&gt;

&lt;p&gt;Have you had a chance to go through Todd&apos;s attempt and see if you were able to resolve all of the concerns there? As Stack says, solve the &quot;ripple effect&quot;?&lt;/p&gt;

&lt;p&gt;I like this (or my original proposal) best compared to adding meta columns, which seem to also call for a fundamental rearchitecture to add locality groups proper. Feel free to convince me otherwise &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13393589" author="mcorgan" created="Sun, 17 Jun 2012 19:21:25 +0000"  >&lt;blockquote&gt;&lt;p&gt;@Matt So attributes carry in information and we use a new encoding type to store tags adjacent to KVs if they are labelled?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yeah, basically you would be required to use the new encoding format (TaggedPrefixTrie, for example), and if you switched back to DataBlockEncoding.NONE, your tags would be erased (we&apos;d want to make that scenario appropriately difficult of course.).  The trie would de-duplicate them, take up no space if they aren&apos;t there, and use &amp;gt;=1 byte per cell index if they are there.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Have you had a chance to go through Todd&apos;s attempt and see if you were able to resolve all of the concerns there?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I was aware Todd tried this at some point but haven&apos;t looked into the details or talked to him about it.  I assume  he was attempting a full &quot;extract interface&quot; style refactoring, which I think is probably too big of a change.  My approach is a little different and sets in place a strategy for gradually migrating to the interface.  From the top of the HCell class linked to above, you can see these methods that require any implementation to be able to create legacy KeyValues.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;//V1 is the &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] format of the current KeyValue implementation.
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;//&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; building a result to send to client
&lt;/span&gt;&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; getV1KeyLength();
&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; getV1Length();
&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] getV1KeyValueArray();
KeyValue getKeyValue();
ByteBuffer getV1KeyBuffer();

&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; appendKeyToV1ByteArray(&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] output, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; offset);
&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; appendToV1ByteArray(&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] output, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; offset);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This lets the interface start in the data block encoders and slowly grow out into the storefiles, filters, etc, and eventually out to the client.  Eventually we deprecate those methods from the interface and try to finalize the transition.  One problem with this approach with regard to the tags is that only the storage layer would know about them at first, and it would take some time to expose them to the client.&lt;/p&gt;

&lt;p&gt;All-in-all, the tags raise some interesting questions in my mind like &quot;why isn&apos;t everything in the KV implemented as a tag?&quot;  For example, i&apos;d love to see per-cell TTL&apos;s someday.  Maybe tags go hand-in-hand with co-processors to implement features like that?&lt;/p&gt;</comment>
                            <comment id="13393617" author="apurtell" created="Sun, 17 Jun 2012 21:36:40 +0000"  >&lt;p&gt;@Lars&lt;/p&gt;

&lt;p&gt;I was following up to this point:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I like this (or my original proposal) best compared to adding meta columns, which seem to also call for a fundamental rearchitecture to add locality groups proper.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s not &lt;em&gt;essential&lt;/em&gt; to storing labels in a metacolumn, though it may be advisable for performance reasons.&lt;/p&gt;</comment>
                            <comment id="13393618" author="apurtell" created="Sun, 17 Jun 2012 21:40:40 +0000"  >&lt;p&gt;@Matt&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;@Matt So attributes carry in information and we use a new encoding type to store tags adjacent to KVs if they are labelled?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, basically you would be required to use the new encoding format (TaggedPrefixTrie, for example), and if you switched back to DataBlockEncoding.NONE, your tags would be erased (we&apos;d want to make that scenario appropriately difficult of course.). The trie would de-duplicate them, take up no space if they aren&apos;t there, and use &amp;gt;=1 byte per cell index if they are there.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So we may have this as a way to store tags inline with data, with dedup/optimize away if not needed; and we may have Lars&apos; somehow tag structure addition to KV (Lars: what would that look like?). Worth doing a bake-off? &lt;/p&gt;</comment>
                            <comment id="13393621" author="apurtell" created="Sun, 17 Jun 2012 21:51:05 +0000"  >&lt;blockquote&gt;&lt;p&gt;All-in-all, the tags raise some interesting questions in my mind like &quot;why isn&apos;t everything in the KV implemented as a tag?&quot; For example, i&apos;d love to see per-cell TTL&apos;s someday. Maybe tags go hand-in-hand with co-processors to implement features like that?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The metacolumn idea was actually the result of some brainstorming on how to do per-cell TTLs. By no means do I raise it as a potentially superior alternative, simply one implementation strategy that wouldn&apos;t touch core. However tags in KV would be another way to go that touches core only once. &lt;/p&gt;

&lt;p&gt;We could agree on criteria such as:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Tag storage optimized out if no tags present&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Compartmentalized changes&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Generic mechanism for adding, reading, removing, and modifying tags, usable by coprocessors.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;maybe?&lt;/p&gt;</comment>
                            <comment id="13393622" author="apurtell" created="Sun, 17 Jun 2012 21:54:22 +0000"  >&lt;p&gt;@Jon, Stack: No we don&apos;t have to mimic the Accumulo API though if the goal here is to be an alternative, it must be possible to build a direct API translation shim that provides the same labelling and visibility semantisc.&lt;/p&gt;</comment>
                            <comment id="13393623" author="stack" created="Sun, 17 Jun 2012 21:55:10 +0000"  >&lt;blockquote&gt;&lt;p&gt;I would assume the latter, a map of key values for each tag.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This strikes me as odd; keyvalues within the keyvalues (and then keyvalues on the keyvalues in keyvalue) and then along comes Matt w/ his &quot;why isn&apos;t everything in the KV implemented as a tag?&quot; which is a reasonable question.  A response would be because we don&apos;t want to have to have exotic deserialization and sort but I suppose with Trie we might have that already?  It&apos;d certainly be &apos;flexible&apos; which is what you want LarsG? (A nice objective that usually comes at performance cost).  A core of required&apos;s with optional tags that don&apos;t cost unless you use them would be grand.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think the data is so important, it should be part of the KV itself.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good point.  Maybe not even lost, mayhaps a bug would cause us skip the metacolumn?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;....attaching the tag bag after the key.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This seems like it would not require much of a refactor (would have to somehow mark where key ends and tag/bag starts).&lt;/p&gt;

</comment>
                            <comment id="13393625" author="mcorgan" created="Sun, 17 Jun 2012 22:03:38 +0000"  >&lt;blockquote&gt;&lt;p&gt;Worth doing a bake-off?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;If we didn&apos;t want to wait for the KV interface development to percolate out to the client code (could take a while), then we&apos;d have to add the tag info to the current KeyValue via Lars&apos;s suggestion or something like it so it can work with existing mechanisms like the memstore, client, filters, etc.  The upside is that we wouldn&apos;t have to be super-paranoid about adding bloat to the KeyValue since it will someday become just one of the cell implementations.  I guess I&apos;m saying it&apos;s maybe ok to muck up the current KV even more given that data block encoding should be able to clean up the mess down the road.  That being said, I don&apos;t personally need this feature so I hate to suggest mucking up anything!&lt;/p&gt;</comment>
                            <comment id="13393676" author="lakshman" created="Mon, 18 Jun 2012 06:13:33 +0000"  >&lt;p&gt;Good to see lot of interest and discussion in this.&lt;/p&gt;

&lt;p&gt;I couldn&apos;t understand the above discussion completely.&lt;br/&gt;
But, I&apos;ve some basic questions.&lt;br/&gt;
1) Do we really have any known use-cases for KV based access control? &lt;br/&gt;
2) Does scalability affected badly for the users who needs at KV level access control?&lt;/p&gt;

&lt;p&gt;How about other approach of supporting access control through &lt;b&gt;HBase views&lt;/b&gt;?&lt;br/&gt;
If we want to restrict access for a CF/CQ and a set of rows to a user/group then create a view for that set and control access through view.&lt;/p&gt;

&lt;p&gt;It&apos;s just an idea based on my understanding of RDBMS (Oracle). Not really sure if this is really feasible in HBase. Please respond with use-cases and comments.&lt;/p&gt;</comment>
                            <comment id="13393697" author="larsgeorge" created="Mon, 18 Jun 2012 07:04:10 +0000"  >&lt;blockquote&gt;&lt;p&gt;@Andy That&apos;s not essential to storing labels in a metacolumn, though it may be advisable for performance reasons.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Understood. I am not saying this is needed or that metacolumns do not work without. In fact, I think that they are very useful in the context you discussed with Matt, i.e. for example TTLs. I personally think there is a need for two optional features: a) metacolumns - which cover broader rules for a many columns or rows, and b) KV tags - which are carried as low as they can get to retain per cell information. &lt;/p&gt;

&lt;p&gt;So for TTL I would think that the tags are too low, yet for security I do think that metacolumns are too &quot;weak&quot; of a guarantee.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;@Andy and @Matt: So we may have this as a way to store tags inline with data, with dedup/optimize away if not needed; and we may have Lars&apos; somehow tag structure addition to KV (Lars: what would that look like?). Worth doing a bake-off?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think this is not either or, but - and Matt please correct me if mistaken - if we add Trie compression then we can leverage the implementation to handle it. If we decide not to merge the two, then we can use my suggestion of adding them to the KV optionally and we can handle the compression implications later.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;@Andy: We could agree on criteria such as: Tag storage optimized out if no tags present&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Indeed, since we use a new type, no extra storage is needed if no tag is attached.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;@Andy: Compartmentalized changes&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed, we add a new type and handle that case separately. Though the majority of the code is shared, the new type would trigger the extraction of the tags if called for (which I assume would be done lazily).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;@Andy: Generic mechanism for adding, reading, removing, and modifying tags, usable by coprocessors.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;These are the KeyValue.addTag(byte[] name, byte[] value) and KeyValue.getTag(byte[] name) helpers I was referring to. The coprocessors has full access that way, since the tags are carried for each KV.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;@Andy: No we don&apos;t have to mimic the Accumulo API though if the goal here is to be an alternative, it must be possible to build a direct API translation shim that provides the same labelling and visibility semantisc.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Indeed. One of the arguments I hear comparing HBase and Accumulo is the fact that we have no cell level security tagging. That is what this is all about. My proposal is - as much as I can tell - lean (as it uses no extra storage if not used), can be combined with the non-cell level security (you might not want this level of security to avoid extra baggage), does not change the comparators, and overall is quite non-intrusive in existing code. On the other hand it seems useful for other cell level features in the future.&lt;/p&gt;

&lt;p&gt;As Jon says, Accumulo uses these tags and the always-on filter to achieve security (on a very high level view), and so can we then. For me this is comparable then. We do not need to comply to the entire API, but feature set level only.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;@stack: A core of required&apos;s with optional tags that don&apos;t cost unless you use them would be grand. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That is exactly my point. As for &quot;KV in KV&quot;, I do not see how this is &quot;odd&quot; as our KeyValue for starters is the odd one given what most people understand of what a KV is. Coming to terms with our complex key and various sorting rules is not trivial.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;@stack: Good point. Maybe not even lost, mayhaps a bug would cause us skip the metacolumn?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Spot on!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;@Matt: I guess I&apos;m saying it&apos;s maybe ok to muck up the current KV even more given that data block encoding should be able to clean up the mess down the road. That being said, I don&apos;t personally need this feature so I hate to suggest mucking up anything!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed, this is about timing as well. Your patch is highly intrusive - but for good reasons. So I would love to discuss this current issue with your changes already applied. But on the other hand we have to make a call for what we want and when?&lt;/p&gt;

&lt;p&gt;@Laxman: The basic premise here is to be on-par security wise with Accumulo. That is the use-case. As for scalability, I do not see why a few extra bytes and a coprocessor that checks them is disastrous. Sure, this needs evaluation, but we know that other systems - like Accumulo - does it, so if someone wants to enable it, they should see the same impact. Small or big. Or asking the other way around, where do you see this could affect the performance?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;How about other approach of supporting access control through HBase views?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The issue is that these are typically only on the row level. With the cell level you can filter as fine grained as possible. Views - and please object if I am wrong - are more coarse grained. Think of blocking access to some columns differently across many rows. Not just all CF/CQs allowed for all rows.&lt;/p&gt;

&lt;p&gt;That latter is the crucial difference of what is needed to be on-par.&lt;/p&gt;</comment>
                            <comment id="13395815" author="lakshman" created="Mon, 18 Jun 2012 11:24:18 +0000"  >&lt;blockquote&gt;&lt;p&gt;The basic premise here is to be on-par security wise with Accumulo. That is the use-case.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;IMHO, that&apos;s one implementation but not use-case. Definitely, Accumulo would have some straight use-case. Do we that use-case? Based on use-case, we can brainstorm on different approaches (KV level, Views, something else may be).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;where do you see this could affect the performance?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I have following concern w.r.to &lt;b&gt;scalability&lt;/b&gt;.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;With current implementation, ACLs are cached. With cell level, it may grow heavily.&lt;/li&gt;
	&lt;li&gt;Please take a look @AccessController.permissionGranted method. We need to call this method(+some more checks for KV based) for every KV. This may become a hotspot when we introduce KV based access control.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;We are currently evaluating performance with security enabled. Soon, I will share our report.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Think of blocking access to some columns differently across many rows.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I agree. Can you please explain how do we solve this with a traditional RDBMS like Oracle. &lt;/p&gt;

&lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; I definitely don&apos;t want to bring up the well known discussion &quot;SQL vs NOSQL&quot; here and I&apos;m only trying to understand the use-case as a HBase user/developer. Only point I want to put forward is we should have proper understanding of use-case and user before we start on a approach/solution.&lt;/p&gt;</comment>
                            <comment id="13395834" author="anoopsamjohn" created="Mon, 18 Jun 2012 11:45:45 +0000"  >&lt;p&gt;I dont think the approach that we are discussing is, to keep the ACL details of each cell in the &lt;em&gt;acl&lt;/em&gt; table. So that wont be a concern as such&lt;/p&gt;</comment>
                            <comment id="13395856" author="lakshman" created="Mon, 18 Jun 2012 12:24:55 +0000"  >&lt;p&gt;Thanks for clarification Anoop. So, one of the concerns w.r.to cache can be ruled out for further discussion.&lt;/p&gt;</comment>
                            <comment id="13396190" author="kturner" created="Mon, 18 Jun 2012 19:50:12 +0000"  >&lt;p&gt;The security label in the Accumulo key is called Column Visibility.  Its part of the sort order and uniqueness of an &lt;br/&gt;
Accumulo key.  The key is sorted on row, then column fam, column qual, then column vis, then timestamp, then delete flag.  So for example the following entries would be distinct and sort in the following way.&lt;/p&gt;

&lt;p&gt;row=1234 cf=name cq=last cv=S&amp;amp;GOLF ts=5 val=Smith&lt;br/&gt;
row=1234 cf=name cq=last cv=S&amp;amp;GOLF ts=4 val=Smit&lt;br/&gt;
row=1234 cf=name cq=last cv=U ts=9 val=Doe&lt;/p&gt;</comment>
                            <comment id="13396197" author="larsgeorge" created="Mon, 18 Jun 2012 20:04:03 +0000"  >&lt;p&gt;A comparable concept in the RDBMS world is Oracle&apos;s label security:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.oracle.com/us/products/database/options/label-security/overview/index.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.oracle.com/us/products/database/options/label-security/overview/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is much more involved as it has labels, departments, and so on. It also combines default labels with runtime ones, making up the actual value to check against. The data labels are stored in a hidden column in the table and is for the entire row.&lt;/p&gt;

&lt;p&gt;Accumulo stores the labels with the policy in each KV, for example &quot;A&amp;amp;B&amp;amp;(D|E)&quot;. The system level filter evaluates the labels and compares them to the actual authorization details of the user. It then let&apos;s the user access the data or not. So this is simpler compared to OLS.&lt;/p&gt;

&lt;p&gt;I was thinking that adding &quot;tags&quot; is the actual support feature to enable the same functionality. Then we need a coprocessor to apply the rules. The part we do not have here is the authorization against the labels. The labels in Accumulo are created ad-hoc, which means we would need to attach the user authorization in the ACL table, but that can be cached. &lt;/p&gt;</comment>
                            <comment id="13396972" author="apurtell" created="Tue, 19 Jun 2012 18:33:09 +0000"  >&lt;p&gt;Correct me if I&apos;m wrong but given all of the above discussion therefore the scope of changes necessary are:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Add a facility for storing string tags with each KV. Will need to do this for both puts and deletes.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Update the KV comparators to take into account tags in the sort order, if present.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Add a coprocessor (perhaps another implementation of Constraint) that:
	&lt;ul&gt;
		&lt;li&gt;Implements a visibility filter that evaluates for each KV if the current set of user-supplied labels intersects with allowed labels according to visibility predicates stored in the KV, if any, and emits (or not);&lt;/li&gt;
		&lt;li&gt;Unpacks labels added by the client via our generic op attributes facility and adds them to KVs in a mutator op or programs the visibility filter on a Get or Scan;&lt;/li&gt;
		&lt;li&gt;Always adds the visibility filter to Get and Scan operations, wrapping any other supplied filter with FilterList(MUST_PASS_ALL) and the visibility filter on the RHS so we can let the other filters reduce the number of visibility evaluations necessary.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Shell support
	&lt;ul&gt;
		&lt;li&gt;Add setuaths and getauths equivalent shell commands&lt;/li&gt;
		&lt;li&gt;Extend the other shell ops with sugar for adding labels as a working example of how to do it via the Java client&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;And the constraints on implementation are:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Tag storage optimized out if no tags present&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Compartmentalized changes&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;The mechanism for adding, reading, removing, and modifying tags in the KV should be generic&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Does that about sum it up?&lt;/p&gt;

&lt;p&gt;@Laxman: Such a Constraint-based coprocessor as described would be orthogonal to AccessController. One could use both at the same time independently, or they could be unified at some point. &lt;/p&gt;

&lt;p&gt;@Lars&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;@Andy: Compartmentalized changes&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed, we add a new type and handle that case separately. Though the majority of the code is shared, the new type would trigger the extraction of the tags if called for (which I assume would be done lazily).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So one new type that causes us to extract tags then recurse on the actual wrapped op? And we extend all necessary internal method signatures to carry tags around? Edit: By that I mean a pointer to where they are serialized in byte[] if doing it lazily as you suggest.&lt;/p&gt;

&lt;p&gt;Edit: Removed one line of language where I went off in the weeds a bit.&lt;/p&gt;</comment>
                            <comment id="13397057" author="jmhsieh" created="Tue, 19 Jun 2012 20:42:45 +0000"  >&lt;p&gt;From my point of view, I&apos;d like really like to understand more than just accumulo&apos;s implementation &amp;#8211; I really care about if accumulo&apos;s semantics are 1) intentional and required for accumulo use cases and 2) if applications only use a constrained sets of its capabilities.  One specific thing I don&apos;t quite understand is the ramifications of having column visibility settings are encoded as part of the key and sort order.  This could be equivalent expressions that are no longer equals, and some of somewhat goofy future/past views.&lt;/p&gt;

&lt;p&gt;Another thought: At a high level it seems odd for the co-processor to constrain what can be seen &amp;#8211; we definitely would not want to let a &quot;normal&quot; client view the raw underlaying tags or visibility metadata tables!&lt;/p&gt;

&lt;p&gt;IMO I&apos;d probably prefer a completely generic tag system for HBase only after we have a few different serious use cases (possibly existing ones!) that would use it.  Making something overly generic introduces its own set of new problems.&lt;/p&gt;

&lt;p&gt;@Keith I&apos;ll search on the accumulo mailing to see if things will answer my semantics questions &amp;#8211; and if I don&apos;t find it I&apos;ll shoot off some questions there.&lt;/p&gt;</comment>
                            <comment id="13397121" author="apurtell" created="Tue, 19 Jun 2012 22:31:30 +0000"  >&lt;p&gt;@Jon You just argued for a metacolumn, no?&lt;/p&gt;</comment>
                            <comment id="13397122" author="apurtell" created="Tue, 19 Jun 2012 22:33:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;At a high level it seems odd for the co-processor to constrain what can be seen &#8211; we definitely would not want to let a &quot;normal&quot; client view the raw underlaying tags or visibility metadata tables!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;There would not be a &quot;normal&quot; client in this case, the coprocessor would obviously be installed as a system level coprocessor and the visibility filter would therefore always be active. Didn&apos;t mean to imply otherwise somehow. Certainly that&apos;s not how I read the comment stream above.&lt;/p&gt;</comment>
                            <comment id="13397665" author="ecn" created="Wed, 20 Jun 2012 17:38:15 +0000"  >&lt;p&gt;For clarification, Accumulo does not support negation in the visibility expressions.  &quot;!&quot; may be reserved for future use, but expressions are limited to terms, &quot;&amp;amp;&quot; or &quot;|&quot; and parens for precedence.&lt;/p&gt;

&lt;p&gt;Visibility expressions are not required: the metadata table does not use them, for example.&lt;/p&gt;

&lt;p&gt;The visibility needs to be part of the key in order to have different values at different visibilities.&lt;/p&gt;

&lt;p&gt;@Jonathan - enjoyed your talk @hadoop summit.&lt;/p&gt;</comment>
                            <comment id="13400209" author="larsgeorge" created="Sun, 24 Jun 2012 20:51:58 +0000"  >&lt;p&gt;As a note, I raised the question of what we need as per the use-cases we see at customers. We are in the process of evaluating this and I should be able to share the requirements here sometime soon. &lt;/p&gt;

&lt;p&gt;One of the questions is where we put policies: either in the labels and therefore the tags on each KV, or in a separate place that applies dynamic runtime policies that match the user to the data labels. &lt;/p&gt;</comment>
                            <comment id="13483960" author="jerrychenhf" created="Thu, 25 Oct 2012 08:04:22 +0000"  >&lt;p&gt;@Jon&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;From my point of view, I&apos;d like really like to understand more than just accumulo&apos;s implementation &#8211; I really care about if accumulo&apos;s semantics are 1) intentional and required for accumulo use cases and 2) if applications only use a constrained sets of its capabilities. One specific thing I don&apos;t quite understand is the ramifications of having column visibility settings are encoded as part of the key and sort order. This could be equivalent expressions that are no longer equals, and some of somewhat goofy future/past views.  &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I looked into the accumulo implementation. And one thing that accumulo want to achieve by making the ColumnVisibility as a part of the column key is that the authorization can be enforced without reading the existing records that may be affected by the current mutation. Because the ColumnVisibility is part of the key, you need to explicitly give the ColumnVisibility to identify/match to the column you are targeting to change (put or delete), and thus VisibilityConstraint check can be performed on the given ColumnVisibility with the user&apos;s authorization tokens to make sure the user has been authorized for performing the mutation logically on an existing column, without scanning the existing columns that it may make changes on. HBase and accumulo are at the same situation for this.&lt;/p&gt;

&lt;p&gt;There may some other issues to be addressed if something is not part of the key and also not part of the value when multiple versions of a logical column existed. For example, a Put with new Visibility values of the key of &lt;/p&gt;
{row1, family1:qualifier1}
&lt;p&gt; will make an logical changes on all the cells with key &lt;/p&gt;
{row1, family1:qualifier1}
&lt;p&gt;, and thus authorization must be checked over all these affected items (which may with different Visibility values) with the user authorization to see whether the Put can be performed or not. And the deletion gets the same thing to consider when considering DeleteFamily and DeleteColumn which logically affect a lot of columns that may have different Visibility values).&lt;/p&gt;

&lt;p&gt;One important change on the client API when the Visibility is part of the column key is the Visibility need to be specified either explicitly or implicitly (such as empty Visibility is used when no Visibility provided in the parameters) when performing Put or Delete mutations. This does seem a little strange at a first glance when comparing with approaches used by traditional database row level authorization such as Oracle Label Security. But the question is do we have other better choices both solve the problem and fit into the current framework?&lt;/p&gt;</comment>
                            <comment id="13484279" author="stack" created="Thu, 25 Oct 2012 17:07:33 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=gqchen&quot; class=&quot;user-hover&quot; rel=&quot;gqchen&quot;&gt;Jerry Chen&lt;/a&gt; A put that broadened visibility would be for the current put only?  How would it effect already-put values?  (I can see how an Increment would have to check current visibility setting to see if it was allowed increment it &amp;#8211; ditto for check and put)  The DeleteFamily, DeleteColumn case is interesting.  HBase would have to change how it does these operation pretty radically &amp;#8211; at least the way we do delete family.  &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=larsgeorge&quot; class=&quot;user-hover&quot; rel=&quot;larsgeorge&quot;&gt;Lars George&lt;/a&gt; Anything to report?  It has to be per KV?  Or could it be metacolumn/Oracle Label Security-like?&lt;/p&gt;</comment>
                            <comment id="13485788" author="jerrychenhf" created="Mon, 29 Oct 2012 02:15:03 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;A put that broadened visibility would be for the current put only? How would it effect already-put values?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;When the visibility is part of the column key, a broadened visibility will not affect the existing columns that with the same &lt;/p&gt;
{rowid, family, qualifier}
&lt;p&gt; but with different visibilities. Thus, the put will only affect the columns that has the same &lt;/p&gt;
{rowid, family, qualifier, visibility}. Different visibilities has the same effect as different qualifiers.&lt;br/&gt;
&lt;br/&gt;
While as to DeleteFamily or DeleteColumn, Accumulo doesn&apos;t have such as operations. It has only Delete mutation to delete a specified {rowid, family, qualifier, visibility}
&lt;p&gt;. The idea to keep DeleteFamily and DeleteColumn still working with visibility in HBase is that A DeleteFamily operation now will only affect &quot;all columns in this family with the specified visibility&quot; other than originally &quot;all columns in this family&quot;. The same with DeleteColumn.&lt;/p&gt;

&lt;p&gt;One thing to consider if the visibility is part of the key. As there are suggestions to provide support for general tags for KV so that not only visibility tags can be stored in it, but also other tags that needed in the future can be added easily. Will general tags concept (comparing to a visibility tag) makes the concept of the column key too complex?&lt;/p&gt;


</comment>
                            <comment id="13492029" author="apurtell" created="Wed, 7 Nov 2012 01:20:36 +0000"  >&lt;p&gt;I am currently exploring/coding a couple of implementation options in parallel. Please ping me if you&apos;re working in this area.&lt;/p&gt;</comment>
                            <comment id="13492577" author="v.himanshu" created="Wed, 7 Nov 2012 18:34:46 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=apurtell&quot; class=&quot;user-hover&quot; rel=&quot;apurtell&quot;&gt;Andrew Purtell&lt;/a&gt; We would like to collaborate on adding this feature. What are the approaches you are considering?&lt;/p&gt;

&lt;p&gt;We also looked into this feature a while ago, and came up with the attached PRD and design. It will be great to have your feedback on it. &lt;/p&gt;</comment>
                            <comment id="13492608" author="apurtell" created="Wed, 7 Nov 2012 19:15:35 +0000"  >&lt;p&gt;Thanks for attaching the design documents. I could comment on them but am pursing a substantially different direction.&lt;/p&gt;

&lt;p&gt;Regarding KV tags:&lt;/p&gt;

&lt;p&gt;Right now I&apos;m experimenting with code that adds tags to KVs in a backwards compatible way. I would call this a transitional change. We overload the existing KV binary format, technically the tags are prepended to value data but are not considered part of it. For KVs that contain tags, the value length is encoded as a negative integer. When a negative value length is encountered, we walk over the value part of the KV, parsing out tags, until we reach an end marker. Once we know the size of the tag data, we adjust the value offset and value length returned to API callers. The parsing of tags in the KV is cached after the first time it is performed. Thus no change to KV handling has to happen outside of the KeyValue class.&lt;/p&gt;

&lt;p&gt;Regarding cell level permissions:&lt;/p&gt;

&lt;p&gt;Instead of visibility labels we extend the AccessController to support per cell ACLs. These are serialized TablePermissions stored with a KV in a tag. We add a helper class UserTablePermissions which supports both PB and Writable serialization of Listmultimap&amp;lt;String,TablePermission&amp;gt;. The permissions checking of the AccessController is extended in a straightforward way to check if any KV passing through the AccessControlFilter contains tags containing ACLs. If so, an access grant check is first performed using TablePermissions deserialized from the tag(s). This allows per cell ACLs to overload CF or table level permissions wherever they might exist. While the TablePermission type is not strictly needed for this (Permission would suffice), it was easier to simply allow a TablePermission to store nulls for table, cf, and qualifier than make more extensive changes to the AccessController. Doing so could be considered a refinement. This does mean that the AccessControlFilter implementation is changed to pass back SKIP instead of NEXT_COL hints, so every KV is examined by the filter, and use of the filter to wrap Gets and Scans is now unconditional. The performance impact of this has yet to be quantified but is expected not to be that different from changes that require per-KV visibility labels to be evaluated (and could be less expensive since we are not evaluating a mini label language).&lt;/p&gt;

&lt;p&gt;No API changes are necessarily required. The new UserTablePermissions type is serialized to PB and then passed as an attribute using the existing API facility for that. Not all mutation types are supported. It doesn&apos;t make sense to attach an ACL on a Delete, because the KVs covered by the delete will be ... deleted. Additionally, Increment is not currently supported because it doesn&apos;t support attributes (doesn&apos;t extend either Mutation nor OperationWithAttributes) and anyway the upsert code paths don&apos;t pass KVs through a coprocessor down into HBase core so bundling tags with the user value doesn&apos;t work there. Also, while I haven&apos;t done this quite yet, I anticipate the upsert code will require a second core modification to preserve any tags that might be in the value to update.&lt;/p&gt;

&lt;p&gt;Obviously my goal is to add per-cell (&quot;per-KeyValue&quot;) security through as simple and straightforward extensions of the existing AccessController implementation as possible, with minimal to no changes to core code*. I do not aim for Accumulo parity nor support for multi label security schemes. It may be more appropriate to post this work to another JIRA when it is ready for review. This work could be considered orthogonal to any label based approach, and could probably play nicely together with it should one come to exist, as long as both are based on a generic KV tag facility.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;- I am also evaluating an option that avoids making any change to KeyValue, thus no change to core HBase at all. Instead it stores the equivalent of KV tags in &quot;shadow KVs&quot; stored in a shadow metacolumn. Implementation of this is underway but as you can imagine it&apos;s not so straightforward to produce something that could perform (nearly) as well as inline in-KV checks. This approach wouldn&apos;t have the limitation regarding Increment nor the requirement to change the upsert code.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All of the above is subject to change.&lt;/p&gt;</comment>
                            <comment id="13493387" author="yuzhihong@gmail.com" created="Thu, 8 Nov 2012 18:56:09 +0000"  >&lt;p&gt;@Himanshu:&lt;br/&gt;
I have some questions about your design doc.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Versions will be kept for each unique visibility expression.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Would this inflate memstore because we are keeping potentially many more versions of KeyValue which differ by visibility expression only ?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;HTable-level property: a property &#8220;ENABLE_CELL_LEVEL_SECURITY&#8221; in&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Since HFile metadata would include similar information, looks like storing such information at column family level is better.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The property &#8220;ENABLE_CELL_LEVEL_SECURITY&#8221; can be change only after enabling/disabling the table.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I assume that the table is in disabled state when this property is changed.&lt;/p&gt;

&lt;p&gt;on page 12:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;It attaches the CVFilter to the Get object,&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Suppose a user belongs to more than one group, would multiple CVFilter instances be attached to the Get object ?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;it passes only the ones which pass the &#8220;Secret&#8221; visibility expression.He will get v1 and v4.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The above is inconsistent with description on page 11 where v2 and v4 are said to be returned.&lt;/p&gt;

&lt;p&gt;Thanks&lt;/p&gt;</comment>
                            <comment id="13494519" author="v.himanshu" created="Sat, 10 Nov 2012 02:07:56 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=apurtell&quot; class=&quot;user-hover&quot; rel=&quot;apurtell&quot;&gt;Andrew Purtell&lt;/a&gt;Thanks for the writeup. Yes, your approach is different. Few thoughts:&lt;/p&gt;

&lt;p&gt;a) Its not clear how/where you are storing the acls at keyvalue level. You use &lt;em&gt;acl&lt;/em&gt; table, or something else? Reading through this gives an idea that the keyvalue level acls have null table, cf and cq attribute with them. Does this mean a user can have only one type of KV level acls in the application. Or in other words, how does the KV acl looks like in the &lt;em&gt;acl&lt;/em&gt; table?&lt;/p&gt;

&lt;p&gt;b) Currently, all the acl entries are stored in zk (limit of znode is 1 mb); will you be using the same approach?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It doesn&apos;t make sense to attach an ACL on a Delete, because the KVs covered by the delete will be ... deleted.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I don&apos;t completely agree with this but will not comment also unless I completely understand your approach.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=yuzhihong%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;yuzhihong@gmail.com&quot;&gt;Ted Yu&lt;/a&gt; Thanks for taking time to read through it. &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Versions will be kept for each unique visibility expression.Would this inflate memstore because we are keeping potentially many more versions of KeyValue which differ by visibility expression only ?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Or HFile, right? If so, yes, as different visibility expressions provides different access control to user. If user A does two Put with Visibility A|B, C and then does a delete with visibility A|B, another user with acl of C should be able to see this.&lt;/p&gt;

&lt;p&gt;re: ENABLE_CELL_LEVEL_SECURITY&lt;br/&gt;
I initially visualized a table level (will give some more thought about CF level... as mentioned in the doc also)&lt;br/&gt;
Yes, change it after disabling the table as it will flush out the memstore.&lt;/p&gt;

&lt;p&gt;re: Multiple CVFilter&lt;br/&gt;
No, only one should be good enough. How come you got this idea? I should fix the doc.&lt;/p&gt;

&lt;p&gt;re: Typo: &lt;br/&gt;
Yes, he will get v2 and v4. Thanks for pointing this out.&lt;/p&gt;
</comment>
                            <comment id="13494750" author="apurtell" created="Sat, 10 Nov 2012 19:31:26 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=v.himanshu&quot; class=&quot;user-hover&quot; rel=&quot;v.himanshu&quot;&gt;Himanshu Vashishtha&lt;/a&gt; Thanks for the gracious comments.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Currently, all the acl entries are stored in zk (limit of znode is 1 mb); will you be using the same approach?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No. Pursuing an incremental approach, so, we keep per-table and per-CF ACLs implemented as-is for now. Then add per cell ACLs as a third level of permissions checking. Per cell ACLs are stored in the region alongside the data. It&apos;s an open question if having an ACL table will still be necessary as things evolve.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Its not clear how/where you are storing the acls at keyvalue level.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;There are different approaches to doing this, will try two of them to establish the extent of changes to core code required and performance differences:&lt;/p&gt;

&lt;p&gt;1. Store per cell ACLs in tags in KV, using the approach to putting tags in KV that I described above. &lt;/p&gt;

&lt;p&gt;2. Store per cell ACLs in a &quot;shadow ACL column&quot;. Per cell ACLs are still associated with individual KVs but in effect tag storage is moved external to the data KV, so no changes to the KeyValue implementation are necessary, and stored in the same region. Will incur some additional cost for querying tags but will not require intra cluster RPC.&lt;/p&gt;

&lt;p&gt;3. Store per cell ACLs in the ACL table. Tag storage again is external to the data KV, and now in a separate table. Will incur cost for querying tags and furthermore require intra cluster RPC. Probably won&apos;t actually try this.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;You use acl table, or something else?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The ACL is stored &quot;in&quot; the KV (depends which impl option if that is physical or logical). The table, row, family, qualifier, and timestamp of an in-KV permission are implicit &amp;#8211; those of the KV&apos;s location. I do use TablePermission to represent ACLs at the KV level but only to avoid some refactoring in the AccessController that would be outside the scope of a proof of concept. Pardon if mentioning this detail was confusing.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;It doesn&apos;t make sense to attach an ACL on a Delete, because the KVs covered by the delete will be ... deleted.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I don&apos;t completely agree with this but will not comment also unless I completely understand your approach.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We treat ACLs on a KV as timestamped like the rest of the KV. An ACL in a new Put applies only to that Put. It doesn&apos;t change the ACL of any previous Put. However, we require a Put to have covering&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; permission &amp;#8211; so either table perms, CF perms, or perms in the most recent visible existing value, if any, must allow the pending Put (or Append, or Increment, or any mutation) in order for it to be applied. This is because the pending operation will replace the visible value and its ACL, if it has one, for Gets and Scans that don&apos;t ask for more than one version. If you actually want to change the ACL on a specific KV, you must Delete then Put, if you have perms for that. On reads, a KV is visible to the InternalScanner if either table perms, CF perms, or perms stored in the KV allow, similar to visibility labels in a sense but with ACL semantics. The AccessControlFilter is extended to do that&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;. For Deletes, &lt;em&gt;all&lt;/em&gt; visible prior versions covered by the Delete must allow the Delete, because a major compaction could remove them if we allow the tombstone and it covers them, regardless of any ACL they might contain. &quot;Visible&quot; here is defined as not covered by an already committed tombstone. This allows simple and straightforward evolution of security policy over time without requiring expensive updates&lt;span class=&quot;error&quot;&gt;&amp;#91;3&amp;#93;&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;So a Delete doesn&apos;t update ACLs. ACLs are bits of information to be stored with the KV. It&apos;s meaningless to put an ACL on an op that stores nothing. And, an ACL on a Delete would not grant that Delete permission to do something. It would be the union of per table, per CF, and all ACLs on visible covered values that would grant (or not). Since we are only looking at the most recent version of a KV, if any, except for Deletes, only Delete - and especially DeleteColumn - can be potentially expensive to check. There is no free lunch but union-of-ACL semantics helps: Granting appropriate per table or per CF perms to a user or group obviates the need for KV ACL checking for that user or her groups, so we can early out and avoid going to the store in that case.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; Maybe &quot;covering&quot; isn&apos;t quite the best term. Suggestions welcome.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt; This changes AC semantics some. A user who doesn&apos;t have permissions to a CF or exact location (column+qualifier) just won&apos;t get values back from a scan or get, as opposed to previous behavior which would throw an AccessDeniedException if the user did not have required perms to the CF at the CF level. I refactored TestAccessController to address this in a clean way.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;3&amp;#93;&lt;/span&gt; On the other hand GRANT and REVOKE commands could provide a convenient way to change per KV ACLs too, since they are DDL not DML ops. We could consider enhancing the GRANT and REVOKE command processing in the AccessController to replace all per KV ACLs covered by the action, if they exist. A possible optimization is lazy updates via a timestamped log of recent GRANTs and REVOKEs (but I just thought of that now so it&apos;s a superficial suggestion).&lt;/p&gt;</comment>
                            <comment id="13494755" author="apurtell" created="Sat, 10 Nov 2012 20:18:54 +0000"  >&lt;p&gt;I forgot to mention something and want to highlight something.&lt;/p&gt;

&lt;p&gt;The new KVs for Append and Increment inherit the KV tags (hence ACLs) of the value(s) they are updating. This is both logical and works around the fact that Increment is not a Mutation (see &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-7114&quot; title=&quot;Increment does not extend Mutation but probably should&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-7114&quot;&gt;&lt;del&gt;HBASE-7114&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;If &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=v.himanshu&quot; class=&quot;user-hover&quot; rel=&quot;v.himanshu&quot;&gt;Himanshu Vashishtha&lt;/a&gt; or someone else wants to implement Accumulo-style visibility labels (or if I ultimately end up doing it), then I encourage following the same design principles:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Coprocessor based implementation&lt;/li&gt;
	&lt;li&gt;Minimal to no changes to core code&lt;/li&gt;
	&lt;li&gt;Perhaps just building on a KV generic tags facility&lt;/li&gt;
	&lt;li&gt;Use OperationWithAttributes#
{get,set}
&lt;p&gt;Attribute for passing through your new metadata&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Then, you can see how what I describe above and perhaps something else that implements Accumulo-style visibility labels can be consistent in deployment and API details &lt;b&gt;and can be easily stacked on top of each other&lt;/b&gt;.&lt;/p&gt;</comment>
                            <comment id="13494820" author="stack" created="Sun, 11 Nov 2012 03:46:38 +0000"  >&lt;p&gt;If cp fails to load, will all the data then become visible Andrew?  Anything we can do to have it default to be non-viewable unless via a visibility CP (Otherwise, adding generic tags facility to kv w/ visibility done in a visibility cp sounds sweet)&lt;/p&gt;</comment>
                            <comment id="13495528" author="apurtell" created="Mon, 12 Nov 2012 19:19:28 +0000"  >&lt;blockquote&gt;&lt;p&gt;If cp fails to load, will all the data then become visible Andrew? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is straightforward to address. The CP framework can fail to open a region if required CPs cannot be loaded and initialized. This is &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-6873&quot; title=&quot;Clean up Coprocessor loading failure handling&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-6873&quot;&gt;&lt;del&gt;HBASE-6873&lt;/del&gt;&lt;/a&gt;. &lt;/p&gt;</comment>
                            <comment id="13562067" author="apurtell" created="Thu, 24 Jan 2013 22:32:18 +0000"  >&lt;p&gt;Split into subtasks.&lt;/p&gt;</comment>
                            <comment id="13585579" author="apurtell" created="Mon, 25 Feb 2013 03:05:34 +0000"  >&lt;p&gt;Attached 6222-aclcf.patch. This is the implementation option which uses a shadow column family for cell ACL metadata storage.&lt;/p&gt;

&lt;p&gt;Edit: I had to context switch to something else and am coming back to this now. I would like to update this patch with more unit tests so should not be considered a final version of anything.&lt;/p&gt;</comment>
                            <comment id="13585580" author="apurtell" created="Mon, 25 Feb 2013 03:06:23 +0000"  >&lt;p&gt;Attached &apos;cell-acls-kv-tags-not-for-review.zip&apos;, an implementation option that uses inline storage for ACL data.&lt;/p&gt;</comment>
                            <comment id="13585693" author="ram_krish" created="Mon, 25 Feb 2013 07:52:16 +0000"  >&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
   } &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (more);
    scanner.close();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In AccessController.requireCoveringPermission the close should be in finally block?&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// Before per cell ACLs we used to &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; the NEXT_COL hint, but can no
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// no longer &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; that since, given the possibility of per cell ACLs
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// anywhere, we now need to examine all KVs with &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; filter.&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;May be we can move this before the &apos;if&apos; condition just before this.&lt;/p&gt;</comment>
                            <comment id="13585700" author="ram_krish" created="Mon, 25 Feb 2013 07:55:02 +0000"  >&lt;p&gt;@Test tag misses for testCellPermissions().  Was it intentional?&lt;/p&gt;</comment>
                            <comment id="13585714" author="ram_krish" created="Mon, 25 Feb 2013 08:17:49 +0000"  >&lt;p&gt;Andy,&lt;br/&gt;
The memstore flushes if more than 1 CF exists, will it have an impact on this new CF introduced?&lt;br/&gt;
One more question is,&lt;br/&gt;
Once in the AccessController hooks we have ensured that the permission is available by checking the new CF &lt;em&gt;acl&lt;/em&gt;, when the actual scan goes we can avoid this Cell right?  May be am missing something.  Pls correct me if am wrong.&lt;/p&gt;</comment>
                            <comment id="13586041" author="yuzhihong@gmail.com" created="Mon, 25 Feb 2013 17:53:41 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=apurtell&quot; class=&quot;user-hover&quot; rel=&quot;apurtell&quot;&gt;Andrew Purtell&lt;/a&gt;:&lt;br/&gt;
The attached document is interesting.&lt;br/&gt;
Do you have performance comparison for writes ?&lt;/p&gt;

&lt;p&gt;Thanks&lt;/p&gt;</comment>
                            <comment id="13586073" author="apurtell" created="Mon, 25 Feb 2013 18:13:53 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=yuzhihong%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;yuzhihong@gmail.com&quot;&gt;Ted Yu&lt;/a&gt; The results for writes are not interesting, boxplots align etc. I would have expected some impact to be noticeable so I plan to look into that more. Stay tuned.&lt;/p&gt;</comment>
                            <comment id="13586093" author="apurtell" created="Mon, 25 Feb 2013 18:26:52 +0000"  >&lt;blockquote&gt;&lt;p&gt;In AccessController.requireCoveringPermission the close should be in finally block?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;May be we can move this before the &apos;if&apos; condition just before this.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;@Test tag misses for testCellPermissions(). Was it intentional?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No. Checked the test logs and it still runs, but will add this of course.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The memstore flushes if more than 1 CF exists, will it have an impact on this new CF introduced?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The ACL CF is only hidden from the client. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Once in the AccessController hooks we have ensured that the permission is available by checking the new CF acl, when the actual scan goes we can avoid this Cell right?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We could modify the Scan object in a preScannerOpen hook to exclude the ACL CF. The values from that family are not used in the filter. (I seem to remember exploring that idea is why no such exclusion presently.)&lt;/p&gt;

&lt;p&gt;Thanks for the review!&lt;/p&gt;</comment>
                            <comment id="13586709" author="ram_krish" created="Tue, 26 Feb 2013 03:57:26 +0000"  >&lt;p&gt;@Andy&lt;br/&gt;
May be &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5416&quot; title=&quot;Filter on one CF and if a match, then load and return full row (WAS: Improve performance of scans with some kind of filters)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5416&quot;&gt;&lt;del&gt;HBASE-5416&lt;/del&gt;&lt;/a&gt; can be used here.  Need to go thro the patch once again to see if it is possible.&lt;/p&gt;</comment>
                            <comment id="13586724" author="yuzhihong@gmail.com" created="Tue, 26 Feb 2013 04:15:52 +0000"  >&lt;p&gt;I was thinking about &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5416&quot; title=&quot;Filter on one CF and if a match, then load and return full row (WAS: Improve performance of scans with some kind of filters)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5416&quot;&gt;&lt;del&gt;HBASE-5416&lt;/del&gt;&lt;/a&gt; as well.&lt;br/&gt;
However, user scan may be utilizing &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5416&quot; title=&quot;Filter on one CF and if a match, then load and return full row (WAS: Improve performance of scans with some kind of filters)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5416&quot;&gt;&lt;del&gt;HBASE-5416&lt;/del&gt;&lt;/a&gt; at the same time.&lt;/p&gt;

&lt;p&gt;Meaning, there might be two essential families.&lt;/p&gt;</comment>
                            <comment id="13586948" author="ram_krish" created="Tue, 26 Feb 2013 08:53:37 +0000"  >&lt;p&gt;Yes.  Going thro the patch once again.&lt;br/&gt;
Basically we say if a family is essential or not as part of Filters.&lt;br/&gt;
So once ACL layer is done we should have a mechanism to avoid a CF ( here it is the &lt;em&gt;acl&lt;/em&gt; CF).  &lt;/p&gt;</comment>
                            <comment id="13586954" author="apurtell" created="Tue, 26 Feb 2013 09:05:59 +0000"  >&lt;p&gt;With &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5416&quot; title=&quot;Filter on one CF and if a match, then load and return full row (WAS: Improve performance of scans with some kind of filters)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5416&quot;&gt;&lt;del&gt;HBASE-5416&lt;/del&gt;&lt;/a&gt; maybe the AccessController can add or wrap any filters on the Scan with a filter that excludes the ACL CF since the AccessControlFilter doesn&apos;t consult that data inline with scanner iteration.&lt;/p&gt;

&lt;p&gt;Longer term though most likely the AccessControlFilter will have ACL data available inline with the KVs (as tags). See the alternate implementation attached to this JIRA for an example of how that could work. The separate ACL CF would go away.&lt;/p&gt;

&lt;p&gt;If cell tags can make it into 0.96, then the ACL CF could go away now. 5416 would not be useful in that case.&lt;/p&gt;

&lt;p&gt;Edit: I misread the tail of 5416, so it&apos;s in trunk already.&lt;/p&gt;</comment>
                            <comment id="13586956" author="ram_krish" created="Tue, 26 Feb 2013 09:08:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;If cell tags can make it into 0.96, then the ACL CF could go away now. 5416 would not be useful in that case&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Ya of course right.&lt;/p&gt;</comment>
                            <comment id="13590103" author="apurtell" created="Fri, 1 Mar 2013 00:29:06 +0000"  >&lt;p&gt;Updated file 6222.pdf. Updated results for minicluster load tests with latest Hadoop 2.0.4-SNAPSHOT + HBase 0.95-SNAPSHOT (just before branch) and &lt;em&gt;not&lt;/em&gt; using multiPuts. Now I&apos;m seeing what I expect.&lt;/p&gt;</comment>
                            <comment id="13592079" author="apurtell" created="Mon, 4 Mar 2013 09:18:28 +0000"  >&lt;p&gt;Some feedback from the Feb 28 HUG: Consider storing a reference to an ACL in the KV (logically in the ACL CF or inline as a tag) instead of the ACL itself. The ACL could be stored, versioned, in the &lt;em&gt;acl&lt;/em&gt; table. &lt;/p&gt;

&lt;p&gt;This is an interesting idea. It would address the case where the same ACL is stored in hundreds or thousands (or more) of values. We should save some space by writing the actual ACL only to one location. This also facilitates easy updates of the ACL, as a single atomic change, especially useful in the case where the initial mutations may have included an incorrect ACL. However, the tradeoff is two lookups instead of one for deciding what to do with every KeyValue: first, to the ACL CF to get the reference, if any, associated with the KV (but at least this is within the region); the second to a probably remote region of the &lt;em&gt;acl&lt;/em&gt; table to retrieve the ACL itself. It could be possible to cache the results of the ACL data lookups for a limited time, for however long a policy decision can be allowed to be out of date. If we have KV tags, the first lookup goes away but unfortunately the second remains, taking back some (most?) of the performance/latency gains we expect from inline storage.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure the benefits outweigh the drawbacks.&lt;/p&gt;</comment>
                            <comment id="13592095" author="nkeywal" created="Mon, 4 Mar 2013 10:06:55 +0000"  >&lt;p&gt;If I understand well, the choice depends on the number of different ACL are we expecting and if we have access patterns that would make caching efficient. Do we know this? With a reference based implementation, for a scan it would make sense  to first check the reference of the ACL that gives us a read access, and then use this for all the kv in the table. The caching duration policy could be per scan. &lt;/p&gt;

&lt;p&gt;Lastly, if it&apos;s considered as &quot;nearly immutable&quot; data, it&apos;s possible to use a ZooKeeper node to invalidate the cache on an update. This works well if you have a few update per hour (with as many insert as you like).  Then policy is &apos;infinite cache&apos;.&lt;/p&gt;</comment>
                            <comment id="13592103" author="apurtell" created="Mon, 4 Mar 2013 10:35:18 +0000"  >&lt;blockquote&gt;&lt;p&gt;the choice depends on the number of different ACL are we expecting and if we have access patterns that would make caching efficient. Do we know this?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Maybe for a given row. Wouldn&apos;t say so in general but there&apos;s no &quot;real world&quot; user usage data. We should expect best practice for a very common cell ACL is a factoring of it to out a CF or table grant, to avoid any IO checking cover for mutations. So at the cell level either no data or probably lots of varying ACLs. &lt;/p&gt;</comment>
                            <comment id="13592138" author="nkeywal" created="Mon, 4 Mar 2013 11:28:18 +0000"  >&lt;p&gt;Ok. For the use cases, do we know how Accumulo is used today?&lt;/p&gt;</comment>
                            <comment id="13592170" author="apurtell" created="Mon, 4 Mar 2013 12:53:07 +0000"  >&lt;blockquote&gt;&lt;p&gt;For the use cases, do we know how Accumulo is used today?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Accumulo provides labels, &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-7663&quot; title=&quot;[Per-KV security] Visibility labels&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-7663&quot;&gt;&lt;del&gt;HBASE-7663&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13592768" author="mcorgan" created="Mon, 4 Mar 2013 22:51:45 +0000"  >&lt;p&gt;My understanding of the goal of per-KeyValue security is that it&apos;s to eliminate all doubt that levels above the KeyValue could break or misinterpret permissions.  If that&apos;s accurate, would adding caching and indirection layers above KeyValue possibly compromise the fundamental design goal?&lt;/p&gt;</comment>
                            <comment id="13592966" author="apurtell" created="Tue, 5 Mar 2013 02:24:23 +0000"  >&lt;blockquote&gt;&lt;p&gt;If that&apos;s accurate, would adding caching and indirection layers above KeyValue possibly compromise the fundamental design goal&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m inclined to agree. Certainly it complicates it. Shouldn&apos;t be in an initial drop for the sake of establishing correctness first. &lt;/p&gt;</comment>
                            <comment id="13592971" author="apurtell" created="Tue, 5 Mar 2013 02:28:12 +0000"  >&lt;p&gt;And to be clear I&apos;d like to surface this discussion from the HUG but am not advocating for such changes. &lt;/p&gt;</comment>
                            <comment id="13665690" author="apurtell" created="Thu, 23 May 2013 21:28:13 +0000"  >&lt;p&gt;Should we commit the &quot;shadow column family&quot; based approach we have today and migrate later to something based on KV tags, or wait for tags proper?&lt;/p&gt;</comment>
                            <comment id="13665817" author="enis" created="Thu, 23 May 2013 23:12:13 +0000"  >&lt;blockquote&gt;&lt;p&gt;Should we commit the &quot;shadow column family&quot; based approach we have today and migrate later to something based on KV tags, or wait for tags proper?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I think you mentioned that shadow column family approach is considerably slower than a native tag based approach. I think the questions are (1) whether it still justifies given the performance penalty (2) How far along we are from having tags in Cells. &lt;/p&gt;</comment>
                            <comment id="13665825" author="apurtell" created="Thu, 23 May 2013 23:28:12 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think you mentioned that shadow column family approach is considerably slower than a native tag based approach. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Some single host benchmarks that illustrate the difference are in the PDF attached to this JIRA. There&apos;s a price for security but we would pay less with tags in cells. Of course, if you don&apos;t use cell ACLs then it&apos;s not an issue either way. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;How far along we are from having tags in Cells.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If the timeframe for that is a couple of months, I&apos;d recommend waiting. Anyway, this issue has been sitting here for a while, but not on account of the patch not being in a committable state.&lt;/p&gt;</comment>
                            <comment id="13665964" author="ram_krish" created="Fri, 24 May 2013 03:14:12 +0000"  >&lt;p&gt;@Andy&lt;br/&gt;
I think you need to update the patch with the default deny approach in the absence of KVs granting the action and then commit it if you are planning to.&lt;/p&gt;</comment>
                            <comment id="13677481" author="apurtell" created="Thu, 6 Jun 2013 20:39:11 +0000"  >&lt;blockquote&gt;
&lt;p&gt;@Andy&lt;br/&gt;
I think you need to update the patch with the default deny approach in the absence of KVs granting the action and then commit it if you are planning to.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ram_krish&quot; class=&quot;user-hover&quot; rel=&quot;ram_krish&quot;&gt;ramkrishna.s.vasudevan&lt;/a&gt;. I put up the refreshed patches on &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-7661&quot; title=&quot;[Per-KV security] Store and apply per cell ACLs in a shadow CF&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-7661&quot;&gt;&lt;del&gt;HBASE-7661&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="13866794" author="anoop.hbase" created="Thu, 9 Jan 2014 16:54:47 +0000"  >&lt;p&gt;Great ! All the subtasks are closed now. Good to close this main Jira?&lt;/p&gt;</comment>
                            <comment id="13866897" author="apurtell" created="Thu, 9 Jan 2014 18:46:40 +0000"  >&lt;blockquote&gt;&lt;p&gt;Great ! All the subtasks are closed now. Good to close this main Jira?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Resolved! Let&apos;s party.&lt;/p&gt;</comment>
                            <comment id="13866912" author="lhofhansl" created="Thu, 9 Jan 2014 19:00:08 +0000"  >&lt;p&gt;Yeah!&lt;/p&gt;</comment>
                            <comment id="13866914" author="stack" created="Thu, 9 Jan 2014 19:04:27 +0000"  >&lt;p&gt;Excellent lads.&lt;/p&gt;</comment>
                            <comment id="15016029" author="lars_francke" created="Fri, 20 Nov 2015 11:53:38 +0000"  >&lt;p&gt;This issue was closed as part of a bulk closing operation on 2015-11-20. All issues that have been resolved and where all fixVersions have been released have been closed (following discussions on the mailing list).&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12608907">HBASE-6873</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12615206">HBASE-7114</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12633453">HBASE-7897</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="12310040">
                    <name>Required</name>
                                            <outwardlinks description="requires">
                                        <issuelink>
            <issuekey id="12646149">HBASE-8496</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12639497">HBASE-8209</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12571508" name="6222.pdf" size="1365432" author="apurtell" created="Fri, 1 Mar 2013 00:29:06 +0000"/>
                            <attachment id="12552507" name="HBaseCellRow-LevelSecurityDesignDoc.docx" size="297495" author="v.himanshu" created="Wed, 7 Nov 2012 18:34:46 +0000"/>
                            <attachment id="12552508" name="HBaseCellRow-LevelSecurityPRD.docx" size="31482" author="v.himanshu" created="Wed, 7 Nov 2012 18:34:46 +0000"/>
                            <attachment id="12570707" name="cell-acls-kv-tags-not-for-review.zip" size="27815" author="apurtell" created="Mon, 25 Feb 2013 03:06:23 +0000"/>
                    </attachments>
                <subtasks>
                            <subtask id="12629165">HBASE-7661</subtask>
                            <subtask id="12629167">HBASE-7662</subtask>
                            <subtask id="12629169">HBASE-7663</subtask>
                            <subtask id="12675913">HBASE-9846</subtask>
                            <subtask id="12629170">HBASE-7664</subtask>
                            <subtask id="12676446">HBASE-9858</subtask>
                            <subtask id="12679908">HBASE-9997</subtask>
                            <subtask id="12687805">HBASE-10297</subtask>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 16 Jun 2012 06:34:58 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>250960</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            1 year, 4 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0b2rz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>62562</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>