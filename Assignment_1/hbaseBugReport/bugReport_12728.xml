<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 20:35:49 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-12728/HBASE-12728.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-12728] buffered writes substantially less useful after removal of HTablePool</title>
                <link>https://issues.apache.org/jira/browse/HBASE-12728</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;In previous versions of HBase, when use of HTablePool was encouraged, HTable instances were long-lived in that pool, and for that reason, if autoFlush was set to false, the table instance could accumulate a full buffer of writes before a flush was triggered. Writes from the client to the cluster could then be substantially larger and less frequent than without buffering.&lt;/p&gt;

&lt;p&gt;However, when HTablePool was deprecated, the primary justification seems to have been that creating HTable instances is cheap, so long as the connection and executor service being passed to it are pre-provided. A use pattern was encouraged where users should create a new HTable instance for every operation, using an existing connection and executor service, and then close the table. In this pattern, buffered writes are substantially less useful; writes are as small and as frequent as they would have been with autoflush=true, except the synchronous write is moved from the operation itself to the table close call which immediately follows.&lt;/p&gt;

&lt;p&gt;More concretely :&lt;br/&gt;
```&lt;br/&gt;
// Given these two helpers ...&lt;/p&gt;

&lt;p&gt;private HTableInterface getAutoFlushTable(String tableName) throws IOException &lt;/p&gt;
{
  // (autoflush is true by default)
  return storedConnection.getTable(tableName, executorService);
}

&lt;p&gt;private HTableInterface getBufferedTable(String tableName) throws IOException &lt;/p&gt;
{
  HTableInterface table = getAutoFlushTable(tableName);
  table.setAutoFlush(false);
  return table;
}

&lt;p&gt;// it&apos;s my contention that these two methods would behave almost identically,&lt;br/&gt;
// except the first will hit a synchronous flush during the put call,&lt;br/&gt;
and the second will&lt;br/&gt;
// flush during the (hidden) close call on table.&lt;/p&gt;

&lt;p&gt;private void writeAutoFlushed(Put somePut) throws IOException {&lt;br/&gt;
  try (HTableInterface table = getAutoFlushTable(tableName)) &lt;/p&gt;
{
    table.put(somePut); // will do synchronous flush
  }
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;private void writeBuffered(Put somePut) throws IOException {&lt;br/&gt;
  try (HTableInterface table = getBufferedTable(tableName)) &lt;/p&gt;
{
    table.put(somePut);
  }
&lt;p&gt; // auto-close will trigger synchronous flush&lt;br/&gt;
}&lt;br/&gt;
```&lt;/p&gt;

&lt;p&gt;For buffered writes to actually provide a performance benefit to users, one of two things must happen:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The writeBuffer itself shouldn&apos;t live, flush and die with the lifecycle of it&apos;s HTableInstance. If the writeBuffer were managed elsewhere and had a long lifespan, this could cease to be an issue. However, if the same writeBuffer is appended to by multiple tables, then some additional concurrency control will be needed around it.&lt;/li&gt;
	&lt;li&gt;Alternatively, there should be some pattern for having long-lived HTable instances. However, since HTable is not thread-safe, we&apos;d need multiple instances, and a mechanism for leasing them out safely &amp;#8211; which sure sounds a lot like the old HTablePool to me.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;See discussion on mailing list here : &lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/hbase-user/201412.mbox/%3CCAPdJLkEzmUQZ_kvD%3D8mrxi4V%3DhCmUp3g9MUZsddD%2Bmon%2BAvNtg%40mail.gmail.com%3E&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://mail-archives.apache.org/mod_mbox/hbase-user/201412.mbox/%3CCAPdJLkEzmUQZ_kvD%3D8mrxi4V%3DhCmUp3g9MUZsddD%2Bmon%2BAvNtg%40mail.gmail.com%3E&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="12762928">HBASE-12728</key>
            <summary>buffered writes substantially less useful after removal of HTablePool</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.png">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="ndimiduk">Nick Dimiduk</assignee>
                                    <reporter username="abeppu">Aaron Beppu</reporter>
                        <labels>
                    </labels>
                <created>Fri, 19 Dec 2014 18:38:31 +0000</created>
                <updated>Fri, 4 Nov 2016 02:18:34 +0000</updated>
                            <resolved>Fri, 23 Jan 2015 17:14:55 +0000</resolved>
                                    <version>0.98.0</version>
                                    <fixVersion>1.0.0</fixVersion>
                    <fixVersion>2.0.0</fixVersion>
                    <fixVersion>1.1.0</fixVersion>
                                    <component>hbase</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>20</watches>
                                                                                                            <comments>
                            <comment id="14253780" author="apurtell" created="Fri, 19 Dec 2014 18:47:55 +0000"  >&lt;p&gt;I believe &lt;a href=&quot;https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTableMultiplexer.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;HTableMultiplexer&lt;/a&gt; is meant to stand in for HTablePool for buffered writing. &lt;/p&gt;</comment>
                            <comment id="14253834" author="abeppu" created="Fri, 19 Dec 2014 19:17:00 +0000"  >&lt;p&gt;Andrew Purtell on the thread mentioned HTableMultiplexer on the mailing list thread, and it does seem like this would handle write buffers correctly. He asked me to repost this comment:&lt;br/&gt;
It kind of seems like HTable should then (if autoFlush == false) send writes to the multiplexer, rather than setting it in its own, short-lived writeBuffer. If nothing else, it&apos;s still super confusing that HTableInterface exposes setAutoFlush() and setWriteBufferSize(), given that the writeBuffer won&apos;t meaningfully buffer anything if all tables are short-lived.&lt;/p&gt;</comment>
                            <comment id="14253861" author="ndimiduk" created="Fri, 19 Dec 2014 19:27:29 +0000"  >&lt;p&gt;It seems like we would want to push HTable&apos;s aswyncWriteBuffer down into the connection, we&apos;d have one for each unique table name. I&apos;m not sure where AP responsible for actually sending edits would sit &amp;#8211; its executor is managed by the table at the moment. Connection teardown would also need to check the buffers and send any pending data.&lt;/p&gt;</comment>
                            <comment id="14254558" author="lhofhansl" created="Sat, 20 Dec 2014 07:07:36 +0000"  >&lt;p&gt;I do not quite follow the argument here. One can (a) hang on to any HTable instance as long as one wants or (b) buffer in a List&amp;lt;Put&amp;gt; and pass that to HTable.put(List).&lt;br/&gt;
I never liked the autoFlush huh hah, as it would flush at essentially random times and the client has no knowledge (easily at least) of what happened with the edits.&lt;/p&gt;</comment>
                            <comment id="14254936" author="stack" created="Sat, 20 Dec 2014 19:28:39 +0000"  >&lt;p&gt;I like the &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt; take (with implication that the Table manages any write buffer and not Connection)&lt;/p&gt;

&lt;p&gt;There is though a &apos;gap&apos; (as has been noted up on the mailing list) as to how folks get from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=abeppu&quot; class=&quot;user-hover&quot; rel=&quot;abeppu&quot;&gt;Aaron Beppu&lt;/a&gt;&apos;s predicament of many threads writing a table up on to Lars&apos; world; would a thread-safe Table implementation or an updated pool that does new style Interfaces? (no close on add back to the pool)&lt;/p&gt;</comment>
                            <comment id="14255886" author="sduskis" created="Mon, 22 Dec 2014 16:13:36 +0000"  >&lt;p&gt;I agree that autoFlush aught to be removed from the Table API.  Like &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt; says, it has some major issues.  The Table bulk operations for put and delete already exist for a separate mechanism to build an RPC buffering functionality.&lt;/p&gt;

&lt;p&gt;There are various use cases for buffering that may need slightly different behavior.  &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;A servlet that takes in requests might need different behavior than a batch map/reduce.  For example, a servlet might need periodic flushing for low traffic times.&lt;/li&gt;
	&lt;li&gt;There might be cases where there needs to be bulk deletes in addition to bulk puts.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Neither Connection nor Table seem to be the appropriate abstraction for the buffering behavior.  java.util.Writer/BufferedWriter decorator approach seems like a good inspiration for the type of work.  Since Table is both a reader and a writer, decorator not a perfect approach in its current form.   I propose that we split Table into TableWriter and TableReader interfaces and move buffering functionality into a new implementation of TableWriter.&lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                            <comment id="14256471" author="enis" created="Tue, 23 Dec 2014 02:20:23 +0000"  >&lt;p&gt;There is no limitation that Table objects cannot be long lived. Just that short lived Table objects are possible. Table is already a BufferedWriter equivalent IMO. &lt;br/&gt;
It seems that for this use case, some kind of pooling is desired to share the buffers between contextes (and threads). HTablePool is gone, but a TablePool for pooling Table objects, or a multi threaded Table wrapper can still be developed on top of Table objects.  &lt;/p&gt;</comment>
                            <comment id="14256603" author="stack" created="Tue, 23 Dec 2014 05:09:31 +0000"  >&lt;blockquote&gt;&lt;p&gt;A servlet that takes in requests might need different behavior than a batch map/reduce. For example, a servlet might need periodic flushing for low traffic times.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For a servlet, we could checkout from a pool that is instantiated on servlet init?  When the servlet finishes the request, check the Table back into the pool (w/o flush or close).  The pool would have autoflush true set flushing at a size threshold or on a period (we&apos;d have to add the periodicity as a Table intrinsic or have it done by the threadpool internally).&lt;/p&gt;

&lt;p&gt;If we let TableWriter float free, we&apos;d have to have a pool of TableWriters for the servlet scenario? (Or TableWriter would have to be threadsafe)?&lt;/p&gt;


</comment>
                            <comment id="14256627" author="lhofhansl" created="Tue, 23 Dec 2014 05:38:38 +0000"  >&lt;blockquote&gt;&lt;p&gt;A servlet that takes in requests might need different behavior than a batch map/reduce. For example, a servlet might need periodic flushing for low traffic times.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I still find that a bit dubious. You&apos;re saying you have a servlet thread that is writing something to an HTable, but you do not really care whether those changes actually makes it into HBase? (that&apos;s what you&apos;re doing, if you&apos;re Put&apos;ing, but not flushing the commits)&lt;/p&gt;</comment>
                            <comment id="14256995" author="sduskis" created="Tue, 23 Dec 2014 14:16:43 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;: I guess you&apos;re right.  Online systems would probably not benefit not need to use buffered writing.  They&apos;d also want generally confirmation that the write worked.  So in the online case, it sounds like the there would need to be a way to read or write to a table without incurring the cost of establishing a connection.  To borrow a construct from the sql world, maybe the right tool there is a ConnectionPool.  Pooling Connections would give the user more flexibility than pooling Tables but with the same performance benefits.  Bulk writes can still happen through the table.put(List&amp;lt;&amp;gt;) and table.delete(List&amp;lt;&amp;gt;) methods.&lt;/p&gt;

&lt;p&gt;The ConnectionPool concept used to be available in the form of managed connections.  Managed connections have been deprecated, and I don&apos;t think that there is a recommended alternative.  I think that topic might benefit from a separate thread. &lt;/p&gt;</comment>
                            <comment id="14257165" author="sduskis" created="Tue, 23 Dec 2014 16:30:01 +0000"  >&lt;p&gt;So back to buffering writes.  FWIW, my thoughts here are more about thinking out loud about the nature of the problem than offering guidance.  I don&apos;t understand the problem well enough, and I&apos;m hoping to learn more about the nature of the need with more discussion.&lt;/p&gt;

&lt;p&gt;It sounds like one reason for buffered writes is in map/reduces into a single Table.  Specifically, map-reduces where the content of the per key is not ideal for batching through the Table.put(List&amp;lt;&amp;gt;) method.  In such a case, a single table with auto-flush turned on makes perfect sense.  TableOutputFormatBase does that, so most reduce cases are covered.  (FYI, I just checkout out Import and noticed that it does not seem to use auto-flush for some reason.)&lt;/p&gt;

&lt;p&gt;Is m/r the main reason for autoFlush?  Are there other good cases?&lt;/p&gt;</comment>
                            <comment id="14257274" author="stack" created="Tue, 23 Dec 2014 17:59:59 +0000"  >&lt;blockquote&gt;&lt;p&gt;FWIW, my thoughts here are more about thinking out loud about the nature of the problem than offering guidance.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Pardon us if our reaction appeared to not understand that this was the case.  Your &apos;outside&apos; perspective has been refreshing up to this. Please do not suppress your &apos;thoughts&apos; because our response on occasion is basic.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Is m/r the main reason for autoFlush? Are there other good cases?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Stating the obvious, autoflush makes sense anytime the writes are small and many; it especially makes sense when there is no natural flush point. In the m/r case, when-to-flush could be done inside the m/r externally as opposed to the autoFlush intrinsic, but it gets a little more complicated in your servlet case. Presuming many small writes by many threads, it makes sense that the Table instance figures when to flush (size or period).  Could create a (thread-safe) Table on servlet init (or a pool) and on destroy, do a flush/close of the Table instance (or pool).&lt;/p&gt;

&lt;p&gt;I don&apos;t think the ConnectionPool concept from sql-world maps well to ours where many servers are involved rather than one. Or, in our world, a ClusterConnection sort of equates to ConnectionPool since the ClusterConnection will put up and cache a Connection per server in the cluster (true, we might get more throughput if more than one connection per server in the cluster but that I think an implementation detail rather than a modeling item).&lt;/p&gt;

&lt;p&gt;I suggest that to answer the problem raised by &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=abeppu&quot; class=&quot;user-hover&quot; rel=&quot;abeppu&quot;&gt;Aaron Beppu&lt;/a&gt;, that we add back a TablePool (&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt; &amp;#8211; you think this a regression?) and a thread-safe version of Table with the Table instance responsible for write buffer (we could add flushing on a period to the pool and as an option on the thread-safe Table in another issue)? I can work on this if agreement.&lt;/p&gt;
</comment>
                            <comment id="14257303" author="sduskis" created="Tue, 23 Dec 2014 18:25:42 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt; In the servlet case, does it simply make sense to create a new Table for every request?  Is Table creation cheap once the Connection is created?  If creating Tables is expensive, then TablePool makes sense; if not, then it&apos;s probably easier to simply create a new Table for each request.&lt;/p&gt;</comment>
                            <comment id="14257332" author="sduskis" created="Tue, 23 Dec 2014 18:45:48 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=abeppu&quot; class=&quot;user-hover&quot; rel=&quot;abeppu&quot;&gt;Aaron Beppu&lt;/a&gt; What&apos;s the use case that you&apos;re trying to solve?  Is it an online system or a batch system?  I&apos;m trying to wrap my head around the need for both a TablePool and autoflush simultaneously.&lt;/p&gt;</comment>
                            <comment id="14257352" author="stack" created="Tue, 23 Dec 2014 18:55:34 +0000"  >&lt;blockquote&gt;&lt;p&gt;In the servlet case, does it simply make sense to create a new Table for every request?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not when Table owns the write buffer because then a new Table per request will mean a flush/rpc per request when we close the Table when request processing is done.&lt;/p&gt;</comment>
                            <comment id="14257393" author="carterpage" created="Tue, 23 Dec 2014 19:23:53 +0000"  >&lt;p&gt;So I&apos;ve been back and forth on this and have come to the same conclusion as &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt;.  I&#8217;ll even be a little more blunt and assert that auto-flush is categorically bad.  It leads to an illusion of free speed gains when, in fact, you sacrifice durability guarantees, a basic tenet of a database.&lt;/p&gt;

&lt;p&gt;If a user makes a decision to sacrifice durability for speed, that can be done without help from the HBase client.  Create a thread-safe object wrapping two lists, one for buffering, and one for updating.  That object manages a thread that gets triggered with the collection reaches a certain length or when a timeout expires, at which point it moves the buffered list into the update list and submits the batch.&lt;/p&gt;

&lt;p&gt;If this is a common enough use case, then HBase could even package this as a utility for those who need it.  Something like this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class PutBuffer {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; PutBuffer(ConnectionFactory connectionFactory) {&#8230;}
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void setFlushTimeout(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; millis) {&#8230;}
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; getFlushTimeout() {&#8230;}
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void addPut(TableName table, Put put) {&#8230;}
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void flush() {&#8230;}
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But putting this as first-class functionality baked into the client itself is inherently confusing (&#8220;where did my writes go when the servlet crashed?&#8221;) and adds a lot of unnecessary complexity to the critical write path.  It&apos;s a complex-enough system already.  Keep it simple wherever possible.&lt;/p&gt;

&lt;p&gt;My $0.02.&lt;/p&gt;</comment>
                            <comment id="14257764" author="carterpage" created="Wed, 24 Dec 2014 01:12:30 +0000"  >&lt;p&gt;If my previous comment seems a little heavy-handed, a less radical approach may be the earlier suggestion of a buffered delegator.  &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=enis&quot; class=&quot;user-hover&quot; rel=&quot;enis&quot;&gt;Enis Soztutar&lt;/a&gt; points out above that the client is already buffered, but my argument is 1) that&apos;s not the best place for this relatively heavy logic, and 2) Java&apos;s polymorphism makes it quite easy to extend the core behavior without baking it into a single mega-class.  The new interfaces actually make this fairly simple.  And most importantly, a user won&apos;t need to change any code except at instantiation.&lt;/p&gt;

&lt;p&gt;We could create a class called BufferedTable that implements Table and delegates to an underlying Table instance.  We surface the buffer-related methods from the core client here.  Something like this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
/**
 * Javadoc here warning about the possibility of losing writes on client crash.
 *
 * Also, emphasize the need to always close, probably inside a &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt;{}.
 **/
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class BufferedTable &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; Table {
    &lt;span class=&quot;code-comment&quot;&gt;// This constructor will be familiar &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; people who know BufferedWriter
&lt;/span&gt;    pubic BufferedTable(Table table) {...}  

    &lt;span class=&quot;code-comment&quot;&gt;// All methods except Put pass through.  Put calls a singleton that handles buffering.
&lt;/span&gt;    ...

    &lt;span class=&quot;code-comment&quot;&gt;// Remove setAutoFlush and isAutoFlush since that&apos;s implicit in using &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; class.
&lt;/span&gt;    /* snip */

    &lt;span class=&quot;code-comment&quot;&gt;// Change these to statics since they need to talk to an underlying singleton.
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void flushCommits() {...}
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void setWriteBufferSize(&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; writeBufferSize) {...}

    &lt;span class=&quot;code-comment&quot;&gt;// Maybe use reference counting here to force a flush on the last close.
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void close();
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14257936" author="stack" created="Wed, 24 Dec 2014 04:08:56 +0000"  >&lt;blockquote&gt;&lt;p&gt;It leads to an illusion of free speed gains when, in fact, you sacrifice durability guarantees, a basic tenet of a database.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah it does that. We should put this in flashing lights in the autoFlush javadoc.  Folks will still want to buffer up writes though, in spite of the dangers.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If this is a common enough use case, then HBase could even package this as a utility for those who need it. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It is a common use case and yes, we should have it as utillity.  Up to this the utility has been in the Table implementation but the suggestion is that doing it this way &quot;..is inherently confusing &quot;.&lt;/p&gt;

&lt;p&gt;For your PutBuffer strawman, in a multithreaded context &amp;#8211; e.g. servlet &amp;#8211; where each thread does small writes, PutBuffer would have to be threadsafe.  You&apos;d create it at the start of your map task or if a servlet, on servlet init, and keep it around until the map task was done, or servlet destroyed?&lt;/p&gt;

&lt;p&gt;You like it because it makes the buffering distinct, apart from Table? This could work.&lt;/p&gt;

&lt;p&gt;On your less radical BufferedTable, again, we&apos;d need it threadsafe &amp;#8211; or a threadsafe version &amp;#8211; or else a pool of BufferedTables.  This could work also; would be closer to what we currently have.&lt;/p&gt;

&lt;p&gt;For both proposals, it sounds like Table would change to immediately flush any puts; it would no longer keep any running buffer.&lt;/p&gt;</comment>
                            <comment id="14258665" author="lhofhansl" created="Thu, 25 Dec 2014 07:24:10 +0000"  >&lt;p&gt;I do apologize if came across as not understanding. It&apos;s that we&apos;re using HBase a lot in batch and non-batch scenarios, and I never find autoflush helpful. We always build up a list of puts - that would be the write buffer, and write that list to HBase and continue when that is successful.&lt;/p&gt;

&lt;p&gt;The only useful case for autoflush I can think off is the scenario stack outlines above: You have a large body of data to write to HBase in a restartable way. In that case you want trickle data to HBase in chunks most optimal for HBase. So you &quot;stream&quot; the data to an HTable instance, and force a flush only in the end. If anything goes wrong you restart the entire job.&lt;br/&gt;
So, yeah, I&apos;d say that M/R is one of the few usecases for this, and even there it&apos;s mostly for API convenience.&lt;/p&gt;

&lt;p&gt;It&apos;s quite possible that I am biased, it was me who suggested the API change, which let&apos;s us manage a connection to a cluster as a durable thing, and uses HTable as cheap proxies to tables only.&lt;/p&gt;

&lt;p&gt;I was just going to suggest a special implementation of HTable that does the buffering in a threadsafe way and remove any buffering form the current implementations... And saw that &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=carterpage&quot; class=&quot;user-hover&quot; rel=&quot;carterpage&quot;&gt;Carter&lt;/a&gt; beat me to it.&lt;/p&gt;</comment>
                            <comment id="14259514" author="abeppu" created="Sat, 27 Dec 2014 23:06:44 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt; Sorry, was offline for the holidays. Our use case is an online system. Our clients send us a steady stream of data points, which drive our ML system. Because our clients mostly benefit from the aggregate experience of our ML system, it&apos;s acceptable to us if some small minority of writes are lost, though naturally we&apos;d prefer that loss to be zero or negligible. So currently each individual handler uses the HTablePool to acquire a table, and &quot;writes&quot; to it, and we set autoflush to false such that only a minority of those &quot;writes&quot; actually triggers a flush.&lt;/p&gt;

&lt;p&gt;Honestly, I could be convinced that this choice on our part was misguided, but I would hasten to point out that there exists &quot;blessed&quot; documentation &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; which explicitly advises setting autoflush to false when handling a large write volume.&lt;/p&gt;

&lt;p&gt;It would certainly be possible for us to manage our own write buffer. Similarly, it would be possible for us to manage our own table pool. In either case, in our migration (from 0.94 to 0.98.6), we&apos;re replicating some functionality which was previously part of hbase-client.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; SS 14.8.4 &lt;a href=&quot;http://hbase.apache.org/book/perf.writing.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hbase.apache.org/book/perf.writing.html&lt;/a&gt; &lt;/p&gt;</comment>
                            <comment id="14260086" author="carterpage" created="Mon, 29 Dec 2014 12:54:25 +0000"  >&lt;p&gt;We probably don&apos;t want to remove write buffering wholesale from HBase, since some users understand the trade-offs and still count on it.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=abeppu&quot; class=&quot;user-hover&quot; rel=&quot;abeppu&quot;&gt;Aaron Beppu&lt;/a&gt;, if we provided a BufferedTable with signatures as I described above, would that work for you?  Some details around lifecycle management for the underlying buffer still need to be worked out, but functionally you would be able to invoke it like a normal Table.&lt;/p&gt;</comment>
                            <comment id="14260152" author="sduskis" created="Mon, 29 Dec 2014 15:18:07 +0000"  >&lt;p&gt;A BufferedTable implementation seems to me to imply a change in the Table interface.  If the buffering logic is an implementation detail for some implementation of Table, does that imply that the Table interface should not have any autoflush related methods on it?&lt;/p&gt;</comment>
                            <comment id="14260239" author="abeppu" created="Mon, 29 Dec 2014 17:23:39 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=carterpage&quot; class=&quot;user-hover&quot; rel=&quot;carterpage&quot;&gt;Carter&lt;/a&gt; Yes, a BufferedTable, with the signatures you described above, and either of the properties that &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt; described would work for us.&lt;/p&gt;</comment>
                            <comment id="14260547" author="lhofhansl" created="Mon, 29 Dec 2014 23:37:18 +0000"  >&lt;p&gt;If we do not want an API change for the existing interface we can invent a &quot;LightweightTable&quot; or &quot;UnbufferedTable&quot;. But I&apos;d prefer BufferedTable as a new interface.&lt;br/&gt;
Too late for 1.0? &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=enis&quot; class=&quot;user-hover&quot; rel=&quot;enis&quot;&gt;Enis Soztutar&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="14260911" author="apurtell" created="Tue, 30 Dec 2014 08:21:36 +0000"  >&lt;p&gt;My 0.02, it shouldn&apos;t be too late for 1.0. Table is a fundamental API and we should get it right for a 1.0 release. Let things slip if need be IMHO&lt;/p&gt;</comment>
                            <comment id="14260920" author="apurtell" created="Tue, 30 Dec 2014 08:38:07 +0000"  >&lt;p&gt;FWIW, I recently rewrote the YCSB client for HBase because it was setting auto flush to off and using large write buffers to collect puts. Unfortunately although producing &apos;excellent&apos; write latency measurements this lead to multiple threads flushing deep buffers more or less at the same time, resulting in long periods of write unavailability. I&apos;m sure that was an unintended consequence. I believe that YCSB client code was written by HBase devs. An earlier era in any case, but my point is devs very familiar with the API can get into trouble never mind newcomers. Removing buffering from Table and moving it into BufferedTable with suitable advice in javadoc there sounds like a good idea to me. &lt;/p&gt;</comment>
                            <comment id="14261147" author="sduskis" created="Tue, 30 Dec 2014 15:13:52 +0000"  >&lt;p&gt;Is HTableMultiplexer a good existing solution to replace the functionality of HTable without autoflush?&lt;/p&gt;</comment>
                            <comment id="14261316" author="carterpage" created="Tue, 30 Dec 2014 18:11:58 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt; and I have been discussing this offline for a couple of days and have come up with the following proposal.  It will require a few JIRA sub-tasks, but it&apos;s probably only a week&apos;s worth of work, plus reviews.  In a nutshell:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;Deprecate autoFlush methods (ie Put buffering) in &lt;tt&gt;HTable&lt;/tt&gt;&lt;/li&gt;
	&lt;li&gt;Remove all autoFlush methods from &lt;tt&gt;Table&lt;/tt&gt;&lt;/li&gt;
	&lt;li&gt;Create &lt;tt&gt;BufferedTable&lt;/tt&gt; (outlined below), which will buffer Puts using &lt;tt&gt;HTableMultiplexer&lt;/tt&gt;&lt;/li&gt;
	&lt;li&gt;Create &lt;tt&gt;BufferedConnection&lt;/tt&gt; as a new factory class&lt;/li&gt;
	&lt;li&gt;Have &lt;tt&gt;HTableMultiplexer&lt;/tt&gt; implement &lt;tt&gt;Closeable&lt;/tt&gt; (just fixing bad behavior)&lt;/li&gt;
	&lt;li&gt;&lt;em&gt;Behavior change&lt;/em&gt;: &lt;tt&gt;HTableMultiplexer&lt;/tt&gt; flushes Puts by having &lt;tt&gt;FlushWorker&lt;/tt&gt; threads...
	&lt;ul&gt;
		&lt;li&gt;&lt;em&gt;OLD&lt;/em&gt;: implement low-level logic against &lt;tt&gt;AsyncProcess&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;em&gt;NEW&lt;/em&gt;: call &lt;tt&gt;Table#put&amp;lt;List&amp;lt;Put&amp;gt;&amp;gt;&lt;/tt&gt;, thus removing duplicate code and improving encapsulation&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;em&gt;Behavior change&lt;/em&gt;: When its queue is full, &lt;tt&gt;HTableMultiplexer&lt;/tt&gt;...
	&lt;ul&gt;
		&lt;li&gt;&lt;em&gt;OLD&lt;/em&gt;: immediately rejects all Puts&lt;/li&gt;
		&lt;li&gt;&lt;em&gt;NEW&lt;/em&gt;: blocks for a configurable time in ms (can be 0) before rejecting Puts&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;em&gt;Behavior change&lt;/em&gt;: When an async Put fails...
	&lt;ul&gt;
		&lt;li&gt;&lt;em&gt;OLD&lt;/em&gt;: the exception is thrown during a unrelated future Put operation (confusing)&lt;/li&gt;
		&lt;li&gt;&lt;em&gt;NEW&lt;/em&gt;: an exception is sent to the a listener provided by the client, following the Observer pattern&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;These are the new classes:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class BufferedConnection &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; Connection {
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; Connection c;
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; HTableMultiplexer htm;

    /* If listener is &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, will log but won&apos;t notify an async exceptions */
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; BufferedConnection(Connection c, ExceptionListener l) {
        &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.c = c;
        &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.htm = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HTableMultiplexer(..., c, l);
    }
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; BufferedTable getTable(TableName tn) {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; BufferedTable(c.getTable(tn), htm);
    }

    /* getAdmin() and getRegionLocator(...) methods delegate to Connection */
}

&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class BufferedTable &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; Table {
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; Table t;
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; HTableMultiplexer htm;

    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; BufferedTable(Table t, HTableMultiplexer htm) { ... }

    /* Puts go to htm.doPut(...), all methods delegate to t */
}

&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; ExceptionListener {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void onException(RetriesExhaustedWithDetailsException e);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;From a user standpoint it looks like this:&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Before&lt;/b&gt;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Connection conn = ConnectionFactory.createConnection();
Table t = conn.getTable(TableName.valueOf(&lt;span class=&quot;code-quote&quot;&gt;&quot;mytable&quot;&lt;/span&gt;));
t.setAutoFlushTo(&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;);

/* &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; stuff */

t.close();
conn.close();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;b&gt;After&lt;/b&gt;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Connection conn = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; BufferedConnection(ConnectionFactory.createConnection());
Table t = conn.getTable(TableName.valueOf(&lt;span class=&quot;code-quote&quot;&gt;&quot;mytable&quot;&lt;/span&gt;));

/* &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; stuff */

t.close();
conn.close();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In essence, a few new classes, a moderate amount of work in HTableMultiplexer, and a few deprecation annotations in HTable.  Let us know if this looks acceptable and we&apos;ll create some subtasks and make it so.&lt;/p&gt;</comment>
                            <comment id="14261628" author="stack" created="Tue, 30 Dec 2014 23:16:44 +0000"  >&lt;p&gt;A few comments:&lt;/p&gt;

&lt;p&gt;Its &lt;b&gt;pretty&lt;/b&gt; the way it acts the way you add buffering to io classes.&lt;/p&gt;

&lt;p&gt;HTableMultiplexer should no longer be first-class object?  You would change its nature (and besides, it doesn&apos;t work w/ the new Connection/Table idiom).  Deprecate it so can make it package private?  Or deprecate and do a new version of HTM and call it something else?  TM?&lt;/p&gt;

&lt;p&gt;An HTM also allows you write any table &amp;#8211; you pass table name when you do the put &amp;#8211; but in your implementation this would not be so.&lt;/p&gt;

&lt;p&gt;When I call t.close, what happens?  Do we flush the buffer?  Or we don&apos;t flush till connection.close is called?&lt;/p&gt;

&lt;p&gt;Thread-safe putting?&lt;/p&gt;

&lt;p&gt;Why expose, make public, BufferedTable at all?  That new constructor which takes table a HTM and a Table is only for BufferedConnection to use?&lt;/p&gt;

&lt;p&gt;How will configuration be done (sizing of buffers and when to flush?)&lt;/p&gt;

&lt;p&gt;Thanks for doing this lads.  It looks great.&lt;/p&gt;</comment>
                            <comment id="14261629" author="stack" created="Tue, 30 Dec 2014 23:17:34 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=abeppu&quot; class=&quot;user-hover&quot; rel=&quot;abeppu&quot;&gt;Aaron Beppu&lt;/a&gt;, the &apos;customer&apos;, it would be cool if you had a sec to chime in on the lads nice proposal. Thanks.&lt;/p&gt;</comment>
                            <comment id="14261636" author="eclark" created="Tue, 30 Dec 2014 23:24:20 +0000"  >&lt;blockquote&gt;&lt;p&gt;Is HTableMultiplexer a good existing solution to replace the functionality of HTable without autoflush?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No. It was first used to speed up puts across multiple connections and multiple tcp streams for things that value speed over correctness. There&apos;s no way to check on which puts fail and which succeed.&lt;/p&gt;

&lt;p&gt;IMO it shouldn&apos;t be recommended. I would even go so far as to say that it&apos;s use should be discouraged.&lt;/p&gt;</comment>
                            <comment id="14261675" author="ndimiduk" created="Tue, 30 Dec 2014 23:57:13 +0000"  >&lt;p&gt;I&apos;ve asked multiple times; I don&apos;t think HTableMultiplexer is in common use and should be deprecated/discarded.&lt;/p&gt;

&lt;p&gt;I like &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=carterpage&quot; class=&quot;user-hover&quot; rel=&quot;carterpage&quot;&gt;Carter&lt;/a&gt;&apos;s outline from the user&apos;s perspective. It follows &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=enis&quot; class=&quot;user-hover&quot; rel=&quot;enis&quot;&gt;Enis Soztutar&lt;/a&gt;/&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt;&apos;s idea of a decorator/wrapper to explicitly handle buffering. My two critiques:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;don&apos;t depend on HTableMultiplexer; implement the buffering for a single table and give us a chance to offer better default semantics around buffer capacity.&lt;/li&gt;
	&lt;li&gt;is a BufferedConnection really necessary? The connection isn&apos;t buffering, it&apos;s just handing back the same BufferedTable instance to each caller, correct? That makes for little/no code change for a consumer to convert to the buffered implementation, but I think that isn&apos;t idea. Better to have the decorator accept the Table instance (or TableName + Connection instance?) and allow for setting up buffers/queues/&amp;amp;c for async flushing.&lt;/li&gt;
&lt;/ol&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Connection conn = ConnectionFactory.createConnection();
BufferedTable t = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; BufferedTable(conn, TableName.valueOf(&lt;span class=&quot;code-quote&quot;&gt;&quot;myTable&quot;&lt;/span&gt;));
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;or &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
ExecutorService pool = Executors.newFixedThreadPool(poolSize);
Queue&amp;lt;Put&amp;gt; workQueue = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ArrayBlockingQueue(100);
BufferedTable t = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; BufferedTable(conn, TableName.valueOf(&lt;span class=&quot;code-quote&quot;&gt;&quot;myTable&quot;&lt;/span&gt;), pool, workQueue);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14261697" author="abeppu" created="Wed, 31 Dec 2014 00:18:52 +0000"  >&lt;p&gt;I like the API exposed to the user of having a BufferedConnection + BufferedTable that can be swapped in so easily.&lt;/p&gt;

&lt;p&gt;The tricky part that I as a user would be cautious of is that since HTableMultiplexer maintains a different buffer for each region server, the timing at which flushes happen, and the age of writes by the time they get flushed will be slightly more complicated to reason about than with the buffer-per-table model.&lt;/p&gt;

&lt;p&gt;Here are example differences that I would bear in mind while auditing our use of buffered writes to predict the impacts of migrating to this idiom:&lt;/p&gt;

&lt;p&gt;1. With the buffer-per-table model, the time-in-buffer for a given write was roughly just HTablePoolSize * writeBufferSize / (writes per second). With the buffer-per-regionserver model used by HTM, if writes aren&apos;t uniformly distributed over the region servers for whatever reason, writes going to &quot;cold&quot; regionservers will live in buffer for longer than writes going to &quot;hot&quot; region servers.&lt;/p&gt;

&lt;p&gt;2. With the buffer-per-table model, time-in-buffer for writes to table A was independent of stuff happening on table B (so long as we don&apos;t totally overwhelm the cluster or something). With the HTM model, a decrease in write volume to table B can increase my time-in-buffer for table A. We may choose to have separate BufferedConnections with separate HTM instances specifically to avoid this.&lt;/p&gt;

&lt;p&gt;3. Even if I just want to migrate my system onto this idiom without changing the number or size of flushes then I&apos;d want to pick HTableMultiplexer.perRegionServerBufferQueueSize such that &lt;br/&gt;
perRegionServerBufferQueueSize * (# of region servers) ~= HTable.writeBufferSize * (average size of HTablePool)&lt;br/&gt;
The only thing that&apos;s weird about that is that (# of region servers) changes over time. I.e. if today I pick reasonable buffer sizes for HTM, then in 6 months, if the incoming write rate is unchanged but the cluster is larger due to data growth, my time-in-buffer will have increased.&lt;/p&gt;

&lt;p&gt;From just the API described, I think the proposal above looks really clean. From the perspective of someone operating a system where using HTablePool + buffered writes was a calculated risk, the HTM-driven buffering sounds workable, but it opens the door for a range of new variables to influence our system&apos;s core write pathways, and for that reason I&apos;d be cautious adopting it.&lt;/p&gt;</comment>
                            <comment id="14261816" author="enis" created="Wed, 31 Dec 2014 02:36:17 +0000"  >&lt;blockquote&gt;&lt;p&gt;Too late for 1.0?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;No, the 1.0.0RC0 already sank for a different reason. I was planning on doing the next RC after new years, but agreed that we can wait for getting it right before 1.0. &lt;/p&gt;</comment>
                            <comment id="14262718" author="sduskis" created="Fri, 2 Jan 2015 02:30:56 +0000"  >&lt;blockquote&gt;&lt;p&gt;2. is a BufferedConnection really necessary? The connection isn&apos;t buffering, it&apos;s just handing back the same BufferedTable instance to each caller, correct? That makes for little/no code change for a consumer to convert to the buffered implementation, but I think that isn&apos;t idea. Better to have the decorator accept the Table instance (or TableName + Connection instance?) and allow for setting up buffers/queues/&amp;amp;c for async flushing.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Are HTable.delete(), .batch(), coprocessorService() and others thread-safe?  If not, then in the multithreaded case, we likely need to create new (or a pooled) BufferredTable per thread.  The &quot;BufferredConnection&quot; would perform that functionality.  We could implement it as a group of BufferTables that use the same underlying write buffer.&lt;/p&gt;</comment>
                            <comment id="14263110" author="carterpage" created="Fri, 2 Jan 2015 18:26:08 +0000"  >&lt;p&gt;Okay, here&apos;s another pass, scratching out the HTableMultiplexer idea.  Instead we&apos;ll create a new class called &lt;tt&gt;AsyncPutter&lt;/tt&gt;. (Not a huge fan of the name, so if you have a better one, please share.)&lt;/p&gt;

&lt;p&gt;First off, here are our basic requirements in this refactor:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Handle the M/R case where a user wants to batch and flush in a single thread&lt;/li&gt;
	&lt;li&gt;Handle the case Aaron described where we batch across multiple threads&lt;/li&gt;
	&lt;li&gt;Provide a way to do this through the new Table interface for convenience&lt;/li&gt;
	&lt;li&gt;Buffering/batching limits based on size in bytes, not queue length&lt;/li&gt;
	&lt;li&gt;Move towards &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt;&apos;s suggestion of &quot;HTable as cheap proxies to tables only&quot;&lt;/li&gt;
	&lt;li&gt;While durability can&apos;t be guaranteed in case of a crash, avoid losing data otherwise.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;So here are our classes:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// BufferedTable is lightweight and single-threaded.  Many of them can share a single AsyncPutter.
&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class BufferedTable &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; Table {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; BufferedTable(Table t, AsyncPutter ap);
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void flush();
}

&lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-safe handler of puts &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; one or more BufferedTable instances.
&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class AsyncPutter &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; Closeable {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; AsyncPutter(Connection c, ExecutorService pool, ExceptionListener e, PutBuffer pb);
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; add(Put put);  &lt;span class=&quot;code-comment&quot;&gt;// Synchronization adds nanoseconds in the single-threaded &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt;.  No biggie.
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; flush();
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; close();
}

&lt;span class=&quot;code-comment&quot;&gt;// Simple single-threaded data holder.
&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class PutBuffer {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; PutBuffer(&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; maxBufferSize);  &lt;span class=&quot;code-comment&quot;&gt;// In bytes.  This makes more sense than queue length &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; memory management.
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// maxBufferSize = totalBufferMem / numberOfExecutorPoolThreads
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void add(Put p);
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; isBatchAvailable();
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;Put&amp;gt; removeBatch();
}

&lt;span class=&quot;code-comment&quot;&gt;// To make sure exceptions don&apos;t get swallowed.
&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; ExceptionListener {
    void onException(RetriesExhaustedWithDetailsException e);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We also proposed a &lt;tt&gt;BufferedConnection&lt;/tt&gt; factory, simply to make it easier to switch between Table and BufferTable implementations without much refactoring.  When used, it would own the AsyncPutter.  Pros/cons for this idea?  It&apos;s not essential.&lt;/p&gt;

&lt;p&gt;Asynchronous exception handling takes place through an &lt;tt&gt;ExceptionListener&lt;/tt&gt; observer provided by the user.  This means that exceptions are not thrown for simple put failures; they are passed to the listener.  The thought here is I find the current behavior non-deterministic:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
table.put(put1);  &lt;span class=&quot;code-comment&quot;&gt;// This put causes an exception
&lt;/span&gt;table.put(put2);  &lt;span class=&quot;code-comment&quot;&gt;// But we don&apos;t see the exception until we get here ...
&lt;/span&gt;table.put(put3);  &lt;span class=&quot;code-comment&quot;&gt;// ... or maybe(?) here.  put3 succeeded, but I got an exception thrown.  That&apos;s counter-intuitive.&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;An ExceptionListener is a pretty standard pattern for asynchronous error handling.  M/R or other cases might rely on an exception being thrown synchronously to rollback appropriately, but it&apos;s easy enough to mimic that behavior with the listener approach.&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;BufferedTable#close&lt;/tt&gt; does not flush since we need to support batching across multiple threads.  &lt;tt&gt;AsyncPutter#close&lt;/tt&gt; does flush.  (Will JavaDoc this.)  If we decide to provide a BufferedConnection, then closing that would also flush, since it owns the AsyncPutter.&lt;/p&gt;

&lt;p&gt;Do we need a timeout-based flush?  I don&apos;t see one in the current HTable implementation, but if it&apos;s important we could add it to the AsyncPutter.  Seems a good way to limit lost mutations during slow periods of writes into a big buffer.&lt;/p&gt;</comment>
                            <comment id="14265273" author="sduskis" created="Mon, 5 Jan 2015 22:55:44 +0000"  >&lt;p&gt;Issue &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12728&quot; title=&quot;buffered writes substantially less useful after removal of HTablePool&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12728&quot;&gt;&lt;del&gt;HBASE-12728&lt;/del&gt;&lt;/a&gt; seems to suggest that setAutoFlushTo(), flushCommits() and etc. should be removed from Table.  &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12802&quot; title=&quot;Remove unnecessary Table.flushCommits()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12802&quot;&gt;&lt;del&gt;HBASE-12802&lt;/del&gt;&lt;/a&gt; cleans up some currently unnecessary calls to flushCommits() which is a precursor to a new buffering solution.&lt;/p&gt;</comment>
                            <comment id="14265279" author="yuzhihong@gmail.com" created="Mon, 5 Jan 2015 22:59:55 +0000"  >&lt;p&gt;For AsyncPutter, please consider adding:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; add(List&amp;lt;Put&amp;gt; puts);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14265393" author="lhofhansl" created="Tue, 6 Jan 2015 00:13:37 +0000"  >&lt;p&gt;I think for BufferedHTable is essential that the buffering is thread safe to avoid confusing. (unbuffered) HTable then should naturally be thread safe as it does not need to maintain any internal state, right?&lt;/p&gt;</comment>
                            <comment id="14266961" author="enis" created="Tue, 6 Jan 2015 23:31:29 +0000"  >&lt;p&gt;I think API wise, what Carter proposes above makes sense with a couple of comments. &lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I think &lt;tt&gt;BufferedTable&lt;/tt&gt; should be an interface still with &lt;tt&gt;flush()&lt;/tt&gt; or &lt;tt&gt;flushCommits()&lt;/tt&gt; method.&lt;/li&gt;
	&lt;li&gt;&lt;tt&gt;ExceptionListener&lt;/tt&gt; should also get the original &lt;tt&gt;Put&lt;/tt&gt; so that it can learn about which operation has failed (not just the exception).&lt;/li&gt;
	&lt;li&gt;Do we want AsyncPutter, etc to be client-public API at all? I like the &lt;tt&gt;BufferedConnection&lt;/tt&gt; route where we can have getBufferedTable() method to construct this and not worry about any class. However do we want to address doing puts() with flush and doing async flush by the same client? Does the client maintain two Connection objects?&lt;/li&gt;
	&lt;li&gt;Should the interfaces be &lt;tt&gt;Put&lt;/tt&gt; based or &lt;tt&gt;Mutation&lt;/tt&gt; based? We can make it generic in case of we add Delete&apos;s later on, but may not be worth the extra cost.&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;BufferedTable#close does not flush since we need to support batching across multiple threads. AsyncPutter#close does flush. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Seems a bit unintuitive. If we do the BufferedConnection route, the only way to flush everything is to &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Do we need a timeout-based flush?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;It makes sense, but this can be added later I say. &lt;/p&gt;</comment>
                            <comment id="14267060" author="ndimiduk" created="Wed, 7 Jan 2015 00:24:14 +0000"  >&lt;p&gt;I agree with &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=enis&quot; class=&quot;user-hover&quot; rel=&quot;enis&quot;&gt;Enis Soztutar&lt;/a&gt; that hiding AsyncPutter and PutBuffer behind BufferedConnection makes better sense. Also that BufferedTable should be an interface, and that all these API&apos;s should accept Mutation as the argument, not Put.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt;&apos;s question is interesting. Is your meaning for BufferedTable&apos;s to be lightweight like Tables? Or does BufferedTable become the shared object, like the current Connection is? I think we want the former, not the latter.&lt;/p&gt;

&lt;p&gt;AsyncPutter looks a lot like HTable&apos;s internal AsyncProcess. How are these classes related/shared? Re-implementing all this work seems a waste, though AsyncProcess jumps through some hoops to maintain some semblance of backward compatibility with 0.94 semantics.&lt;/p&gt;

&lt;p&gt;Calling BufferedTable.flush() forces a flush of the contents of the PutBuffer, does it block the calling thread, or is it asynchronous?&lt;/p&gt;

&lt;p&gt;In the event of a BufferedTable that does not share it&apos;s PutBuffer with any other instances, can it just defer back to the current implementation in HTable?&lt;/p&gt;

&lt;p&gt;Isn&apos;t PutBuffer just an implementation detail for communication between the BufferedTableImpls and AsyncPutter? Shouldn&apos;t it be a BlockingQueue or some such, that can be drained in the background and allow some rate-limiting?&lt;/p&gt;</comment>
                            <comment id="14267096" author="stack" created="Wed, 7 Jan 2015 01:00:18 +0000"  >&lt;p&gt;Feedback.&lt;/p&gt;

&lt;p&gt;On AsyncPutter, will we ever want to buffer Increments or Appends or Deletes (Increments we might want to aggregate client-side but that is something different from AsyncPutter i suppose); if so, AsyncMutator instead? (An uglier name!).&lt;/p&gt;

&lt;p&gt;Async is probably good to have in the name since it conveys detachment between invocation and when the op actually happens but on other hand, we could just call it Buffer&amp;lt;Put&amp;gt; or recast the PutBuffer you have above and do away with an extra moving part?&lt;/p&gt;

&lt;p&gt;Ditto, do we even need to expose BufferedTable? Just add to Connection a #getTable(TableName, PutBuffer) that takes a PutBuffer &amp;#8211; the implementation behind the scenes would use the passed PutBuffer. I suppose this would mean you&apos;d have to ask Connection for a PutBuffer instance (Connection#getPutBuffer(maxsize, executor) or maybe this is just where your BufferedConnection comes in; it adds these methods.&lt;/p&gt;

&lt;p&gt;Having the PutBuffer detached from Table is clean but what is to prevent me adding a Put for TableA to TableB&apos;s PutBuffer?  There&apos;d be no protection against this? (That&apos;d probably be fine)&lt;/p&gt;

&lt;p&gt;The flush on BufferedTable is a noop, right?&lt;/p&gt;

&lt;p&gt;BufferedTable shouldn&apos;t have a close if its not going to do anything?&lt;/p&gt;

&lt;p&gt;The ExceptionListener seems good but should it supply more info than just the exception? For example, where we are in the processing of the buffer &amp;#8211; what edits have succeeded and which have failed (or would that just be TMI?)&lt;/p&gt;

&lt;p&gt;Good stuff &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=carterpage&quot; class=&quot;user-hover&quot; rel=&quot;carterpage&quot;&gt;Carter&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14267164" author="lhofhansl" created="Wed, 7 Jan 2015 01:48:07 +0000"  >&lt;blockquote&gt;&lt;p&gt;Is your meaning for BufferedTable&apos;s to be lightweight like Tables? Or does BufferedTable become the shared object, like the current Connection is? I think we want the former, not the latter.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think I meant the latter. The discussion started by saying that we need some kind of shared space to buffer edits across threads of a web container.&lt;br/&gt;
It&apos;s possible I misunderstood, and in any case we can say the caller is responsible for thread safety.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The flush on BufferedTable is a noop, right?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Why? I was thinking BufferedTable would be essentially what HTable is now. And HTable would have all buffering, autoflushing, and related huh-hah removed.&lt;/p&gt;

&lt;p&gt;Personally I&apos;d favor an API where the have Connection and BufferedConnection. Both would have just a getTable(name) method. Connection.getTable(...) returns an instance of HTable, BufferedConnection.getTable(...) an instance of BufferedTable... I do not feel strongly about this, though. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="14267187" author="ndimiduk" created="Wed, 7 Jan 2015 02:19:48 +0000"  >&lt;blockquote&gt;&lt;p&gt;I was thinking BufferedTable would be essentially what HTable is now. &lt;span class=&quot;error&quot;&gt;&amp;#91;snip&amp;#93;&lt;/span&gt; Personally I&apos;d favor an API where the have Connection and BufferedConnection.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If BufferedTable is doing all the buffering that HTable currently does, but it designed to be consumed from multiple threads, what is BufferedConnection doing? It sounds like BufferedTable is pretty self-contained. Just add a Connection.getBufferedTable method.&lt;/p&gt;</comment>
                            <comment id="14267283" author="lhofhansl" created="Wed, 7 Jan 2015 05:11:53 +0000"  >&lt;p&gt;BufferedConnection would just return BufferedTables as opposed to HTables.&lt;/p&gt;</comment>
                            <comment id="14267302" author="stack" created="Wed, 7 Jan 2015 05:49:52 +0000"  >&lt;blockquote&gt;&lt;p&gt;Why? &lt;span class=&quot;error&quot;&gt;&amp;#91;The flush on BufferedTable is a noop, right?&amp;#93;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Because in the proposal, the BufferedTable is not the owner of the put buffer; it is sharing it with other BufferedTable instances.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I was thinking BufferedTable would be essentially what HTable is now.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We could do that. Its where we started. Only the BufferedTable would have to be threadsafe (which HTable is not) or we&apos;d need to add back a pool that gave out these BufferedTables. BufferedTable would not be lightweight; each would be carrying a fat buffer at least.&lt;/p&gt;

&lt;p&gt;The latest suggestion has us taking buffering out of Table and explicitly managing it separately.  Cleaner and clearer as to what is going on.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;BufferedConnection would just return BufferedTables as opposed to HTables.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If multiple threads, they&apos;d all share the one, thread-safe instance?  Could only flush the buffer when size/time limits broached or when BufferedConnection#close was called (or add BufferedConnection#flush); calls to BufferedTable#flush would have to be ignored. What happens when a thread calls #close on a shared instance? We don&apos;t want one behavior if a Table instance (i.e. create and close when done) and another when BufferedTable (don&apos;t close it!)&lt;/p&gt;</comment>
                            <comment id="14267482" author="carterpage" created="Wed, 7 Jan 2015 10:15:59 +0000"  >&lt;p&gt;Lots of great comments/questions.  Solomon can dig into some of the grittier implementation trade-offs, as this is largely his design.  I can answer some initial questions to keep the ball rolling:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;tt&gt;ExceptionListener&lt;/tt&gt; should also get the original &lt;tt&gt;Put&lt;/tt&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We were planning to return &lt;tt&gt;RetriesExhaustedWithDetailsException&lt;/tt&gt; whenever possible, which contains the Put.  That&#8217;s more consistent with calling Put synchronously.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;all these API&apos;s should accept Mutation as the argument&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Figuring that&#8217;s where we should head eventually, but doesn&#8217;t seem we need to be there immediately, right?  Probably makes sense to follow Stack&#8217;s idea and make a more general name, e.g. s/AsyncPutter/AsyncMutator/&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;AsyncPutter looks a lot like HTable&apos;s internal AsyncProcess&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, worth making sure we&#8217;re not reinventing the wheel, but also don&#8217;t want to inherit unnecessary complexity.  I&apos;ll leave this one to Solomon, and maybe it can be debated further in a patch review.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;does BufferedTable.flush() block the calling thread?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Absolutely.  It&#8217;s a way to guarantee that previous writes are persisted, when such confidence is needed.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Isn&apos;t PutBuffer just an implementation detail&#8230;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;PutBuffer is an implementation detail, and it&#8217;s probably confusing that I surfaced it in the last straw man.  Just disregard it and focus on the AsyncPutter, which is the long-lived owner of the buffered mutation mechanism and all that entails.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In the event of a BufferedTable that does not share it&apos;s PutBuffer with any other instances, can it just defer back to the current implementation in HTable?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If it makes sense to have a different AsyncPutter for single-threaded situations than multi-threaded, then I&#8217;d suggest another implementation rather than trying to make it guess for itself.  But why do you think we should have multiple implementations?  Synchronization locks should be insignificant compared to even very fast wire latencies.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;On AsyncPutter, will we ever want to buffer Increments or Appends or Deletes?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think deletes make sense.  Appends make me nervous because we&#8217;re already breaking sequence guarantees.  I think if we do a solution which supports puts, and can be extended to any other mutation, then we can decide at another time.  Using {[AsyncMutator}} as a name would hint at such extensibility.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;do we even need to expose BufferedTable?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, need it for flush(), which I described more above.&lt;/p&gt;

&lt;p&gt;Re: stack&#8217;s concern on ExceptionListener, returning RetriesExhaustedWithDetailsException should provide enough info, no?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;BufferedTable shouldn&apos;t have a close&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree, but if it implements Table, then it has to have a nop close.&lt;/p&gt;

&lt;p&gt;We&#8217;re generally still in alignment with Lars&#8217; comments.  Table implementations become lightweight.  BufferedConnection might be a bit of a misnomer, since it&#8217;s more a factory than a &#8220;buffered connection&#8221;.  But it seems easier for a developer to understand rather than minting a new factory concept.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Just add a Connection.getBufferedTable&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But Connection is an interface.  BufferedConnection is intended as an implementation of that interface, something like:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class BufferedConnection &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; Connection {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; BufferedConnection(Connection conn, ExceptionListener l);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The idea is that given any implementation of conn, BufferedConnection will wrap the encapsulated tables that are created with buffering logic.  If we put it in Connection, then we make buffering first-class functionality again, rather than extended functionality.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Because in the proposal, the BufferedTable is not the owner of the put buffer&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;BufferedTable#flush would be a synchronous pass-through to AsyncPutter#flush.  It doesn&apos;t need to own it to do so.&lt;/p&gt;

&lt;p&gt;Some more comments...&lt;/p&gt;

&lt;p&gt;Was not planning to have BufferedTable to be heavy or thread safe.  Doing that makes it less interchangeable with HTable &#8212; which is not thread safe, and would be lighter after this refactor.&lt;/p&gt;

&lt;p&gt;Basically the lifecycle revolves around the &lt;tt&gt;AsyncMutator&lt;/tt&gt;, which is the only heavy thing here.  BufferedConnection constructs and owns it, and injects the mutator into new BufferedTable objects, which will be cheap to construct.  Calling BufferedConnection#close would close AsyncMutator, which in turn would flush its buffers and shutdown its worker threads.  (And throw IllegalStateException if any other operations come through, except for another close, which should be idempotent.)&lt;/p&gt;

&lt;p&gt;There was also a question about the need for two Connection objects.  There only needs to be one Connection object, which BufferedConnection would wrap.  All operations, synchronous and asynchronous would go through it.&lt;/p&gt;</comment>
                            <comment id="14267678" author="sduskis" created="Wed, 7 Jan 2015 14:35:56 +0000"  >&lt;p&gt;I like having a separate interface for bulk writing that&apos;s accessible from a new method on Connection.  &lt;/p&gt;

&lt;p&gt;At this point, I&apos;m rethinking the AsyncPutter / BufferedTable approach.  Bulk writing asynchronously is geared to a couple of very specific cases.   Table currently has 37 methods on it, most of which will not be implemented any differently in the asynchronous use cases.  Given those two complexities, I would think that a Separation of Concerns and Keep It Simple might be best.  &lt;/p&gt;

&lt;p&gt;A BulkWriter (or BulkMutator) interface with a limited number of methods on it might work better than extending Table.  Perhaps a simplified API like this might work:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; BulkWriter {
  void put(Put p);
  void delete(Delete);
  flush();
  close();
}

&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; Connection {
  ...
  BulkWriter getBulkWriter(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; maxBufferSize [, some other configuration parameters]);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                            <comment id="14268157" author="ndimiduk" created="Wed, 7 Jan 2015 20:23:49 +0000"  >&lt;p&gt;After reviewing comments and talking this through with &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=enis&quot; class=&quot;user-hover&quot; rel=&quot;enis&quot;&gt;Enis Soztutar&lt;/a&gt;, I thought I&apos;d try working up a bare-bones patch so that we could get a feel for the user-perspective on the API. This patch (vs. branch-1.0) follows the idea of a BufferedConnection that owns the write buffers for multiple BufferedTables. BufferedTable is a lightweight, disposable class, just like Table. The implementation is messy, turning enough of HTable inside-out so as to expose the AsyncProcess and write buffer. It deviates slightly from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=carterpage&quot; class=&quot;user-hover&quot; rel=&quot;carterpage&quot;&gt;Carter&lt;/a&gt;&apos;s API in some minor details.&lt;/p&gt;

&lt;p&gt;I pursued this approach rather than &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt;&apos;s suggestion of a heavy-weight, concurrency-safe BufferedTable instance because I think trying to turn an HTable into a concurrency-safe implementation will be wrought with subtle bugs. However, maybe someone wants to take a stab at such an approach?&lt;/p&gt;</comment>
                            <comment id="14268236" author="lhofhansl" created="Wed, 7 Jan 2015 21:16:22 +0000"  >&lt;p&gt;Seems the consensus is to keep the buffer at the connection level. All good with me &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="14268294" author="sduskis" created="Wed, 7 Jan 2015 21:41:05 +0000"  >&lt;p&gt;My last proposal was to keep the buffering logic in a long lived, thread-safe object that only deals with bulk/bufferred mutations.  If a user wants buffering, then they get an instance of that object from Connection and share it across all of their requests.  This new buffered mutator should only do one thing and do it as well as possible.&lt;/p&gt;

&lt;p&gt;It would be ideal to have a clean interface that keeps HTable as it is and does not expose either the AsyncProcess or write buffer implementation details.  I think that we can get a much cleaner implementation regarding keeping internals using the BulkMutator interface I posted above.&lt;/p&gt;

&lt;p&gt;If it&apos;s ok, Can we try both the approach &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ndimiduk&quot; class=&quot;user-hover&quot; rel=&quot;ndimiduk&quot;&gt;Nick Dimiduk&lt;/a&gt; is describing above and the BulkMutator approach and weigh the pros and cons with actual implementations?&lt;/p&gt;</comment>
                            <comment id="14268304" author="enis" created="Wed, 7 Jan 2015 21:46:27 +0000"  >&lt;blockquote&gt;&lt;p&gt;A BulkWriter (or BulkMutator) interface with a limited number of methods on it might work better than extending Table. Will &lt;tt&gt;HTable&lt;/tt&gt; implement BulkWriter in case setAutoFlush() is set for backwards compat? &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I agree with Solomon on this one. Simpler interface surface seems much better. BufferedWriter/BulkWriter can live in the same level as Table/Admin, but unlike those, we can have the BufferedWriter be thread safe. Every Connection can return a bulk writer or it can just return a Table with no-op flush() which will not do the buffering. &lt;/p&gt;

&lt;p&gt;Should we have base-interfaces for &lt;tt&gt;put()&lt;/tt&gt; and &lt;tt&gt;delete()&lt;/tt&gt; so that Table and BulkWriter will share them. May not be needed. &lt;/p&gt;

&lt;p&gt;I like Nick&apos;s changes in Table and HTable as well as the example. The final patch should have an example usage like this committed.&lt;/p&gt;

&lt;p&gt;I think we can break up the work, by first committing the new API without the changes in Table (since it will make the patch much bigger with test changes). Then do a second patch to remove Table methods and fix internal usage? &lt;/p&gt;</comment>
                            <comment id="14268317" author="ndimiduk" created="Wed, 7 Jan 2015 21:52:56 +0000"  >&lt;blockquote&gt;&lt;p&gt;But why do you think we should have multiple implementations? Synchronization locks should be insignificant compared to even very fast wire latencies.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m thinking in terms of minimizing code duplication. We have to maintain support for the deprecated HTable implementation, which already implements the single-thread buffer. Following the implementation in the attached patch, maybe we have&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;public BufferedTable getBufferedTable(TableName table, UsageContext ctx, ...) {
  switch (ctx) {
    case SINGLE_THREAD {
      return new HTable(...);
    }
    case MULTI_THREAD {
      return new BufferedTableImpl(...);
    }
  }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14268418" author="ndimiduk" created="Wed, 7 Jan 2015 22:38:34 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If it&apos;s ok, Can we try both the approach Nick Dimiduk is describing above and the BulkMutator approach and weigh the pros and cons with actual implementations?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I have no issue with the BulkMutator implementation. That would be a good iteration on the patch I posted. My major concern was with maintaining BC for users of HTableInterface. I think you could isolate the goodness in BulkMutator, have HTable extend it, and be headed in the right direction.&lt;/p&gt;</comment>
                            <comment id="14268488" author="stack" created="Wed, 7 Jan 2015 23:20:28 +0000"  >&lt;p&gt;I like the BulkWriter/BulkMutator suggestion.  Seems cleanest suggestion so far (You&apos;d need to pass tablename when getting BulkWriter since we need one per Table I believer &amp;#8211; see how &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ndimiduk&quot; class=&quot;user-hover&quot; rel=&quot;ndimiduk&quot;&gt;Nick Dimiduk&lt;/a&gt; does it in his patch).&lt;/p&gt;

&lt;p&gt;On the &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ndimiduk&quot; class=&quot;user-hover&quot; rel=&quot;ndimiduk&quot;&gt;Nick Dimiduk&lt;/a&gt; direction (thanks for working up a patch boss), a few comments:&lt;/p&gt;

&lt;p&gt;+ In the multithreaded case, which thread calls the BufferedTable#flush? If all do, no buffering is going on. Is flush then called after a &apos;big&apos; put? How&apos;s that going to work when many threads? Better if flush is done internally at size/time/shutdown thresholds. It doesn&apos;t seem like a function that belongs in the BufferedTable instance.&lt;br/&gt;
+ Ditto ExceptionListener in BufferedTable. Its awkward, right?  If I register a listener on BufferedTable, internally I&apos;ll need to pass this interest to the exception handler and then remove interest when the BufferedTable goes away.&lt;br/&gt;
+ If you buy the above two points, then need for a special BufferedTable Interface goes away....but then how to listen on exceptions and how to flush? (See the last &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt; suggestion?)&lt;br/&gt;
+ I like AsyncMutator being an internal &apos;detail&apos;.&lt;br/&gt;
+ We need a BufferedConnection?  Can&apos;t we just add the few methods to Connection?  It is new in 1.0 so we&apos;d be breaking no one (though there is the issue of being able to specify an executor, at least optionally, which I see you doing in BufferedConnection constructor in the factory).&lt;br/&gt;
+ The flush on the BufferedConnection is a bit odd, yeah.  Flushes all tables?  Or there&apos;d be an override that allowed passing which table to flush?&lt;/p&gt;
</comment>
                            <comment id="14270055" author="sduskis" created="Thu, 8 Jan 2015 21:12:06 +0000"  >&lt;p&gt;This is what I had in mind for BulkMutator.  I basically moved the put functionality out of HTable and into HBulkMutator.  HTable now has-a HBulkMutator to which it delegates puts.&lt;/p&gt;

&lt;p&gt;Please note the use of Lock in HBulkMutator for synchronization purposes as well as the DoNothingLock used in HTable which is assumed to be thread-safe.  Java&apos;s Lock interface allows us to have more control over synchronization than the &quot;synchronized&quot; key word.&lt;/p&gt;</comment>
                            <comment id="14270126" author="carterpage" created="Thu, 8 Jan 2015 22:15:39 +0000"  >&lt;p&gt;I like this approach.  Rather than transparent switching of core behavior and durability/consistency guarantees based on configuration, it&apos;s explicit in the code.&lt;/p&gt;

&lt;p&gt;Not sure what others think, but I&apos;m not fond of the name BulkMutator.  I&apos;d suggest renaming it, for example, to BufferedMutator or AsyncMutator.  It&apos;s not clear at a naive glance that the class is asynchronous, or why something like batch() shouldn&apos;t be in a &quot;BulkMutator&quot;.&lt;/p&gt;</comment>
                            <comment id="14270149" author="ndimiduk" created="Thu, 8 Jan 2015 22:37:25 +0000"  >&lt;p&gt;Thanks for having a look &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In the multithreaded case, which thread calls the BufferedTable#flush? If all do, no buffering is going on. Is flush then called after a &apos;big&apos; put? How&apos;s that going to work when many threads? Better if flush is done internally at size/time/shutdown thresholds. It doesn&apos;t seem like a function that belongs in the BufferedTable instance.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I thought about this a bit, but maybe &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=abeppu&quot; class=&quot;user-hover&quot; rel=&quot;abeppu&quot;&gt;Aaron Beppu&lt;/a&gt; has other ideas. My thinking is that after a large batch of puts, before a thread exists, it wants to call BufferedTable#flush() to ensure all of it&apos;s stuff is done. In this case, it&apos;s a flush of all threads&apos; pending edits. Similar in concept to writes to our own WAL, where we have thread &quot;flush&quot; and wait for their seqNum to come up before proceeding. I think this is no incompatible with flushes happening on their own, based on size/time. Shutdown is a separate matter (flush everything and exit).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Ditto ExceptionListener in BufferedTable. Its awkward, right? If I register a listener on BufferedTable, internally I&apos;ll need to pass this interest to the exception handler and then remove interest when the BufferedTable goes away.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is true. My patch doesn&apos;t do proper accounting for ExceptionListener OR the AsyncMutator. These need address in a &quot;real&quot; implementation. I think you&apos;d want any EL&apos;s registered by a BatchTable instance to expire when that table is closed.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If you buy the above two points, then need for a special BufferedTable Interface goes away....but then how to listen on exceptions and how to flush?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;b&gt;nod&lt;/b&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;We need a BufferedConnection? Can&apos;t we just add the few methods to Connection? It is new in 1.0 so we&apos;d be breaking no one (though there is the issue of being able to specify an executor, at least optionally, which I see you doing in BufferedConnection constructor in the factory).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Nope, we could just as easily add these methods to Connection, but that means putting their implementation down in ConnectionManager#HConnectionImplementation, or some other implementation that wraps CM#HCI in the same way that I&apos;ve done. I have a separate interface because that&apos;s what was discussed earlier in the thread. The patch was to provoke API design discussion, so mission accomplished ::smile::&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The flush on the BufferedConnection is a bit odd, yeah. Flushes all tables? Or there&apos;d be an override that allowed passing which table to flush?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, it would need to be flush all tables. See the comment I left in BufferedConnectionImpl#close():&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;  @Override
  public void close() throws IOException {
    assert aps.isEmpty() : &quot;Leaking resources&quot;;
    /* TODO: instead of assert, something like
    for (TableName t : aps.keySet()) {
      try (BufferedTable table = getBufferedTable(t)) {
        table.flush();
      }
    }
     */
    delegate.close();
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Originally I implemented BC#flush() in this way, but decided to pull it and see if anyone brought it up in discussion. Given that we have this new object that is explicitly buffering, I think we owe it to the interface to provide a means for explicitly flushing the buffers. I can&apos;t think off hand of know why a user would want it, but I think it should be there.&lt;/p&gt;</comment>
                            <comment id="14270150" author="stack" created="Thu, 8 Jan 2015 22:37:38 +0000"  >&lt;p&gt;BufferedMutator or AsyncMutator seems better yes.&lt;/p&gt;

&lt;p&gt;Is this intended; i.e. that we will flush after each Put or List&amp;lt;Put&amp;gt;? Isn&apos;t point that we do not flush unless this method is called?&lt;/p&gt;

&lt;p&gt;82	  /**&lt;br/&gt;
83	   * Executes all the buffered &lt;/p&gt;
{@link Put} operations.&lt;br/&gt;
84	   * &amp;lt;p&amp;gt;&lt;br/&gt;
85	   * This method gets called once automatically for every {@link Put}
&lt;p&gt; or batch&lt;br/&gt;
86	   * of &lt;/p&gt;
{@link Put}
&lt;p&gt;s (when &amp;lt;code&amp;gt;put(List&amp;lt;Put&amp;gt;)&amp;lt;/code&amp;gt; is used) when&lt;br/&gt;
87	   * @throws IOException if a remote or network exception occurs.&lt;br/&gt;
88	   */&lt;br/&gt;
89	  void flushCommits() throws IOException;&lt;/p&gt;

&lt;p&gt;I&apos;d say remove this from Interface:&lt;/p&gt;

&lt;p&gt;100	  /**&lt;br/&gt;
101	   * Sets the size of the buffer in bytes.&lt;br/&gt;
102	   * &amp;lt;p&amp;gt;&lt;br/&gt;
103	   * If the new size is less than the current amount of data in the&lt;br/&gt;
104	   * write buffer, the buffer gets flushed.&lt;br/&gt;
105	   * @param writeBufferSize The new write buffer size, in bytes.&lt;br/&gt;
106	   * @throws IOException if a remote or network exception occurs.&lt;br/&gt;
107	   */&lt;br/&gt;
108	  void setWriteBufferSize(long writeBufferSize) throws IOException;&lt;/p&gt;

&lt;p&gt;Get a new instance if you want to change buffer size post-construction.&lt;/p&gt;

&lt;p&gt;This should not be public, right? i.e. the constructor... needs to be shut down because you get one from Connection?&lt;/p&gt;

&lt;p&gt;64	  public HBulkMutator(TableName tableName,&lt;/p&gt;

&lt;p&gt;Skimmed the rest. Some of the changes seem a little gratuitous (refactoring by your IDE?) so unnecessarily bloats your patch.&lt;/p&gt;

&lt;p&gt;That is great that you move HTable on to the new stuff.&lt;/p&gt;

&lt;p&gt;On the DoNothingLock, its for testing? Put it in test package?&lt;/p&gt;

&lt;p&gt;Nice.&lt;/p&gt;</comment>
                            <comment id="14270176" author="ndimiduk" created="Thu, 8 Jan 2015 22:57:08 +0000"  >&lt;blockquote&gt;&lt;p&gt;but that means putting their implementation down in ConnectionManager#HConnectionImplementation, or ...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Disregard that bit; I was barking up the wrong class hierarchy.&lt;/p&gt;</comment>
                            <comment id="14270235" author="ndimiduk" created="Thu, 8 Jan 2015 23:48:14 +0000"  >&lt;p&gt;+1 for BufferedMutator (over the rest). I don&apos;t think of this as &quot;asynchronous&quot; as much as &quot;batching&quot;.&lt;/p&gt;

&lt;p&gt;+1 for doing away with changing the buffer size after construction.&lt;/p&gt;

&lt;p&gt;We&apos;re working to get away from the H-prefix in class names. How about BufferedMutatorImpl? Can the ExceptionListener be a nested interface under it&apos;s parent?&lt;/p&gt;

&lt;p&gt;Nice work in pulling the write path up out of HTable. Much better than my inside-out refactoring.&lt;/p&gt;

&lt;p&gt;nit: BufferedMutator#flushCommits can be just flush(); since HTable is delegating, BufferedMutator is not bound to the old API.&lt;/p&gt;

&lt;p&gt;Is there any place where a Lock implementation other than your DoNothingLock would be used? All paths I read are using this no-op implementation... which means they can only be used by a single thread? If I want to share a BufferedMutator across threads, I just pass in a real Lock implementation? I guess that would come it for a &quot;BufferedTable&quot;.&lt;/p&gt;

&lt;p&gt;Agreed on locking down the BulkMutator constructor. I&apos;m also not a fan of exposing this class to the user API. I prefer the BufferedTable interface discussed previously. Wrap it up nice and tidy like with new ConnectionFactory methods.&lt;/p&gt;

&lt;p&gt;Can you add some example code so we can see how a use case like &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=abeppu&quot; class=&quot;user-hover&quot; rel=&quot;abeppu&quot;&gt;Aaron Beppu&lt;/a&gt;&apos;s would be addressed?&lt;/p&gt;</comment>
                            <comment id="14271185" author="sduskis" created="Fri, 9 Jan 2015 15:37:03 +0000"  >&lt;blockquote&gt;&lt;p&gt;We&apos;re working to get away from the H-prefix in class names. How about BufferedMutatorImpl? Can the ExceptionListener be a nested interface under it&apos;s parent?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK and will do&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;nit: BufferedMutator#flushCommits can be just flush(); since HTable is delegating, BufferedMutator is not bound to the old API.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Is there any place where a Lock implementation other than your DoNothingLock would be used? All paths I read are using this no-op implementation... which means they can only be used by a single thread? If I want to share a BufferedMutator across threads, I just pass in a real Lock implementation? I guess that would come it for a &quot;BufferedTable&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It sounds like you have the gist of it.  I&apos;ll show it in code in the example you asked for.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Agreed on locking down the BulkMutator constructor. I&apos;m also not a fan of exposing this class to the user API. I prefer the BufferedTable interface discussed previously. Wrap it up nice and tidy like with new ConnectionFactory methods.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed and will do&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Can you add some example code so we can see how a use case like Aaron Beppu&apos;s would be addressed?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Here&apos;s what I was thinking&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; MyServlet &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; Servlet {

  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; Connection connection;
  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; BulkMutator mutator;

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void init(ServletConfig config) {
     connection = ...;
     mutator = connection.getBulkMutator(tableName, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ReentrantLock(), myExecutorService, myListener);
  }
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void service(ServletRequest req, ServletResponse res) {
     ...
     &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (doDelete) {
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; (Table table = connection.getTable(...)) {
           table.delete(..);
        }
     } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
        mutator.put(..);
     }
  }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14275510" author="stack" created="Tue, 13 Jan 2015 16:40:38 +0000"  >&lt;p&gt;Can I help out on this one?&lt;/p&gt;</comment>
                            <comment id="14275876" author="sduskis" created="Tue, 13 Jan 2015 20:27:25 +0000"  >&lt;p&gt;I implemented BulkMutator, and removed autoflush from Table.&lt;/p&gt;

&lt;p&gt;There&apos;s more to do in terms of documentation, but I figured that this is good enough for further review.&lt;/p&gt;</comment>
                            <comment id="14276074" author="hadoopqa" created="Tue, 13 Jan 2015 22:23:20 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12692039/HBASE-12728.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12692039/HBASE-12728.patch&lt;/a&gt;&lt;br/&gt;
  against master branch at commit 4ac457a7bc909cc92e0a1a0cab21ed0ce6bae893.&lt;br/&gt;
  ATTACHMENT ID: 12692039&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 102 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 javadoc&lt;/font&gt;.  The javadoc tool appears to have generated 13 warning messages.&lt;/p&gt;

&lt;p&gt;                &lt;font color=&quot;red&quot;&gt;-1 checkstyle&lt;/font&gt;.  The applied patch generated 2080 checkstyle errors (more than the master&apos;s current 2075 errors).&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 findbugs&lt;/font&gt;.  The patch appears to introduce 1 new Findbugs (version 2.0.3) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 core tests&lt;/font&gt;.  The patch passed unit tests in .&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-rest.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-rest.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-annotations.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-annotations.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Checkstyle Errors: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/checkstyle-aggregate.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/checkstyle-aggregate.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;                Javadoc warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/patchJavadocWarnings.txt&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//artifact/patchprocess/patchJavadocWarnings.txt&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12449//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14276224" author="enis" created="Tue, 13 Jan 2015 23:59:53 +0000"  >&lt;p&gt;Great patch. &lt;br/&gt;
BulkMutator looks good except I would also prefer BufferedMutator. Table already does bulk puts via put(List&amp;lt;Put&amp;gt;) interface. This is more like buffered/async puts. &lt;/p&gt;

&lt;p&gt;Shouldn&apos;t this get the BulkMutator (the interface) instead of the implementation class?&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void onException(RetriesExhaustedWithDetailsException exception, HBulkMutator hBulkMutator)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;BulkMutatorParameters -&amp;gt; BulkMutatorConfig(uration). We usually suffix these kind of objects with Config (look at TableConfiguration). Also can we do builder-style on setXXX() methods. This class is only for passing args to the method it seems. Do we really need it?&lt;/p&gt;

&lt;p&gt;Why are we exposing Lock to users. Should this be a boolean whether you want thread-safe or not. &lt;/p&gt;

&lt;p&gt;Table.close -&amp;gt; BulkMutator.close() below:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+   * The caller is responsible &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; calling {@link Table#close()} on the returned bulkMutator
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;HBulkMutator -&amp;gt; H prefix is old school. Let&apos;s use Impl suffix. &lt;/p&gt;
</comment>
                            <comment id="14277103" author="sduskis" created="Wed, 14 Jan 2015 15:52:53 +0000"  >&lt;p&gt;I think I addressed all of &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=enis&quot; class=&quot;user-hover&quot; rel=&quot;enis&quot;&gt;Enis Soztutar&lt;/a&gt;&apos;s comments.&lt;/p&gt;</comment>
                            <comment id="14277318" author="hadoopqa" created="Wed, 14 Jan 2015 17:51:50 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12692239/HBASE-12728-2.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12692239/HBASE-12728-2.patch&lt;/a&gt;&lt;br/&gt;
  against master branch at commit 1a21c1684c5d68cb2d1da8ed33500993b0965f8a.&lt;br/&gt;
  ATTACHMENT ID: 12692239&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 96 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 javadoc&lt;/font&gt;.  The javadoc tool appears to have generated 14 warning messages.&lt;/p&gt;

&lt;p&gt;                &lt;font color=&quot;red&quot;&gt;-1 checkstyle&lt;/font&gt;.  The applied patch generated 2081 checkstyle errors (more than the master&apos;s current 2074 errors).&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any new Findbugs (version 2.0.3) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 release audit&lt;/font&gt;.  The applied patch generated 2 release audit warnings (more than the master&apos;s current 0 warnings).&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 lineLengths&lt;/font&gt;.  The patch introduces the following lines longer than 100:&lt;br/&gt;
    + * An implementation of &lt;/p&gt;
{@link Lock}
&lt;p&gt; that doesn&apos;t actually lock anything. &lt;/p&gt;
{@link BufferedMutatorImpl}
&lt;p&gt; uses&lt;br/&gt;
+  public static void loadData(final HBaseTestingUtility util, final BufferedMutator mutator, int rows,&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 site&lt;/font&gt;.  The patch appears to cause mvn site goal to fail.&lt;/p&gt;

&lt;p&gt;     &lt;font color=&quot;red&quot;&gt;-1 core tests&lt;/font&gt;.  The patch failed these unit tests:&lt;/p&gt;


&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//testReport/&lt;/a&gt;&lt;br/&gt;
Release audit warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/patchReleaseAuditWarnings.txt&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/patchReleaseAuditWarnings.txt&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-rest.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-rest.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-annotations.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-annotations.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Checkstyle Errors: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/checkstyle-aggregate.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/checkstyle-aggregate.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;                Javadoc warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/patchJavadocWarnings.txt&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//artifact/patchprocess/patchJavadocWarnings.txt&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12460//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14277366" author="stack" created="Wed, 14 Jan 2015 18:19:27 +0000"  >&lt;p&gt;Nice doc on BufferedMutator.&lt;/p&gt;

&lt;p&gt;This bit of doc is incomplete:&lt;/p&gt;

&lt;p&gt;100	   * This method gets called once automatically for every &lt;/p&gt;
{@link Put} or batch&lt;br/&gt;
101	   * of {@link Put}
&lt;p&gt;s (when &amp;lt;code&amp;gt;put(List&amp;lt;Put&amp;gt;)&amp;lt;/code&amp;gt; is used) when&lt;/p&gt;

&lt;p&gt;And we don&apos;t want the above either? Right? It was from asyncflush?&lt;/p&gt;

&lt;p&gt;s/instantiating/instantiating/&lt;/p&gt;

&lt;p&gt;We need to expose threadsafe as an option?  Why not just threadsafe all the time?  One less thing for the user to worry about (Minor cost when uncontended crossing of synchronization barrier)&lt;/p&gt;

&lt;p&gt;The config class has wrong tab sizing.&lt;/p&gt;

&lt;p&gt;This class is a bit of an odd bird (particularly so because all the rest of your changes are elegant). Let me read the rest of the patch.... OK.  Back again.  I see how it is intended to be used.  Yeah, what Enis says, can we do Builder... and perhaps Fluent pattern (e.g. &lt;a href=&quot;http://jlordiales.me/2012/12/13/the-builder-pattern-in-practice/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://jlordiales.me/2012/12/13/the-builder-pattern-in-practice/&lt;/a&gt;) so instead of a method name thatIsMultithreaded, it&apos;d be multhreaded and instead of withPool, it&apos;d be just pool.  Not a deal-breaker. Just a suggestion.&lt;/p&gt;

&lt;p&gt;Public constructor on BufferedMutatorImpl needs to be shutdown... private.&lt;/p&gt;

&lt;p&gt;This is interesting:&lt;/p&gt;

&lt;p&gt;164	    // This behavior is highly non-intuitive... it does not protect us against&lt;br/&gt;
165	    // 94-incompatible behavior, which is a timing issue because hasError, the below code&lt;br/&gt;
166	    // and setter of hasError are not synchronized. Perhaps it should be removed.&lt;/p&gt;


&lt;p&gt;I got a little lost (because it non-intuitive I suppose &amp;#8211; smile) We are flushing out writes that were buffered before the error showed up?&lt;/p&gt;

&lt;p&gt;Can the lock be an internal detail rather than passed on construction? (the less options the user has the better)&lt;/p&gt;

&lt;p&gt;s/CachingConnection/BufferingConnection/ to highlight the connection between BufferedMutator and this new Connection type?&lt;/p&gt;

&lt;p&gt;Is user supposed to be able to create their own CachingConnection?  Should this be package protected to force folks via the ConnectionFactory?&lt;/p&gt;

&lt;p&gt;The redo of HTable to use the new stuff and the changes in Interfaces look great.&lt;/p&gt;

&lt;p&gt;Very nice work &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt;&lt;/p&gt;







</comment>
                            <comment id="14277474" author="sduskis" created="Wed, 14 Jan 2015 19:08:31 +0000"  >&lt;blockquote&gt;&lt;p&gt;This bit of doc is incomplete: ...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ll update the comments .  I wanted to get the code out for review.  The documentation can definitely use more work&lt;/p&gt;

&lt;p&gt;b1. We need to expose threadsafe as an option? Why not just threadsafe all the time? One less thing for the user to worry about (Minor cost when uncontended crossing of synchronization barrier)&lt;/p&gt;

&lt;p&gt;I&apos;m fine either way.  I&apos;ll make it all synchronized.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This class is a bit of an odd bird (particularly so because all the rest of your changes are elegant). Let me read the rest of the patch.... OK. Back again. I see how it is intended to be used. Yeah, what Enis says, can we do Builder... and perhaps Fluent pattern (e.g. &lt;a href=&quot;http://jlordiales.me/2012/12/13/the-builder-pattern-in-practice/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://jlordiales.me/2012/12/13/the-builder-pattern-in-practice/&lt;/a&gt;) so instead of a method name thatIsMultithreaded, it&apos;d be multhreaded and instead of withPool, it&apos;d be just pool. Not a deal-breaker. Just a suggestion.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ll defer to the wisdom of the crowd here.  I added in a lot of options which could result in a proliferation of Connection.getBufferedMutator() methods.  I&apos;ll remove the Config, since we&apos;re removing the number of optiosn.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Public constructor on BufferedMutatorImpl needs to be shutdown... private.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is interesting:&lt;br/&gt;
164	// This behavior is highly non-intuitive... it does not protect us against&lt;br/&gt;
165	// 94-incompatible behavior, which is a timing issue because hasError, the below code&lt;br/&gt;
166	// and setter of hasError are not synchronized. Perhaps it should be removed.&lt;br/&gt;
I got a little lost (because it non-intuitive I suppose &#8211; smile) We are flushing out writes that were buffered before the error showed up?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That bit was copied directly from HTable.  I&apos;m impartial about the correct algorithm in this case, I just didn&apos;t want to rock the boat.  This issue is definitely worth a discussion, but I&apos;d ask that if we want to change the algorithm, we do it in another JIRA issue.  &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Can the lock be an internal detail rather than passed on construction? (the less options the user has the better)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If everything is synchronized, then sure.  We can even rely on plain old synchronized methods instead of fancy Lock objects.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;s/CachingConnection/BufferingConnection/ to highlight the connection between BufferedMutator and this new Connection type?&lt;br/&gt;
Is user supposed to be able to create their own CachingConnection? Should this be package protected to force folks via the ConnectionFactory?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I got a bit fancy for the sake of MultiTableOutputFormat which puts Tables into a Map&amp;lt;String, Table&amp;gt;.  I needed to add a Map&amp;lt;String, BufferedMutator&amp;gt; so I moved that functionality into a separate class for potential reusability.  It looks like it would be better to KISS and move the CachingConnection functionality back into MultiTableOutputFormat.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The redo of HTable to use the new stuff and the changes in Interfaces look great.&lt;br/&gt;
Very nice work Solomon Duskis&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="14277489" author="stack" created="Wed, 14 Jan 2015 19:15:05 +0000"  >&lt;p&gt;All synchronized in a new class seems good to me till someone turns up a perf problem &amp;#8211; especially if it means simplification.&lt;/p&gt;

&lt;p&gt;Yeah, if not enough options to justify the conf class, axe it for now?&lt;/p&gt;

&lt;p&gt;Agree this issue is about the new Interfaces and new class only &amp;#8211; fixing non-intuitives are for another issue.&lt;/p&gt;

&lt;p&gt;Good on you &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt;&lt;/p&gt;


</comment>
                            <comment id="14277551" author="ndimiduk" created="Wed, 14 Jan 2015 19:47:21 +0000"  >&lt;p&gt;The patch is looking really good. I have no major issues to add to previous reviewers&apos;. I do prefer a &lt;tt&gt;BufferedTable&lt;/tt&gt; interface, that extends &lt;tt&gt;Table&lt;/tt&gt;, over separating out the buffered functionality into &lt;tt&gt;BufferedMutator&lt;/tt&gt;. I think bringing along the Table implementation will make it easier for folks to sub in. However, no one else is raising the point, so maybe I&apos;m in the minority.&lt;/p&gt;

&lt;p&gt;For future reference, you may want to post larger patches to reviews.apache.org so it&apos;s easier to keep track of reviewer comments. It&apos;s no gerrit, but it&apos;s better than nothing.&lt;/p&gt;

&lt;p&gt;throughout javadocs and exception strings: s/HTable/Table/, s/BulkMutator/BatchMutator/&lt;/p&gt;

&lt;p&gt;nit: throughout, theres on value in empty @param or @throws javadocs. Usually at least param names are obvious and this javadoc can be omitted.&lt;/p&gt;

&lt;p&gt;on the docs for BatchMutator#put(List&amp;lt;Put&amp;gt;), it should be pointed out that this list of edits will not necessarily be sent in the same batch (i think this is an omission in our current doc strings too).&lt;/p&gt;

&lt;p&gt;re: BufferedMutatorConfig, I think you&apos;re following the TableConfiguration convention. This isn&apos;t common within the HBase code; we tend to use builders or &quot;context&quot; objects instead.&lt;/p&gt;

&lt;p&gt;Looks like tabs in BufferedMutatorExceptionListener as well. If you&apos;re using Eclipse or IntelliJ, we have formatting config file in dev-support/hbase_eclipse_formatter.xml&lt;/p&gt;

&lt;p&gt;s/prodcution/production/&lt;/p&gt;

&lt;p&gt;formatting of ASF header in CachingConnection is mangled, I think this will set off the apache-rat-plugin license check at release time.&lt;/p&gt;

&lt;p&gt;this doc on Connection#getBufferedMutator(TableName, BufferedMutatorConfig) is incomplete &quot;  * provided Lock object. This object can be used for long lived &amp;lt;br&amp;gt;&quot;&lt;/p&gt;

&lt;p&gt;Better to move this default value decision from getBufferedMutator down into the BufferedMutatorConfig so it&apos;s contained there.&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;      Lock lock = config.isMultithreaded() ? new ReentrantLock() : new DoNothingLock();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14277565" author="lhofhansl" created="Wed, 14 Jan 2015 19:55:05 +0000"  >&lt;blockquote&gt;&lt;p&gt;I do prefer a &lt;tt&gt;BufferedTable&lt;/tt&gt; interface, that extends &lt;tt&gt;Table&lt;/tt&gt;, over separating out the buffered functionality into &lt;tt&gt;BufferedMutator&lt;/tt&gt;. I think bringing along the Table implementation will make it easier for folks to sub in. However, no one else is raising the point, so maybe I&apos;m in the minority.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I raised the point, and I agree &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="14277577" author="sduskis" created="Wed, 14 Jan 2015 20:02:55 +0000"  >&lt;blockquote&gt;&lt;p&gt;I do prefer a BufferedTable interface, that extends Table, over separating out the buffered functionality into BufferedMutator. I think bringing along the Table implementation will make it easier for folks to sub in. However, no one else is raising the point, so maybe I&apos;m in the minority.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We can add setAutoFlushTo() back into the Table interface, and all would be well as far as single threaded uses cases go since HTable defers to a BufferedMutator in my patch.  Frankly, the only case where BufferedMutator makes sense by itself is in a multi-threaded case like Aaron Beppu&apos;s multi-threaded case.&lt;/p&gt;</comment>
                            <comment id="14277708" author="sduskis" created="Wed, 14 Jan 2015 21:22:14 +0000"  >&lt;p&gt;Do we want to keep the autoflush functionality on Table()?  If so most of the changes that I made can be reverted.  The only thing we&apos;d have to change is introduce BufferedMutator, BufferedMutatorImpl and a method on Connection to create a BufferedMutator.  We&apos;d also keep some form of async exception listener.  All of the other changes to the Table interface and the cascading changes to the 40ish classes would go away...  &lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                            <comment id="14277715" author="eclark" created="Wed, 14 Jan 2015 21:27:03 +0000"  >&lt;p&gt;I really like the idea of removing autoFlush from HTable. It really shows the users that the difference. Additionally I think that it mirrors BufferedReader/BufferedWriter from java pretty well, so users should be used to different classes providing buffered implementations.&lt;/p&gt;</comment>
                            <comment id="14277859" author="sduskis" created="Wed, 14 Jan 2015 23:10:19 +0000"  >&lt;p&gt;After this last exchange I&apos;ve thoroughly convinced myself that HTable is mostly fine as it is.  The problem that the original poster presented is a case where I think that HBase ought not provide a coded solution, since the use cases require a lot of knowledge about the nuances of the situation.  The problem &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=abeppu&quot; class=&quot;user-hover&quot; rel=&quot;abeppu&quot;&gt;Aaron Beppu&lt;/a&gt; is trying to solve for is for a long lived service that wants to use asynchronous puts across a lot of requests.  The assumption is that Tables are by short lived objects.  From what I see, the only limitation of short-lived-ness is conceptual.  There&apos;s nothing in the HTable codebase that I see any reason to not keep it around for the lifecycle of the service.  Here&apos;s my preferred implementation:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class MyService {
  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; HTableInterface table;
  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; ExecutorService executor;

  ...

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void initialize(..) {
     table = storedConnection.getTable(tableName);
     &lt;span class=&quot;code-object&quot;&gt;Runnable&lt;/span&gt; r = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Runnable&lt;/span&gt;() {
        &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void run() {
           synchronize(table) {
             &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                table.flushCommits();
             } ...
           }
        }
     }
     &lt;span class=&quot;code-comment&quot;&gt;// somehow use the executor to invoke r every 100 ms. or so
&lt;/span&gt;  }

  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void writeBuffered(Put somePut) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
     synchronize(table) {
       table.put(somePut); 
     }
  }

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void close() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
     table.close()
  }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I&apos;ve come to the conclusion that the problem is in the documentation, not the implementation.  All of my work in the patch should be thrown away and I&apos;ll consider it a learning experience.&lt;/p&gt;

&lt;p&gt;It could be that my analysis about short-lived-ness is way off base, but if it is, then my implementation of BufferedMutator will have the same problems as HTable.&lt;/p&gt;

&lt;p&gt;There still is the problem of exception handling, and an async exception listener would be a good idea, but one for a different JIRA ticket.&lt;/p&gt;

&lt;p&gt;I feel like I could have missed something critical in my analysis... Thoughts on this?&lt;/p&gt;</comment>
                            <comment id="14278012" author="enis" created="Thu, 15 Jan 2015 00:52:09 +0000"  >&lt;blockquote&gt;&lt;p&gt;The assumption is that Tables are by short lived objects. From what I see, the only limitation of short-lived-ness is conceptual. There&apos;s nothing in the HTable codebase that I see any reason to not keep it around for the lifecycle of the service.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Agreed. &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;There still is the problem of exception handling, and an async exception listener would be a good idea, but one for a different JIRA ticket.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I see no point of having an API in Table (or elsewhere) where you can do async puts, but no way to learn about the status of the results. So I think async puts and setting Listener goes hand-in-hand. That might still be reason to create a separate interface or change Table.setAutoFlushTo() to have a ExceptionListener parameter at least. &lt;/p&gt;

&lt;p&gt;The reason there is such a thing called HTablePool in my opinion is that HTable is not thread safe. Having a thread safe buffered writer as in your patch solves the use case in this issue as well as MR use case. When we remove BufferedMutator out of HTable, if HTable can be made thread safe cheaply as well, then there is still no need to have a ref-counting pool. Rather a user can simply have a TableName -&amp;gt; Table map of objects as it&apos;s own pool. &lt;/p&gt;</comment>
                            <comment id="14278111" author="stack" created="Thu, 15 Jan 2015 02:11:54 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The problem that the original poster presented is a case where I think that HBase ought not provide a coded solution, since the use cases require a lot of knowledge about the nuances of the situation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right or wrong, we have been steering the likes of the original poster awry by providing a &apos;solution&apos; up to this with table pool and an HTable having a write buffer. We could add your suggestion to the doc for those trying to figure what to do now pool has been deprecated/removed (though it would be better if the synchronization and background writing was done for them internal to HTable rather than have every user implement the background thread anew), but what for those up on the new Interfaces who would do buffered mutating?  Here, don&apos;t we want your nice, new, clean BufferedMutator with listening for errors, etc?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;...but if it is, then my implementation of BufferedMutator will have the same problems as HTable.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Which problems? Is it that BM won&apos;t have &quot;...a lot of knowledge about the nuances of the situation&quot;?&lt;/p&gt;

&lt;p&gt;BM is synchronized. HT is not.&lt;br/&gt;
BM has listener for exceptions. HT does not.&lt;br/&gt;
With BM the intent is plain. HT is a bucket.&lt;br/&gt;
BM nicely compliments the new Table Interface.  HT is amorphous legacy.&lt;/p&gt;

&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14278154" author="sduskis" created="Thu, 15 Jan 2015 02:45:50 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I see no point of having an API in Table (or elsewhere) where you can do async puts, but no way to learn about the status of the results. So I think async puts and setting Listener goes hand-in-hand. That might still be reason to create a separate interface or change Table.setAutoFlushTo() to have a ExceptionListener parameter at least.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1.  The exception listener seems to be important regardless of whether we have a separate interface for mutations.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The reason there is such a thing called HTablePool in my opinion is that HTable is not thread safe. Having a thread safe buffered writer as in your patch solves the use case in this issue as well as MR use case. When we remove BufferedMutator out of HTable, if HTable can be made thread safe cheaply as well, then there is still no need to have a ref-counting pool. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We&apos;re assuming that thread safety is negligible for BufferedMutator.  Let&apos;s make the same assumption for Table, or even better test out the assumption.  If synchronization is relatively cheap, or seen as an option we want to give users for mutations, why not add the synchronization option directly to Table or document some simple rules to ensure that they can do the synchronization themselves? &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Rather a user can simply have a TableName -&amp;gt; Table map of objects as it&apos;s own pool.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;if they need to write to multiple Tables, that would be a simple solution for their needs. &lt;/p&gt;</comment>
                            <comment id="14278246" author="sduskis" created="Thu, 15 Jan 2015 04:36:53 +0000"  >&lt;blockquote&gt;
&lt;p&gt;We could add your suggestion to the doc for those trying to figure what to do now pool has been deprecated/removed (though it would be better if the synchronization and background writing was done for them internal to HTable rather than have every user implement the background thread anew),&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;There already is Async writing in a background thread HTable.  That happens through AsyncProcess.  The only hitch in the current implementation of HTable is problems around multiple threads changing the in memory &lt;tt&gt;List&amp;lt;Row&amp;gt; writeAsyncBuffer&lt;/tt&gt; at the same time.  if we synchronize the &lt;tt&gt;backgroundFlushCommits()&lt;/tt&gt; and &lt;tt&gt;doPuts&lt;/tt&gt; methods, then Table puts should be thread-safe.&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;quote&lt;/tt&gt;&lt;br/&gt;
BM is synchronized. HT is not.&lt;br/&gt;
BM has listener for exceptions. HT does not.&lt;br/&gt;
{{quote}&lt;/p&gt;

&lt;p&gt;We can fix that in HT.&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;quote&lt;/tt&gt;&lt;br/&gt;
BM nicely compliments the new Table Interface. HT is amorphous legacy.&lt;br/&gt;
With BM the intent is plain. HT is a bucket.&lt;br/&gt;
&lt;tt&gt;quote&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;Is the Table interface enough or does it need to be split up into components like BM?&lt;/p&gt;</comment>
                            <comment id="14278380" author="stack" created="Thu, 15 Jan 2015 07:30:29 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt; How to move forward on this issue?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;if we synchronize the backgroundFlushCommits() and doPuts methods, then Table puts should be thread-safe.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes. But HTable is going underground, right? And Table is what users are left with?  HTable constructors are deprecated. It is becoming an internalized implementation. Whats a fella who wants to do buffering or &quot;short-lived-ness&quot; to do going forward?&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;</comment>
                            <comment id="14278781" author="sduskis" created="Thu, 15 Jan 2015 15:16:03 +0000"  >&lt;blockquote&gt;&lt;p&gt;Yes. But HTable is going underground, right? And Table is what users are left with? HTable constructors are deprecated. It is becoming an internalized implementation. Whats a fella who wants to do buffering or &quot;short-lived-ness&quot; to do going forward?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In terms of buffering, why not simply keep autoflush and suggest synchronization on a Table in a multi-threaded environment?  That would solve the user&apos;s original issue.&lt;/p&gt;

&lt;p&gt;In all of this discussion, it feels like there isn&apos;t consensus about separating Table from BM functionality.  Some want to remove Table.autoflush and some want to keep it.  I don&apos;t have a strong view either way at this point.  I&apos;ll be glad to continue to help, but I don&apos;t want to invest too much more time in implementation details until a consensus exists for a more coherent strategy.  If BM is a Good Thing (tm) because it&apos;s a coherent unit and HT (and maybe Table even) is amorphous legacy, then perhaps it&apos;s more worthwhile taking a look at segmenting Table as a whole into coherent units rather than focusing on BM alone.&lt;/p&gt;</comment>
                            <comment id="14279142" author="stack" created="Thu, 15 Jan 2015 19:16:48 +0000"  >&lt;blockquote&gt;&lt;p&gt;In terms of buffering, why not simply keep autoflush and suggest synchronization on a Table in a multi-threaded environment?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We could. It would be better if we did the safe access for the user rather than have them have to do it everywhere (and possibly get it wrong or forget to).&lt;/p&gt;

&lt;p&gt;It&apos;d also be a pity dropping on the ground the nice cleanup that you&apos;ve done up in your last patch untangling buffering from Table (and providing the user utility so they don&apos;t have to do said synchronizations).&lt;/p&gt;

&lt;p&gt;I&apos;d be up for carrying &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt; last patch past the finish line if Solomon doesn&apos;t want to. Thanks for the work so far &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="14279186" author="sduskis" created="Thu, 15 Jan 2015 19:37:16 +0000"  >&lt;p&gt;I&apos;m certainly not against you doing the work.  I&apos;m not against picking up the work again myself either.  What would be nice at this point is to have a clear notion of whether Table ought to extend BufferedMutator or not.&lt;/p&gt;</comment>
                            <comment id="14279220" author="stack" created="Thu, 15 Jan 2015 19:59:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;What would be nice at this point is to have a clear notion of whether Table ought to extend BufferedMutator or not.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Makes sense &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt; Agreed.&lt;/p&gt;

&lt;p&gt;Opinions?  I&apos;m for driving how the last posted patch (Buffering taken out of Table done in a dedicated utility class).&lt;/p&gt;</comment>
                            <comment id="14279373" author="ndimiduk" created="Thu, 15 Jan 2015 22:10:58 +0000"  >&lt;p&gt;I think it&apos;s better to cover the multi-threaded coordination on behalf of the user than expect them to do the synchronizing themselves. The train rolling here is a good one &amp;#8211; it&apos;s nice cleanup, it&apos;s consistent with previous behaviors, and it makes things more obvious for users. Accompany this with thoughtful javadoc review and a fat example that we can dump into the online book and this will be a fine resolution.&lt;/p&gt;

&lt;p&gt;I still like better having a &lt;tt&gt;Table&lt;/tt&gt;,&lt;tt&gt;BufferedTable&lt;/tt&gt; instead of &lt;tt&gt;Table&lt;/tt&gt;,&lt;tt&gt;BufferedMutator&lt;/tt&gt;. I think having a drop-in buffering option will make the most sense for a usable API. I hear the argument of maybe it&apos;s not the place of our client out-of-the-box, but we have a solution to this today that some folks depend on, so I think it&apos;s irresponsible to omit it for 1.0. If &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt; is truly fed up with us ( ::smile:: ) I&apos;m happy to pick up the patch in this direction.&lt;/p&gt;

&lt;p&gt;I also think splitting the &lt;tt&gt;Table&lt;/tt&gt; concept into a reader and a writer is something worth exploring, but not for 1.0. I&apos;m hoping by 2.0 we&apos;ll have a valid story for an async (or &lt;a href=&quot;http://www.reactivemanifesto.org&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;reactive&lt;/a&gt;?) client and maybe even something that operates on top of a C/native implementation so we can close the gap for folks who aren&apos;t on the JVM. For now, let&apos;s get 1.0 release unblocked.&lt;/p&gt;</comment>
                            <comment id="14279403" author="stack" created="Thu, 15 Jan 2015 22:28:27 +0000"  >&lt;p&gt;BM IMO is a step beyond BT in terms of API cleanup but if a step too far, I&apos;d be fine w/ BT for 1.0. I like the way you characterize what has been going on here as a &apos;train&apos; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ndimiduk&quot; class=&quot;user-hover&quot; rel=&quot;ndimiduk&quot;&gt;Nick Dimiduk&lt;/a&gt; and that we were going to a better place.&lt;/p&gt;</comment>
                            <comment id="14279442" author="sduskis" created="Thu, 15 Jan 2015 22:47:13 +0000"  >&lt;p&gt;b1. If Solomon Duskis is truly fed up with us ( ::smile:: ) I&apos;m happy to pick up the patch in this direction.&lt;/p&gt;

&lt;p&gt;The HBase community is a wonderful crew and I&apos;m happy to be part of it.  That said, I think that it would be a load off my shoulders to humbly pass this along to you so that the results are as you&apos;d like them to be.&lt;/p&gt;</comment>
                            <comment id="14283151" author="ndimiduk" created="Mon, 19 Jan 2015 23:11:03 +0000"  >&lt;p&gt;Here&apos;s a patch that continues on &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt;&apos;s good work. I think I&apos;ve addressed all reviewer feedback. It retains BufferedMutation as part of the public API, an instance that supports concurrent access and is managed explicitly by the user. Let&apos;s see what BuildBot has to say.&lt;/p&gt;

&lt;p&gt;I experimented with the BufferedTable approach but decided the complexities for resource and setting management were too confusing. If anyone wants to explore that option in more detail, I&apos;m happy to discuss.&lt;/p&gt;</comment>
                            <comment id="14283266" author="hadoopqa" created="Tue, 20 Jan 2015 01:19:14 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12693172/HBASE-12728-3.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12693172/HBASE-12728-3.patch&lt;/a&gt;&lt;br/&gt;
  against master branch at commit 53815afc1023a624d6b6069f4111692951a78848.&lt;br/&gt;
  ATTACHMENT ID: 12693172&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 99 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 javadoc&lt;/font&gt;.  The javadoc tool appears to have generated 3 warning messages.&lt;/p&gt;

&lt;p&gt;                &lt;font color=&quot;red&quot;&gt;-1 checkstyle&lt;/font&gt;.  The applied patch generated 2084 checkstyle errors (more than the master&apos;s current 2073 errors).&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any new Findbugs (version 2.0.3) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 lineLengths&lt;/font&gt;.  The patch introduces the following lines longer than 100:&lt;br/&gt;
    + * &amp;lt;p&amp;gt;BufferedMutator can also be used on more exotic circumstances. Map/Reduce batch jobs will have a&lt;br/&gt;
+ * single BufferedMutator per thread. A single BufferedMutator can also be effectively used in high volume&lt;br/&gt;
+  private void doMutate(Mutation m) throws InterruptedIOException, RetriesExhaustedWithDetailsException {&lt;br/&gt;
+   * This is used for legacy purposes in &lt;/p&gt;
{@link HTable}
&lt;p&gt; only. This ought not be called for production&lt;br/&gt;
+ * An implementation of &lt;/p&gt;
{@link Lock}
&lt;p&gt; that doesn&apos;t actually lock anything. &lt;/p&gt;
{@link BufferedMutatorImpl}
&lt;p&gt; uses&lt;br/&gt;
+  public static void loadData(final HBaseTestingUtility util, final BufferedMutator mutator, int rows,&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 core tests&lt;/font&gt;.  The patch passed unit tests in .&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-rest.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-rest.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-annotations.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-annotations.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Checkstyle Errors: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/checkstyle-aggregate.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/checkstyle-aggregate.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;                Javadoc warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/patchJavadocWarnings.txt&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//artifact/patchprocess/patchJavadocWarnings.txt&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12512//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14283288" author="ndimiduk" created="Tue, 20 Jan 2015 01:41:37 +0000"  >&lt;p&gt;Let me track down these hygiene issues.&lt;/p&gt;

&lt;p&gt;Running locally, I&apos;m seeing these two tests are being flaky, I&apos;m surprised to see Jenkins pass them&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;TestFastFail.testFastFail
TestFromClientSide.testCheckAndDeleteWithCompareOp
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14284941" author="ndimiduk" created="Wed, 21 Jan 2015 00:57:06 +0000"  >&lt;p&gt;Cleanup style errors, remove unused class DoNothingLock.&lt;/p&gt;</comment>
                            <comment id="14285069" author="hadoopqa" created="Wed, 21 Jan 2015 02:53:37 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12693458/HBASE-12728-4.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12693458/HBASE-12728-4.patch&lt;/a&gt;&lt;br/&gt;
  against master branch at commit 9bdb81f0a1db308a8a452379455b6bbfe70ea20d.&lt;br/&gt;
  ATTACHMENT ID: 12693458&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 99 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 javadoc&lt;/font&gt;.  The javadoc tool appears to have generated 2 warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 checkstyle&lt;/font&gt;.  The applied patch does not increase the total number of checkstyle errors&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any new Findbugs (version 2.0.3) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 core tests&lt;/font&gt;.  The patch passed unit tests in .&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-rest.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-rest.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-annotations.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/newPatchFindbugsWarningshbase-annotations.html&lt;/a&gt;&lt;br/&gt;
Checkstyle Errors: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/checkstyle-aggregate.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/checkstyle-aggregate.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;  Javadoc warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/patchJavadocWarnings.txt&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//artifact/patchprocess/patchJavadocWarnings.txt&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12523//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14286188" author="ndimiduk" created="Wed, 21 Jan 2015 20:10:31 +0000"  >&lt;p&gt;Addresses all reviewer feedback except for the question of what we do with the BufferedMutatorBuilder.&lt;/p&gt;

&lt;p&gt;I like the builder as it is. We don&apos;t have any explicit builders in our client API, and I think this sets a nice example. Closest thing is the fluent setters on Scan, &amp;amp;c.&lt;/p&gt;</comment>
                            <comment id="14286305" author="stack" created="Wed, 21 Jan 2015 21:29:50 +0000"  >&lt;p&gt;Fix javadoc on commit.&lt;/p&gt;

&lt;p&gt;I commented on rb on builder issue.  I think we have to go your route.&lt;/p&gt;</comment>
                            <comment id="14286317" author="ndimiduk" created="Wed, 21 Jan 2015 21:35:13 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt; would be great to get your blessing on the final patch &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="14286329" author="ndimiduk" created="Wed, 21 Jan 2015 21:40:39 +0000"  >&lt;p&gt;I checked javadoc and check style locally on patch v5 before attaching, should be good to go. Do look once more at the use of synchronized keyword in BufferedMutatorImpl, I used it a bit more aggressively in the latest patch, the idea being to lock down concurrent changes to the writeBuffer.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=enis&quot; class=&quot;user-hover&quot; rel=&quot;enis&quot;&gt;Enis Soztutar&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt; I have your +1&apos;s over on RB, mind carrying them here for the book keeping.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lhofhansl&quot; class=&quot;user-hover&quot; rel=&quot;lhofhansl&quot;&gt;Lars Hofhansl&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=eclark&quot; class=&quot;user-hover&quot; rel=&quot;eclark&quot;&gt;Elliott Clark&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=abeppu&quot; class=&quot;user-hover&quot; rel=&quot;abeppu&quot;&gt;Aaron Beppu&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=carterpage&quot; class=&quot;user-hover&quot; rel=&quot;carterpage&quot;&gt;Carter&lt;/a&gt; anything else to add?&lt;/p&gt;</comment>
                            <comment id="14286332" author="ndimiduk" created="Wed, 21 Jan 2015 21:41:26 +0000"  >&lt;p&gt;FYI, I moved the BufferedTable idea over into &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12895&quot; title=&quot;Introduce BufferedTable&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12895&quot;&gt;HBASE-12895&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="14286410" author="hadoopqa" created="Wed, 21 Jan 2015 22:19:17 +0000"  >&lt;p&gt;&lt;font color=&quot;green&quot;&gt;+1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12693688/HBASE-12728-5.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12693688/HBASE-12728-5.patch&lt;/a&gt;&lt;br/&gt;
  against master branch at commit 9bdb81f0a1db308a8a452379455b6bbfe70ea20d.&lt;br/&gt;
  ATTACHMENT ID: 12693688&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 99 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javadoc&lt;/font&gt;.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 checkstyle&lt;/font&gt;.  The applied patch does not increase the total number of checkstyle errors&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any new Findbugs (version 2.0.3) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 core tests&lt;/font&gt;.  The patch passed unit tests in .&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-rest.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-rest.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-annotations.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-annotations.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Checkstyle Errors: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/checkstyle-aggregate.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//artifact/patchprocess/checkstyle-aggregate.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;  Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12527//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14286621" author="enis" created="Thu, 22 Jan 2015 00:20:17 +0000"  >&lt;p&gt;Forwarding my +1 from RB. &lt;/p&gt;</comment>
                            <comment id="14286777" author="stack" created="Thu, 22 Jan 2015 02:04:39 +0000"  >&lt;p&gt;Also forwarding +1 from RB. Nice release  note.&lt;/p&gt;</comment>
                            <comment id="14286779" author="stack" created="Thu, 22 Jan 2015 02:05:21 +0000"  >&lt;p&gt;This work for you &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=abeppu&quot; class=&quot;user-hover&quot; rel=&quot;abeppu&quot;&gt;Aaron Beppu&lt;/a&gt; ? &lt;/p&gt;</comment>
                            <comment id="14286815" author="abeppu" created="Thu, 22 Jan 2015 02:23:19 +0000"  >&lt;p&gt;Yeah, LGTM.&lt;/p&gt;</comment>
                            <comment id="14286817" author="abeppu" created="Thu, 22 Jan 2015 02:23:22 +0000"  >&lt;p&gt;Yeah, LGTM.&lt;/p&gt;</comment>
                            <comment id="14286818" author="abeppu" created="Thu, 22 Jan 2015 02:23:22 +0000"  >&lt;p&gt;Yeah, LGTM.&lt;/p&gt;</comment>
                            <comment id="14286819" author="abeppu" created="Thu, 22 Jan 2015 02:23:23 +0000"  >&lt;p&gt;Yeah, LGTM.&lt;/p&gt;</comment>
                            <comment id="14286820" author="abeppu" created="Thu, 22 Jan 2015 02:23:34 +0000"  >&lt;p&gt;Yeah, LGTM.&lt;/p&gt;</comment>
                            <comment id="14286822" author="abeppu" created="Thu, 22 Jan 2015 02:24:08 +0000"  >&lt;p&gt;Sorry, connection was being janky, and I thought my replies weren&apos;t going through. Ugh. Will attempt to delete repeats.&lt;/p&gt;</comment>
                            <comment id="14287754" author="sduskis" created="Thu, 22 Jan 2015 17:07:09 +0000"  >&lt;p&gt;I like the change to mutate() rather than put().  I&apos;m also very grateful for someone else having taken over this critical work.  I do have a couple of preferences:&lt;/p&gt;

&lt;p&gt;1) I&apos;m guessing that Delete objects won&apos;t be as big as Puts as far as heapSize is concerned.  It might not be appropriate to use the currentWriteBufferSize to track Deletes like it is for Puts.  Perhaps something more like a deleteCount would be appropriate?&lt;/p&gt;

&lt;p&gt;2) Since BufferedMutatorBuilder is passed into the Connection object, I&apos;d prefer that it doesn&apos;t have any references to internal classes such as ClusterConnection, RpcRetryingCallerFactory and RpcControllerFactory.  I&apos;d also prefer that it doesn&apos;t return a BufferedMutatorImpl, and that the Connection would be responsible for the initialization.  &lt;/p&gt;</comment>
                            <comment id="14288027" author="ndimiduk" created="Thu, 22 Jan 2015 19:16:19 +0000"  >&lt;blockquote&gt;&lt;p&gt;1) I&apos;m guessing that Delete objects won&apos;t be as big as Puts as far as heapSize is concerned. It might not be appropriate to use the currentWriteBufferSize to track Deletes like it is for Puts. Perhaps something more like a deleteCount would be appropriate?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Interesting idea. How would we surface this to the user? Flush when writeBuffer gets to N size OR when number of deletes reaches X? Maybe we leave this as part of the existing caveat of &quot;buffer at your own risk&quot;?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;2) Since BufferedMutatorBuilder is passed into the Connection object, I&apos;d prefer that it doesn&apos;t have any references to internal classes such as ClusterConnection, RpcRetryingCallerFactory and RpcControllerFactory. I&apos;d also prefer that it doesn&apos;t return a BufferedMutatorImpl, and that the Connection would be responsible for the initialization.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I see what you&apos;re saying. BMB is straddling two worlds right now, both Interface and Implementation. I included those non-public setters as a convenience for passing the necessary pieces around between responsible parties. Because they&apos;re all in the same namespace, I figured it wouldn&apos;t hurt anything.&lt;/p&gt;

&lt;p&gt;Maybe build() should be a package-protected method &amp;#8211; it&apos;s not really intended to be called by the user anyway as they don&apos;t have all the setters they need to create a usable BufferedMutator instance. Or do you mean remove the build method entirely and just use it as a grab-bag of properties?&lt;/p&gt;</comment>
                            <comment id="14288039" author="ndimiduk" created="Thu, 22 Jan 2015 19:19:34 +0000"  >&lt;p&gt;Attaching patches back ported to branch-1 and branch-1.0, based on the latest patch from master. I&apos;m spinning them both through tests locally.&lt;/p&gt;</comment>
                            <comment id="14288044" author="hadoopqa" created="Thu, 22 Jan 2015 19:22:02 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12693966/HBASE-12728.05-branch-1.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12693966/HBASE-12728.05-branch-1.patch&lt;/a&gt;&lt;br/&gt;
  against master branch at commit 319f9bb7918af8cfe7e65f97b654f37f0d5983f3.&lt;br/&gt;
  ATTACHMENT ID: 12693966&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 144 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 patch&lt;/font&gt;.  The patch command could not apply the patch.&lt;/p&gt;

&lt;p&gt;Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12554//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12554//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14288269" author="ndimiduk" created="Thu, 22 Jan 2015 21:45:48 +0000"  >&lt;p&gt;Addressing &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt;&apos;s (and others&apos;) concerns about the builder thingy. Now it&apos;s a params thingy with no build and no details beyond its public getter/setters. Connection is now responsible for call the BufferedMutatorImpl constructor and providing the necessary additional parameters.&lt;/p&gt;</comment>
                            <comment id="14288292" author="ndimiduk" created="Thu, 22 Jan 2015 22:02:00 +0000"  >&lt;p&gt;Patches for branch-1.0 and branch-1.&lt;/p&gt;</comment>
                            <comment id="14288325" author="hadoopqa" created="Thu, 22 Jan 2015 22:17:43 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12694008/HBASE-12728.06-branch-1.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12694008/HBASE-12728.06-branch-1.patch&lt;/a&gt;&lt;br/&gt;
  against master branch at commit e370baf8a50adb0533bf6cae78f7b7986bdd2714.&lt;br/&gt;
  ATTACHMENT ID: 12694008&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 144 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 patch&lt;/font&gt;.  The patch command could not apply the patch.&lt;/p&gt;

&lt;p&gt;Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12561//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12561//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14288464" author="enis" created="Thu, 22 Jan 2015 23:40:59 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt; you good with the latest? &lt;/p&gt;</comment>
                            <comment id="14288663" author="ndimiduk" created="Fri, 23 Jan 2015 03:08:02 +0000"  >&lt;p&gt;BuildBot seems out to lunch. Rebased, reattached.&lt;/p&gt;</comment>
                            <comment id="14288791" author="hadoopqa" created="Fri, 23 Jan 2015 05:46:11 +0000"  >&lt;p&gt;&lt;font color=&quot;green&quot;&gt;+1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12694075/HBASE-12728-6.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12694075/HBASE-12728-6.patch&lt;/a&gt;&lt;br/&gt;
  against master branch at commit 5fbf80ee5ecb288804d2d2d042199dcd834ae848.&lt;br/&gt;
  ATTACHMENT ID: 12694075&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 126 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javadoc&lt;/font&gt;.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 checkstyle&lt;/font&gt;.  The applied patch does not increase the total number of checkstyle errors&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any new Findbugs (version 2.0.3) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 core tests&lt;/font&gt;.  The patch passed unit tests in .&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop2-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-prefix-tree.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-annotations.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-annotations.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-client.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-client.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-rest.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-rest.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-protocol.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-protocol.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-hadoop-compat.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-examples.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-examples.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-thrift.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/newPatchFindbugsWarningshbase-thrift.html&lt;/a&gt;&lt;br/&gt;
Checkstyle Errors: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/checkstyle-aggregate.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//artifact/patchprocess/checkstyle-aggregate.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;  Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/12564//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14289536" author="ndimiduk" created="Fri, 23 Jan 2015 17:14:55 +0000"  >&lt;p&gt;Pushed to branch-1.0+. Thanks a lot to &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt; for taking this one on, and everyone for the reviews.&lt;/p&gt;</comment>
                            <comment id="14289711" author="hudson" created="Fri, 23 Jan 2015 18:50:08 +0000"  >&lt;p&gt;FAILURE: Integrated in HBase-1.1 #101 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-1.1/101/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-1.1/101/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12728&quot; title=&quot;buffered writes substantially less useful after removal of HTablePool&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12728&quot;&gt;&lt;del&gt;HBASE-12728&lt;/del&gt;&lt;/a&gt; buffered writes substantially less useful after removal of HTablePool (Solomon Duskis and Nick Dimiduk) (ndimiduk: rev 8556e2598e6885b15ce44843aa52589e53d2e601)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRegionServerMetrics.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/BufferedMutatorImpl.java&lt;/li&gt;
	&lt;li&gt;hbase-it/src/test/java/org/apache/hadoop/hbase/test/IntegrationTestLoadAndVerify.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/mapred/TableOutputFormat.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestCloneSnapshotFromClient.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/HTableInterface.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/client/HTableWrapper.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/MultiTableOutputFormat.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/PerformanceEvaluation.java&lt;/li&gt;
	&lt;li&gt;hbase-rest/src/main/java/org/apache/hadoop/hbase/rest/RowResource.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestEndToEndSplitTransaction.java&lt;/li&gt;
	&lt;li&gt;hbase-it/src/test/java/org/apache/hadoop/hbase/test/IntegrationTestBigLinkedList.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/replication/TestReplicationSmallTests.java&lt;/li&gt;
	&lt;li&gt;hbase-examples/src/main/java/org/apache/hadoop/hbase/client/example/BufferedMutatorExample.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRegionFavoredNodes.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMultiParallel.java&lt;/li&gt;
	&lt;li&gt;hbase-rest/src/test/java/org/apache/hadoop/hbase/rest/PerformanceEvaluation.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabelsReplication.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/HTable.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/BufferedMutator.java&lt;/li&gt;
	&lt;li&gt;hbase-rest/src/test/java/org/apache/hadoop/hbase/rest/client/TestRemoteTable.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestDistributedLogSplitting.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/TestRestoreFlushSnapshotFromClient.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/Table.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMaster.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.java&lt;/li&gt;
	&lt;li&gt;hbase-it/src/test/java/org/apache/hadoop/hbase/test/IntegrationTestWithCellVisibilityLoadAndVerify.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestAsyncProcess.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionAdapter.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestScannerWithBulkload.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/wal/TestLogRolling.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestClientPushback.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/coprocessor/TestHTableWrapper.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/Connection.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestClientNoCluster.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/TestFlushSnapshotFromClient.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/SnapshotTestingUtils.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/BufferedMutatorParams.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/replication/TestReplicationWithTags.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestFSErrorsExposed.java&lt;/li&gt;
	&lt;li&gt;hbase-it/src/test/java/org/apache/hadoop/hbase/trace/IntegrationTestSendTraceRequests.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/TableConfiguration.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionManager.java&lt;/li&gt;
	&lt;li&gt;hbase-it/src/test/java/org/apache/hadoop/hbase/test/IntegrationTestBigLinkedListWithVisibility.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/replication/TestReplicationChangingPeerRegionservers.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestRpcControllerFactory.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestRestoreSnapshotFromClient.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14289715" author="hudson" created="Fri, 23 Jan 2015 18:53:07 +0000"  >&lt;p&gt;FAILURE: Integrated in HBase-1.0 #678 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-1.0/678/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-1.0/678/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12728&quot; title=&quot;buffered writes substantially less useful after removal of HTablePool&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12728&quot;&gt;&lt;del&gt;HBASE-12728&lt;/del&gt;&lt;/a&gt; buffered writes substantially less useful after removal of HTablePool (Solomon Duskis and Nick Dimiduk) (ndimiduk: rev 7bbbaaeb53295d3a50b9d863f3c01801df0a78b4)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/client/HTableWrapper.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/PerformanceEvaluation.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRegionFavoredNodes.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/TableConfiguration.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/replication/TestReplicationChangingPeerRegionservers.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMaster.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestClientNoCluster.java&lt;/li&gt;
	&lt;li&gt;hbase-rest/src/test/java/org/apache/hadoop/hbase/rest/client/TestRemoteTable.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/replication/TestReplicationWithTags.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestScannerWithBulkload.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestFSErrorsExposed.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/replication/TestReplicationSmallTests.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionAdapter.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestRestoreSnapshotFromClient.java&lt;/li&gt;
	&lt;li&gt;hbase-rest/src/main/java/org/apache/hadoop/hbase/rest/RowResource.java&lt;/li&gt;
	&lt;li&gt;hbase-it/src/test/java/org/apache/hadoop/hbase/trace/IntegrationTestSendTraceRequests.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/HTableInterface.java&lt;/li&gt;
	&lt;li&gt;hbase-it/src/test/java/org/apache/hadoop/hbase/test/IntegrationTestBigLinkedListWithVisibility.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestEndToEndSplitTransaction.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMultiParallel.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestClientPushback.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/HTable.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestCloneSnapshotFromClient.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/Connection.java&lt;/li&gt;
	&lt;li&gt;hbase-examples/src/main/java/org/apache/hadoop/hbase/client/example/BufferedMutatorExample.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestDistributedLogSplitting.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionManager.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/BufferedMutatorParams.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/BufferedMutatorImpl.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/TestFlushSnapshotFromClient.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/TestRestoreFlushSnapshotFromClient.java&lt;/li&gt;
	&lt;li&gt;hbase-it/src/test/java/org/apache/hadoop/hbase/test/IntegrationTestWithCellVisibilityLoadAndVerify.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/Table.java&lt;/li&gt;
	&lt;li&gt;hbase-rest/src/test/java/org/apache/hadoop/hbase/rest/PerformanceEvaluation.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestAsyncProcess.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/SnapshotTestingUtils.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/BufferedMutator.java&lt;/li&gt;
	&lt;li&gt;hbase-it/src/test/java/org/apache/hadoop/hbase/test/IntegrationTestBigLinkedList.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/MultiTableOutputFormat.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/coprocessor/TestHTableWrapper.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestRpcControllerFactory.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRegionServerMetrics.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/mapred/TableOutputFormat.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabelsReplication.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/wal/TestLogRolling.java&lt;/li&gt;
	&lt;li&gt;hbase-it/src/test/java/org/apache/hadoop/hbase/test/IntegrationTestLoadAndVerify.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14289774" author="hudson" created="Fri, 23 Jan 2015 19:21:25 +0000"  >&lt;p&gt;FAILURE: Integrated in HBase-TRUNK #6049 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-TRUNK/6049/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-TRUNK/6049/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12728&quot; title=&quot;buffered writes substantially less useful after removal of HTablePool&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12728&quot;&gt;&lt;del&gt;HBASE-12728&lt;/del&gt;&lt;/a&gt; buffered writes substantially less useful after removal of HTablePool (Solomon Duskis and Nick Dimiduk) (ndimiduk: rev ab18158e6001a7f15a35679ca8fc7ff772f90e25)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/coprocessor/TestHTableWrapper.java&lt;/li&gt;
	&lt;li&gt;hbase-rest/src/test/java/org/apache/hadoop/hbase/rest/PerformanceEvaluation.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/BufferedMutatorImpl.java&lt;/li&gt;
	&lt;li&gt;hbase-it/src/test/java/org/apache/hadoop/hbase/test/IntegrationTestWithCellVisibilityLoadAndVerify.java&lt;/li&gt;
	&lt;li&gt;hbase-it/src/test/java/org/apache/hadoop/hbase/test/IntegrationTestBigLinkedList.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabelsReplication.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionManager.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/mapred/TableOutputFormat.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionAdapter.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/replication/TestReplicationChangingPeerRegionservers.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/Connection.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestClientPushback.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestDistributedLogSplitting.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/Table.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestFSErrorsExposed.java&lt;/li&gt;
	&lt;li&gt;hbase-it/src/test/java/org/apache/hadoop/hbase/test/IntegrationTestLoadAndVerify.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/HTable.java&lt;/li&gt;
	&lt;li&gt;hbase-examples/src/main/java/org/apache/hadoop/hbase/client/example/BufferedMutatorExample.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/wal/TestLogRolling.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestScannerWithBulkload.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/PerformanceEvaluation.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestAsyncProcess.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/TestMultiVersions.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRegionFavoredNodes.java&lt;/li&gt;
	&lt;li&gt;hbase-it/src/test/java/org/apache/hadoop/hbase/trace/IntegrationTestSendTraceRequests.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/BufferedMutator.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/TestFlushSnapshotFromClient.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMaster.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMultiParallel.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestRestoreSnapshotFromClient.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/client/HTableWrapper.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/replication/TestReplicationWithTags.java&lt;/li&gt;
	&lt;li&gt;hbase-it/src/test/java/org/apache/hadoop/hbase/test/IntegrationTestBigLinkedListWithVisibility.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestRpcControllerFactory.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestEndToEndSplitTransaction.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/SnapshotTestingUtils.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/mapreduce/MultiTableOutputFormat.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/HTableInterface.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestCloneSnapshotFromClient.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/BufferedMutatorParams.java&lt;/li&gt;
	&lt;li&gt;hbase-rest/src/test/java/org/apache/hadoop/hbase/rest/client/TestRemoteTable.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/snapshot/TestRestoreFlushSnapshotFromClient.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/replication/TestReplicationSmallTests.java&lt;/li&gt;
	&lt;li&gt;hbase-rest/src/main/java/org/apache/hadoop/hbase/rest/RowResource.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/TableConfiguration.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRegionServerMetrics.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestClientNoCluster.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14289782" author="enis" created="Fri, 23 Jan 2015 19:24:24 +0000"  >&lt;p&gt;Great! Thanks for the work everyone. &lt;/p&gt;</comment>
                            <comment id="14289793" author="ndimiduk" created="Fri, 23 Jan 2015 19:33:56 +0000"  >&lt;p&gt;Some of these failures look related. Let me cleanup.&lt;/p&gt;</comment>
                            <comment id="14290126" author="enis" created="Fri, 23 Jan 2015 22:27:11 +0000"  >&lt;p&gt;Agreed, this looks related : &lt;a href=&quot;https://builds.apache.org/view/All/job/HBase-1.0/678/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/view/All/job/HBase-1.0/678/&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14290157" author="ndimiduk" created="Fri, 23 Jan 2015 22:43:55 +0000"  >&lt;p&gt;Sorry for the delay. This fixes the failing TestAssignmentManager.&lt;/p&gt;</comment>
                            <comment id="14290158" author="ndimiduk" created="Fri, 23 Jan 2015 22:44:35 +0000"  >&lt;p&gt;I&apos;m not sure about TestFSErrorsExposed.testFullSystemBubblesFSErrors&lt;/p&gt;</comment>
                            <comment id="14290265" author="hudson" created="Sat, 24 Jan 2015 00:26:47 +0000"  >&lt;p&gt;SUCCESS: Integrated in HBase-TRUNK #6050 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-TRUNK/6050/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-TRUNK/6050/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12728&quot; title=&quot;buffered writes substantially less useful after removal of HTablePool&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12728&quot;&gt;&lt;del&gt;HBASE-12728&lt;/del&gt;&lt;/a&gt; buffered writes substantially less useful after removal of HTablePool (addendum) (ndimiduk: rev 588b43b06ba9a3434dc2178b5b014283cc959d62)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/HTable.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14290281" author="hudson" created="Sat, 24 Jan 2015 00:42:32 +0000"  >&lt;p&gt;FAILURE: Integrated in HBase-1.1 #103 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-1.1/103/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-1.1/103/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12728&quot; title=&quot;buffered writes substantially less useful after removal of HTablePool&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12728&quot;&gt;&lt;del&gt;HBASE-12728&lt;/del&gt;&lt;/a&gt; buffered writes substantially less useful after removal of HTablePool (addendum) (ndimiduk: rev 4b9eaf585124094f02db41cc4f84805e936417b3)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/HTable.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14290287" author="yuzhihong@gmail.com" created="Sat, 24 Jan 2015 00:51:57 +0000"  >&lt;p&gt;Addendum for 1.0 allows TestFSErrorsExposed to pass.&lt;/p&gt;</comment>
                            <comment id="14290295" author="hudson" created="Sat, 24 Jan 2015 00:57:07 +0000"  >&lt;p&gt;FAILURE: Integrated in HBase-1.0 #680 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-1.0/680/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-1.0/680/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12728&quot; title=&quot;buffered writes substantially less useful after removal of HTablePool&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12728&quot;&gt;&lt;del&gt;HBASE-12728&lt;/del&gt;&lt;/a&gt; buffered writes substantially less useful after removal of HTablePool (addendum) (ndimiduk: rev baf879967a41151293e780bc32092046a3aa7af2)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/HTable.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14290321" author="ndimiduk" created="Sat, 24 Jan 2015 01:18:35 +0000"  >&lt;blockquote&gt;&lt;p&gt;Addendum for 1.0 allows TestFSErrorsExposed to pass&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s extremely subtle; I&apos;d have thought those lines equivalent. Why does it allow the test to pass?&lt;/p&gt;</comment>
                            <comment id="14290360" author="ndimiduk" created="Sat, 24 Jan 2015 01:54:31 +0000"  >&lt;p&gt;addendum2 doesn&apos;t resolve this issue for me on branch-1.0. branch-1 appears to not have the problem.&lt;/p&gt;</comment>
                            <comment id="14290400" author="yuzhihong@gmail.com" created="Sat, 24 Jan 2015 03:00:25 +0000"  >&lt;p&gt;After doing a clean build, the test doesn&apos;t pass with addendum 2.&lt;br/&gt;
Though there&apos;re a lot of exceptions:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
2015-01-23 18:56:53,209 WARN  [PriorityRpcServer.handler=2,queue=0,port=52379] hdfs.DFSInputStream(1078): Connection failure: Failed to connect to /127.0.0.1:52369 &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; file /    user/tyu/test-data/58b7b2ea-9919-4535-baf5-c3ed27fce466/data/hbase/meta/1588230740/info/517adf8439d34234bf13b9c98d8ebdfd &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; block BP-1225607801-192.168.0.19-1422068063192:      blk_1073741838_1014:java.net.ConnectException: Connection refused
java.net.ConnectException: Connection refused
  at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)
  at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:739)
...
  at org.apache.hadoop.hbase.regionserver.HRegion.getScanner(HRegion.java:2118)
  at org.apache.hadoop.hbase.regionserver.RSRpcServices.scan(RSRpcServices.java:2033)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;the exceptions are not bubbled up to caller.&lt;br/&gt;
Debugging.&lt;/p&gt;</comment>
                            <comment id="14290424" author="yuzhihong@gmail.com" created="Sat, 24 Jan 2015 04:16:57 +0000"  >&lt;p&gt;Placing a breakpoint on the following line in StoreFileScanner :&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
      &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IOException(&lt;span class=&quot;code-quote&quot;&gt;&quot;Could not seek &quot;&lt;/span&gt; + &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; + &lt;span class=&quot;code-quote&quot;&gt;&quot; to key &quot;&lt;/span&gt; + key, ioe);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I found that it was in hbase:meta scanning where the above breakpoint got hit.&lt;br/&gt;
However, this IOE was not delivered to TestFSErrorsExposed.&lt;/p&gt;</comment>
                            <comment id="14290428" author="enis" created="Sat, 24 Jan 2015 04:26:02 +0000"  >&lt;p&gt;I think the problem is that, because of the retries in branch-1.0 is done 3 times for the region lookup, where each lookup does 3 retries of its own from DFSInputStream causing a timeout on the original scan RPC so causing a SocketTimeout (60 sec) instead of IOException as expected from the test. &lt;/p&gt;

&lt;p&gt;Notice that we set the retries number in 2 places in the test: &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
      &lt;span class=&quot;code-comment&quot;&gt;// We set it not to run or it will trigger server shutdown &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; sync&apos;ing
&lt;/span&gt;      &lt;span class=&quot;code-comment&quot;&gt;// because all the datanodes are bad
&lt;/span&gt;      util.getConfiguration().setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER, 3);
     ...
      util.getConfiguration().setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER, 1);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Notice that the Connection in util is created before the second set, so it gets the retries number from the initial set, which is 3. That is why the test fails in branch-1.0. In branch-1 and master, the connection still have retries of 3, but due to &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12761&quot; title=&quot;On region jump ClientScanners should get next row start key instead of a skip.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12761&quot;&gt;&lt;del&gt;HBASE-12761&lt;/del&gt;&lt;/a&gt;, the scanner initialization have changed, making the first try throw the exception. &lt;/p&gt;

&lt;p&gt;Attached patch fixes the problem. We can commit it to all 3 branches (it does not affect branch-1 and master but good to have). &lt;/p&gt;</comment>
                            <comment id="14290430" author="yuzhihong@gmail.com" created="Sat, 24 Jan 2015 04:32:09 +0000"  >&lt;p&gt;I was thinking of making the same change.&lt;br/&gt;
+1&lt;/p&gt;

&lt;p&gt;Wondering why the original test sets retry count twice.&lt;/p&gt;</comment>
                            <comment id="14290435" author="yuzhihong@gmail.com" created="Sat, 24 Jan 2015 04:47:11 +0000"  >&lt;p&gt;I think addendum 3 should only be applied to branch-1.0 - due to the limitation cited above.&lt;/p&gt;

&lt;p&gt;For branch-1 and master, let&apos;s keep the current test code - when TestFSErrorsExposed#testFullSystemBubblesFSErrors times out, we know there is a regression.&lt;/p&gt;</comment>
                            <comment id="14290812" author="ndimiduk" created="Sat, 24 Jan 2015 20:22:56 +0000"  >&lt;blockquote&gt;&lt;p&gt;Wondering why the original test sets retry count twice.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think this was intentional.&lt;/p&gt;

&lt;p&gt;&lt;ins&gt;1 for addendum 3 for branch-1.0&lt;/ins&gt;, the test passes with this change on all 3 branches. Looks like good cleanup of the test.&lt;/p&gt;

&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=tedyu&quot; class=&quot;user-hover&quot; rel=&quot;tedyu&quot;&gt;Ted Yu&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=enis&quot; class=&quot;user-hover&quot; rel=&quot;enis&quot;&gt;Enis Soztutar&lt;/a&gt; for investigating.&lt;/p&gt;</comment>
                            <comment id="14290950" author="enis" created="Sun, 25 Jan 2015 02:03:01 +0000"  >&lt;p&gt;I&apos;ve pushed the addendum to all three branches. Thanks Ted and Nick. &lt;/p&gt;</comment>
                            <comment id="14290970" author="hudson" created="Sun, 25 Jan 2015 03:31:41 +0000"  >&lt;p&gt;SUCCESS: Integrated in HBase-TRUNK #6052 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-TRUNK/6052/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-TRUNK/6052/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12728&quot; title=&quot;buffered writes substantially less useful after removal of HTablePool&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12728&quot;&gt;&lt;del&gt;HBASE-12728&lt;/del&gt;&lt;/a&gt; buffered writes substantially less useful after removal of HTablePool (addendum for failing test in branch-1.0) (enis: rev e05341d01d3d1a5bac08359babfdd9cfad05052e)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestFSErrorsExposed.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14290974" author="hudson" created="Sun, 25 Jan 2015 03:51:39 +0000"  >&lt;p&gt;SUCCESS: Integrated in HBase-1.1 #104 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-1.1/104/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-1.1/104/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12728&quot; title=&quot;buffered writes substantially less useful after removal of HTablePool&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12728&quot;&gt;&lt;del&gt;HBASE-12728&lt;/del&gt;&lt;/a&gt; buffered writes substantially less useful after removal of HTablePool (addendum for failing test in branch-1.0) (enis: rev e180f0bdd1534910a20da0b02894249537628a7a)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestFSErrorsExposed.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14290977" author="hudson" created="Sun, 25 Jan 2015 04:01:09 +0000"  >&lt;p&gt;SUCCESS: Integrated in HBase-1.0 #681 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-1.0/681/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-1.0/681/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12728&quot; title=&quot;buffered writes substantially less useful after removal of HTablePool&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12728&quot;&gt;&lt;del&gt;HBASE-12728&lt;/del&gt;&lt;/a&gt; buffered writes substantially less useful after removal of HTablePool (addendum for failing test in branch-1.0) (enis: rev 1f0eb701dfc2794654c130f600a1614572155f17)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestFSErrorsExposed.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14331906" author="enis" created="Sat, 21 Feb 2015 23:49:58 +0000"  >&lt;p&gt;Closing this issue after 1.0.0 release.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310060">
                    <name>Container</name>
                                            <outwardlinks description="contains">
                                        <issuelink>
            <issuekey id="12764797">HBASE-12802</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12857077">YARN-4061</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13017903">HBASE-17018</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12769085">HBASE-12895</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12694306" name="12728-1.0-addendum-2.txt" size="817" author="yuzhihong@gmail.com" created="Sat, 24 Jan 2015 00:51:57 +0000"/>
                            <attachment id="12690605" name="12728.connection-owns-buffers.example.branch-1.0.patch" size="32227" author="ndimiduk" created="Wed, 7 Jan 2015 20:23:49 +0000"/>
                            <attachment id="12692239" name="HBASE-12728-2.patch" size="154000" author="sduskis" created="Wed, 14 Jan 2015 15:52:53 +0000"/>
                            <attachment id="12693172" name="HBASE-12728-3.patch" size="150340" author="ndimiduk" created="Mon, 19 Jan 2015 23:11:03 +0000"/>
                            <attachment id="12693458" name="HBASE-12728-4.patch" size="151664" author="ndimiduk" created="Wed, 21 Jan 2015 00:57:06 +0000"/>
                            <attachment id="12693688" name="HBASE-12728-5.patch" size="160557" author="ndimiduk" created="Wed, 21 Jan 2015 20:10:31 +0000"/>
                            <attachment id="12694075" name="HBASE-12728-6.patch" size="164854" author="ndimiduk" created="Fri, 23 Jan 2015 03:08:02 +0000"/>
                            <attachment id="12694004" name="HBASE-12728-6.patch" size="164854" author="ndimiduk" created="Thu, 22 Jan 2015 21:45:48 +0000"/>
                            <attachment id="12693965" name="HBASE-12728.05-branch-1.0.patch" size="168544" author="ndimiduk" created="Thu, 22 Jan 2015 19:19:34 +0000"/>
                            <attachment id="12693966" name="HBASE-12728.05-branch-1.patch" size="168130" author="ndimiduk" created="Thu, 22 Jan 2015 19:19:34 +0000"/>
                            <attachment id="12694007" name="HBASE-12728.06-branch-1.0.patch" size="167352" author="ndimiduk" created="Thu, 22 Jan 2015 22:02:00 +0000"/>
                            <attachment id="12694008" name="HBASE-12728.06-branch-1.patch" size="166922" author="ndimiduk" created="Thu, 22 Jan 2015 22:02:00 +0000"/>
                            <attachment id="12694275" name="HBASE-12728.addendum.patch" size="1055" author="ndimiduk" created="Fri, 23 Jan 2015 22:43:55 +0000"/>
                            <attachment id="12692039" name="HBASE-12728.patch" size="164976" author="sduskis" created="Tue, 13 Jan 2015 20:27:25 +0000"/>
                            <attachment id="12690944" name="bulk-mutator.patch" size="119136" author="sduskis" created="Thu, 8 Jan 2015 21:15:55 +0000"/>
                            <attachment id="12694330" name="hbase-12728-1.0-addendum-3.patch" size="1669" author="enis" created="Sat, 24 Jan 2015 04:26:02 +0000"/>
                    </attachments>
                <subtasks>
                            <subtask id="12764797">HBASE-12802</subtask>
                            <subtask id="12765007">HBASE-12809</subtask>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>16.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 19 Dec 2014 18:47:55 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310191" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Hadoop Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10343"><![CDATA[Reviewed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            1 year, 42 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i23mvz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310192" key="com.atlassian.jira.plugin.system.customfieldtypes:textarea">
                        <customfieldname>Release Note</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>In our pre-1.0 API, HTable is considered a light-weight object that consumed by a single thread at a time. The HTablePool class provided a means of sharing multiple HTable instances across a number of threads. As an optimization, HTable managed a &amp;quot;write buffer&amp;quot;, accumulating edits and sending a &amp;quot;batch&amp;quot; all at once. By default the batch was sent as the last step in invocations of put(Put) and put(List&amp;lt;Put&amp;gt;). The user could disable the automatic flushing of the write buffer, retaining edits locally and only sending the whole &amp;quot;batch&amp;quot; once the write buffer has filled or when the flushCommits() method in invoked explicitly. Explicit or implicit batch writing was controlled by the setAutoFlushTo(boolean) method. A value of true (the default) had the write buffer flushed at the completion of a call to put(Put) or put(List&amp;lt;Put&amp;gt;). A value of false allowed for explicit buffer management. HTable also exposed the buffer to consumers via getWriteBuffer().&lt;br/&gt;
&lt;br/&gt;
The combination of HTable with setAutoFlushTo(false) and the HTablePool provided a convenient mechanism by which multiple &amp;quot;Put-producing&amp;quot; threads could share a common write buffer. Both HTablePool and HTable are deprecated, and they are officially replaced in The new 1.0 API by Table and BufferedMutator. Table, which replaces HTable, no longer exposes explicit write-buffer management. Instead, explicit buffer management is exposed via BufferedMutator. BufferedMutator is made safe for concurrent use. Where code would previously retrieve and return HTables from an HTablePool, now that code creates and shares a single BufferedMutator instance across all threads.</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>