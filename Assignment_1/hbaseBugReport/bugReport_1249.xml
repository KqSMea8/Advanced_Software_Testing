<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 18:51:57 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-1249/HBASE-1249.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-1249] Rearchitecting of server, client, API, key format, etc for 0.20</title>
                <link>https://issues.apache.org/jira/browse/HBASE-1249</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;To discuss all the new and potential issues coming out of the change in key format (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1234&quot; title=&quot;Change HBase StoreKey format&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1234&quot;&gt;&lt;del&gt;HBASE-1234&lt;/del&gt;&lt;/a&gt;): zero-copy reads, client binary protocol, update of API (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-880&quot; title=&quot;Improve the current client API by creating new container classes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-880&quot;&gt;&lt;del&gt;HBASE-880&lt;/del&gt;&lt;/a&gt;), server optimizations, etc...&lt;/p&gt;</description>
                <environment></environment>
        <key id="12416456">HBASE-1249</key>
            <summary>Rearchitecting of server, client, API, key format, etc for 0.20</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.png">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="6">Invalid</resolution>
                                        <assignee username="streamy">Jonathan Gray</assignee>
                                    <reporter username="streamy">Jonathan Gray</reporter>
                        <labels>
                    </labels>
                <created>Mon, 9 Mar 2009 17:32:25 +0000</created>
                <updated>Sun, 13 Sep 2009 22:24:27 +0000</updated>
                            <resolved>Tue, 26 May 2009 15:55:38 +0000</resolved>
                                                    <fixVersion>0.20.0</fixVersion>
                                        <due></due>
                            <votes>1</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="12680214" author="stack" created="Mon, 9 Mar 2009 17:51:24 +0000"  >&lt;p&gt;Thanks for opening this Jon.&lt;/p&gt;

&lt;p&gt;I&apos;m currently working on changing the key format, &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1234&quot; title=&quot;Change HBase StoreKey format&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1234&quot;&gt;&lt;del&gt;HBASE-1234&lt;/del&gt;&lt;/a&gt;, as part of a regionserver rewrite that does away with HStoreKey replacing it with a new org.apache.hadoop.hbase.regionserver.KeyValue data structure that lives inside a ByteBuffer.  The new key format is described in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1234&quot; title=&quot;Change HBase StoreKey format&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1234&quot;&gt;&lt;del&gt;HBASE-1234&lt;/del&gt;&lt;/a&gt; and its latest manifestation can be found in the github repositiory here: &lt;a href=&quot;http://github.com/ryanobjc/hbase/blob/5ed35fb55bd4ba2404ecbc94c6c45d7c8a7162e4/src/java/org/apache/hadoop/hbase/regionserver/KeyValue.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://github.com/ryanobjc/hbase/blob/5ed35fb55bd4ba2404ecbc94c6c45d7c8a7162e4/src/java/org/apache/hadoop/hbase/regionserver/KeyValue.java&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here is from the class comment:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
* Utility &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; making, comparing and fetching pieces of a hbase KeyValue blob.
* Blob format is: &amp;lt;keylength&amp;gt; &amp;lt;valuelength&amp;gt; &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;
* Key is decomposed as: &amp;lt;rowlength&amp;gt; &amp;lt;row&amp;gt; &amp;lt;columnfamilylength&amp;gt; &amp;lt;columnfamily&amp;gt; &amp;lt;columnqualifier&amp;gt; &amp;lt;timestamp&amp;gt; &amp;lt;keytype&amp;gt;
* Rowlength maximum is &lt;span class=&quot;code-object&quot;&gt;Short&lt;/span&gt;.MAX_SIZE, column family length maximum is
* &lt;span class=&quot;code-object&quot;&gt;Byte&lt;/span&gt;.MAX_SIZE, and column qualifier + value length must be &amp;lt; &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;.MAX_SIZE.
* The column does not contain the family/qualifier delimiter.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here are some notes on what I&apos;ve learned as part of the rewrite:&lt;/p&gt;

&lt;p&gt;+ Turns out we were doing a bunch of expensive column matching lookup operations &amp;#8211; 10%+ of all CPU in recent seek+scan 1000 rows test &amp;#8211; that were not necessary at all.  The column match was being done in a store/family context so a bunch of the column family parse and fetching from maps of column matchers to find what to use in a particular column context were not needed.&lt;br/&gt;
+ How deletes work will have to be redone now we have a richer delete vocabulary.  What was there previous was ugly anyways so no harm in a rewrite except for the work debugging new implementation.&lt;br/&gt;
+ We need to make the ByteBuffer that holds the KV that comes out hfile read-only&lt;br/&gt;
+ Will need to redo memcache size calculations (need Ryan and Erik help here).&lt;/p&gt;
</comment>
                            <comment id="12680601" author="erikholstad@gmail.com" created="Tue, 10 Mar 2009 20:14:45 +0000"  >&lt;p&gt;Looks good!&lt;br/&gt;
A couple of things that I&apos;ve been thinking about are:&lt;br/&gt;
1. For deletes I think it would make sense to not build the delete set alongside but instead delete the column in the asked for column list. So when going though memCache and the stores, when coming to a delete, just remove it from the get list.&lt;br/&gt;
2. I think that the setting of the timestamp should not be exposed to the user but, be set by HBase at all times. This limitation simplifies a lot when reasoning about the order across storefiles and client formats, to make it as fast, early outs and simple, list instead of map, as possible.&lt;br/&gt;
3. The client return type RowResult seems to be a pretty good general purpose return format, but think we should have an option to get the list&amp;lt;ByteBuffer&amp;gt; instead so that when you have knowledge about what kind of data that you have in your system you can make the format much easier, for example if you are asking for 1 row, 1 family, all columns and 1 version you only need map&amp;lt;qf, value&amp;gt; or a list of tuples.&lt;/p&gt;

&lt;p&gt;Looking at the implementation for the KeyValue there are a couple of things that I want to bring up.&lt;br/&gt;
The Type has some unused bits that can be used in the future for different flags, just to keep in mind.&lt;br/&gt;
I&apos;ve added a new constructor family on my branch in KeyValue that deals with separating the column into family and qualifier so that we don&apos;t need to look for : and then add it back after we are done. If you still want the : for printing purposes or what not you can put it in the family.&lt;/p&gt;


</comment>
                            <comment id="12680603" author="stack" created="Tue, 10 Mar 2009 20:31:56 +0000"  >&lt;p&gt;Thanks for the review Erik.&lt;/p&gt;

&lt;p&gt;On 1., I&apos;ve been thinking something similar &amp;#8211; do it in actual return list.  Need to keep the delete around though in case we come across a deleted value subsequently.  Was thinking just before we let the thing out of the server, we&apos;d remove deletes &amp;#8212; or something like that.&lt;/p&gt;

&lt;p&gt;On 2., thats a big change.  We should put it up on list.... something like remove timestamping till we do it right because meantime it only gives wrong impression.&lt;/p&gt;

&lt;p&gt;On 3., once we have server passing client Set of KVBBs, yes, we should do this as convenience for the perverse bit-shifters&lt;/p&gt;

&lt;p&gt;Yeah, the type has extra space.  We should remember that as you point out.&lt;/p&gt;

&lt;p&gt;Ok on the family/qualifier stuff; lets get it into the patch we commit.&lt;/p&gt;</comment>
                            <comment id="12680633" author="streamy" created="Tue, 10 Mar 2009 21:49:35 +0000"  >&lt;p&gt;Comments on above:&lt;/p&gt;

&lt;p&gt;1.  Not exactly following you, stack.  I think Erik&apos;s idea is that when we are doing any kind of get that is explicit with the columns, we can match any deletes we find against the input list of columns.  Just removing them from this list, rather than keeping a running list of deletes, should be more efficient.  This leads into a new discussion I will post on next.&lt;/p&gt;

&lt;p&gt;2.  I&apos;m +1 on Erik&apos;s thought.  Timestamps should not be set client side.  If there is a need to know the timestamp, might be possible to have it returned.  But the ability to set the timestamp means we can never optimize when dealing with versions because there could be a newer version of something in an older storefile, thus no ability to early-out ever.  If you need more control over the timestamp, then you probably aren&apos;t really using versions for versioning and you should model your data differently.&lt;/p&gt;

&lt;p&gt;3.  +1&lt;/p&gt;

&lt;p&gt;Not really sure what the opinion is for family + qualifier.  I see no reason to store or use the : ever, anywhere.  Client APIs should separate family and column as separate args.  Is there a good argument for not doing it this way?  Our comparators and new key format have no need for it.&lt;/p&gt;</comment>
                            <comment id="12680649" author="streamy" created="Tue, 10 Mar 2009 22:17:22 +0000"  >&lt;p&gt;In the reworking of basically everything, I&apos;d like to propose we change server-side methods to allow optimizations wherever possible and client APIs to more closely reflect implementation.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;very&lt;/em&gt; rough draft to show what i&apos;m talking about:&lt;/p&gt;

&lt;p&gt;getColumnsLatest(byte [] row, byte [][] columns)  - only takes columns, no families&lt;br/&gt;
getFamiliesLatest(byte [] row, byte [][] families)  - only takes families&lt;/p&gt;

&lt;p&gt;getColumnsVersions(byte [] row, byte [][] columns, int numVersions)&lt;/p&gt;

&lt;p&gt;getColumnsVersionsAfter(byte [] row, byte [][] columns, long afterStamp)&lt;br/&gt;
getColumnsVersionsBefore(byte [] row, byte [][] columns, long beforeStamp)&lt;/p&gt;

&lt;p&gt;getLatest(byte [] row) implementation is the same as getFamiliesLatest() with all families specified.&lt;/p&gt;


&lt;p&gt;It&apos;s easy to see now how splitting families and columns into two fields will not at all work with the current API.  Need a more hierarchical client api, client utilities, something more like BatchUpdate even for reads, ...&lt;/p&gt;

&lt;p&gt;Also, when dealing with versions (or latest), we will not be able to do most of the optimizations if the client can manually specify the timestamp as described above.&lt;/p&gt;

&lt;p&gt;A few reasons to do this.  For one, it is more clear to users how things are being implemented.  But more importantly, it makes sure we&apos;re writing a server-side method for all the different cases for which we can make optimizations.  Right now getting explicitly listed columns shares code with getting all columns for explicitly listed families.  These two things each contain their own unique possibilities for optimization.  There are also different optimizations to be made for deletes and more well-defined read types will make the cell cache easier.&lt;/p&gt;</comment>
                            <comment id="12680669" author="streamy" created="Tue, 10 Mar 2009 22:42:29 +0000"  >&lt;p&gt;To be more clear about the API, above is a pseudo-api that doesn&apos;t make sense.  In the first method with byte [][] columns, that would have to include families.  There&apos;s no such thing as a column w/o a family.&lt;/p&gt;

&lt;p&gt;My thought for a new API is to try and mirror the new key format.  Basically, for gets you&apos;d have a row, and then a set of keys that represented what you wanted to filter by.  If it&apos;s columns, then you&apos;d have keys that had both the family and the column.  If it&apos;s families, you&apos;d have the family in the key but an empty column value.  Do we support empty column values?  if so, we might also make use of the extra type bits to add more info...&lt;/p&gt;</comment>
                            <comment id="12680671" author="stack" created="Tue, 10 Mar 2009 22:49:22 +0000"  >&lt;p&gt;My thought is that you need to keep running list of deletes so that the delete in memcache is available when you trip over the cell that is in store file N.&lt;/p&gt;</comment>
                            <comment id="12680676" author="streamy" created="Tue, 10 Mar 2009 22:58:46 +0000"  >&lt;p&gt;(assuming real timestamps)&lt;/p&gt;

&lt;p&gt;Get latest version of columns:  &lt;span class=&quot;error&quot;&gt;&amp;#91;fam:col1, fam:col2, fam:col3, fam:col4&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Begin reading through Memcache... &lt;/p&gt;

&lt;p&gt;We find col1: we add it to resultset and then remove from list of columns to match&lt;/p&gt;

&lt;p&gt;We find a delete for fam:col2:  we remove it from the list of columns to match&lt;/p&gt;

&lt;p&gt;We find col2:  doesn&apos;t matter, not in list of columns to match&lt;/p&gt;

&lt;p&gt;We find col1:  old version, doesn&apos;t matter, not in list of cols&lt;/p&gt;

&lt;p&gt;Open up first store file...&lt;/p&gt;

&lt;p&gt;We find col2: old version, still doesn&apos;t matter, not in list&lt;/p&gt;

&lt;p&gt;We find col3: add to results, remove from list of cols to match&lt;/p&gt;

&lt;p&gt;etc...&lt;/p&gt;</comment>
                            <comment id="12680677" author="streamy" created="Tue, 10 Mar 2009 22:59:36 +0000"  >&lt;p&gt;This optimization only works if timestamps are set by the server AND points out why we should separate implementation of grabbing explicit columns vs all in a family.&lt;/p&gt;</comment>
                            <comment id="12680679" author="stack" created="Tue, 10 Mar 2009 23:02:03 +0000"  >&lt;p&gt;Now understand.  That&apos;d be sweet if we had that.&lt;/p&gt;</comment>
                            <comment id="12681915" author="erikholstad@gmail.com" created="Fri, 13 Mar 2009 22:18:20 +0000"  >&lt;p&gt;Some more thoughts for puts into memCache.&lt;br/&gt;
I think that when writing a delete to memCache and timestamp is specified we should just overwrite the value in there and not save both.&lt;br/&gt;
When we get a more complicated deletes such as row, family etc, I propose that we after that insert walk down the tailTree of that node and&lt;br/&gt;
delete all it&apos;s children. This will result in less flushing of memCache and make things easier when reading.&lt;/p&gt;</comment>
                            <comment id="12682353" author="jimk" created="Mon, 16 Mar 2009 16:23:50 +0000"  >&lt;p&gt;&amp;gt; Erik Holstad added a comment - 10/Mar/09 01:14 PM&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; 2. I think that the setting of the timestamp should not be exposed to the user but, be set by HBase at all times. This limitation&lt;br/&gt;
&amp;gt; simplifies a lot when reasoning about the order across storefiles and client formats, to make it as fast, early outs and simple, &lt;br/&gt;
&amp;gt; list instead of map, as possible.&lt;/p&gt;

&lt;p&gt;-1 Unless there is another &quot;version&quot; field. We have an application that makes extensive use of timestamp at Powerset.&lt;/p&gt;</comment>
                            <comment id="12682369" author="stack" created="Mon, 16 Mar 2009 16:51:15 +0000"  >&lt;p&gt;.bq -1 Unless there is another &quot;version&quot; field. We have an application that makes extensive use of timestamp at Powerset.&lt;/p&gt;

&lt;p&gt;We should review our internal app.  I don&apos;t believe our application guards against timestamps&apos; being set non-chronologically.&lt;/p&gt;

&lt;p&gt;On the timestamping issue, we speak with forked tongue.  We allow setting it all over our API but we only internally support chronologically-ordered stamps.  If a user enters out-of-order timestamps, results are indeterminate&lt;/p&gt;</comment>
                            <comment id="12682371" author="stack" created="Mon, 16 Mar 2009 16:56:53 +0000"  >&lt;p&gt;I should have said, unless we intend allowing fellas set their own timestamp though they are out of order, then I&apos;m in favor of removing it from the API &amp;#8211; tell it like it is rather than how we might like it to be  (though as JK raises, need to figure what that means for pset application).&lt;/p&gt;</comment>
                            <comment id="12682421" author="erikholstad@gmail.com" created="Mon, 16 Mar 2009 19:31:46 +0000"  >&lt;p&gt;Jim, are you -1 my proposal of removing from memCache or just removing timestamps as settable for the user?&lt;/p&gt;</comment>
                            <comment id="12682424" author="jimk" created="Mon, 16 Mar 2009 19:41:56 +0000"  >&lt;p&gt;@Erik&lt;/p&gt;

&lt;p&gt;Sorry, just opposed to removing user settable timestamps.&lt;/p&gt;</comment>
                            <comment id="12682499" author="erikholstad@gmail.com" created="Mon, 16 Mar 2009 22:42:10 +0000"  >&lt;p&gt;With the new KeyValue format puts and deletes are put in the same format, KeyValue. We have for delete types:&lt;br/&gt;
Delete&lt;br/&gt;
DeleteColumn&lt;br/&gt;
DeleteFamily&lt;br/&gt;
DeleteRow&lt;br/&gt;
The difference between Delete and DeleteColumn one would think is that DeleteColumn deletes all versions and for a delete&lt;br/&gt;
you specify a version ts to delete.&lt;br/&gt;
But KeyValue only holds one ts, so the way I see it we have 3 options:&lt;br/&gt;
1. Not store the time of the delete and only use it in case of a Delete, &lt;/p&gt;

&lt;p&gt;2. Set ts to the time of the delete and not support delete explicit versions, but just delete all versions.&lt;/p&gt;

&lt;p&gt;3. Have an extra field to store the extra ts, so we have 2.&lt;/p&gt;

&lt;p&gt;I think that nr 1 is the best way to go and if we remove all puts in memcache underneath a delete we are not going to lose any functionality.&lt;br/&gt;
I&apos;m not totally against nr 2 either, but would have made more sense if we didn&apos;t allow users to set the timestamp.&lt;br/&gt;
Don&apos;t like nr. 3 since it requires and extra layer or something like that to keep the extra ts.&lt;/p&gt;
</comment>
                            <comment id="12682758" author="erikholstad@gmail.com" created="Tue, 17 Mar 2009 18:58:50 +0000"  >&lt;p&gt;Some more thoughts:&lt;br/&gt;
DeleteRow should not exist on the server side but broken up into&lt;br/&gt;
DeleteFamily  for all the families for that region. &lt;/p&gt;

&lt;p&gt;Client side&lt;br/&gt;
DeleteRow&lt;br/&gt;
DeleteFamily&lt;br/&gt;
DeleteColumn&lt;br/&gt;
Delete&lt;/p&gt;

&lt;p&gt;Ts for the deletes should be &quot;now&quot; for DeleteRow and DeleteFamily, an optional on for DeleteColumn that will delete everything after that ts,&lt;br/&gt;
if not specified it will use &quot;now&quot; and Delete should always take a ts for the put in question and will only react to exact matches of that ts.&lt;/p&gt;

&lt;p&gt;and at the server we have&lt;br/&gt;
DeleteFamily&lt;br/&gt;
DeleteColumn&lt;br/&gt;
Delete&lt;/p&gt;

&lt;p&gt;I like the idea of having a special ts for the bigger Deletes so you would know what to get from memCache and where to seekTo in the store,&lt;br/&gt;
but maybe an even better option is to have a separate delete set that can be read in if needed to go to store file for more data.&lt;br/&gt;
So for every delete that comes in, it first deletes everything in memCache that is related to it and then it is added to the deleteSet. &lt;br/&gt;
this means that everything that is in memCache is valid data, and you only need to take deletes into consideration if you are going to the stores.&lt;/p&gt;</comment>
                            <comment id="12682935" author="streamy" created="Wed, 18 Mar 2009 06:38:33 +0000"  >&lt;p&gt;We need to do some testing on that.  Scanning through the deletes in the memcache might be pretty fast, regardless.  However I think it sounds like a good idea and the basis for some more thoughts.&lt;/p&gt;

&lt;p&gt;And yeah, there should probably be no such thing as a DeleteRow on the server.  And this is especially the case with locality groups as you&apos;d need to seek to the start of the row every time before seeking down to your family.&lt;/p&gt;

&lt;p&gt;But in thinking more about memcache deletes... when we flush the memcache, we can guarantee that none of the values being flushed have been deleted (if we do as above, applying deletes to the memcache).  So we have a list of deletes that apply to older store files.  Then we start a new memcache.&lt;/p&gt;

&lt;p&gt;When we read in the newest storefile, we actually know that we can process it without looking at any deletes except those that are in the new memcache.  The deletes in this storefile aren&apos;t needed until the second newest is looked at.  And at that point we can read them in in bulk from the previous storefile that&apos;s already been opened.  Can even compare stamps from the deletes to the storefile stamps to possible query stamps to early out.  This is a far cry from how things are now... deletes are interspersed and duplicated everywhere.&lt;/p&gt;

&lt;p&gt;It does seem to make sense to have the deletes order above where they apply, but then we have to check those sections first before reading?  Well come to think of it, what could make sense is to order them below.  The only time we actually have deletes in a storefile is when they need to be applied to the older storefiles.  So, we can scan these deletes at the end, once we have reached past what we wanted (and still need to read additional storefiles) we can scan and seek for deletes pertaining to this row/family/column, if there are any.&lt;/p&gt;

&lt;p&gt;Those deletes are added to the in-memory deleteset for the remaining storefiles.&lt;/p&gt;

&lt;p&gt;Any rewriting of files must enforce deletions across them, and files must be sequential in age if not all are combined.&lt;/p&gt;

&lt;p&gt;So, DeleteRow and DeleteFamily would take no time parameters, and would be stored with the time of deletion.  Their KeyValue will sort at the end of the row, meaning you need to scan to this spot any time you reach the end of what you&apos;re reading from that store&apos;s row and need to read the next.&lt;/p&gt;

&lt;p&gt;DeleteColumn would use now by default, or you could specify a stamp and it would delete everything &amp;lt;= that stamp.  This &lt;em&gt;could&lt;/em&gt; sort at the end of the column, but is there any point?  It should probably be at the end of the row, this is where you have to seek to look for a DeleteFamily anyways.&lt;/p&gt;

&lt;p&gt;Delete would be the same thing.  Sorted at the end of the row.  Just need to get the deleteset and comparators right so they can do the matching well for these different delete types against different cell KeyValues.&lt;/p&gt;

&lt;p&gt;Might make sense to have a DeleteRow in this case, would be less work in the case of locality groups.  But not a big deal either way really.&lt;/p&gt;</comment>
                            <comment id="12683111" author="erikholstad@gmail.com" created="Wed, 18 Mar 2009 17:56:27 +0000"  >&lt;p&gt;Yeah Jonathan, that sounds like a really good approach, we get all the benefits from splitting deletes and puts and don&apos;t have to pay the cost of doing that, very nice.&lt;/p&gt;

&lt;p&gt;On the whole put/get/delete issue:&lt;/p&gt;

&lt;p&gt;When looking for a value in HBase we have 3 lists that need to be compared to&lt;br/&gt;
each other, the list of data, da, in the storefile, the list of keys, k, to look&lt;br/&gt;
for and the list of deletes, de.&lt;/p&gt;

&lt;p&gt;Today, we compare every da with every k and every match with every de, as far as&lt;br/&gt;
I can tell. We get a complexity that looks something like da*k+k*de, which might&lt;br/&gt;
be ok, when all those value are small, but if da = k = de = 10 you get 200&lt;br/&gt;
comparisons that you have to do.&lt;/p&gt;

&lt;p&gt;I&apos;m proposing more like a merge approach where you merge compare da and de and&lt;br/&gt;
produce a survivor list, this list is then compared to k. This will result in&lt;br/&gt;
de+da + da+k  = 40 in worst case, which seems like a much better way to go.&lt;br/&gt;
Can even be made more efficient. &lt;/p&gt;

&lt;p&gt;Think we should add get types into KeyValue, so we can tell the difference between getting &lt;br/&gt;
a value for a specific ts and getting all values after a specific ts.&lt;/p&gt;
</comment>
                            <comment id="12683169" author="streamy" created="Wed, 18 Mar 2009 21:03:01 +0000"  >&lt;p&gt;Describes new KeyValue format, StoreFile format, and the default comparator/ordering of KeyValues within a StoreFile.&lt;/p&gt;</comment>
                            <comment id="12683210" author="streamy" created="Wed, 18 Mar 2009 22:27:43 +0000"  >&lt;p&gt;This is somewhat related to &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-880&quot; title=&quot;Improve the current client API by creating new container classes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-880&quot;&gt;&lt;del&gt;HBASE-880&lt;/del&gt;&lt;/a&gt;, but specifically talks about how we will implement Gets on the server-side.&lt;/p&gt;

&lt;p&gt;For each GetX object we have on the client, there will be a corresponding GetXServer object that will contain any necessary state for processing the request.  In addition, the GetServer interface will include a very unique and specialized compareTo(KeyValue) method with a range of return values &lt;span class=&quot;error&quot;&gt;&amp;#91;-1, 4&amp;#93;&lt;/span&gt; as described in the doc.&lt;/p&gt;

&lt;p&gt;These GetServer implementations will be where all the specialized server-side logic will live that allow the different styles of gets to be done in an optimized way.  The bulk of that logic lives in the column/timestamp comparison in the compareTo.&lt;/p&gt;

&lt;p&gt;More information and examples to follow.&lt;/p&gt;</comment>
                            <comment id="12683228" author="streamy" created="Wed, 18 Mar 2009 23:13:04 +0000"  >&lt;p&gt;Erik pointed out that return codes 3 and 4 are not explicit about whether you should include the current value or not in the ResultSet.&lt;/p&gt;

&lt;p&gt;This updates the spec so that 3 and 4 mean DO NOT include the current key in the result.  This means that you &lt;/p&gt;

&lt;p&gt;Also note, another optimization we will have is removing things in the Get that are to be matched once we have matched all that are required.  For example, we specify we want the most recent versions of 5 explicit columns.  Once we find one of them, they will be removed from the match list.  Once all are found, and thus removed, the next compareTo call will see that there is nothing left to match on and return a 4.  Return code of 3 would be used in many other cases, for example, if we&apos;re looking for all versions of a single column, once we scan past that column in the current storefile, we return 3 to jump to the next one.&lt;/p&gt;</comment>
                            <comment id="12683229" author="streamy" created="Wed, 18 Mar 2009 23:14:32 +0000"  >&lt;p&gt;Finishing my thought... This means that you may have to read an additional key that you otherwise would not have had to.  Another option would be to add two additional return codes, but my thought is that 6 is more than enough as is and in general (when we&apos;d return 3, not 4) we&apos;ll need to continue scanning anyways to read in all the deletes.&lt;/p&gt;</comment>
                            <comment id="12683230" author="streamy" created="Wed, 18 Mar 2009 23:15:29 +0000"  >&lt;p&gt;Also, that next comparison would not even require any comparison to the KeyValue.  It would just be a simple check at the start of compareTo to check if we&apos;ve overrun the boundaries as defined in return codes 3 and 4.&lt;/p&gt;</comment>
                            <comment id="12683237" author="streamy" created="Wed, 18 Mar 2009 23:44:59 +0000"  >&lt;p&gt;Another thing I just realized.  If we are going to push all the specialized server-side implementation of Gets into the GetServer implementing Classes, they must know the IDs (latest stamp) of all the StoreFiles in the current Store.  This is known on the server so not a big deal, but I&apos;ve not mentioned this before.&lt;/p&gt;</comment>
                            <comment id="12683273" author="streamy" created="Thu, 19 Mar 2009 01:27:42 +0000"  >&lt;p&gt;This contains an example Memcache and two example StoreFiles using previously described keys, comparators, and deletes.&lt;/p&gt;

&lt;p&gt;There are wordy psuedo-code implementations of 5 different queries and their server-side execution logic.  It explains how everything in GetQueries would work in practice.&lt;/p&gt;

&lt;p&gt;It&apos;s difficult to break this work up, like one person working on deletes, because to do this stuff right it requires a much bigger overall rearchitecture of things.  Erik already has a good bit of code written for all this, so he and I are willing to take this stuff on.  &lt;/p&gt;

&lt;p&gt;That being said, these are major changes and we need feedback.&lt;/p&gt;</comment>
                            <comment id="12683316" author="erikholstad@gmail.com" created="Thu, 19 Mar 2009 04:36:40 +0000"  >&lt;p&gt;The pdfs looks really good and they make sense to me, just hope that they can help others to understand what we are going for here.&lt;br/&gt;
Just a couple of things that are a little bit unclear to me in the examples:&lt;br/&gt;
DeleteFamily in MemCache, should probably have a different ts, to belong there, same thing with stuff in the storefiles.&lt;/p&gt;

&lt;p&gt;For the GetColumns(RowA, Fam, &lt;span class=&quot;error&quot;&gt;&amp;#91;ColA, ColB&amp;#93;&lt;/span&gt;, ts(20, 0)), I would think that that query would mean give me 1 version of &lt;br/&gt;
ColA and ColB from the timeperiod 20 - 0.&lt;/p&gt;

&lt;p&gt;And for GetFamily(RowA, Fam, num=1), Couldn&apos;t you early out as soon as you encounter the DeleteFamily in MemCache?&lt;/p&gt;</comment>
                            <comment id="12683403" author="ryanobjc" created="Thu, 19 Mar 2009 09:59:34 +0000"  >&lt;p&gt;A few things:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;in the storefile pdf, you have a row like so:&lt;br/&gt;
RowA, Delete, Fam, ColA, 6, X&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Is the &apos;X&apos; a typo?  This should be a */no value since deletes dont actually carry any &lt;em&gt;value&lt;/em&gt; info - the info is in the key itself.&lt;/p&gt;

&lt;p&gt;And as for the delete/memcache thing.... It sounds like we lose the ability to version deletes if the value is in memcache.  Eg:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;insert row A, ColA, value X&lt;/li&gt;
	&lt;li&gt;delete row A, Col A&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;in a row, both will hit the memcache (probably).  It seems like with your proposal we would process the delete by nuking the insert (aka put) right away, and storing the delete for posterity and to cover up older values in older hfiles.&lt;/p&gt;

&lt;p&gt;or am i missing something?&lt;/p&gt;</comment>
                            <comment id="12683438" author="streamy" created="Thu, 19 Mar 2009 11:39:44 +0000"  >&lt;p&gt;Erik:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DeleteFamily in MemCache, should probably have a different ts, to belong there, same thing with stuff in the storefiles. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Why should DeleteFamily have different timestamps?  In the Memcache, it is a DeleteFamily for ts &amp;lt;= 9.  This request can come in at any time so could be in the Memcache.  Remember, deletes in the current memcache/storefile relate only to older ones (smaller timestamps).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For the GetColumns(RowA, Fam, &lt;span class=&quot;error&quot;&gt;&amp;#91;ColA, ColB&amp;#93;&lt;/span&gt;, ts(20, 0)), I would think that that query would mean give me 1 version of ColA and ColB from the timeperiod 20 - 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I meant all versions.  Will update and fix that.  You&apos;re right, default should probably always be 1.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;And for GetFamily(RowA, Fam, num=1), Couldn&apos;t you early out as soon as you encounter the DeleteFamily in MemCache?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I don&apos;t believe so.  You encounter the DeleteFamily(ts &amp;lt;= 9), but the ID of the next StoreFile is 21, so you don&apos;t know anything about what&apos;s in there.  You are actually done at this point, for this particular query, but there is no way to know that there are not versions of other columns besides colA and colB in StoreFile1, or even StoreFile2 (id=11, so could also contain undeleted columns for the resultset).  For example, a (RowA, Put, Fam, ColC, 19, M) in StoreFile1 would be part of the resultset if it existed.&lt;/p&gt;

&lt;p&gt;Ryan:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(RowA, Delete, Fam, ColA, 6, X)&lt;br/&gt;
Is the &apos;X&apos; a typo? This should be a */no value since deletes dont actually carry any value info - the info is in the key itself.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, that is a typo.  If you look at the latest Example pdf, the StoreFiles should be accurate.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It sounds like we lose the ability to version deletes if the value is in memcache&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I&apos;m not sure I totally understand what you&apos;re saying about the removal from memcache affecting that.  To expand on your example...&lt;/p&gt;

&lt;p&gt;We do a put of KeyValue:  (rowA, fam, put, colA, ts=now=100, X)&lt;br/&gt;
Then we do a delete of KeyValue, either Delete or DeleteColumn:  &lt;br/&gt;
DeleteColumn(rowA, fam, deletecolumn, colA, ts&amp;lt;=#)&lt;br/&gt;
Delete(rowA, fam, delete, colA, ts=#)&lt;/p&gt;

&lt;p&gt;The timestamp that the delete goes in with is how you version the delete.  Delete is for the lowest unit, single row, single family, single column, single version.  DeleteColumn is for a range of versions of a column, my current thought was &amp;lt;= the specified stamp.  If you don&apos;t specify one, then you will do now and that would delete all versions.  Does that make more sense?  I wasn&apos;t really clear about the 3 different delete types.&lt;/p&gt;</comment>
                            <comment id="12683465" author="streamy" created="Thu, 19 Mar 2009 13:29:09 +0000"  >&lt;p&gt;Added numVersions=MAX to second GetColumns example.&lt;/p&gt;</comment>
                            <comment id="12683487" author="erikholstad@gmail.com" created="Thu, 19 Mar 2009 15:35:49 +0000"  >&lt;p&gt;Jonathan, I guess the confusion is about the way that DeleteFamily is used, as I wrote 12 posts above, or something, I thought that ts&lt;br/&gt;
for DeleteRow and DeleteFamily should be set to now, that is why I thought it was in the wrong place or had the wrong ts, but I guess&lt;br/&gt;
the reason for having it that way was for the sorting and since we sort by type before ts now, it is no longer needed and we can use that&lt;br/&gt;
ts as in the case of DeleteColumn.&lt;/p&gt;</comment>
                            <comment id="12683602" author="stack" created="Thu, 19 Mar 2009 20:46:04 +0000"  >&lt;p&gt;I need some preamble.  I can&apos;t figure out how to read these docs.  Someone needs to hold my hand.&lt;/p&gt;

&lt;p&gt;For example, whats this compareTo method?  Is it on an object GetServer (i.e. a Get on the server-side)?&lt;/p&gt;

&lt;p&gt;Whats this mean &apos;RegionUniqueID = Creation Stamp&apos;?&lt;/p&gt;

&lt;p&gt;It looks like another rewrite of the Server?&lt;/p&gt;</comment>
                            <comment id="12683614" author="erikholstad@gmail.com" created="Thu, 19 Mar 2009 21:05:12 +0000"  >&lt;p&gt;I think that the idea is a the compareTo sits inside the Get interface and different Gets implement their own methods.&lt;br/&gt;
But we didn&apos;t want to keep the compareto code on the client so that is why a serverside object is created.&lt;br/&gt;
The idea of having a create stamp is just to be able to go to pass memCache and storefiles faster incase of a timeRange query,&lt;br/&gt;
but that is an optimization.&lt;/p&gt;</comment>
                            <comment id="12685397" author="streamy" created="Sat, 21 Mar 2009 00:48:53 +0000"  >&lt;p&gt;Erik has been doing good work on implementing these ideas in code.  One thing he realized today was that we decided partway through the design process to handle DeleteSet inside of the Get rather than in the HRegion logic.  That further simplifies HRegion code and means the Get.compareTo function now returns one of 4 values rather than 6 total.&lt;/p&gt;</comment>
                            <comment id="12685398" author="streamy" created="Sat, 21 Mar 2009 00:49:18 +0000"  >&lt;p&gt;Changes Get.compareTo codes and HRegion sample logic.&lt;/p&gt;</comment>
                            <comment id="12693596" author="erikholstad@gmail.com" created="Sun, 29 Mar 2009 18:18:04 +0000"  >&lt;p&gt;When bringing DeleteFamily into the mix it creates problems with the current layout, cause every time you need to merge the deletes from the previous storefile with the current deletes and every time you compare those deletes with the current position that you are looking at in the current storefile you need to compare those timestamps. There are a couple of ways around this as I see it.&lt;/p&gt;

&lt;p&gt;1. Only letting the user set the timestamp for the DeleteFamily to now, where now can be System.currentTimeMillis() or some user generated now. This would mean the current memCache would be cleaned and all other storefiles considered to be deleted, for this row and family. This would mean that you only need to do one check for every storefile to see if there is a DeleteFamily entry in there and you will know that all data in that storefile is ok and that you don&apos;t need to look in any more storefiles.&lt;/p&gt;

&lt;p&gt;2. Do the check if there is a DeleteFamily in the deletes and have 2 different methods taking care of the cases where you have a DeleteFamily entry and when you don&apos;t. The downside of this is that you still have to pay the cost if you do have a DeleteFamily, worst case you have to do these 2 checks for every entry in every storefile.&lt;/p&gt;

&lt;p&gt;3. Keep the DeleteFamily sorted at the timestamp where it belongs, so that all deletes would be sorted in timestamp order before column. This is a rather big change, because it means that also the puts would have to be sorted this way for it to make any sense. Another advantage of this approach would be that earlying out from a query with a timerange &quot;filter&quot; would be more effective.&lt;/p&gt;

&lt;p&gt;I personally like the 3 option the most, but I can see people not liking it because it sort of redefines what HBase is, so I think that number 1 is the best option and after that number 2.&lt;/p&gt;

&lt;p&gt;Would love to get some input in this matter to see if there is anything that people might have against number 1. Otherwise I will move on with the process of implementing that option.&lt;/p&gt;

&lt;p&gt;Regards Erik&lt;/p&gt;</comment>
                            <comment id="12693602" author="streamy" created="Sun, 29 Mar 2009 18:55:26 +0000"  >&lt;p&gt;I&apos;m a little bit confused about what you&apos;re saying.  First, I don&apos;t think you or I have described any recent changes we&apos;ve made in the design from the current posted docs.  Namely, separation of the deletes after all the puts is not actually a good idea.&lt;/p&gt;

&lt;p&gt;Rather than separating them out and having a KV sort like (row,type,column,ts) it would be (row,column,ts,type).  You end up building your delete list as you go but now you can early out in more cases.  I will update the pdfs later in the week.&lt;/p&gt;

&lt;p&gt;Erik has also simplified the return codes of Get.compareTo.&lt;/p&gt;

&lt;p&gt;Regarding the DeleteFamily issue... There&apos;s some new DeleteSet object now that handles the merging of deletes and containment checking?  Should be very simple for it to keep around a single, optional DeleteFamily (really just a timestamp... defaults to 0L and is checked every time, or set to null and skip it if none found (should be able to get away with an overhead of a single if == null check when no deletefamily present)... it would get set when reading a DeleteFamily and then just a single long check for each timestamp.&lt;/p&gt;

&lt;p&gt;Regarding #1 above, i don&apos;t follow why they can only set to now?  The rule can and should be, you can do anything for now or anything in the past.  How would setting something in the past break anything here?&lt;/p&gt;

&lt;p&gt;2.  This is what I&apos;m proposing I guess?  What&apos;s the downside?  If no deletefamily, you have one line of code, a single instruction comparison.  This is the least complex and seems efficient.&lt;/p&gt;

&lt;p&gt;3.  I think you&apos;re saying the entire row should be timestamp ordered here?  As you know, I&apos;m against that.  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12693603" author="jimk" created="Sun, 29 Mar 2009 19:00:03 +0000"  >&lt;p&gt;I would say, eliminate timestamp as a parameter to all the deleteFamily methods, and the one that finally actually makes the server call supplies HConstants.LATEST_TIMESTAMP. This is essentially option 1.&lt;/p&gt;</comment>
                            <comment id="12693605" author="streamy" created="Sun, 29 Mar 2009 19:25:21 +0000"  >&lt;p&gt;I don&apos;t understand what we gain from #1 versus #2.  What do we lose the ability to do by allowing past timestamp to be set for DeleteFamily?&lt;/p&gt;

&lt;p&gt;Also, Jim, you were the one who voiced opposition to disallowing manual setting of timestamps.  I&apos;ve come to agree with that, with the restriction only being on disallowing &lt;em&gt;future&lt;/em&gt; stamps (which breaks nearly all optimizations).  Is there a particular reason it makes sense to allow inserts to be put in with any timestamp but not a delete?&lt;/p&gt;</comment>
                            <comment id="12693606" author="erikholstad@gmail.com" created="Sun, 29 Mar 2009 19:38:15 +0000"  >&lt;p&gt;So what you gain by going with number 1 instead of number 2 is that you don&apos;t need to check any of the storefiles for more than containment of a  DeleteFamily insert, so no need to check the timestamp for every get and for merging of deletes, since yo know that all the deletes that are in that storefile are inserted after the DeleteFamily insert was made. The only time you actually take care of removing stuff in regards to the DeleteFamily call is in memCache. So basically you dont&apos; have to do the checks for the DeleteFamily timestamp, because you know that none of the storefiles after the storefile where you encountered the DeleteFamily entry are &quot;deleted&quot;.&lt;/p&gt;

&lt;p&gt;Regards Erik&lt;/p&gt;</comment>
                            <comment id="12693609" author="streamy" created="Sun, 29 Mar 2009 19:42:33 +0000"  >&lt;p&gt;Ah, so not setting it and performing deletes on the memcache means reading a deletefamily means everything prior storefiles is deleted for that row.&lt;/p&gt;

&lt;p&gt;I guess I just don&apos;t agree with that kind of selective restrictions for performance unless we&apos;re going to make a conscious and logical design decision.  There&apos;s a very clear and logical argument for disallowing the manual setting of timestamps.  However, this ability is part of the BigTable spec and there are numerous use cases for this (including pset).  It closes the door for potential optimizations for those of us who have no need to manually set them, but it&apos;s not terrible to allow it as long as they&apos;re only in the past.&lt;/p&gt;

&lt;p&gt;The same argument can be applied to this and a bunch of other issues we&apos;ve been tossing back and forth.&lt;/p&gt;

&lt;p&gt;Let&apos;s not make these kinds of decisions without deciding what our requirements are.  Either timestamp is a user-settable attribute, or it isn&apos;t.  I think it should be.  Part of the issues with the current API is you can do certain things in one part of the API that aren&apos;t supported in the other type.  Scanning and versions don&apos;t play nice even though we logically can support it.  There shouldn&apos;t be caveats like, you can insert at any time in the past, but if you want to delete a row, you can only delete every version or particular versions of particular columns, not all versions older than a specified stamp.&lt;/p&gt;

&lt;p&gt;Erik&apos;s digging has shown numerous potential optimizations for the future, very good stuff.  BUT Let&apos;s not alter our requirements or the properties of HBase in significant ways in the name of minor optimization of edge cases.  &lt;/p&gt;

&lt;p&gt;If I understand correctly, even with #2 if you do a deleteFamily and specify NOW, it would have the same early-out possibility as with #1.  I see a DeleteFamily with a stamp that is newer than the latest stamp in the next storefile.  I know all columns are deleted so I do nothing.  Enforcing the deletes in memcache means you tuck it away untli the next storefile anyways.  So implementation is identical with #2 if used in the way #1 forces you to.&lt;/p&gt;

&lt;p&gt;But you remove the ability of the user to put a past stamp in.  And this just adds additional caveats instead of keeping it simple.  If a user does a deletefamily with a past stamp, then read queries would need to open additional stores.  That&apos;s required for correctness of the query, this is not an inefficiency this is what the user wants to happen if he uses puts and deletes in this way.&lt;/p&gt;</comment>
                            <comment id="12693630" author="erikholstad@gmail.com" created="Mon, 30 Mar 2009 00:45:36 +0000"  >&lt;p&gt;@jgray&lt;br/&gt;
I agree with most of the things that you are saying about letting the user setting the timestamp in some places but not in others and I think that it is a good point. &lt;br/&gt;
But the reason that I brought this up is because I would like to keep the code as simple as possible and not have to deal with all these special cases, which DeleteFamily with the ability of setting the timestamp in the past brings, not to make it more complicated. But I guess we can do the same way as with the settable timestamps for the inserts, put a red warning label on there and try to explain in there what will actually happen when making a delete like that, because as a new user I think it is hard to fully understand all the details of your actions even though they make perfect sense.&lt;br/&gt;
So I guess that leaves us with number 2 where we have 2 different cases to take care of, one with DeleteFamily and one without.&lt;/p&gt;</comment>
                            <comment id="12694602" author="erikholstad@gmail.com" created="Wed, 1 Apr 2009 16:10:44 +0000"  >&lt;p&gt;I thing that was shown in Jonathan&apos;s fine looking example.pdf is the notion of a timestamp for the storefile so that we could use that to find out if there is anything in there that might be of interest for the query. I looked at how storefiles are created today and it looks like they have a sequenceid/logCacheFlushId which to me just looks like in incremented value at the HR level, so all storefiles in a store have unique keys. So to me it looks like it would be possible to use a timestamp here instead and use that information to speed up the get queries. The new id would be set to the latest timestamp of the inserts in the flushed memcache or something like that.&lt;/p&gt;</comment>
                            <comment id="12694631" author="streamy" created="Wed, 1 Apr 2009 17:33:43 +0000"  >&lt;p&gt;Right.  My idea was just to use NOW as the storefile seqid/flushid (if future timestamps are not allowed, we maintain a property of no versions in a storefile being newer than the seqid/flush stamp).  Nothing fancy like getting the newest version of the flush or anything, don&apos;t think that&apos;s necessary.&lt;/p&gt;</comment>
                            <comment id="12695255" author="stack" created="Fri, 3 Apr 2009 06:12:02 +0000"  >&lt;p&gt;I like the idea of NOW as seqid/flushid.&lt;/p&gt;</comment>
                            <comment id="12702622" author="erikholstad@gmail.com" created="Fri, 24 Apr 2009 23:34:51 +0000"  >&lt;p&gt;To clear out some confusion that has come up since the pdfs that were put up has not been updated about the sort order that we are using for the new server. In the pdfs is says that we are sorting row/type/fam/col/ts or something like that, what we are actually doing is row/fam/col/ts,type, so the regular comparator from KeyValue is used. &lt;br/&gt;
Will update the pdfs a soon a possible for it not to be so confusing.&lt;/p&gt;</comment>
                            <comment id="12703427" author="streamy" created="Mon, 27 Apr 2009 22:49:48 +0000"  >&lt;p&gt;Updated StoreFile design.  New sort order of row, family, column, timestamp, type.&lt;/p&gt;</comment>
                            <comment id="12703430" author="streamy" created="Mon, 27 Apr 2009 23:01:05 +0000"  >&lt;p&gt;Updated version of GetQuery.  The GetServer.compareTo implementation shown in the design document is a general design.  There are three unique server-side Get implementation, each containing a slightly modified/specialized version of that method.&lt;/p&gt;</comment>
                            <comment id="12703494" author="stack" created="Tue, 28 Apr 2009 04:48:34 +0000"  >&lt;p&gt;Docs are hard to read because no context.&lt;/p&gt;

&lt;p&gt;Let me have a go at interpreting them and commenting on them:&lt;/p&gt;

&lt;p&gt;StoreFile-v4:&lt;/p&gt;

&lt;p&gt;+ DeleteRow is in square brackets.  Whats that mean?&lt;br/&gt;
+ Looks like KeyValue is same as we currently have.  Is that right?&lt;br/&gt;
+ &quot;Deletes apply only to older StoreFiles&quot; means?  Deletes in current file effect older files because deletes will have been directly applied in memcache?&lt;br/&gt;
+ Will sorting puts before deletes work?  How do I delete an item in memcache? I split the memcache TreeMap at the put record though I&apos;ve been passed a delete?  And then iterate over its tail.  If a put, remove it, then enter the delete?&lt;br/&gt;
+ Says &quot;DeleteColumn/Delete&quot; are sorted in ascending lexic order?  Whats that mean?  Ain&apos;t type a single byte?  So ain&apos;t it just a case of saying what the code for deletecolumn, deletefamily is?  Currently, we have a maximum type.  We split the memcache on that and iterate over its tail.  Deletes sort before so they override any Puts that are present.  I like the idea that we execute on deletes immediately.  Could make savings here.  But need bit more info on how this&apos;d all work.&lt;br/&gt;
+ In &quot;StoreFile Notes&quot;, the idea that we deletes only apply to the next file sounds good but what about the ryan rawson point of what happens when a compaction? What do we do?  In minor compaction, we are picking up two files from a possible N.  We are putting together the edits.  The dictum that deletes only apply to the next file is broke.&lt;br/&gt;
+ Don&apos;t say nothing on how deletes work regards timestamp.  Does a deletefamily delete all in a family at the given timestamp?  Or is it all in the family at the timestamp and older?  What happens if I do a get behind the timestamp?   I can find the values that were &quot;deleted&quot;&lt;/p&gt;

&lt;p&gt;More comments to follow.&lt;/p&gt;</comment>
                            <comment id="12703498" author="erikholstad@gmail.com" created="Tue, 28 Apr 2009 05:13:33 +0000"  >&lt;p&gt;Try to answer the questions:&lt;br/&gt;
DeleteRow with square brackets only mean that it is a call from the client side but is broken up into multiple deleteFamilies on the server side, same thing as the type deleteRow.&lt;br/&gt;
The sort order is the same as for the Kv.Comparator in KeyValue, if deletes are sorted above puts, have to check.&lt;br/&gt;
Yes, that is exactly what that means. Deletes are taken care of directly in memcache by calling tailMap with the deleteKeyValue and remove all the affected puts and deletes, so &quot;smaller&quot; deletes are removed in case of a &quot;bigger&quot; one that comes in afterwards.&lt;br/&gt;
In case of a merge deletes needs to be taken care of, so that we don&apos;t loose that rule that deletes only apply to the files after. So for a minor compaction we save all the deletes unless a &quot;bigger&quot; on comes in first and remove all the affected puts for those deletes.&lt;br/&gt;
The DeleteFamily type is moved down through all the file just like the other deletes, but stored in a separate place and needs to be checked for every delete to see if it applies to the current KeyValue.&lt;/p&gt;</comment>
                            <comment id="12703500" author="stack" created="Tue, 28 Apr 2009 05:32:02 +0000"  >&lt;p&gt;So v4 of doc. is wrong where it says Puts come before Deletes (thats fine).&lt;/p&gt;

&lt;p&gt;Ok on the DeleteRow.&lt;/p&gt;

&lt;p&gt;Sort from TRUNK KV is:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  /**
   * Key type.
   * Has space &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; other key types to be added later.  Cannot rely on
   * &lt;span class=&quot;code-keyword&quot;&gt;enum&lt;/span&gt; ordinals . They change &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; item is removed or moved.  Do our own codes.
   */
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;enum&lt;/span&gt; Type {
    Put((&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;)4),
    Delete((&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;)8),
    DeleteColumn((&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;)16),
    DeleteFamily((&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;)32),
    &lt;span class=&quot;code-comment&quot;&gt;// Maximum is used when searching; you look from maximum on down.
&lt;/span&gt;    Maximum((&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;)255);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I don&apos;t follow what you mean by &quot;separate place&quot; for DeleteFamily.  That sounds odd. &lt;/p&gt;

&lt;p&gt;What about how deletes and timestamps mix?  Does a delete only delete cell of that ts?  Or does it delete that ts and all behind?&lt;/p&gt;</comment>
                            <comment id="12703505" author="stack" created="Tue, 28 Apr 2009 05:54:23 +0000"  >&lt;p&gt;Looking at the GetQuery-v4:&lt;/p&gt;

&lt;p&gt;+ TimeStamp looks like CellBounds in 880 proposal 5 v2 only its missing versions.  How are versions done?&lt;br/&gt;
+ Is the Family object needed?  The old array of arrays where columns were compound of family and qualifier would seem to be more compact?&lt;br/&gt;
+ How do I read GetXServer?  Is that the client-side GetX that has been deserialized Server-side?   The GetXServer.compareTo will take into consideration the TimeRange?  I think I like it.  Why do I need result 2 and 3 out of the compareTo?  Whats wrong with the compareTo working like any other comparator returning &amp;lt; 0, 0, or &amp;gt; 0?  If 0, we add to the result.  If &amp;gt; 0, we&apos;ve gone past whatever our context, storefile or store, and then in the loop we just move on to the next storefile or store.  Shouldn&apos;t be compareTo if returning different kind of results.&lt;br/&gt;
+ What about deletes?  They are orthogonal to this compareTo test?  They are a running list that we bring along with our results as we do currently?  Looks like you have this thing called NewDeletes that GetX knows about?&lt;br/&gt;
+ How does your DeleteSet work?  How will it delete with different types (e.g. what do you add to this Set?  Deletes?  If so, how you going to have the Put something is supposed to Delete match in the comparator?  Currently I have a special comparator that ignores types... that won&apos;t be good enough if need to consider family, column and plain deletes).&lt;br/&gt;
+ We&apos;re changing how filters work?&lt;/p&gt;</comment>
                            <comment id="12703506" author="erikholstad@gmail.com" created="Tue, 28 Apr 2009 05:56:59 +0000"  >&lt;p&gt;On the sorting of the types, that is good. So we have &quot;bigger&quot; deletes sorted before smaller, so that they we be encountered first.&lt;br/&gt;
When I talked about deleteFamily being stored in a separate place that is when you are doing a get call, not how they are stored in&lt;br/&gt;
the file. In the file they are stored first in the row, since they have an empty value in the column field.&lt;/p&gt;

&lt;p&gt;When it comes to deletes and timestamps the deleteFamily and deleteColumn deletes all data that comes after that ts but for&lt;br/&gt;
delete it only deletes the given ts and does not affect other data.&lt;/p&gt;

&lt;p&gt;In memcache if putting first a delete(ts1) and then after a while putting a deleteColumn(ts3) the delete(ts1) is removed and deleteColumn(ts3) kept. But if they are put in, in opposite order deleteColumn(ts1) and then delete(ts3) both of them are kept. &lt;/p&gt;

&lt;p&gt;Another optimization that is made in memcache and also can be done when doing a minor compaction is to remove the delete itself in the case you find that exact timestamp, only for delete and not for the &quot;bigger&quot; deletes.&lt;/p&gt;</comment>
                            <comment id="12703513" author="erikholstad@gmail.com" created="Tue, 28 Apr 2009 06:27:33 +0000"  >&lt;p&gt;+ Do you mean TimeRange, or are you really talking about TimeStamp?&lt;br/&gt;
+ Versions are handled differently depending on what kind of query is is, but basically there is a separate list that keeps track of how many versions that have been fetched that lines up with the list of KeyValue fetched.&lt;br/&gt;
+ The Family object is not needed but it makes a nice abstraction from the array of arrays, and for the case of using the family for e get, you don&apos;t need to store the family name more than once, which is not the case with the old way. I nice thing with having a family object is also that you don&apos;t need to look at the objects themselves to figure out what family it is, since it is stored separately. &lt;br/&gt;
+ The GetXServer is a GetX that has be deserialized on the server, but also includes the compareTo(KeyValue) method and some other get specific methods that belong on the server side. Yes  the compareTo(KeyValue) method in the GetXServer class checks everything from row/column to ttl, TimeRange, Filter and versions, everything is handled in this method. The reason that there are to different return code for next storefile and Done is to be able to early out, so that you don&apos;t have to go to the next storfile, but you are right, it should probably be called something else than compareTo since it doesn&apos;t have the expected return codes.&lt;br/&gt;
+So in the GetXServer class you have like 6 different list, you have gets, newGets, deletes, newDeletes, versions and newVersions, all of these are not used for all types of gets but basically how it works it that you create the newList in the current storefile and after every store file you merge the 2 lists into one and they are but into the non new lists.&lt;br/&gt;
+All the compare code that I&apos;m using is currently in the GetXServer class, the only external compare that I&apos;m currently using it Bytes.compare(). The reason that I&apos;ve done it this way is because I don&apos;t want to recalculate the offsets and lengths when doing different compares. I don&apos;t have a deleteSet just a list of KeyValues that are deletes. The basic layout that we can&apos;t escape is that we have 3 lists, one with the KeyValues in the current memcache/storefile, data, one with things that we are looking for, gets and one with the deletes. So instead of having sets or sortedmaps where these are stores we just have 3 sorted lists. So for every data, we look in the get list to see if that entry can be found and iterate down the get list until we find that entry or something that is bigger. In the case of a hit in the get list we do the same thing in the delete list. This means that if the lists are k, l, m long worst case lookup are k+l+m.&lt;br/&gt;
+ I haven&apos;t done anything with filters yet, I just have a part in the compareTo(KeyValue) where the filter check should sit.&lt;/p&gt;</comment>
                            <comment id="12703523" author="stack" created="Tue, 28 Apr 2009 07:16:59 +0000"  >&lt;p&gt;Yes, I mean TimeRange (sorry).&lt;/p&gt;

&lt;p&gt;On the Family object, how many times would we have to repeat family in the old byte [][] of columns before it cost more than creation of Family object with a List?  I&apos;m guessing we&apos;d have to have a lot of entries in a Get before it&apos;d cost less using Family objects (In general, just trying to keep down number of items we deal with).  Would the Family be passed over IRC?&lt;/p&gt;

&lt;p&gt;I can early out if compareTo returns &amp;gt; 0 &amp;#8211; i.e. we&apos;ve gone beyond &amp;#8211; and we have enough versions?  Do I need extra codes?&lt;/p&gt;

&lt;p&gt;Is GetXServer different from GetX on client?&lt;/p&gt;

&lt;p&gt;On filters, the docs suggest we&apos;re doing new type of filter.  Was asking if that true.&lt;/p&gt;</comment>
                            <comment id="12703529" author="stack" created="Tue, 28 Apr 2009 08:00:37 +0000"  >&lt;p&gt;On filters, reading code, it looks like filters would be our old favorite interface, RowFilterInterface.... so I answered my own question.&lt;/p&gt;</comment>
                            <comment id="12703696" author="streamy" created="Tue, 28 Apr 2009 16:03:57 +0000"  >&lt;blockquote&gt;
&lt;p&gt;+ Is the Family object needed? The old array of arrays where columns were compound of family and qualifier would seem to be more compact?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, it is more compact.  And insanely difficult to actually use and reason about.  We have had a good amount of back and forth about whether to use more classes or not.  This applies to 880 especially.  My general argument is (client-side):&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The HTable API needs to be smaller, it is very wide and it makes things complicated.&lt;/li&gt;
	&lt;li&gt;The HTable API does not reflect server-side implementation.&lt;/li&gt;
	&lt;li&gt;Dealing with family:column and binary is a nightmare.  Delimiters generally suck.&lt;/li&gt;
	&lt;li&gt;We can retain a slimmer, direct byte[] based HTable API for ease-of-use, and then use classes for more complex/custom queries.&lt;/li&gt;
	&lt;li&gt;A hierarchical client API that maps to a server-side set of classes mirrors queries to implementation and makes it more clear to the user which things have a cost (like each family you add as a parameter is much different than adding an additional column parameter to a family).&lt;/li&gt;
	&lt;li&gt;Instantiating objects on the client-side for Gets is basically to be considered &quot;free&quot;.  Compared to the amount of comparators, utility functions, and allocation we currently have to deal with family:column byte[]s, there&apos;s no difference in performance on the client-side using nested objects and lists.  Performance does/will come from getting rid of server-side instantiation/allocation (zero-copy reads, optimized Gets, not using TreeMap after TreeMap).&lt;/li&gt;
	&lt;li&gt;Methods of all sorts basically being a single serialized object, many times just lists of KeyValues, for RPC in the interest of moving towards a language agnostic client protocol.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Should bring this conversation to IRC if people want to chime in... we definitely want others input, this is a big decision, but the API is much more usable like this and server implementations much easier to reason about.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;+ How do I read GetXServer? Is that the client-side GetX that has been deserialized Server-side? The GetXServer.compareTo will take into consideration the TimeRange? I think I like it. Why do I need result 2 and 3 out of the compareTo? Whats wrong with the compareTo working like any other comparator returning &amp;lt; 0, 0, or &amp;gt; 0? If 0, we add to the result. If &amp;gt; 0, we&apos;ve gone past whatever our context, storefile or store, and then in the loop we just move on to the next storefile or store. Shouldn&apos;t be compareTo if returning different kind of results.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;No problem with renaming it.  It does break the normal convention.  It can&apos;t be -1, 0, 1 because it has four different things it needs to say.  You say, if &amp;gt; 0, we&apos;ve gone past storefile or store.  That means in every query, we will always have to check every storefile.  Many of our queries (GetColumns, GetTop at least) have early-outs where they do not need to look into any other storefiles.  So this compare needs to be able to say, i&apos;m done, return to client now.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;+ What about deletes? They are orthogonal to this compareTo test? They are a running list that we bring along with our results as we do currently? Looks like you have this thing called NewDeletes that GetX knows about?&lt;br/&gt;
+ How does your DeleteSet work? How will it delete with different types (e.g. what do you add to this Set? Deletes? If so, how you going to have the Put something is supposed to Delete match in the comparator? Currently I have a special comparator that ignores types... that won&apos;t be good enough if need to consider family, column and plain deletes).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Best answered by Erik... My understanding is basically we keep deletes to the side.  DeleteFamily&apos;s are special cased.  Since deletes only apply to older storefiles, when reading a storefile we insert deletes to a newDeletes list and actually use the oldDeletes list to check if things are deleted.&lt;/p&gt;

&lt;p&gt;But the way things are processed is neat.  It&apos;s a sorted merge down the oldDeletes list.  So you do not have to check against a bunch of things, or do a (log n) treemap operation.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;+ We&apos;re changing how filters work?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I would like to.  None of the code is done.  I have no issue with delaying that for 0.21, but since things are being ripped apart thought we might get it in.  The biggest change outlined here is adding new language similar to the compareTo above... done, return now.  Would allow for efficient limit, offset queries and other such things.  As you say, in current code it is the same.  The other thing with filters is it would be nice to be able to use dynamic classes.  So we might just put off filter changes to 0.21 and give them more attention.&lt;/p&gt;</comment>
                            <comment id="12703721" author="erikholstad@gmail.com" created="Tue, 28 Apr 2009 16:50:19 +0000"  >&lt;p&gt;@Stack&lt;br/&gt;
+ TimeRange might be like the CellBounds, just a class with 2 timestamp, upper and lower bound for the getFetch.&lt;br/&gt;
+ About the Fmaily object, I think I need to do some testing, cause I didn&apos;t know that an object was that big while sending it over the  wire, but we all want the same thing here, to make it as fast as possible, so it that turns out top be the case, we will absolutely change the format. and I guess if you wanted to send extra params along with the family and columns we can put them before. Just seems more complicated to have a non object approach, but will have a look at the sizes.&lt;br/&gt;
+ The version code is now handled inside of the compareTo(KeyValue) and if we would lift it out of there we would have to add some extra logic outside, nothing major. The biggest reason for not doing this is the fact that the GetRow/GetFamilies calls will have to do this compare too, even thought they can never early out, so those calls are going to have to carry some extra weight.&lt;br/&gt;
+ GetXServer is different from GetX by the compareTo(KeyValue) method and some other smaller helper methods that are related to that one, but that is the only thing.&lt;br/&gt;
+ For now I only have the RowFilterInterface in my code, so that is the same for now.&lt;/p&gt;</comment>
                            <comment id="12703742" author="erikholstad@gmail.com" created="Tue, 28 Apr 2009 17:07:26 +0000"  >&lt;p&gt;Extra comment on Jonathan&apos;s  comment:&lt;br/&gt;
About deletes.&lt;br/&gt;
So when you enter a new file and walking down the lists doing the sorted merge between the data in the store, the gets and the previous deletes. When finding a delete in the current file this is just added to the newDelete list. Since all data is sorted the inserts in the newDeletes list will be sorted too. When the current store is done and if you need to go to the next one you first merge the oldDeletes with the new and use these for checking in the next storefile.&lt;/p&gt;

&lt;p&gt;Same thing is done for the gets, in the case of a GetRow/GetFamilies call.&lt;/p&gt;

&lt;p&gt;Versions are just a different list that sits in the GetXServer. This list is handled differently depending on what kind of call it is. In case of a GetColumns call this list is getting smaller and smaller and for the other cases it gets bigger and bigger. This is because columns are removed from the column list in the case of a GetColumns call, so the versions list has to match.&lt;/p&gt;</comment>
                            <comment id="12703757" author="stack" created="Tue, 28 Apr 2009 17:29:30 +0000"  >&lt;p&gt;@jon&lt;/p&gt;

&lt;p&gt;+ If client-side needs to reflect server-implementation, then we&apos;re off going by current state of src (Server objective is all byte arrays, client is introducing classes that are carried over to the server and then made into byte arrays; e.g. Family).&lt;br/&gt;
+ I&apos;m against two implementations, a &apos;slimmer&apos; byte-based, and then a object-based one for more complex queries IF they do not resolve to same thing client side (otherwise, as I see it we are multiplying the number of client/server methods and reasoning in server)&lt;br/&gt;
+ Family:column has been reined in server-side with comparators that compare the family only portion of column &amp;#8211; no new allocations.&lt;br/&gt;
+ I&apos;m grand w/ lots of objects client-side but not wanton profligacy &amp;#8211; should be elegant design&lt;br/&gt;
+ I wish I saw more KV in the current src; seems little going between client and server currently.&lt;br/&gt;
+ If we&apos;ve gone past the current store file, and we have enough versions... thats how we figure when we can early-out, right?  What other factor is there?  Only one that might complicate is the GetTop.  For that, you need to count versions differently &amp;#8211; not per column-family but in total &amp;#8211; IIUC.  Has to be really good reason for doing a compare that is like but just a little different from what devs are used to.&lt;br/&gt;
+ I wonder why bother with NewDeletes?  Just add them to the running deletes list?  Its a lookup into a sorted set so extra numbers will make a very-slight difference, not enough of a difference that its worth instantiating 3x the lists and running combine as we move from one storefile to the next I&apos;d guess (Looks like I&apos;m not getting something here in the way the test if a cell is deleted is working &amp;#8211; please help me understand if I&apos;m missing something about how this system works.. the delete system).&lt;br/&gt;
+ OK w/ putting of filters to 0.21... using what we have not if we can.&lt;/p&gt;

&lt;p&gt;@Erik&lt;/p&gt;

&lt;p&gt;+ Version handling inside the compareTo says to me that the method is not a compareTo at all... that its a kind of hasEnough test.  Might be nice having the version code all up inside the hasEnough method.&lt;/p&gt;

&lt;p&gt;Erik, how do you figure this code makes things faster.  Its not plain to me how it does that.&lt;/p&gt;


</comment>
                            <comment id="12703916" author="erikholstad@gmail.com" created="Wed, 29 Apr 2009 00:36:41 +0000"  >&lt;p&gt;@Stack&lt;br/&gt;
+ I totally agree that the naming of the compareTo(KeyValue) method is not the best, should probably be something else like you suggested hasEnough or shouldAdd or something along those lines.&lt;/p&gt;

&lt;p&gt;+ Why this new code is faster than the old one. There are a couple of things that will make this new code faster than the old one:&lt;br/&gt;
You have your KeyValue iterator, data length k, your columns asked for, gets length l,  and your deleteStructure, deletes length m.&lt;br/&gt;
1. The way a get is done today is that for every data you compare it to all the columns asked for and for every match you do a contains on that data. This means that you will do k*l +l*something for the delete contains check. Since the deletes are stored in a sortedSet every insert into it takes log&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_down.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
2. The way the KeyValue object is used in many places it to call getRowLength and then getColumnLength after each other, this means that you have to do all the calculations for the lengths and offsets multiple times. &lt;br/&gt;
3. When not having a structure from the client that groups families together you will have to get the right store for every KeyValue. &lt;/p&gt;

&lt;p&gt;1. The new code don&apos;t have any complicated data structures, just ArrayList&amp;lt;KeyValue&amp;gt; and the only operation that is done to these are add(KeyValue), so the time complexity if compared to the old way is k+l+m which is much fewer compares. &lt;br/&gt;
2. In the new code I have moved all the compare methods in to the actual code, this means that there will be more code that is duplicated, but I think that it is a better approach when we are going for speed. I don&apos;t recalculate and lengths or offset if it is not absolutely necessary .&lt;/p&gt;

&lt;p&gt;But the biggest gain in time comes from not having complicated data structures on the server but rather keeping it simple. Of course there are other things that becomes more complicated like merging the lists after every storefile, but there is no way around that as I see it. Don&apos;t think it gets much faster than doing a sorted merge.&lt;/p&gt;</comment>
                            <comment id="12704147" author="erikholstad@gmail.com" created="Wed, 29 Apr 2009 15:13:21 +0000"  >&lt;p&gt;So was a little bit confused when it came to the number of compares for the old version yesterday, somehow I thought that the deletes structure was a hashset, but it is a sorted set.&lt;br/&gt;
So the number of compares for getting becomes k*l+ l*log(m) and for the new k+l+m, which if you just wanna put some totally unreasonable test numbers in  there just to get a feeling, k=l=m=8 turns out to be&lt;br/&gt;
8*8 + 8*3 = 64+24 = 88 vs 8+8+8 = 24.&lt;/p&gt;

&lt;p&gt;For the new code, like said earlier the most complex part is the merging of the lists and specially the merge of the deletes. On the other hand it is very easy to write unit test for this to test it in isolation, which has also been done.&lt;/p&gt;</comment>
                            <comment id="12704194" author="stack" created="Wed, 29 Apr 2009 16:34:24 +0000"  >&lt;p&gt;@Holstad&lt;/p&gt;

&lt;p&gt;Do you have profiling stats that show us getting gains we&apos;ll even be able to notice?&lt;/p&gt;

&lt;p&gt;.bq You have your KeyValue iterator, data length k, your columns asked for, gets length l, and your deleteStructure, deletes length m.&lt;/p&gt;

&lt;p&gt;I don&apos;t follow the above and can you expand more on your exposition on why things will be faster?  Looks like you&apos;ve spent some time figuring it.&lt;/p&gt;

&lt;p&gt;1. My sense is that the delete check is not costly, not in the scheme of things.&lt;br/&gt;
2. There is caching of lengths being done in many of those cases, right?&lt;br/&gt;
3. I was going to say that I don&apos;t think this expensive in the scheme of things but just looked at PE profiling and see it taking 2% of CPU... this and getRegion... and this is with the simple PE schema (one family).&lt;/p&gt;

&lt;p&gt;-1 on duplicated code.  Lets work on that.  Especially when its complex code like this.&lt;/p&gt;

&lt;p&gt;You talked of 2x speedup.  How&apos;d you make out that?&lt;/p&gt;</comment>
                            <comment id="12704271" author="streamy" created="Wed, 29 Apr 2009 19:24:25 +0000"  >&lt;p&gt;(this was written together with erik holstad)&lt;/p&gt;

&lt;p&gt;@Stack&lt;/p&gt;

&lt;p&gt;We don&apos;t have any profiling stats or end-to-end numbers at the moment, but we do have are some early naive timing test that compare the 2 implementations and already for very few inserts like 10 to 15 entries with no deletes in 2 storefiles + memcache I saw around 2x improvment. These test were only done on the server and I have not tested for bigger tables and from the client, since I only got the rpc to work the other day and we&apos;ve done some reworks since then, but it looks promising.&lt;/p&gt;

&lt;p&gt;When we looked at the get code and how to make it faster we started to look what structures were used and how many compares you have to do to get your result. Because to me the way to speed things up is to cut down the total number of compares that you need to do to get your result. Of course the total fetch time is made up by a number of causes, but on the server, outside of HFile/HDFS, where I think most time is spent is comparing entries to see if they should be included in the result or not (this decision made by looking at the query to see if it was asked for, comparing for deletes, checking for ttl, maxVersions requested, timeRange, etc).&lt;/p&gt;


&lt;p&gt;So what I saw when looking at the old code is that for every new entry from the storefile you compare it to all entries in the get set and then for every match between those you have to check to see it is has been deleted.&lt;/p&gt;

&lt;p&gt;Let &lt;tt&gt;&lt;b&gt;k&lt;/b&gt;&lt;/tt&gt; be the number KeyValues we will look at.  Let &lt;tt&gt;&lt;b&gt;l&lt;/b&gt;&lt;/tt&gt; be the number of columns asked for by the client.&lt;/p&gt;

&lt;p&gt;Old Way: We compare every entry from the storefile (k) with every entry from the getset (l) which will give you &lt;tt&gt;&lt;b&gt;k * l&lt;/b&gt;&lt;/tt&gt; compares in total.&lt;/p&gt;

&lt;p&gt;If the getset is sorted (storefile/memcache always is), then you are just doing a sorted merge between two sorted lists.&lt;/p&gt;

&lt;p&gt;New Way: We do a sorted merge between the entries in the storefile (k) with the entries in the sorted getset (l) which will give you &lt;tt&gt;&lt;b&gt;k + l&lt;/b&gt;&lt;/tt&gt; compares in total.&lt;/p&gt;

&lt;p&gt;The difference between &lt;tt&gt;&lt;b&gt;k * l&lt;/b&gt;&lt;/tt&gt; and &lt;tt&gt;&lt;b&gt;k + l&lt;/b&gt;&lt;/tt&gt; can be significant if you are matching more than one column.&lt;/p&gt;

&lt;p&gt;Notes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;current plan is to build the sortedset behind the scenes on the client in the Get&lt;/li&gt;
	&lt;li&gt;this insertion sort will have a negligible impact on clients and no additional work will be required server-side&lt;/li&gt;
	&lt;li&gt;we will send the sortedset over the wire as a list.  in that case, it will not have to be re-sorted.&lt;br/&gt;
(this last optimization is important.  right now we do a LOT of serializing a sorted tree, sending it over the wire, and then deserializing it.  the deserializing of trees actually rebuilds the entire tree, thus reperforming the sort.  using lists (which are sorted) will give us time and memory savings.)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;On the delete part, we have two things to deal with.  Checking current KVs against the current DeleteSet, and adding newly seen deletes into the DeleteSet.&lt;/p&gt;

&lt;p&gt;Let &lt;tt&gt;&lt;b&gt;k&lt;/b&gt;&lt;/tt&gt; be the number of KeyValues we will look at.  Let &lt;tt&gt;&lt;b&gt;m&lt;/b&gt;&lt;/tt&gt; be the number of deletes we have already seen.  Let &lt;tt&gt;&lt;b&gt;n&lt;/b&gt;&lt;/tt&gt; be the number of new deletes we will see.&lt;/p&gt;

&lt;p&gt;Old way of checking current KVs agains the current DeleteSet:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;DeleteSet is a sortedSet, so it has &lt;tt&gt;&lt;b&gt;log(m)&lt;/b&gt;&lt;/tt&gt; inserts/gets/deletes/contains operations.&lt;/li&gt;
	&lt;li&gt;For each KV seen (k), we have a &lt;tt&gt;&lt;b&gt;log(m)&lt;/b&gt;&lt;/tt&gt; operation to see if it is deleted.&lt;/li&gt;
	&lt;li&gt;This will give you &lt;tt&gt;&lt;b&gt;k * log(m)&lt;/b&gt;&lt;/tt&gt; total comparisons.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Old way of inserting newly seen delete KVs into current DeleteSet:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;When we see a delete, we insert it to the deleteset in &lt;tt&gt;&lt;b&gt;log(m)&lt;/b&gt;&lt;/tt&gt;.  This has downsides.&lt;/li&gt;
	&lt;li&gt;We&apos;re adding deletes which we know will not be relevant in this storefile (increasing m increases subsequent delete checks so we have log(m + n) eventually).&lt;/li&gt;
	&lt;li&gt;We&apos;re doing work which we may not potentially ever have to do (merging newly seen delete with previous set).  If we are going to early-out of this storefile for some reason, there would never have been a reason to pay anything but constant-time cost for deletes related to older storefiles which will not end up being opened.&lt;/li&gt;
	&lt;li&gt;Trees are bad!  Their allocation of lots of small nodes is a disaster for GC.  We should use lists everywhere we can.&lt;/li&gt;
	&lt;li&gt;This gives you &lt;tt&gt;&lt;b&gt;n * log(m)&lt;/b&gt;&lt;/tt&gt; total comparisons.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The new approach is similiar to how we now handle the get list.  Deletes will be stored in two lists.  A currentDeleteList and a newDeleteList.&lt;/p&gt;

&lt;p&gt;To start, the memcache has no deletes to look at.  You will, however, add any deletes seen to the newDeleteList (in constant time, no significant extra work).  Since memcache (and storefiles) are sorted, newDeleteList is sorted.&lt;/p&gt;

&lt;p&gt;When moving to the next storefile, you will merge newDeleteList with currentDeleteList.&lt;/p&gt;

&lt;p&gt;New way of handling deletes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;currentDeleteList is a sorted ArrayList of deletes.  there is a DeleteFamily special-case that just stores a stamp (which implies it&apos;s existence).&lt;/li&gt;
	&lt;li&gt;We do a sorted merge of KVs seen (k) with the currentDeleteList (m), for &lt;tt&gt;&lt;b&gt;k + m&lt;/b&gt;&lt;/tt&gt; total comparisons.&lt;/li&gt;
	&lt;li&gt;Each seen new delete is a O(1) append to the newDeleteList.&lt;/li&gt;
	&lt;li&gt;At the end of the storefile, you will then need to merge the delete lists, for &lt;tt&gt;&lt;b&gt;m + n&lt;/b&gt;&lt;/tt&gt; total comparisons.&lt;/li&gt;
	&lt;li&gt;This will give you &lt;tt&gt;&lt;b&gt;(k + m) + (m + n)&lt;/b&gt;&lt;/tt&gt; total comparisons for each storefile.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The difference in total is: Old = &lt;tt&gt;&lt;b&gt;(k + n) * log(m)&lt;/b&gt;&lt;/tt&gt; vs New = &lt;tt&gt;&lt;b&gt;(k + n) + 2m&lt;/b&gt;&lt;/tt&gt;&lt;/p&gt;


&lt;p&gt;The algorithmic improvements seem clear.  The replacement of Trees/SortedSets with (Sorted)Lists/ArrayLists will also be beneficial for GC/heap usage.&lt;/p&gt;

&lt;p&gt;Additional complexity in things like merging delete lists are not a big deal if we make thorough unit tests (which we have already done in that case).&lt;/p&gt;</comment>
                            <comment id="12704272" author="erikholstad@gmail.com" created="Wed, 29 Apr 2009 19:26:52 +0000"  >&lt;p&gt;@Stack&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1. My sense is that the delete check is not costly, not in the&lt;br/&gt;
scheme of things.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I would say that it is costly in cases where you have many deletes.  I&lt;br/&gt;
also see no downside or big areas where the new design would perform any&lt;br/&gt;
worse.  We also need to think about memory allocation.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;2. There is caching of lengths being done in many of those cases,&lt;br/&gt;
right?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I&apos;m not sure exactly what you mean, but yes there may be.  But without it&lt;br/&gt;
being clear, it seems we would want to ensure in this very important (for&lt;br/&gt;
performance) code path is optimally reusing them.&lt;/p&gt;

&lt;p&gt;One of the problems with java is that you can&apos;t return multiple things at&lt;br/&gt;
the same time in an easy way.  For me trying to make the server&lt;br/&gt;
implementation faster I&apos;d rather have duplication of code than make it&lt;br/&gt;
slower.&lt;/p&gt;

&lt;p&gt;I totally agree that we should try to keep duplication to a minimum, but I&lt;br/&gt;
rather focus on speed first and then work in minimizing the code base,&lt;br/&gt;
might be the wrong approach. When it comes to the part of duplicating&lt;br/&gt;
complex code I totally agree, this makes it more prone to errors and&lt;br/&gt;
should definitely be avoided when possible.&lt;/p&gt;

&lt;p&gt;The code that I duplicate is mostly the compare code for 2 KeyValues, so&lt;br/&gt;
it is pretty straightforward, not like the more complex merge codes which&lt;/p&gt;</comment>
                            <comment id="12704360" author="stack" created="Wed, 29 Apr 2009 21:50:40 +0000"  >&lt;p&gt;Thanks for the exposition.   I like it for case of gets of many columns into table with many deletes.&lt;/p&gt;

&lt;p&gt;I must say though that I&apos;m surprised for the case described above &amp;#8211; few entries with two families and no deletes &amp;#8211; that the difference is even discernible, never mind that its 2x.  Are you sure its because of the above described changes and not something else about the new code path?  Perhaps something is being skipped or there is dumb bug in old code?&lt;/p&gt;</comment>
                            <comment id="12704373" author="erikholstad@gmail.com" created="Wed, 29 Apr 2009 22:11:00 +0000"  >&lt;p&gt;With the old code we used to put all the calls for for multiple columns or all &lt;br/&gt;
columns for a family into the same get call, getFull, this was done even though&lt;br/&gt;
they are doing very different things. So what I would like to see on the server&lt;br/&gt;
side are 2 different pieces of code, that handles the 2 queries differently.&lt;/p&gt;

&lt;p&gt;Let&apos;s call these calls getFamilies and getColumns for simplicity, where&lt;br/&gt;
getFamilies is the call you make when you want to get all the columns for a&lt;br/&gt;
family and getColumns when you specify some columns that you want to get.&lt;/p&gt;

&lt;p&gt;In the new code, for the getColumns call I remove the elements from the list&lt;br/&gt;
that already have the number of versions asked for, so the getList becomes&lt;br/&gt;
smaller and smaller.&lt;/p&gt;



&lt;p&gt;For getFamilies the situation is different since you start with an empty getList&lt;br/&gt;
and build it as you go.&lt;/p&gt;

&lt;p&gt;The problem with the getFamilies query is that you have to keep the numbers of&lt;br/&gt;
versions around even though you have gotten them all.&lt;/p&gt;

&lt;p&gt;The old way of doing things was to build a map that had an entry for every &lt;br/&gt;
KeyValue fetched that mapped to the number of versions fetched.&lt;/p&gt;

&lt;p&gt;The new approach is to keep a newGet list where you insert the new things from&lt;br/&gt;
the current storefile and then before going into the next storefile merge these&lt;br/&gt;
2 lists together, the same way as you do with deletes.&lt;br/&gt;
This is just one small detail in the new implementation, but I thought it was&lt;br/&gt;
important to bring it up since it brings some extra complexity from the&lt;br/&gt;
otherwise pretty simple getColumns code, where most of the code from getFamilies&lt;br/&gt;
is taken from.&lt;/p&gt;



&lt;p&gt;Some timing results:&lt;br/&gt;
These test are only done on the server side and doesn&apos;t include any time for&lt;br/&gt;
sending data between server and client. I basically created a HRegion in the&lt;br/&gt;
test, inserted data into it and queried it with 2 different calls the old&lt;br/&gt;
getFull() and the semi old, getFamilies(). The test were done by inserting&lt;br/&gt;
data at 3 different times with a flush in between so you end up with data in&lt;br/&gt;
memcache and data in 2 storefiles. The region only have one family and the&lt;br/&gt;
qualifiers are numbers ranging from 1-n, so you have 3 versions of every insert.&lt;br/&gt;
The get query was to get 3 versions of all the data, so you need to go through&lt;br/&gt;
all the storefiles and no way of early out, which is always the case when it&lt;br/&gt;
comes down to a query like this.&lt;/p&gt;

&lt;p&gt;Results(ns):&lt;br/&gt;
n = 10&lt;br/&gt;
new timer 483525&lt;br/&gt;
old timer 2619048&lt;/p&gt;

&lt;p&gt;n = 100&lt;br/&gt;
new timer 3237894&lt;br/&gt;
old timer 15307717&lt;/p&gt;

&lt;p&gt;n = 1000&lt;br/&gt;
new timer 22449940&lt;br/&gt;
old timer 435134261&lt;/p&gt;


&lt;p&gt;These test doesn&apos;t include any deletes. In the case of deletes in the system I&lt;br/&gt;
think that the difference will be even greater.&lt;/p&gt;


&lt;p&gt;To be clear about the parts where extra testing and time is need to be spent are&lt;br/&gt;
the following areas in the new code:&lt;br/&gt;
Merging of deletes, merging of Gets and handling of versions in the case of a&lt;br/&gt;
&quot;GetFamilies&quot; call.&lt;/p&gt;


&lt;p&gt;I did find some bugs while running this timing test, so will keep working&lt;br/&gt;
towards a good patch where most of that stuff is taken care of.&lt;/p&gt;</comment>
                            <comment id="12704375" author="erikholstad@gmail.com" created="Wed, 29 Apr 2009 22:16:05 +0000"  >&lt;p&gt;@Stack&lt;br/&gt;
I don&apos;t really know exactly where the big improvement comes from compared to the old code, but I don&apos;t think that it is that weird that we see a big improvement even though the x factor might not be totally true. And I&apos;m not going to say that I haven&apos;t missed anything in the new code, cause that would just be really silly, but I think atleast we have some good numbers to work with. But since I don&apos;t have a working patch just yet, these number should be more as guidelines than actual numbers to compare.&lt;/p&gt;</comment>
                            <comment id="12704390" author="erikholstad@gmail.com" created="Wed, 29 Apr 2009 22:48:12 +0000"  >&lt;p&gt;Just for the people that are still a little bit sceptic that an algorithmic change can make a great improvement in speed, you can just test this simple timing test for different m and n and have a look at what the result is.&lt;/p&gt;

&lt;p&gt; public void timingTester(){&lt;br/&gt;
    long start = 0L;&lt;br/&gt;
    long stop  = 0L;&lt;br/&gt;
    int m = 100;&lt;br/&gt;
    int n = 100; &lt;br/&gt;
    int size = m*n;&lt;br/&gt;
    int ret = 0;&lt;/p&gt;

&lt;p&gt;    //old &lt;br/&gt;
    start = System.nanoTime();&lt;br/&gt;
    for(int i=0; i&amp;lt;size; i++)&lt;/p&gt;
{
      ret = (2*i) -i; //or do something else
    }
&lt;p&gt;    stop = System.nanoTime();&lt;br/&gt;
    System.out.println(&quot;old timer &quot; +(stop-start));&lt;/p&gt;

&lt;p&gt;    //new&lt;br/&gt;
    size = m+n;&lt;br/&gt;
    start = System.nanoTime();&lt;br/&gt;
    for(int i=0; i&amp;lt;size; i++)&lt;/p&gt;
{
      ret = (2*i) -i;
    }
&lt;p&gt;    stop = System.nanoTime();&lt;br/&gt;
    System.out.println(&quot;new timer &quot; +(stop-start));&lt;br/&gt;
  }&lt;/p&gt;</comment>
                            <comment id="12707198" author="erikholstad@gmail.com" created="Fri, 8 May 2009 01:03:54 +0000"  >&lt;p&gt;Been working on a new FilterInterface that will work better with the new server side implementation, been thinking something like:&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Interface to be used for server side filtering for gets and scans.&lt;/li&gt;
	&lt;li&gt;The cases of wanting to not look at any more entries in the current store&lt;/li&gt;
	&lt;li&gt;and the case of always wanting to look at the filter should be handled with&lt;/li&gt;
	&lt;li&gt;the return codes from the individual filters.&lt;br/&gt;
 *&lt;br/&gt;
 */&lt;br/&gt;
public interface FilterInterface extends Writable 
{

  final static int DONE = -1;
  final static int SKIP = 0;
  final static int INCLUDE = 1;
  
  /**
   * Resets the state of this filter. 
   */
  public void reset();
  
  /**
   * Filters the current row to see if it should be included in the result or
   * not.
   * @param bytes
   * @param rowOffset
   * @param rowLength
   * @return -1 if you are done and can return the result, 0 when not to include
   * in result and 1 if this row should be included. 
   */
  public int filterRow(byte [] bytes, int rowOffset, int rowLength);

  /**
   * Filters the current qualifier to see if it should be included in the result
   * or not.
   * @param bytes
   * @param qualifierOffset
   * @param qualifierLength
   * @return -1 if you are done and can return the result, 0 when not to include
   * in result and 1 if this row should be included
   */
  public int filterQualifier(byte [] bytes, int qfOffset, int qfLength);

  /**
   * Filters the current value to see if it should be included in the result or
   * not.
   * @param bytes
   * @param valueOffset
   * @param valueLength
   * @return -1 if you are done and can return the result, 0 when not to include
   * in result and 1 if this row should be included
   */
  public int filterValue(byte [] bytes, int valueOffset, int valueLength);
  
}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;They way I see it work is while comparing the different parts of the KeyValue you after every check do the matching filter check, to be able to early our as soon as possible. An extra method for filterFamily can easily be added in the future if we choose to support multiple families in the same store. &lt;/p&gt;
</comment>
                            <comment id="12707219" author="streamy" created="Fri, 8 May 2009 03:23:03 +0000"  >&lt;p&gt;Code looked okay in the e-mail but is unreadable on the issue.  Attach as a patch or java file next time?  Should probably file another issue for this.&lt;/p&gt;

&lt;p&gt;Can you use an enum instead of ints for return codes?&lt;/p&gt;</comment>
                            <comment id="12707226" author="stack" created="Fri, 8 May 2009 04:26:29 +0000"  >&lt;p&gt;Regards Filter interface, it doesn&apos;t look that different from what we had before, not different enough to warrant redoing.  Is current filter interface antithetical to KV?&lt;/p&gt;</comment>
                            <comment id="12707233" author="streamy" created="Fri, 8 May 2009 04:54:10 +0000"  >&lt;p&gt;I don&apos;t believe there&apos;s anything antithetical to KV with the current implementation.  I&apos;m not sure if we need to redo it or not, but at the least, the current interface needs to be extended to add a column qualifier check.&lt;/p&gt;</comment>
                            <comment id="12707234" author="erikholstad@gmail.com" created="Fri, 8 May 2009 04:57:53 +0000"  >&lt;p&gt;@jgray&lt;br/&gt;
Yeah, it&apos;s is a little weird, cause when I pasted it, it looked really good in the window, but now it looks really bad.&lt;/p&gt;

&lt;p&gt;@Stack&lt;br/&gt;
Not really sure what is considered to be very different, I do think that the difference is quite big&lt;br/&gt;
The only methods that stays pretty much the same is reset() and filterColumn which changes name to filterQualifier since we are trying to get rid of the column notion.&lt;br/&gt;
The filterRowKey could be used as filterRow, but since we only take a byte[] as input we can&apos;t use the KeyValue from the scanners but have to do a copy for every check, which seems like&lt;br/&gt;
an unnecessary  thing to do, specially since the whole plan on the server side is to avoid copying.&lt;br/&gt;
I&apos;m not dying to rewrite the filters, but have started, cause I don&apos;t really seem how we could use the old ones in a good way, but if you see a way for us to do that, I&apos;m happy to not do the work.&lt;br/&gt;
. &lt;/p&gt;</comment>
                            <comment id="12707246" author="stack" created="Fri, 8 May 2009 05:48:14 +0000"  >&lt;p&gt;Erik. You need to update to TRUNK.  Filters were changed so they took byte array, offset and length.&lt;/p&gt;</comment>
                            <comment id="12713066" author="streamy" created="Tue, 26 May 2009 15:55:38 +0000"  >&lt;p&gt;This issue was used for discussion.  A new issue will be opened to turn these design documents into user documentation.&lt;/p&gt;

&lt;p&gt;Closing this issue as &quot;no longer valid&quot;.  This issue is being resolved as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1234&quot; title=&quot;Change HBase StoreKey format&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1234&quot;&gt;&lt;del&gt;HBASE-1234&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1304&quot; title=&quot;New client server implementation of how gets and puts are handled. &quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1304&quot;&gt;&lt;del&gt;HBASE-1304&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                            <outwardlinks description="blocks">
                                        <issuelink>
            <issuekey id="12415413">HBASE-1212</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12409017">HBASE-1015</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12421797">HBASE-1304</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                            <outwardlinks description="incorporates">
                                        <issuelink>
            <issuekey id="12403558">HBASE-861</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12405021">HBASE-899</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12383017">HBASE-52</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12408980">HBASE-1014</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12403648">HBASE-867</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12415194">HBASE-1206</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12386229">HBASE-61</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12404084">HBASE-880</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12415977">HBASE-1234</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12402539" name="HBASE-1249-Example-v1.pdf" size="47785" author="streamy" created="Thu, 19 Mar 2009 01:27:42 +0000"/>
                            <attachment id="12402577" name="HBASE-1249-Example-v2.pdf" size="47930" author="streamy" created="Thu, 19 Mar 2009 13:29:09 +0000"/>
                            <attachment id="12402525" name="HBASE-1249-GetQuery-v1.pdf" size="55217" author="streamy" created="Wed, 18 Mar 2009 22:27:43 +0000"/>
                            <attachment id="12402531" name="HBASE-1249-GetQuery-v2.pdf" size="55159" author="streamy" created="Wed, 18 Mar 2009 23:13:04 +0000"/>
                            <attachment id="12402860" name="HBASE-1249-GetQuery-v3.pdf" size="51217" author="streamy" created="Sat, 21 Mar 2009 00:49:18 +0000"/>
                            <attachment id="12406577" name="HBASE-1249-GetQuery-v4.pdf" size="49995" author="streamy" created="Mon, 27 Apr 2009 23:01:05 +0000"/>
                            <attachment id="12402508" name="HBASE-1249-StoreFile-v1.pdf" size="34887" author="streamy" created="Wed, 18 Mar 2009 21:03:01 +0000"/>
                            <attachment id="12406575" name="HBASE-1249-StoreFile-v4.pdf" size="11019" author="streamy" created="Mon, 27 Apr 2009 22:49:48 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>8.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 9 Mar 2009 17:51:24 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>32063</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 30 weeks, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0hc7b:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>99239</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>