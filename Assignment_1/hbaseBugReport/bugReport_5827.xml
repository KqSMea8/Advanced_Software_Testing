<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:31:18 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-5827/HBASE-5827.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-5827] [Coprocessors] Observer notifications on exceptions</title>
                <link>https://issues.apache.org/jira/browse/HBASE-5827</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;Benjamin Busjaeger wrote on dev@:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is there a reason that RegionObservers are not notified when a get/put/delete fails? Suppose I maintain some (transient) state in my Coprocessor that is created during preGet and discarded during postGet. If the get fails, postGet is not invoked, so I cannot remove the state.&lt;/p&gt;

&lt;p&gt;If there is a good reason, is there any other way to achieve the same thing? If not, would  it be possible to add something the snippet below to the code base?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-comment&quot;&gt;// pre-get CP hook
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (withCoprocessor &amp;amp;&amp;amp; (coprocessorHost != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)) {
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (coprocessorHost.preGet(get, results)) {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; results;
      }
    }
+    &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt;{
    ...
+    } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) {
+        &lt;span class=&quot;code-comment&quot;&gt;// failed-get CP hook
&lt;/span&gt;+        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (withCoprocessor &amp;amp;&amp;amp; (coprocessorHost != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)) {
+          coprocessorHost.failedGet(get, results);
+        }
+        rethrow t;
+    }

    &lt;span class=&quot;code-comment&quot;&gt;// post-get CP hook
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (withCoprocessor &amp;amp;&amp;amp; (coprocessorHost != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)) {
      coprocessorHost.postGet(get, results);
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/blockquote&gt;</description>
                <environment></environment>
        <key id="12551562">HBASE-5827</key>
            <summary>[Coprocessors] Observer notifications on exceptions</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="apurtell">Andrew Purtell</reporter>
                        <labels>
                    </labels>
                <created>Thu, 19 Apr 2012 01:52:15 +0000</created>
                <updated>Thu, 23 Oct 2014 17:55:45 +0000</updated>
                                                                            <component>Coprocessors</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>8</watches>
                                                                <comments>
                            <comment id="13257227" author="ram_krish" created="Thu, 19 Apr 2012 04:36:05 +0000"  >&lt;p&gt;+1 on such a feature.&lt;/p&gt;</comment>
                            <comment id="13257244" author="stack" created="Thu, 19 Apr 2012 05:18:31 +0000"  >&lt;p&gt;This seems like something we need if cps are to be able to keep a running context.&lt;/p&gt;</comment>
                            <comment id="13257483" author="apurtell" created="Thu, 19 Apr 2012 13:59:17 +0000"  >&lt;p&gt;I can try wrapping the code between pre and post hooks with try/catch in a way that doesn&apos;t change indenting inbetween.&lt;/p&gt;</comment>
                            <comment id="13257643" author="busjaeger" created="Thu, 19 Apr 2012 18:00:40 +0000"  >&lt;p&gt;It may make sense to also pass the Throwable to the Coprocessor in the &apos;failedXXX&apos; methods to give it a chance to introspect the error.&lt;/p&gt;</comment>
                            <comment id="13257667" author="ram_krish" created="Thu, 19 Apr 2012 18:27:30 +0000"  >&lt;p&gt;@Andy&lt;br/&gt;
I have some thing which is similar to this and sorry if am diverting the current JIRA title. &lt;br/&gt;
Suppose i want some state variable or some common object to be used across one flow, for eg. take the case of PUT.&lt;br/&gt;
May be i have the current PUT with me and from which i form the new PUTs to be added thro coprocessor hooks to a new region.&lt;br/&gt;
Assume the PUT(and related things) that i created in preBatchPut is also needed while i use the preWALWrite, is there any way i can carry it in one flow?&lt;br/&gt;
Hope am not missing anything? If you feel this can be done may be we can file an Improvement JIRA.  Please provide your suggestions &lt;/p&gt;</comment>
                            <comment id="13401758" author="apurtell" created="Tue, 26 Jun 2012 22:46:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;Assume the PUT(and related things) that i created in preBatchPut is also needed while i use the preWALWrite, is there any way i can carry it in one flow?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You can package the WAL observer and the region observer in the same JAR and they can use any way you&apos;d like to pass state between, perhaps by way of a singleton. Does this work? &lt;/p&gt;</comment>
                            <comment id="13401764" author="apurtell" created="Tue, 26 Jun 2012 22:56:34 +0000"  >&lt;p&gt;I&apos;d like to revisit the API changes under consideration here. &lt;/p&gt;

&lt;p&gt;Do we want a new failXXX for every operation, or should we alter the postXXX methods? &lt;/p&gt;

&lt;p&gt;If the latter, then do we:&lt;/p&gt;

&lt;p&gt;provide backwards compatible postXXX methods that put the Throwable into the Context and provide a new Context method for getting the caught Throwable, or null if nothing was caught;&lt;/p&gt;

&lt;p&gt;or pass the caught Throwable to new postXXX methods as a new parameter, still provide backwards compatible postXXX methods that put the Throwable into the Context, but also deprecate the backwards compatible postXXX methods.&lt;/p&gt;

&lt;p&gt;Edit: To clarify a bit, with the alternatives above involving postXXX, we would move code between preXXX and postXXX hooks into a try block, and in the catch handler call postXXX. The choice presented is basically between introducing a new failXXX method for every hook point or extending postXXX semantics to cover the exception path.&lt;/p&gt;</comment>
                            <comment id="13401774" author="jesse_yates" created="Tue, 26 Jun 2012 23:08:51 +0000"  >&lt;blockquote&gt;&lt;p&gt;provide backwards compatible postXXX methods that put the Throwable into the Context and provide a new Context method for getting the caught Throwable, or null if nothing was caught;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This seems a bit wonky and could will probably break a lot of existing CP functionality (or at least be incredibly wasteful, generating the same puts again, etc). &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;pass the caught Throwable to new postXXX methods as a new parameter,&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This seems a good way to do the failXXX method and not make things too different.&lt;/p&gt;

&lt;p&gt;We should also consider another interface based on (or at least conceptually similar to) SU&apos;s async stuff, so you could register a callback if you are interested in the error, but otherwise is handled by the standard mechanisms. Probably going to be a bit cleaner that doing all this wrapping and calling stuff on failure. Maybe a scope expansion here, but seemed a reasonable application. &lt;/p&gt;</comment>
                            <comment id="13401787" author="apurtell" created="Tue, 26 Jun 2012 23:18:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;We should also consider another interface based on (or at least conceptually similar to) SU&apos;s async stuff, so you could register a callback if you are interested in the error&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;@Jesse, thanks for commenting. I agree.&lt;/p&gt;

&lt;p&gt;For illustration, what the above discussion so far considers is something like:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    if (withCoprocessor &amp;amp;&amp;amp; (coprocessorHost != null)) {
      if (coprocessorHost.preGet(context, get, results)) {
        return results;
      }
    }
+   try {

// Existing code with formatting unchanged

+    } catch (Throwable t) {
+        // failed-get CP hook
+        if (withCoprocessor &amp;amp;&amp;amp; (coprocessorHost != null)) {
+          coprocessorHost.postGet(context, t, get, results);
+        }
+        rethrow t;
+    }
    if (withCoprocessor &amp;amp;&amp;amp; (coprocessorHost != null)) {
-     coprocessorHost.postGet(context, get, results);
+     coprocessorHost.postGet(context, null, get, results);
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What would the alternative look like?&lt;/p&gt;</comment>
                            <comment id="13401788" author="apurtell" created="Tue, 26 Jun 2012 23:22:32 +0000"  >&lt;blockquote&gt;&lt;p&gt;This seems a bit wonky and could will probably break a lot of existing CP functionality (or at least be incredibly wasteful, generating the same puts again, etc). &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Maybe I don&apos;t follow.&lt;/p&gt;

&lt;p&gt;Consider again:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;+    } catch (Throwable t) {
+        // failed-get CP hook
+        if (withCoprocessor &amp;amp;&amp;amp; (coprocessorHost != null)) {
+          coprocessorHost.postGet(context, t, get, results);
+        }
+        rethrow t;
+    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;and then in psuedocode:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;postGet(context, t, get, results):
    context.setThrowable(t)
    postGet(context, get, results)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So actually this would not break any existing CPs at all, it&apos;s the backwards compatible option.&lt;/p&gt;</comment>
                            <comment id="13401793" author="jesse_yates" created="Tue, 26 Jun 2012 23:26:40 +0000"  >&lt;blockquote&gt;&lt;p&gt;So actually this would not break any existing CPs at all, it&apos;s the backwards compatible option.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, you&apos;re right. I mis-understood and thought it would be more along the lines of calling cp.put(...) where the context there also includes the exception (since you probably care about the original put that borked things). This is better.&lt;/p&gt;</comment>
                            <comment id="13401801" author="jesse_yates" created="Tue, 26 Jun 2012 23:40:19 +0000"  >&lt;p&gt;The alternative might we something like:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;Set&amp;lt;ErrorHandler&amp;gt; CPerrorHandlers = &#8230;
&#8230;
loadCPs(){
for(cp : loadedCPs){
  CPerrorHandlers.add( cp.getErrorHandler());
}
&#8230;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Conceptually, the success/failure handlers could be bound via a Callback&amp;lt;success, failure&amp;gt; on the actual operation. The success handler would just be the regular Observer (though maybe it might be worth looking into abstracting that into another class that the Observer would return on request to be added to the Callback). The failure handler would deal with the exception and be preloaded with the rest of the context. &lt;/p&gt;

&lt;p&gt;Conceptually, this is really close to how the CP host works already, so maybe I&apos;m just proposing just doing a class-name change  - you&apos;ve definitely thought about this interface more that me &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Ideally, I would like to see the operation just wrapped in a single handler that keeps track of the success/failure observers, and calls them as necessary (without dealing with too much other state, e.g. host != null feels clunky all over the place).&lt;/p&gt;</comment>
                            <comment id="13401808" author="apurtell" created="Tue, 26 Jun 2012 23:48:56 +0000"  >&lt;p&gt;The postXXX hook is already what you are calling a success handler. &lt;/p&gt;

&lt;p&gt;We would still need to get into position to catch the failure. Invoking the failure handler from a catch clause would be like failXXX but with another name (and class), right?&lt;/p&gt;</comment>
                            <comment id="13401811" author="apurtell" created="Tue, 26 Jun 2012 23:53:40 +0000"  >&lt;p&gt;I don&apos;t want to hijack this discussion but when you say:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Conceptually, the success/failure handlers could be bound via a Callback&amp;lt;success, failure&amp;gt; on the actual operation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;this brings me back to an early thought I had about Coprocessors: that there would be a number of onThis and onThat style callbacks and the callback code (lambdas) would be &quot;submitted&quot; in client side APIs, and shipped to the server to execute. No need to install server side extensions at all. But for a variety of reasons we went instead with a server side upcall model, and that&apos;s what we have now.&lt;/p&gt;</comment>
                            <comment id="13401813" author="jesse_yates" created="Tue, 26 Jun 2012 23:59:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;the postXXX hook is already what you are calling a success handler. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yup, just trying to formalize the concept a little bit.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;nvoking the failure handler from a catch clause would be like failXXX but with another name (and class), right?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, but I&apos;d rather have that encapsulated away from the main code, so the calling methods would just be able to call&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;...
internalPutter.put(stuff)
...
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But again, basically what you have already (clearly more thought through than I did in the last 30mins). I&apos;ll have to take some time to see if a bigger redesign is warranted. &lt;/p&gt;

&lt;p&gt;TL;DR +1 on an onXXXXFailure method + a deprecated postXXX with error in context for compatibility&lt;/p&gt;</comment>
                            <comment id="13401820" author="apurtell" created="Wed, 27 Jun 2012 00:10:28 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;ll have to take some time to see if a bigger redesign is warranted. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In the abstract I&apos;d be all for a &quot;coprocessors v2&quot; if the result is more elegant. We are still pre Singularity. (But that does imply a time horizon.) The current framework design is the familiar upcall model, akin to kernel extensions, or a VFS interface. It counts simplicity and familiarity as pluses. But it is by no means the last word I&apos;d say.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;TL;DR +1 on an onXXXXFailure method + a deprecated postXXX with error in context for compatibility&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ack. And thanks.&lt;/p&gt;</comment>
                            <comment id="13401825" author="apurtell" created="Wed, 27 Jun 2012 00:19:51 +0000"  >&lt;p&gt;@Jesse, for the sake of clarity I&apos;m reading your +1 as a +1 on: &quot;a new postXXX method that accepts an additional Throwable parameter plus a deprecated postXXX with that Throwable in the context for compatibility&quot;, as that is what was proposed. Please indicate if otherwise.&lt;/p&gt;</comment>
                            <comment id="13401834" author="jesse_yates" created="Wed, 27 Jun 2012 00:25:12 +0000"  >&lt;p&gt;@Andrew - yup, that sounds fine. Are you thinking reflection to check existence of the right method or just calling both? Maybe some sort of tiered thing where the default calls the original?&lt;/p&gt;</comment>
                            <comment id="13401837" author="apurtell" created="Wed, 27 Jun 2012 00:35:34 +0000"  >&lt;blockquote&gt;&lt;p&gt;Maybe some sort of tiered thing where the default calls the original&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes.&lt;/p&gt;

&lt;p&gt;So if the CP overrides this, it&apos;s done there.&lt;/p&gt;

&lt;p&gt;If not, the base Observer class that CPs are supposed to be extending will call the original. &lt;/p&gt;

&lt;p&gt;Edit: And the aim is source level compatibility only.&lt;/p&gt;</comment>
                            <comment id="13402842" author="jmhsieh" created="Thu, 28 Jun 2012 04:43:34 +0000"  >&lt;p&gt;Minor clarification &amp;#8211; what happens if the postXXX method throws an exception?  What if you want the postXXX method to eat the exception (because it somehow handles it)?&lt;/p&gt;

&lt;p&gt;Specifically instead of this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// Existing code with formatting unchanged
&lt;/span&gt;
+    } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) {
+        &lt;span class=&quot;code-comment&quot;&gt;// failed-get CP hook
&lt;/span&gt;+        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (withCoprocessor &amp;amp;&amp;amp; (coprocessorHost != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)) {
+          coprocessorHost.postGet(context, t, get, results);
+        }
+        rethrow t;
+    }
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (withCoprocessor &amp;amp;&amp;amp; (coprocessorHost != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)) {
-     coprocessorHost.postGet(context, get, results);
+     coprocessorHost.postGet(context, &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, get, results);
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;would it make more sense to do this?&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// Existing code with formatting unchanged
&lt;/span&gt;
+    } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) {
+        &lt;span class=&quot;code-comment&quot;&gt;// failed-get CP hook
&lt;/span&gt;+        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (withCoprocessor &amp;amp;&amp;amp; (coprocessorHost != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)) {
+          coprocessorHost.postGet(context, t, get, results);  &lt;span class=&quot;code-comment&quot;&gt;// coproc has option to rethrow which would percolate out, or eat the exn &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; it handled it.
&lt;/span&gt;+          &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;; 
+        }
+        rethrow t; &lt;span class=&quot;code-comment&quot;&gt;// no coproc so just rethrow
&lt;/span&gt;+    }
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (withCoprocessor &amp;amp;&amp;amp; (coprocessorHost != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)) {
-     coprocessorHost.postGet(context, get, results);
+     coprocessorHost.postGet(context, &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, get, results);  &lt;span class=&quot;code-comment&quot;&gt;// normal success &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt;; coproc can &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; exn as well.
&lt;/span&gt;    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I&apos;d also suggest that the base observer class implementation would check if there was a non-null exn argument and rethrow; if there was no exn it would do nothing (or maybe just call the original version with no exn argument).&lt;/p&gt;</comment>
                            <comment id="13403244" author="apurtell" created="Thu, 28 Jun 2012 17:21:45 +0000"  >&lt;p&gt;@Jon, both suggestions good, +1 and +1.&lt;/p&gt;</comment>
                            <comment id="13403252" author="apurtell" created="Thu, 28 Jun 2012 17:26:52 +0000"  >&lt;p&gt;I&apos;m going to let this issue stew for a few days and circle back next week to implement.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12712874">HBASE-11125</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 19 Apr 2012 04:36:05 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>236370</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 years, 25 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i02epr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11985</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>