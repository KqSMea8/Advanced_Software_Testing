<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 18:58:27 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-2038/HBASE-2038.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-2038] Coprocessors: Region level indexing</title>
                <link>https://issues.apache.org/jira/browse/HBASE-2038</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2037&quot; title=&quot;Alternate indexed hbase implementation; speeds scans by adding indexes to regions rather secondary tables&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2037&quot;&gt;&lt;del&gt;HBASE-2037&lt;/del&gt;&lt;/a&gt; is a good candidate to be done as coprocessor. It also serve as a good goalpost for coprocessor environment design &amp;#8211; there should be enough of it so region level indexing can be reimplemented as a coprocessor without any loss of functionality. &lt;/p&gt;</description>
                <environment></environment>
        <key id="12443023">HBASE-2038</key>
            <summary>Coprocessors: Region level indexing</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="7">Later</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="apurtell">Andrew Purtell</reporter>
                        <labels>
                    </labels>
                <created>Thu, 10 Dec 2009 20:22:58 +0000</created>
                <updated>Sun, 8 Jun 2014 21:55:05 +0000</updated>
                            <resolved>Sun, 8 Jun 2014 21:55:04 +0000</resolved>
                                                                    <component>Coprocessors</component>
                        <due></due>
                            <votes>3</votes>
                                    <watches>39</watches>
                                                                <comments>
                            <comment id="12851941" author="apurtell" created="Wed, 31 Mar 2010 16:38:01 +0000"  >&lt;p&gt;This issue should now really be about converting IHBase and THBase into coprocessors at some point. &lt;/p&gt;</comment>
                            <comment id="12934308" author="alexb" created="Sun, 21 Nov 2010 18:00:05 +0000"  >&lt;p&gt;Hello,&lt;/p&gt;

&lt;p&gt;As first cut of Coprocessors (CP) implementation has been committed to trunk (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2001&quot; title=&quot;Coprocessors: Colocate user code with regions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2001&quot;&gt;&lt;del&gt;HBASE-2001&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2002&quot; title=&quot;Coprocessors: Client side support&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2002&quot;&gt;&lt;del&gt;HBASE-2002&lt;/del&gt;&lt;/a&gt;) I think there&apos;s a good opportunity to get going with this issue. I believe it&apos;s a good time for this effort and hope that CP-based implementation of region-level indexing will confirm that CP API is complete and has all one might need (for now).&lt;/p&gt;

&lt;p&gt;I revised the design/approach of the IHBase contrib and have several questions to ask with regard to transforming the code based on CPs. It would be great if someone can help me with them!&lt;/p&gt;

&lt;p&gt;1) Are coprocessors meant to be stateless? If not, then I assume that one instance is created and &quot;assigned&quot; to a region and that CP implementation should be thread-safe (e.g. multiple scanners can be handled at the same time for the regions). Otherwise, if coprocessors are meant to be stateless, I believe that CoprocessorEnvironment&apos;s get/put/remove methods are used to store intermediate data (aka attributes) between method calls (if we really need it). Is CoprocessorEnvironment instance is created one-per-region? I know, e.g. I can store some scan-related data using scanId passed to the scan-related callbacks (is it safe?), but what about region-related data (no problem with it in case cp env is one-per-region)?&lt;br/&gt;
In general, do I understand the CP&apos;s API correctly (based on assumptions I share in this point)?&lt;/p&gt;

&lt;p&gt;2) During batch scan (smth which was added in trunk but wasn&apos;t supported in previous HBase versions, and hence current IHBase implementation doesn&apos;t take it into account) we need to return multiple rows from scan&apos;s next() method. It looks like if we apply current approach (from current IHBase implementation) of &quot;fast forwarding&quot; to next value we&apos;ll only fastforward scan to the &lt;b&gt;first&lt;/b&gt; value of those to return. Others will be fetched using &quot;usual&quot; scan logic without using index which isn&apos;t efficient. There&apos;s not a lot we can do without changing scan (and deeper) code. Am I right here? Perhaps it&apos;s ok to have a lack of support for batch reads for the first version of CP-based IHBase? Or, it might me that we should change the approach?&lt;/p&gt;

&lt;p&gt;3) Is it in general a good idea to take this initiave (transform IHBase implementation to CP-based one) by me? I fear that it might be that due to a lot of changes in HBase codebase (trunk versus e.g. 0.20.5) there are going to be severe changes in approach/design of indices implementation (from the current one, which I could use as a base), so poking you guys (HBase devs) from my side &lt;b&gt;a lot&lt;/b&gt; (if really needed) to learn things about it isn&apos;t very efficient way to work on this issue &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;? Anyways, I&apos;d be glad to work on the issue if someone can provide needed guidance.&lt;/p&gt;

&lt;p&gt;4) Haven&apos;t dug into THBase contrib (as in IHBase). Are these contribs (IHBase and THBase) will be &quot;transferred&quot; to CP-based implementation as a single effort? I believe they won&apos;t be merged based on how differently they act now. Was it really meant to put the tasks for &lt;b&gt;both&lt;/b&gt; into single JIRA issue?&lt;/p&gt;

&lt;p&gt;Thank you!&lt;/p&gt;</comment>
                            <comment id="12934313" author="alexb" created="Sun, 21 Nov 2010 18:19:57 +0000"  >&lt;p&gt;The next might be helpful. Some time ago I refactored a bit IHBase and extracted base interfaces to make easier develop any custom indexed implementation: IndexManager and IndexScannerContext (I just published code here: &lt;a href=&quot;https://github.com/abaranau/ihbase&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/abaranau/ihbase&lt;/a&gt;). To give an idea, here&apos;s how they look:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;public abstract class IndexManager implements HeapSize {
  public abstract void initialize(IdxRegion region);
  public abstract Pair&amp;lt;Long, Callable&amp;lt;Void&amp;gt;&amp;gt; rebuildIndexes() throws IOException;
  public abstract void cleanup();
  public abstract IndexScannerContext newIndexScannerContext(Scan scan) throws IOException;
}

public interface IndexScannerContext {
  KeyValue getNextKey();
  void close();
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This refactored code somehow correlates with BaseRegionObserverCoprocessor API (at least in my head):&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;IndexManager&apos;s initialize() should be invoked at region open time,&lt;/li&gt;
	&lt;li&gt;rebuildIndexes() during flush,&lt;/li&gt;
	&lt;li&gt;cleanup() during region close,&lt;/li&gt;
	&lt;li&gt;IndexScannerContext should be created during open scan,&lt;/li&gt;
	&lt;li&gt;it&apos;s getNextKey() (with a bit of addional code) during scan&apos;s next()&lt;/li&gt;
	&lt;li&gt;and finally, close() when scan is closed in region.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;m not saying we should use this refactored version of code, I&apos;m just putting it here for better &quot;visualization purposes&quot;, just as a way to express the idea.&lt;/p&gt;

&lt;p&gt;Please, correct my logic where needed! &lt;br/&gt;
Thanks!&lt;/p&gt;

&lt;p&gt;P.S. Please don&apos;t judge the names of classes, other dirty pieces in the refactored version I&apos;ve  shared, I wanted to a) just &lt;b&gt;try&lt;/b&gt; to add aditional abstraction to be able to inject custom indexing implementation and b) make as little changes in IHBase codebase as I can so that others can follow them easily. Copypasting notes that I took during refactoring (may be helpful if someone wants to go inside the code):&lt;/p&gt;

&lt;p&gt;&quot;1. Extracted interface IndexManager from IdxRegionIndexManager.&lt;br/&gt;
2. Extracted separate IdxRegionIndexManagerMBean from IdxRegionMbean with IndexManager-implementation-specific info&lt;br/&gt;
3. Created IndexScannerContext interface (with IdxScannerContext implementation, which encapsulates idxSearchContext and matchedExpressionIterator for existing code) which performs iteration over indexed expression keys.&lt;/p&gt;

&lt;p&gt;NOTE: Didn&apos;t think about renaming class IdxRegionIndexManager and related.&lt;br/&gt;
NOTE: Didn&apos;t think about &quot;repackaging&quot; things.&lt;br/&gt;
NOTE: New code/classes lack javadocs, will add them&lt;br/&gt;
NOTE: Unit-tests should be added with regard to refactoring (add check IdxRegionIndexManagerMBean values at least)&quot;&lt;/p&gt;</comment>
                            <comment id="12934341" author="ghelmling" created="Sun, 21 Nov 2010 20:00:00 +0000"  >&lt;p&gt;Hi Alex,&lt;/p&gt;

&lt;p&gt;I&apos;m not familiar with the internal IHBase code, but I&apos;ll provide whatever info I can on coprocessors.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1) Are coprocessors meant to be stateless? If not, then I assume that one instance is created and &quot;assigned&quot; to a region and that CP implementation should be thread-safe (e.g. multiple scanners can be handled at the same time for the regions).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No, coprocessor implementations do not need to be stateless.  If anything you&apos;ll need state for many interesting applications.  A single coprocessor instance is created per configured coprocessor implementation on region load.  You can treat the postOpen() and preClose() methods as init() and destroy() methods in your implementation.  And yes, coprocessor implementations need to be thread safe.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;2) During batch scan (smth which was added in trunk but wasn&apos;t supported in previous HBase versions, and hence current IHBase implementation doesn&apos;t take it into account) we need to return multiple rows from scan&apos;s next() method. It looks like if we apply current approach (from current IHBase implementation) of &quot;fast forwarding&quot; to next value we&apos;ll only fastforward scan to the first value of those to return. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry, I&apos;m not familiar with how IHBase handles this or what changed in the scanner API, but I&apos;m guessing RegionObserver.preScannerNext() does provide much help in this fast-forwarding use case.  It seems like this would need much deeper hooks into HRegion.RegionScanner to interact with the positioning code.  Alternately, you could expose your own &quot;indexed scanner&quot; functionality via the dynamic rpc hooks (HTable.coprocessorExec()), but that would require the client to differentiate on indexed vs. non-indexed usage and doesn&apos;t provide the transparency you&apos;re looking for.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;3) Is it in general a good idea to take this initiave (transform IHBase implementation to CP-based one) by me?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry again, I don&apos;t have much of an answer on this one.  I&apos;ll help on anything I can on the coprocessor side of things, though!&lt;/p&gt;
</comment>
                            <comment id="12934344" author="apurtell" created="Sun, 21 Nov 2010 20:18:07 +0000"  >&lt;p&gt;Alex, &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Is it in general a good idea to take this initiave (transform IHBase implementation to CP-based one) by me?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well I for one definitely think this is a good idea. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I believe it&apos;s a good time for this effort and hope that CP-based implementation of region-level indexing will confirm that CP API is complete and has all one might need (for now).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;As do I. However there are additions and improvements to the CP API coming, see &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3256&quot; title=&quot;Coprocessors: Coprocessor host and observer for HMaster&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3256&quot;&gt;&lt;del&gt;HBASE-3256&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3257&quot; title=&quot;Coprocessors: Extend server side integration API to include HLog operations&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3257&quot;&gt;&lt;del&gt;HBASE-3257&lt;/del&gt;&lt;/a&gt;. The latter especially may be relevant.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I assume that one instance is created and &quot;assigned&quot; to a region and that CP implementation should be thread-safe (e.g. multiple scanners can be handled at the same time for the regions). &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Correct.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I believe that CoprocessorEnvironment&apos;s get/put/remove methods are used to store intermediate data (aka attributes) between method calls (if we really need it). &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Correct, but see next answer below. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Is CoprocessorEnvironment instance is created one-per-region? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No. This is created once per coprocessor. Each coprocessor has its own environment, which can be used to keep state between multiple threads of a coprocessor attached to one region, but not between multiple coprocessors.&lt;/p&gt;

&lt;p&gt;CoprocessorHost is the object that is created once per region. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I can store some scan-related data using scanId passed to the scan-related callbacks (is it safe?)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This should be safe. &lt;/p&gt;

&lt;p&gt;I don&apos;t understand the current IHBase implementation enough to answer your question #2.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;This refactored code somehow correlates with BaseRegionObserverCoprocessor API (at least in my head)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that is a great start.&lt;/p&gt;</comment>
                            <comment id="13180068" author="lhofhansl" created="Thu, 5 Jan 2012 01:13:04 +0000"  >&lt;p&gt;@Alex: Are you still planning to work on this?&lt;/p&gt;</comment>
                            <comment id="13180942" author="alexb" created="Thu, 5 Jan 2012 23:22:14 +0000"  >&lt;p&gt;Hi. Sorry for abandoning this issue for so long. I&apos;d love to still work on it, but I think I&apos;ll manage to dedicate enough time to it only in 2-3 weeks. I plan to do some progress in it starting from next week.&lt;br/&gt;
If I couldn&apos;t do anything in this time then someone could take over it, will not hold anymore.&lt;/p&gt;

&lt;p&gt;Is that OK? Or is there someone who wants to work on it right away?&lt;/p&gt;</comment>
                            <comment id="13180996" author="lhofhansl" created="Fri, 6 Jan 2012 00:41:09 +0000"  >&lt;p&gt;Maybe there&apos;s a way to collaborate on this (although I cannot promise much of my time on this either).&lt;/p&gt;

&lt;p&gt;From gleaming &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2037&quot; title=&quot;Alternate indexed hbase implementation; speeds scans by adding indexes to regions rather secondary tables&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2037&quot;&gt;&lt;del&gt;HBASE-2037&lt;/del&gt;&lt;/a&gt; this would not requite ITHBase and the indexes would be always consistent, correct? I have not looked at the 2.5mb&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/warning.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; patch in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2037&quot; title=&quot;Alternate indexed hbase implementation; speeds scans by adding indexes to regions rather secondary tables&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2037&quot;&gt;&lt;del&gt;HBASE-2037&lt;/del&gt;&lt;/a&gt;, yet...&lt;br/&gt;
I was wondering if there&apos;s a summary somewhere about how it works. Specifically how does a client know where to look for an indexed value?&lt;/p&gt;</comment>
                            <comment id="13181010" author="zhihyu@ebaysf.com" created="Fri, 6 Jan 2012 01:04:02 +0000"  >&lt;p&gt;There&apos;re already two projects building secondary index on top of HBase: Lily and Culvert.&lt;/p&gt;

&lt;p&gt;If we provide native secondary indexing support in HBase, we should evaluate what ITHBase, Lily and Culvert have done so that the native support gives better abstraction.&lt;/p&gt;</comment>
                            <comment id="13181069" author="alexb" created="Fri, 6 Jan 2012 03:32:19 +0000"  >&lt;p&gt;+1 for collaboration!&lt;br/&gt;
re &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2037&quot; title=&quot;Alternate indexed hbase implementation; speeds scans by adding indexes to regions rather secondary tables&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2037&quot;&gt;&lt;del&gt;HBASE-2037&lt;/del&gt;&lt;/a&gt; (aka IHBase): it is the base for this effort. Yes, it doesn&apos;t require ITHBase, it is alternative implementation. The refactored code I pointed above (&lt;a href=&quot;https://github.com/abaranau/ihbase&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/abaranau/ihbase&lt;/a&gt;) is also based on the IHBase code.&lt;/p&gt;

&lt;p&gt;In short (sorry, the description is not tied to classes, don&apos;t have them in front of me currently):&lt;/p&gt;

&lt;p&gt;As far as I remember (need to refresh my memory though) the point is that index is being kept for each Region, it is loaded in RAM, not persistent. It is built during Region initialization (after HBase restart or new region creation after split and such). When scan is performed with indexed columns involved it uses the index when finding the next record to navigate to and &lt;b&gt;fast forwards&lt;/b&gt; to this next record (usually by skipping some other records without even reading them). This is where it wins the speed.&lt;/p&gt;

&lt;p&gt;As this was developed before CPs were added the special API was developed which is being used by client.&lt;/p&gt;

&lt;p&gt;Hope this helps a bit. I will refresh my memory from the code and we&apos;ll discuss that a bit deeper.&lt;/p&gt;</comment>
                            <comment id="13181074" author="alexb" created="Fri, 6 Jan 2012 03:50:25 +0000"  >&lt;p&gt;Re comparing this solution to others:&lt;/p&gt;

&lt;p&gt;ITHBase: you can find very good comparison in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2037&quot; title=&quot;Alternate indexed hbase implementation; speeds scans by adding indexes to regions rather secondary tables&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2037&quot;&gt;&lt;del&gt;HBASE-2037&lt;/del&gt;&lt;/a&gt; description&lt;br/&gt;
Lily: apart from different implementation base (Lily uses Lucene while IHBase currently not) IHBase is more like &quot;internal&quot; feature added HBase, not a separate/additional tool/system. I.e. provides in-house support for secondary indexing.&lt;br/&gt;
Culvert: haven&apos;t looked into the internals yet (definitely will), but it looks like this may be smth similar. Not sure&lt;/p&gt;

&lt;p&gt;+1 for doing evaluating and learn from other&apos;s experience use-cases to make &quot;native support&quot; (IHBase-2) better.&lt;/p&gt;</comment>
                            <comment id="13181077" author="lhofhansl" created="Fri, 6 Jan 2012 03:57:46 +0000"  >&lt;p&gt;I see. So if I wanted to do a Get and all I have is the value of an indexed column, I have to ask all regions, correct? (Because there is no way to identify the region with the column value ahead of time)&lt;/p&gt;</comment>
                            <comment id="13181099" author="alexb" created="Fri, 6 Jan 2012 05:00:48 +0000"  >&lt;p&gt;I think that IHBase implementation (current one) implies that. For scans this should not be a big problem though - regions are usually configured to be big and with the help of index the whole region is skipped at once. If we are talking about random single read (Get) operations then this may mean a lot of &quot;useless&quot; work (comparing to amount of useful work).&lt;/p&gt;

&lt;p&gt;Do you have a specific use-case (real one or just the on &quot;in mind&quot;) you want to discuss? If so, may be it makes sense to discuss on ML or even in chat (Skype can work).&lt;/p&gt;</comment>
                            <comment id="13181183" author="lhofhansl" created="Fri, 6 Jan 2012 07:35:48 +0000"  >&lt;p&gt;I have no particular use case... Just that I have been trying to work out how I would do 2nd-ary indexes in HBase and I always came back to this (either it needs some cross region transaction when maintaining the index, or you need to ask all regions when you query the index).&lt;/p&gt;

&lt;p&gt;Not a problem as such. Just confirming.&lt;br/&gt;
Such a get could be farmed off in parallel to manu regions, so latency is not necessarily bad.&lt;br/&gt;
I&apos;d be up for an offline chat. I&apos;ll send an email.&lt;/p&gt;</comment>
                            <comment id="13201205" author="anoopsamjohn" created="Mon, 6 Feb 2012 10:45:39 +0000"  >&lt;p&gt;Hi Lars,&lt;br/&gt;
          I am also trying for a secondary index and I have seen the IHBase concept being good.. But we need this to be moved to coprocessor based so that the kernel code of HBase need not be different for the secondary index. IHBase makes the scan go through all the regions ( as u said ) but they will skip and seek to the later positions in the heap avoid so many possible data read from HDFS etc...&lt;br/&gt;
When I saw the current co processor, we call preScannerNext() from HRegionServer next(final long scannerId, int nbRows)  and pass the RegionScanner here to the co processor.  But as per the IHBase way, within the co processor we should be able to seek to the correct row where the indexed col val equals our value. But we can not do this as of now as RegionScanner seek() not there. &lt;/p&gt;

&lt;p&gt;Also this preScannerNext() will be called once before the actual next(final long scannerId, int nbRows) call happening on the region. Here as per the cache value at the client side the nbRows might be more than one. Now suppose this is nbRows=2 and in the region we have 2 rows one at some what in the middle part of an HFile and the other at another HFile. Now as per IHBase we should 1st seek to the 1st position of the row and after reading this data should seek to the next position. Now as per the current way of calling of preScannerNext() this wont be possible. So I think we might need some change in these area?  What do u say?&lt;/p&gt;

&lt;p&gt;Mean while what is your plan to continue with the way of IHBase storing the index in memory for each of the region or some change in this?&lt;/p&gt;</comment>
                            <comment id="13201430" author="alexb" created="Mon, 6 Feb 2012 17:56:13 +0000"  >&lt;p&gt;Hi Anoop,&lt;/p&gt;

&lt;p&gt;I think your Q in second paragraph denotes the same concern that was stated in one of my first comments (a year ago..):&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;2) During batch scan (smth which was added in trunk but wasn&apos;t supported in previous HBase versions, and hence current IHBase implementation doesn&apos;t take it into account) we need to return multiple rows from scan&apos;s next() method. It looks like if we apply current approach (from current IHBase implementation) of &quot;fast forwarding&quot; to next value we&apos;ll only fastforward scan to the first value of those to return. Others will be fetched using &quot;usual&quot; scan logic without using index which isn&apos;t efficient. There&apos;s not a lot we can do without changing scan (and deeper) code. Am I right here? Perhaps it&apos;s ok to have a lack of support for batch reads for the first version of CP-based IHBase? Or, it might me that we should change the approach?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m reviewing the released 0.92 coprocessors capabilities, will share if I find how this issue can be solved. But from what I see so far this issue remained in a released version...&lt;/p&gt;</comment>
                            <comment id="13202057" author="anoopsamjohn" created="Tue, 7 Feb 2012 03:57:21 +0000"  >&lt;p&gt;Hi Alex,&lt;br/&gt;
    Thanks for your reply...  Yes I had seen your past comment..I am checking the trunk code for the co processor for this work as of now...&lt;/p&gt;

&lt;p&gt;What is your comment on my first comment, that the HRegionServer next(final long scannerId, int nbRows) calls the co processor preScannerNext() by passing the RegionScanner. On this we can not make a seek()..&lt;/p&gt;

&lt;p&gt;Thanks&lt;br/&gt;
Anoop&lt;/p&gt;</comment>
                            <comment id="13202088" author="lhofhansl" created="Tue, 7 Feb 2012 05:30:47 +0000"  >&lt;p&gt;Unfortunately there is no seeking in the coprocessors, yet. They work more like a filter of a real scan. Seeking is done one level (or two actually) level deeper.&lt;br/&gt;
Seeking is done in the StoreScanners, coprocessors see RegionScanners.&lt;/p&gt;

&lt;p&gt;It is not entirely clear to me where to hook this up in that API.&lt;/p&gt;

&lt;p&gt;It might be possible to provide a custom filter to do that. Filters operate at the storescanner level, and so can (and do) provide seek hints to the calling scanner.&lt;/p&gt;</comment>
                            <comment id="13202338" author="alexb" created="Tue, 7 Feb 2012 12:58:35 +0000"  >&lt;p&gt;Yeah, same thought here: use fast-forwarding filter (the one which provides hints for the next row to forward to). I guess we can add such filter to a scan as a hook in open scan (on region level) time. &lt;/p&gt;

&lt;p&gt;I guess ideally we&apos;d want to add such filter for RegionScanner in postScannerOpen(). Though RegionScanner interface does not exposes filters info. We could try to cast it to particular class but it may be too unsafe.&lt;/p&gt;

&lt;p&gt;Alternatively we could try to modify Scan object (add filters), but this is obviously too bad approach as this object is reused across regions.&lt;/p&gt;

&lt;p&gt;May be we can hear some advice from Coprocessor feature devs? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13220981" author="anoopsamjohn" created="Fri, 2 Mar 2012 15:12:19 +0000"  >&lt;p&gt;Hi Lars,&lt;/p&gt;
    &lt;blockquote&gt;&lt;p&gt;It might be possible to provide a custom filter to do that.&lt;/p&gt;&lt;/blockquote&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;What we wanted from the filter is include a row and then seek to the next row which we are interested in. I cant see such a facility with our Filter right now. Correct me if I am wrong. So suppose we already seeked to one row and this need to be included in the result, then the Filter should return INCLUDE. Then when the next next() call happens, then only we can return a SEEK_USING_HINT. So one extra row reading is needed. This might create even one unwanted HFileBlock fetch (who knows).&lt;br/&gt;
Can we add reseek() at higher level?&lt;br/&gt;
If you have suggestion pls give me.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Thanks&lt;br/&gt;
Anoop&lt;/p&gt;</comment>
                            <comment id="13221153" author="lhofhansl" created="Fri, 2 Mar 2012 18:56:57 +0000"  >&lt;p&gt;@Alex: Looks like preScannerOpen could actually change the passed Scan object and add a filter. The API is a bit strange. Scan is marked final, but it is perfectly OK (and possible, and final does not prevent that) to change it here. postScannerOpen also gets the Scan object, but modifying it there is pointless.&lt;/p&gt;

&lt;p&gt;@Anoop: Yep, for that we&apos;d need to add INCLUDE_AND_SEEK_USING_HINT (similar to the INCLUDE_AND_SEEK_NEXT_ROW that we already have). Shouldn&apos;t be hard to add, I&apos;m happy to do that, if that&apos;s the route we want to go with this.&lt;/p&gt;</comment>
                            <comment id="13221185" author="zhihyu@ebaysf.com" created="Fri, 2 Mar 2012 19:21:51 +0000"  >&lt;p&gt;I logged &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5512&quot; title=&quot;Add support for INCLUDE_AND_SEEK_USING_HINT&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5512&quot;&gt;&lt;del&gt;HBASE-5512&lt;/del&gt;&lt;/a&gt; for adding INCLUDE_AND_SEEK_USING_HINT&lt;/p&gt;</comment>
                            <comment id="13221541" author="anoopsamjohn" created="Sat, 3 Mar 2012 08:49:13 +0000"  >&lt;p&gt;@Lars&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Seeking is done one level (or two actually) level deeper.&lt;br/&gt;
Seeking is done in the StoreScanners, coprocessors see RegionScanners.&lt;/p&gt;

&lt;p&gt;It is not entirely clear to me where to hook this up in that API.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes at RegionScanners level we dont have seek() or reseek(). It is one level down @ KeyValueHeap level.&lt;br/&gt;
Will it be correct to add seek() reseek() behaviours at RegionScanner level?[ We just need to delegate seek() or reseek() calls into KeyValueHeap  object within the RegionScanner...]&lt;/p&gt;

&lt;p&gt;If so it would be very easy to do a reseek() to the needed row at the coprocessor preScannerNext().&lt;br/&gt;
next() will take the needed row.&lt;/p&gt;

&lt;p&gt;What do you say? Correct me if my suggestion is wrong.&lt;/p&gt;</comment>
                            <comment id="13221640" author="ram_krish" created="Sat, 3 Mar 2012 16:57:05 +0000"  >&lt;p&gt;Also we need to have a provision to use the nbRows that is passed while scanning to be used in coprocessor such that the normal scanner.next() can be used in sync with the cached preScannerNext that we do with nbRows. &lt;/p&gt;</comment>
                            <comment id="13221759" author="lhofhansl" created="Sun, 4 Mar 2012 01:11:32 +0000"  >&lt;p&gt;@Anoop: We can certainly try to expose this at the RegionScanner level. Although I feel it might actually be harder than you think, as the seeking is dealt with on a store basis, and we do not want to inhibit the ability to deal with Stores in parallel in the future.&lt;br/&gt;
RegionScanner.seek would have to go through all Stores and for each Store seek the MemstoreScanner and all StoreFileScanners. Seeking this way across stores is only valid if we seek on row boundaries (each Store - i.e. column family - has it&apos;s own set of columns, which could even have the same names between stores).&lt;/p&gt;

&lt;p&gt;@&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5521&quot; title=&quot;Move compression/decompression to an encoder specific encoding context&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5521&quot;&gt;&lt;del&gt;HBASE-5521&lt;/del&gt;&lt;/a&gt;: I started working on that, but I am starting to question the usefulness.&lt;br/&gt;
A filter is per KeyValue (at least the method that allows for seeking). So, many KeyValues flow through the Filter for a single row, and the filter needs to seek separately for each ColumnFamily (as explained above and on the mailing list).&lt;br/&gt;
So the gain from this would be fairly minimal (which I guess is why we do not have this).&lt;br/&gt;
For example a row with many column would need to issue many INCLUDE&apos;s and only for the last KeyVakue (and how would it know it&apos;s the last?) issue INCLUDE_AND_SEEK...&lt;/p&gt;</comment>
                            <comment id="13221797" author="anoopsamjohn" created="Sun, 4 Mar 2012 05:47:58 +0000"  >&lt;blockquote&gt;
&lt;p&gt;@&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5521&quot; title=&quot;Move compression/decompression to an encoder specific encoding context&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5521&quot;&gt;&lt;del&gt;HBASE-5521&lt;/del&gt;&lt;/a&gt;: I started working on that, but I am starting to question the usefulness.&lt;br/&gt;
A filter is per KeyValue (at least the method that allows for seeking). So, many KeyValues flow through the Filter for a single row, and the filter needs to seek separately for each ColumnFamily (as explained above and on the mailing list).&lt;br/&gt;
So the gain from this would be fairly minimal (which I guess is why we do not have this).&lt;br/&gt;
For example a row with many column would need to issue many INCLUDE&apos;s and only for the last KeyVakue (and how would it know it&apos;s the last?) issue INCLUDE_AND_SEEK..&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Lars,   I was also thinking on this yesterday after seeing the patch. I wanted to give a test case try run before commenting &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;/p&gt;

&lt;p&gt;Regarding you 1st comment, In our above discussion scenario of seek() we need a row boundary seek.. Yes all the stores ( memstore and all store files in that store) need to get seeked to needed point. Let me see more on this on Monday. we had done small changes and tested this once. I mean we were able to seek to row boundaries.&lt;/p&gt;

&lt;p&gt;Thanks a lot Lars for your work and suggestion&lt;/p&gt;

&lt;p&gt;@Ram: Yes we can file a Jira for co processor support for next( int nbrows)?&lt;/p&gt;</comment>
                            <comment id="13221804" author="anoopsamjohn" created="Sun, 4 Mar 2012 06:14:59 +0000"  >&lt;p&gt;Created &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5517&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-5517&lt;/a&gt; for the co processor change&lt;/p&gt;</comment>
                            <comment id="13222300" author="anoopsamjohn" created="Mon, 5 Mar 2012 12:30:36 +0000"  >&lt;p&gt;@Lars&lt;br/&gt;
    I have created &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5520&quot; title=&quot;Support reseek() at RegionScanner&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5520&quot;&gt;&lt;del&gt;HBASE-5520&lt;/del&gt;&lt;/a&gt; for the support for seek() and reseek() at the RegionScanner.  As I mentioned in the comment we need row boundary seeks only. Yes it might be complex wrt the other kind of seeks. We can support only seek() and reseek() at the row boundary level only at the RegionScanner?&lt;br/&gt;
We can take any of the below approaches&lt;br/&gt;
1. The APIs make use of the rowkey and timestamp only from the KeyValue passed.&lt;br/&gt;
2. Check at the RegionScannerImpl level that it is not having the CF, qualifier in the passed KV. If so throw exception.  Only the KV can have the rowkey and timestamp also.&lt;span class=&quot;error&quot;&gt;&amp;#91;It is ok.Timestamp can be there...&amp;#93;&lt;/span&gt;&lt;br/&gt;
3. Dont bother let the seek happen. But may be dangerous??&lt;/p&gt;

&lt;p&gt;Pls give ur valuable suggestions&lt;/p&gt;

&lt;p&gt;Me and Ram started working with this.&lt;/p&gt;


&lt;p&gt;From the co processor preNext() we can call reseek with KeyValue.createFirstOnRow(final byte [] row)&lt;/p&gt;</comment>
                            <comment id="13222340" author="anoopsamjohn" created="Mon, 5 Mar 2012 13:27:43 +0000"  >&lt;p&gt;Or may be we can give the signature of the seek() and reseek() at the RegionScanner as seek( byte[] rowKey ) reseek( byte[] rowKey )?&lt;br/&gt;
So that the seek will be always to the begin KV of the row in every CF. [ if CF contains that key ]&lt;/p&gt;</comment>
                            <comment id="14021419" author="apurtell" created="Sun, 8 Jun 2014 21:55:05 +0000"  >&lt;p&gt;Stale issue. Reopen if still relevant (if there&apos;s new activity)&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12493110">HBASE-3340</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12443018">HBASE-2037</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="12310040">
                    <name>Required</name>
                                            <outwardlinks description="requires">
                                        <issuelink>
            <issuekey id="12545075">HBASE-5517</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12545171">HBASE-5520</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                            <outwardlinks description="depends upon">
                                        <issuelink>
            <issuekey id="12545700">HBASE-5542</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sun, 21 Nov 2010 18:00:05 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>32380</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            2 years, 27 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0hg8v:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>99894</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>