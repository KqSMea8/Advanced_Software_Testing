<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 18:56:38 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-1818/HBASE-1818.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-1818] HFile code review and refinement</title>
                <link>https://issues.apache.org/jira/browse/HBASE-1818</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;HFile is a good mimic of Google&apos;s SSTable file format. And we want HFile to become a common file format of hadoop in the near future.&lt;br/&gt;
We will review the code of HFile and record the comments here, and then provide fixed patch after the review.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12435012">HBASE-1818</key>
            <summary>HFile code review and refinement</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="schubertzhang">Schubert Zhang</assignee>
                                    <reporter username="schubertzhang">Schubert Zhang</reporter>
                        <labels>
                    </labels>
                <created>Mon, 7 Sep 2009 14:59:27 +0000</created>
                <updated>Fri, 20 Nov 2015 13:01:15 +0000</updated>
                            <resolved>Wed, 16 Sep 2009 02:45:21 +0000</resolved>
                                    <version>0.20.0</version>
                                    <fixVersion>0.20.1</fixVersion>
                    <fixVersion>0.90.0</fixVersion>
                                    <component>io</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="12752169" author="schubertzhang" created="Mon, 7 Sep 2009 15:22:25 +0000"  >&lt;p&gt;Code review comments:&lt;/p&gt;

&lt;p&gt;1. HFile.Writer&lt;/p&gt;

&lt;p&gt;(1) private int totalBytes = 0;  ==&amp;gt; private long totalBytes = 0;&lt;br/&gt;
      int is too small (2GB) to limit the size of uncompressed data.&lt;/p&gt;

&lt;p&gt;(2) private void finishBlock()&lt;br/&gt;
      use int for variable &quot;size&quot;.&lt;/p&gt;

&lt;p&gt;(3) private void checkKey(final byte [] key, final int offset, final int length)&lt;br/&gt;
      to reject to append duplicated key.&lt;/p&gt;

&lt;p&gt;    if (this.comparator.compare(this.lastKeyBuffer, this.lastKeyOffset,&lt;br/&gt;
            this.lastKeyLength, key, offset, length) &amp;gt; 0)&lt;/p&gt;

&lt;p&gt;   should be:&lt;/p&gt;

&lt;p&gt;   if (this.comparator.compare(this.lastKeyBuffer, this.lastKeyOffset,&lt;br/&gt;
            this.lastKeyLength, key, offset, length) &amp;gt;= 0)&lt;/p&gt;

&lt;p&gt;(4) private long writeFileInfo(FSDataOutputStream o)&lt;/p&gt;

&lt;p&gt;      int avgValueLen = this.entryCount == 0? 0:&lt;br/&gt;
        (int)(this.keylength/this.entryCount);&lt;/p&gt;

&lt;p&gt;     should be:&lt;/p&gt;

&lt;p&gt;           int avgValueLen = this.entryCount == 0? 0:&lt;br/&gt;
        (int)(this.valuelength/this.entryCount);&lt;/p&gt;

&lt;p&gt;2. HFile.Reader&lt;/p&gt;

&lt;p&gt;(1) public ByteBuffer getMetaBlock(String metaBlockName)&lt;br/&gt;
     it&apos;s better to use:&lt;br/&gt;
      if (metaIndex.count &amp;lt;= 0) &lt;/p&gt;
{
          return null; // there are no meta blocks
      }

&lt;p&gt;     then:&lt;/p&gt;

&lt;p&gt;      if (trailer.metaIndexCount == 0) &lt;/p&gt;
{
        return null; // there are no meta blocks
      }

&lt;p&gt;      and add:&lt;br/&gt;
      if (buf == null)&lt;br/&gt;
    	return null;&lt;br/&gt;
      since decompress() may return null.&lt;/p&gt;

&lt;p&gt;      remove following to avoud block copy, and improve performance. But to to pay attention, the current position of the buf is at METABLOCKMAGIC.length (not 0):&lt;/p&gt;

&lt;p&gt;      // Toss the header. May have to remove later due to performance.&lt;br/&gt;
      buf.compact();&lt;br/&gt;
      buf.limit(buf.limit() - METABLOCKMAGIC.length);&lt;br/&gt;
      buf.rewind();&lt;/p&gt;


&lt;p&gt;(2) ByteBuffer readBlock(int block, boolean cacheBlock)&lt;br/&gt;
       boundary bug.&lt;br/&gt;
       if (block &amp;lt; 0 || block &amp;gt; blockIndex.count) &lt;/p&gt;
{
        throw new IOException(&quot;Requested block is out of range: &quot; + block +
          &quot;, max: &quot; + blockIndex.count);
      }

&lt;p&gt;     should be:&lt;/p&gt;

&lt;p&gt;      if (block &amp;lt; 0 || block &amp;gt;= blockIndex.count) &lt;/p&gt;
{
        throw new IOException(&quot;Requested block is out of range: &quot; + block +
          &quot;, max: &quot; + blockIndex.count);
      }

&lt;p&gt;      add:&lt;br/&gt;
       if (buf == null) &lt;/p&gt;
{
          throw new IOException(&quot;Decompress block failure &quot; + block);
        }
&lt;p&gt;       since decompress() may return null.&lt;/p&gt;

&lt;p&gt;      remove following to avoud block copy, and improve performance. But to to pay attention, the current position of the buf is at METABLOCKMAGIC.length (not 0), and the cached block also have this position.&lt;/p&gt;

&lt;p&gt;      // Toss the header. May have to remove later due to performance.&lt;br/&gt;
      buf.compact();&lt;br/&gt;
      buf.limit(buf.limit() - METABLOCKMAGIC.length);&lt;br/&gt;
      buf.rewind();&lt;/p&gt;

&lt;p&gt;(3)   public boolean seekTo()&lt;/p&gt;

&lt;p&gt;        if (block != null &amp;amp;&amp;amp; currBlock == 0) &lt;/p&gt;
{
          block.rewind();
          block.position(DATABLOCKMAGIC.length);
          currKeyLen = block.getInt();
          currValueLen = block.getInt();
          return true;
        }
&lt;p&gt;        above code add block.position(DATABLOCKMAGIC.length); since we remove buf.compact previously.&lt;br/&gt;
        add return ture, I guess the code miss it.&lt;/p&gt;

&lt;p&gt;(4)          private void loadBlock(int bloc) throws IOException {&lt;br/&gt;
        if (block == null) &lt;/p&gt;
{
          block = reader.readBlock(bloc, cacheBlocks);
          currBlock = bloc;
          blockFetches++;
        }
&lt;p&gt; else {&lt;br/&gt;
          if (bloc != currBlock) &lt;/p&gt;
{
            block = reader.readBlock(bloc, cacheBlocks);
            currBlock = bloc;
            blockFetches++;
          }
&lt;p&gt; else &lt;/p&gt;
{
            // we are already in the same block, just rewind to seek again.
            block.rewind();
            block.position(DATABLOCKMAGIC.length);  // add this code since we remove buf.compact previously.
          }
&lt;p&gt;        }&lt;br/&gt;
      }&lt;br/&gt;
    }&lt;/p&gt;


</comment>
                            <comment id="12752218" author="schubertzhang" created="Mon, 7 Sep 2009 17:24:13 +0000"  >&lt;p&gt;The previous comments are not so readable. &lt;br/&gt;
Please try the patch.&lt;/p&gt;</comment>
                            <comment id="12752219" author="schubertzhang" created="Mon, 7 Sep 2009 17:25:30 +0000"  >&lt;p&gt;The previous comments are not so readable.&lt;br/&gt;
Please try the patch.&lt;/p&gt;</comment>
                            <comment id="12752609" author="streamy" created="Tue, 8 Sep 2009 17:08:57 +0000"  >&lt;p&gt;Moving to 0.20.1&lt;/p&gt;</comment>
                            <comment id="12752656" author="stack" created="Tue, 8 Sep 2009 18:14:44 +0000"  >&lt;p&gt;This looks good Schubert.&lt;/p&gt;

&lt;p&gt;Is removing the below safe?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (trailer.metaIndexCount == 0) {
-        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;; &lt;span class=&quot;code-comment&quot;&gt;// there are no meta blocks
&lt;/span&gt;-      }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Or are you removing code that is redundant &amp;#8211; if metaIndex == null, the above is null?&lt;/p&gt;

&lt;p&gt;Do all tests pass?&lt;/p&gt;</comment>
                            <comment id="12752885" author="ryanobjc" created="Wed, 9 Sep 2009 03:45:04 +0000"  >&lt;p&gt;stack, I am nearly 100% sure that code block I added to solve a NPE.&lt;/p&gt;</comment>
                            <comment id="12752898" author="schubertzhang" created="Wed, 9 Sep 2009 04:35:55 +0000"  >&lt;p&gt;@stack,&lt;/p&gt;

&lt;p&gt;Thanks, I removed my modification at this point. and  new patch is attached.&lt;/p&gt;

&lt;p&gt;I have done a simple verfication test use HBase PerformanceEvaluation tool. It seem the removal of  buf.compact() does not improve performance.&lt;/p&gt;

&lt;p&gt;@Ryan,&lt;/p&gt;

&lt;p&gt;could you please share your added code?&lt;/p&gt;</comment>
                            <comment id="12752953" author="ryanobjc" created="Wed, 9 Sep 2009 07:04:34 +0000"  >&lt;p&gt;as it turns out, buf.compact() isnt actually copying the buffer, it&apos;s just adjusting some of the internal variables and pointers. Lets leave it as is.&lt;/p&gt;</comment>
                            <comment id="12752963" author="schubertzhang" created="Wed, 9 Sep 2009 07:35:08 +0000"  >&lt;p&gt;I am puzzled......&lt;/p&gt;

&lt;p&gt;In the class HeapByteBuffer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;    public ByteBuffer compact() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {
	System.arraycopy(hb, ix(position()), hb, ix(0), remaining());
	position(remaining());
	limit(capacity());
	return this;
    }&lt;/span&gt; &lt;/div&gt;&lt;/blockquote&gt; 

&lt;p&gt;We can see there is a arraycopy here. But I am puzzled why the performance is no improvement? &lt;/p&gt;


&lt;p&gt;@ryan,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I am nearly 100% sure that code block I added to solve a NPE. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Could you please tell me about your added code block to solve the NPE? I am interested in it.&lt;/p&gt;</comment>
                            <comment id="12752965" author="schubertzhang" created="Wed, 9 Sep 2009 07:37:16 +0000"  >&lt;p&gt;public ByteBuffer compact() &lt;/p&gt;
{
        System.arraycopy(hb, ix(position()), hb, ix(0), remaining());
        position(remaining());
        limit(capacity());
        return this;
    }</comment>
                            <comment id="12752966" author="ryanobjc" created="Wed, 9 Sep 2009 07:39:11 +0000"  >&lt;p&gt;you were advocating removing:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (trailer.metaIndexCount == 0) 
{
-        return null; // there are no meta blocks
-      }&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;i seem to recall adding that to solve some npe or something.&lt;/p&gt;</comment>
                            <comment id="12753296" author="stack" created="Wed, 9 Sep 2009 22:14:25 +0000"  >&lt;p&gt;@Schubert Is it possible that in the scheme of things, the compact arraycopy is too miniscule to show in overall PE numbers?&lt;/p&gt;

&lt;p&gt;The v2 patch looks good.  It does not remove the section flagged above (that Ryan thinks might protect against a NPE). &lt;/p&gt;

&lt;p&gt;I&apos;m moving this issue out of 0.20.1 and will apply to TRUNK.  Its an improvement.  Lets try and do bug fixes only in the branch.&lt;/p&gt;</comment>
                            <comment id="12753304" author="stack" created="Wed, 9 Sep 2009 22:27:21 +0000"  >&lt;p&gt;Committed to TRUNK.  All tests pass. Thanks for the patch Schubert.&lt;/p&gt;</comment>
                            <comment id="12753319" author="stack" created="Wed, 9 Sep 2009 23:00:40 +0000"  >&lt;p&gt;Reopening.  Tests fail, the TestHFile in particular.&lt;/p&gt;</comment>
                            <comment id="12753327" author="ryanobjc" created="Wed, 9 Sep 2009 23:33:49 +0000"  >&lt;p&gt;Here are some comments from the svn commit:&lt;/p&gt;

&lt;p&gt;        if (this.comparator.compare(this.lastKeyBuffer, this.lastKeyOffset,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.lastKeyLength, key, offset, length) &amp;gt; 0) {&lt;br/&gt;
+            this.lastKeyLength, key, offset, length) &amp;gt;= 0) {&lt;br/&gt;
          throw new IOException(&quot;Added a key not lexically larger than&quot; +&lt;br/&gt;
            &quot; previous key=&quot; + Bytes.toString(key, offset, length) +&lt;br/&gt;
            &quot;, lastkey=&quot; + Bytes.toString(this.lastKeyBuffer, this.lastKeyOffset,&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This change has the &lt;em&gt;Exact opposite&lt;/em&gt; effect from the intent.  The intent (as I construct it) is to allow duplicate keys in a HFile, yet by adding &amp;gt;= you are explicitly requiring the next key to be larger, but NOT equal to the previous key.  This has to stay as is.&lt;/p&gt;

&lt;p&gt;+      if (buf == null)&lt;br/&gt;
+       return null;&lt;/p&gt;

&lt;p&gt;This is pointless, we&apos;ll NPE a few lines later anyways. Don&apos;t add checking code that doesnt have any benefits - the caller may not be interpret a null return as &apos;error&apos; in this case, did you check that?&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Toss the header. May have to remove later due to performance.&lt;/li&gt;
	&lt;li&gt;buf.compact();&lt;/li&gt;
	&lt;li&gt;buf.limit(buf.limit() - METABLOCKMAGIC.length);&lt;/li&gt;
	&lt;li&gt;buf.rewind();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I am not super happy with this change... it doesnt affect performance, but it does reduce code simplicity, and leaves open room for errors further on, and requires everyone to realize that the buf has this hidden header which isnt part of the public API of HFile.&lt;/p&gt;
</comment>
                            <comment id="12753403" author="schubertzhang" created="Thu, 10 Sep 2009 03:07:39 +0000"  >&lt;p&gt;@ryan&lt;br/&gt;
1. Regards duplicate keys in a HFile. I am following concern:&lt;br/&gt;
    If we allow duplicate keys. Consider following scenario:&lt;br/&gt;
    A key=&quot;abcd&quot; is append in block1&apos;s last key/value pair.&lt;br/&gt;
    And the the same key=&quot;abcd&quot; is append in block2&apos;s first key/value pair. Then in the block index, the key=&quot;abcd&quot; will point to block2.&lt;br/&gt;
    Then, we want to scan from key=&quot;abcd&quot;, but the first  key=&quot;abcd&quot; (in block1&apos;s last) will be missed out.&lt;br/&gt;
     Can you confirm this scenario is acceptable or required?&lt;/p&gt;

&lt;p&gt;2. + if (buf == null)&lt;br/&gt;
    + return null;&lt;/p&gt;

&lt;p&gt;This check is only added in getMetaBlock(...). In this method, there are three points to return null.&lt;br/&gt;
(1)  if (trailer.metaIndexCount == 0) &lt;/p&gt;
{
         return null; // there are no meta blocks
       }
&lt;p&gt;(2) if (block == -1)&lt;br/&gt;
         return null;&lt;br/&gt;
(3) if (buf == null)   //new added by me&lt;br/&gt;
        return null; &lt;br/&gt;
  If we do not check it, the following buf.get(..) may NPE. because the decompress() method will not throw exception. Do you mean NPE is better than &quot;return null&quot; which same as above two?&lt;br/&gt;
  In fact, it is diffcult to make above trade-off for me, maybe I am doing the way as C++.  &lt;/p&gt;

&lt;p&gt;3. Regards buf.compact().&lt;br/&gt;
    Yes, you may be right. After more test about performance, my patch does not improve the performance (I don&apos;t know if it can improve in some other environments.) I agree to remove this modification in my patch to retain the neat of the returned block buffer (position at 0).&lt;/p&gt;

&lt;p&gt;@stack and ryan&lt;br/&gt;
Thanks for your test. I will change the patch according to you comments. To include only bug fixing.&lt;br/&gt;
If the test fail, please just revert to old version.&lt;br/&gt;
Please give me comments about my above questions, then I can make active immediately. Thanks.&lt;/p&gt;</comment>
                            <comment id="12754074" author="schubertzhang" created="Fri, 11 Sep 2009 10:07:11 +0000"  >&lt;p&gt;I upload the v3 patch, which only include bug fix.&lt;/p&gt;</comment>
                            <comment id="12754308" author="stack" created="Fri, 11 Sep 2009 19:57:17 +0000"  >&lt;p&gt;I buy the argument preventing duplicate keys.&lt;/p&gt;

&lt;p&gt;Patch looks good to me.  +1 on commiting (TestHFile passes).&lt;/p&gt;

&lt;p&gt;@Ryan, what you think?&lt;/p&gt;</comment>
                            <comment id="12754321" author="ryanobjc" created="Fri, 11 Sep 2009 20:19:32 +0000"  >&lt;p&gt;So if compress() returns null (which it should not), some kind of error occurred.  Such as DFS out to lunch, etc, etc.  Returning &apos;null&apos; - which is interpreted as &apos;no such meta block&apos; is really ruining the API contract here. Just let it NPE.  Better than converting a IO error into a logical error as your code would do.&lt;/p&gt;

&lt;p&gt;As for the duplicate key, the block index is based on the last key in the block. So if we have two duplicate keys that straddle a block boundary, the scenario is like so:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;last key of block X is key &apos;A&apos; and that is entered in the index&lt;/li&gt;
	&lt;li&gt;first key of block X+1 is also key &apos;A&apos;, but first key is not part of the index&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Scanning will start at block X, and we will see both.&lt;/p&gt;

&lt;p&gt;The only scenario where we could potentially have an issue is if we have multiple duplicate keys so they span more than 1 block thus causing 2 index entries to have the same key. The binary search algorithm will need to choose the first entry to maintain correct behaviour on scan, and I am not 100% sure if this is what will happen. But even so, this is very rare, since in HBase keys are distinguished with timestamps, it would require either many keys with the same TS or a few really large ones with the same TS. Something to consider testing for.&lt;/p&gt;

&lt;p&gt;More importantly, if we disallow duplicate keys in hfile, that will cause huge problems. Right now there is no other mechanism to prevent duplicate KeyValues from being inserted - its your own lunch if you put multiple values at the same Timestamp.  But this change would cause compactions to throw and prevent them from completing. A far worse scenario.&lt;/p&gt;</comment>
                            <comment id="12754325" author="stack" created="Fri, 11 Sep 2009 20:26:28 +0000"  >&lt;p&gt;I&apos;m wondering how we&apos;d ever write duplicate keys to an hfile?  Wouldn&apos;t the most recent overwrite any older keys in memstore, a TreeMap?&lt;/p&gt;</comment>
                            <comment id="12754327" author="stack" created="Fri, 11 Sep 2009 20:32:55 +0000"  >&lt;p&gt;Ryan held my hand and explained that while not at memstore flush time, it could happen on a compaction &amp;#8211; makes sense.&lt;/p&gt;</comment>
                            <comment id="12754354" author="schubertzhang" created="Fri, 11 Sep 2009 21:18:44 +0000"  >&lt;p&gt;@ryan&lt;br/&gt;
1. Your description of &quot;return null&quot; is good, i.e. null means this meta block no exist.&lt;br/&gt;
     Accept you comment.  &lt;br/&gt;
     Maybe we can throw another Exception here? If you think it is not necessary, I will remove this added code.&lt;/p&gt;

&lt;p&gt;2.  In the HFile.java, I found the block index is based on the first key in the block (not last key).&lt;br/&gt;
     Not only treading HFile as a part of HBase, in fact, we want HFile can be a common file format which can be used in other applications. And in fact, I like to support duplicate keys in an HFile, since my application use HFile directly to store data. But  when I checked the code, I found the risk to add duplicate keys. e.g. &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;block 1:  firstKey=A,  lastKey=B,  indexKey=A&lt;/li&gt;
	&lt;li&gt;block 2:  firstKey=B, lastKey=C,  indexKey=B&lt;br/&gt;
When seek key=B, we go into block 2, and miss the lastKey=B in block 1.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Yes, you are right, if the index of data block is last key instead of  first key. it seems fine:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;block 1:  firstKey=A, lastKey=B, indexKey=B&lt;/li&gt;
	&lt;li&gt;block 2:  firstKey=B, lastKey=C, indexKey=C&lt;br/&gt;
When seek key=B, we go into block 1. The Scanner.seekTo() will find key=B in block 1 from the firstKey of block 1, and the Scanner.next() will not miss the key=B in block 2.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;But I double checked the HFile code, the block index is really firstKey now.&lt;/p&gt;</comment>
                            <comment id="12755465" author="schubertzhang" created="Tue, 15 Sep 2009 12:18:29 +0000"  >&lt;p&gt;@ Ryan and Stack,&lt;br/&gt;
Could you please make time to give me a reply about above two question? Then I will go ahead.&lt;/p&gt;</comment>
                            <comment id="12755520" author="stack" created="Tue, 15 Sep 2009 14:59:45 +0000"  >&lt;p&gt;On hfile as a general format, do think that will work Schubert?  It has stuff like KeyValue imports.  Is that OK?&lt;/p&gt;

&lt;p&gt;Ryan, what you think of index being first rather than last key in block?&lt;/p&gt;

&lt;p&gt;On the exception in decompress, &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1809&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-1809&lt;/a&gt; is an example.  Somehow we&apos;re using the HFile after a close.   Maybe another exception would be good here... at least debugging.  Could emit state of the HFile.Reader.&lt;/p&gt;</comment>
                            <comment id="12755563" author="schubertzhang" created="Tue, 15 Sep 2009 16:32:32 +0000"  >&lt;p&gt;@stack&lt;br/&gt;
Thanks for you reply. So I will make following decision to close this issue.&lt;/p&gt;

&lt;p&gt;1. Do not check the returned buf  of decompress() and let NPE is throwed.&lt;br/&gt;
     I have thought to throw IOException, but it seems it is not a RunTimeException.&lt;/p&gt;

&lt;p&gt;2. Leave the HFile can accept duplicated keys. But I think that will let the scenario of Scanner undefined.&lt;br/&gt;
    The block index uses firstKey of the block.&lt;/p&gt;

&lt;p&gt;So, finally, the patch only include some minor fix.&lt;/p&gt;</comment>
                            <comment id="12755685" author="stack" created="Tue, 15 Sep 2009 20:55:22 +0000"  >&lt;p&gt;Ok on 1. and 2 (I opened new issue to account for the case you discovered in your review where its possible we miss a key if many instances and they span a block &amp;#8211; hbase-1841).&lt;/p&gt;

&lt;p&gt;What about this change:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
@@ -860,7 +859,7 @@
       &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (trailer.metaIndexCount == 0) {
         &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;; &lt;span class=&quot;code-comment&quot;&gt;// there are no meta blocks
&lt;/span&gt;       }
-      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (metaIndex == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; ((metaIndex == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) || (metaIndex.count == 0)) {
         &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IOException(&lt;span class=&quot;code-quote&quot;&gt;&quot;Meta index not loaded&quot;&lt;/span&gt;);
       }
       &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; [] mbname = Bytes.toBytes(metaBlockName);

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Is it possible that metaIndex is loaded but empty?&lt;/p&gt;

&lt;p&gt;Thanks Schubert&lt;/p&gt;</comment>
                            <comment id="12755701" author="ryanobjc" created="Tue, 15 Sep 2009 21:23:52 +0000"  >&lt;p&gt;in reference to the block index, yes the scenario with duplicate keys that span a block boundary exists. &lt;/p&gt;

&lt;p&gt;It&apos;s possible that we could fix these holes with a different write strategy which doesnt create invalid hfiles like the one you theorized above. Another scenario is when you could have duplicate key entries in the index, which could cause problems with the binary search algorithm.&lt;/p&gt;

&lt;p&gt;There is 2 potential fixes here:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fix binary search algorithm to actually find the &lt;em&gt;lower bound&lt;/em&gt; in face of duplicates.&lt;/li&gt;
	&lt;li&gt;prevent hfiles like the one indicated above from being created, in this case by extending block 1 larger than the default sizing until we get a different key.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;there might be other solutions too.&lt;/p&gt;</comment>
                            <comment id="12755844" author="schubertzhang" created="Wed, 16 Sep 2009 02:29:58 +0000"  >&lt;p&gt;Thanks stack for create a new issue (hbase-1841)&lt;/p&gt;

&lt;p&gt;Regards the  2 potential fixes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fix binary search algorithm to actually find the lower bound in face of duplicates.&lt;br/&gt;
      I think maybe we need to change to use lastkey as the block index?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;prevent hfiles like the one indicated above from being created, in this case by extending block 1 larger than the default sizing until we get a different key.&lt;br/&gt;
      In fact, we used this way in one of our old product, i.e. only start new block/index at the boundary of different key. In this case, we should ensure the number of the duplicated keys not too large (that will lead big block).&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12755858" author="stack" created="Wed, 16 Sep 2009 02:45:21 +0000"  >&lt;p&gt;Applied to branch and trunk (v5 is bug fixes and a small optimization).&lt;/p&gt;

&lt;p&gt;Thanks for the patch Schubert.&lt;/p&gt;</comment>
                            <comment id="12965606" author="mbertozzi" created="Wed, 1 Dec 2010 08:19:17 +0000"  >&lt;p&gt;I&apos;ve rewritten Scanner.blockSeek() to perform a binary search.&lt;br/&gt;
The new method has the same behaviours of the previous one even with duplicate keys.&lt;br/&gt;
Unfortunatly I&apos;ve used an ArrayList to keep track of keys&apos; offset, ArrayList can be replaced by an array if number of keys in a block is known. &lt;/p&gt;</comment>
                            <comment id="12965616" author="ryanobjc" created="Wed, 1 Dec 2010 08:35:53 +0000"  >&lt;p&gt;according to my own profiling of hbase, blockSeek is not a hot method.  Could you provide more justification for the extra memory use? &lt;/p&gt;</comment>
                            <comment id="12965623" author="mbertozzi" created="Wed, 1 Dec 2010 09:16:37 +0000"  >&lt;p&gt;@Ryan&lt;br/&gt;
yep, blockSeek is not a hot method, but with larger keys and blocks it can speedup key lookups.&lt;br/&gt;
Extra memory is just 4K for 1024 keys, and for me would not be bad to have it on disk, at the end of the block.&lt;/p&gt;</comment>
                            <comment id="15017756" author="lars_francke" created="Fri, 20 Nov 2015 13:01:15 +0000"  >&lt;p&gt;This issue was closed as part of a bulk closing operation on 2015-11-20. All issues that have been resolved and where all fixVersions have been released have been closed (following discussions on the mailing list).&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12419287" name="HFile-v3.patch" size="3714" author="schubertzhang" created="Fri, 11 Sep 2009 10:07:11 +0000"/>
                            <attachment id="12419651" name="HFile-v4.patch" size="2520" author="schubertzhang" created="Tue, 15 Sep 2009 16:33:53 +0000"/>
                            <attachment id="12419720" name="HFile-v5.patch" size="2186" author="schubertzhang" created="Wed, 16 Sep 2009 02:22:57 +0000"/>
                            <attachment id="12465033" name="binary-block-seek.patch" size="3441" author="mbertozzi" created="Wed, 1 Dec 2010 08:19:17 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 8 Sep 2009 17:08:57 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>32274</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310191" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Hadoop Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10343"><![CDATA[Reviewed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            1 year, 4 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0hffj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>99762</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310230" key="com.atlassian.jira.plugin.system.customfieldtypes:textfield">
                        <customfieldname>Tags</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>HFile</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>