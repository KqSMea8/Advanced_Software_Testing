<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:10:09 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-3434/HBASE-3434.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-3434] ability to increment a counter without reading original value from storage</title>
                <link>https://issues.apache.org/jira/browse/HBASE-3434</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;There are a bunch of applications that do read-modify-write operations on HBase constructs, e.g  a counter; The counter value has to be read in from hdfs before it can be incremented.  We have an application where the number of increments on a counter far outnumbers the number of times the counter is used or read. For these type of applications, it will be very beneficial to not have to read in the counter from disk before it can be incremented.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12495119">HBASE-3434</key>
            <summary>ability to increment a counter without reading original value from storage</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="paulmw">Paul Wilkinson</assignee>
                                    <reporter username="dhruba">dhruba borthakur</reporter>
                        <labels>
                            <label>gsoc2016</label>
                            <label>mentor</label>
                    </labels>
                <created>Mon, 10 Jan 2011 10:22:00 +0000</created>
                <updated>Thu, 24 Mar 2016 22:17:33 +0000</updated>
                                                                            <component>Client</component>
                    <component>regionserver</component>
                        <due></due>
                            <votes>5</votes>
                                    <watches>20</watches>
                                                                <comments>
                            <comment id="12979542" author="hammer" created="Mon, 10 Jan 2011 11:17:57 +0000"  >&lt;p&gt;Can you just put the column in a column family that&apos;s in memory only?&lt;/p&gt;</comment>
                            <comment id="12979629" author="streamy" created="Mon, 10 Jan 2011 16:30:48 +0000"  >&lt;p&gt;That will only work if the working set of counters will fit in memory.  When that is no longer the case is generally when you also see a rapid decline in performance and throughput.&lt;/p&gt;

&lt;p&gt;Also, the in-memory setting is not &quot;in memory only&quot; but just gives blocks from that family a higher priority in the LRU.&lt;/p&gt;</comment>
                            <comment id="12979717" author="dhruba" created="Mon, 10 Jan 2011 19:57:19 +0000"  >&lt;p&gt;The idea is that an increment to a counter is recorded in a new record as an &quot;increment&quot; to the counter, it does not need to have the original value. A new type of Get() call will assort all the &quot;increment&quot; records associated with this counter and return the correct value to the application.&lt;/p&gt;

&lt;p&gt;In fact, I would like to discuss how the basic Key-Value construct be extended to a Key-Collection construct. A Collection has base primitives like adding/deleting/modifying to it, a List and a Counter are two special classes of this Collection construct. In the current implementation, when an application wants to delete an element from a Collection, it reads(R) the List from a HBase key-value, modifies it in memory and then writes a new serialized Collection back to HBase. If the &quot;Collection&quot; was a basic primitive offered by HBase, then the application would have just written a new record to indicate &quot;delete element x from Collection&quot;. This would eliminate the step (marked as (R) above) and converts a read-modify-write to a pure write operation. The Counter is just a specialized version of a Collection construct. The lazy background compaction process assorts all the &quot;operations&quot; on the Collection and materializes a true value of the Collection (let&apos;s call it the tombstone). The creation of the tombstone indicates that all KVs with an older timestamp can be safely discarded.&lt;/p&gt;

&lt;p&gt;The benefit is that all random reads are now converted to sequential reads, thus leading to better scalability of storage. Another benefit could be that it might be easier to reduce conflicts while merging records using HBase replication because it is easier to merge operations-logs rather than absolute values!&lt;/p&gt;
</comment>
                            <comment id="12979727" author="ryanobjc" created="Mon, 10 Jan 2011 20:06:48 +0000"  >&lt;p&gt;can we layer this on top of the existing infrastructure, instead of&lt;br/&gt;
making fundamental changes to KeyValue and HFile?  Or if we must make&lt;br/&gt;
changes, let&apos;s do it in very minimal ways, eg: add 1 or 2 more types&lt;br/&gt;
to KV.&lt;/p&gt;


&lt;p&gt;On Mon, Jan 10, 2011 at 11:58 AM, dhruba borthakur (JIRA)&lt;/p&gt;
</comment>
                            <comment id="12979729" author="stack" created="Mon, 10 Jan 2011 20:10:46 +0000"  >&lt;p&gt;@Dhruba Tell us more what attributes this &apos;new record&apos; type will look like?  How will it differ from plain cell?   Will the cell be marked in some manner if its an aggregation of all behind it?  The server will know to stop looking once it runs up against such a rollup point?  Will rollups be done in background or on a read?&lt;/p&gt;

&lt;p&gt;A KeyCollection is made of KVs?  If not, what are its atoms?  Or its a special version of a KV (We have a Type field in KVs so we might be able to add in a Collection type &amp;#8212; or List or Counter type if thats what we really want).  To get a view on a Collection, we&apos;d have to fetch all mentions of a particular &apos;Collection&apos; back as far as the last Collection &apos;tombstone&apos; instance then roll it all up to present the current view?&lt;/p&gt;

&lt;p&gt;Good stuff Dhruba.&lt;/p&gt;</comment>
                            <comment id="12979816" author="dhruba" created="Mon, 10 Jan 2011 22:34:55 +0000"  >&lt;p&gt;hi stack,  Some of these ideas are still raw in my brain, so please excuse me if my writeup is not very coherant. &lt;/p&gt;

&lt;p&gt;There are two ways to mark these new records. One way is to have a new value for KeyValue.Type.Collection. The other option is to have a new field in HColumnDescriptor to say that all columns in that family are of Collection type. Do you have a preference (and why)? The two different types of collection to start with can be Counters and Lists.&lt;/p&gt;

&lt;p&gt;A cell that has the aggregated value is a TombStone (no scans need to go beyond that). A cell that does not have an aggregated value is called a Delta cell. A KeyCollection is made of Kvs. The precise-type of collection (whether Counters, List, etc) is stored in the Value itself.&lt;/p&gt;

&lt;p&gt;There are two triggers that merge of set of Deltas cells to create a TombStone cell. First, a major compaction thread aggregates Deltas into Tombstones. Secondly, when an application makes a Get() call, it aggregates on demand and stores a TombStone.&lt;/p&gt;</comment>
                            <comment id="12979841" author="stack" created="Mon, 10 Jan 2011 23:15:22 +0000"  >&lt;p&gt;(No worries regards blue-skying Dhruba... go for it).&lt;/p&gt;

&lt;p&gt;If we did not want to alter the fundamentals of HBase, Collections might be done as a Coprocessor instance.  Coprocessors have hooks pre/post Get as well as on flush/compact.  You&apos;d mark the region to load KeyCollectionCoprocessor.  The KCCP would work on ColumnFamilies marked as KeyCollections either of type increment or type List.  On flush, we&apos;d write out the aggregating Tombstone (We want to avoid data bloat if we can &amp;#8211; just don&apos;t put it into the FS beyond the WAL).  On Get, we&apos;d aggregate until we hit a tombstone writing back a new tombstone record if &quot;too many&quot; deltas have gone in since the last tombstone.&lt;/p&gt;

&lt;p&gt;Having all this KeyCollection code cohere inside a Coprocessor is a nice way of keeping the code all together rather than spread about the server.&lt;/p&gt;

&lt;p&gt;Otherwise, we could make a HCD as carrying Collections only and then have the server do extra processing on Get, flush, compact if the HCD is of this type.  If the marking was done as a special KV Type, then we could have Collections live in the same family as plain KVs, if we wanted to do such a thing (I don&apos;t think we do especially if the write-rate of increments is high).&lt;/p&gt;



</comment>
                            <comment id="12980585" author="dhruba" created="Wed, 12 Jan 2011 06:30:27 +0000"  >&lt;p&gt;Using co-processors seems to be the right thing to do. if I build it this way, do I still contribute the code back to the Apache HBase svn tree? if so, where will it be located?&lt;/p&gt;</comment>
                            <comment id="12980779" author="streamy" created="Wed, 12 Jan 2011 16:26:25 +0000"  >&lt;p&gt;I think it remains to be seen exactly where features implemented via coprocessors will live.  Certainly there will be some open source home for them, I just think there&apos;s some aversion to shipping with and managing a big set of contribs.&lt;/p&gt;</comment>
                            <comment id="13496913" author="asafm" created="Wed, 14 Nov 2012 07:17:14 +0000"  >&lt;p&gt;Dhurba - did you managed to code this stuff? We&apos;ve just been hitting the exact same problem. I&apos;ve seen a very similar design implemented in project &lt;a href=&quot;https://github.com/sematext/HBaseHUT&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;HBaseHUT&lt;/a&gt;, but he focused on Puts rather than increments and decided to place code in Client and a M/R job other than using co-processors &lt;/p&gt;</comment>
                            <comment id="15210783" author="stack" created="Thu, 24 Mar 2016 19:10:22 +0000"  >&lt;p&gt;Assigned issue to myself and marked it w/ labels so it will show as candidate for gsoc2016&lt;/p&gt;</comment>
                            <comment id="15210785" author="jmspaggi" created="Thu, 24 Mar 2016 19:11:40 +0000"  >&lt;p&gt;Nice! I know someone that have a very nice design to address that... Let me ping him and see if he can help...&lt;/p&gt;</comment>
                            <comment id="15210791" author="stack" created="Thu, 24 Mar 2016 19:14:14 +0000"  >&lt;p&gt;Dump it in here &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jmspaggi&quot; class=&quot;user-hover&quot; rel=&quot;jmspaggi&quot;&gt;Jean-Marc Spaggiari&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Also to consider is doing increments with CRDTs. See comment here &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-14460?focusedCommentId=14909404&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14909404&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-14460?focusedCommentId=14909404&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14909404&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If CRDT, could do for increments only but would be sweet if other read-modify-write ops were at least considered in design of CRDT support.&lt;/p&gt;</comment>
                            <comment id="15210794" author="stack" created="Thu, 24 Mar 2016 19:16:03 +0000"  >&lt;p&gt;See also &lt;a href=&quot;https://github.com/caskdata/cdap-hbase-increments&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/caskdata/cdap-hbase-increments&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15210804" author="jmspaggi" created="Thu, 24 Mar 2016 19:20:08 +0000"  >&lt;p&gt;Let&apos;s wait for Paul to ring here but Paul&apos;s idea was really accumulation. Like counters, but not only. Also why not Avro objetc and then you only put the modified fields later and accumulate on compactions and reads. You can plug any compaction logic you want.&lt;/p&gt;</comment>
                            <comment id="15211053" author="paulmw" created="Thu, 24 Mar 2016 22:16:54 +0000"  >&lt;p&gt;Hey folks, happy to take this on. The current prototype code (based on co-processors) is at &lt;a href=&quot;https://github.com/paulmw/hbase-aggregation/tree/master/src/main/java/aggregation/coprocessor&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/paulmw/hbase-aggregation/tree/master/src/main/java/aggregation/coprocessor&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It&apos;s a work in progress for sure, but most of the ideas are in there. It aggregates data both during flushes and compactions, as well as during gets and scans. So counters are implemented simply by adding the co-processor and performing puts. It&apos;s very much not limited to summation though, as you can plug in a custom value aggregation function (by implementing &lt;a href=&quot;https://github.com/paulmw/hbase-aggregation/blob/master/src/main/java/aggregation/coprocessor/ValueAccumulator.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/paulmw/hbase-aggregation/blob/master/src/main/java/aggregation/coprocessor/ValueAccumulator.java&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;The decision on what cells to aggregate is also pluggable - the default is versions of the same cell (&lt;a href=&quot;https://github.com/paulmw/hbase-aggregation/blob/master/src/main/java/aggregation/coprocessor/DefaultCellAccumulator.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/paulmw/hbase-aggregation/blob/master/src/main/java/aggregation/coprocessor/DefaultCellAccumulator.java&lt;/a&gt;, which implements CellAccumulator) but it&apos;s easy to imagine the kind of multi-level rollup you often get in time series - keeping 1 minute granularity for today, 10 minute granularity for the previous 6 days, hourly beyond that etc. So long as those values are all consecutive in KV terms, that&apos;s still possible in a stateless fashion.&lt;/p&gt;

&lt;p&gt;What&apos;s missing as yet is a design for how aggregation functions are registered - happy to take direction there. It&apos;s also possible it could become more supported in HBase itself, rather than in client land. Again, happy to take direction from folks here. It&apos;s certain though that there&apos;s a need to retain the custom aggregation part of this, rather than just doing a better version of counters.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 10 Jan 2011 11:17:57 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>33023</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            38 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i02ein:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11953</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>