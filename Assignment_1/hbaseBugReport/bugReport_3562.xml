<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:11:14 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-3562/HBASE-3562.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-3562] ValueFilter is being evaluated before performing the column match</title>
                <link>https://issues.apache.org/jira/browse/HBASE-3562</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;When performing a Get operation where a both a column is specified and a ValueFilter, the ValueFilter is evaluated before making the column match as is indicated in the javadoc of Get.setFilter()  : &quot; &lt;/p&gt;
{@link Filter#filterKeyValue(KeyValue)}
&lt;p&gt; is called AFTER all tests for ttl, column match, deletes and max versions have been run. &quot;&lt;/p&gt;

&lt;p&gt;The is shown in the little test below, which uses a TestComparator extending a WritableByteArrayComparable.&lt;/p&gt;

&lt;p&gt;public void testFilter() throws Exception {&lt;br/&gt;
	byte[] cf = Bytes.toBytes(&quot;cf&quot;);&lt;br/&gt;
	byte[] row = Bytes.toBytes(&quot;row&quot;);&lt;br/&gt;
	byte[] col1 = Bytes.toBytes(&quot;col1&quot;);&lt;br/&gt;
	byte[] col2 = Bytes.toBytes(&quot;col2&quot;);&lt;br/&gt;
	Put put = new Put(row);&lt;br/&gt;
	put.add(cf, col1, new byte[]&lt;/p&gt;
{(byte)1}
&lt;p&gt;);&lt;br/&gt;
	put.add(cf, col2, new byte[]&lt;/p&gt;
{(byte)2}
&lt;p&gt;);&lt;br/&gt;
	table.put(put);&lt;/p&gt;

&lt;p&gt;	Get get = new Get(row);&lt;br/&gt;
	get.addColumn(cf, col2); // We only want to retrieve col2&lt;/p&gt;

&lt;p&gt;	TestComparator testComparator = new TestComparator();&lt;br/&gt;
	Filter filter = new ValueFilter(CompareOp.EQUAL, testComparator);&lt;br/&gt;
	get.setFilter(filter);&lt;br/&gt;
	Result result = table.get(get);&lt;br/&gt;
}&lt;/p&gt;


&lt;p&gt;public class TestComparator extends WritableByteArrayComparable {&lt;br/&gt;
    /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Nullary constructor, for Writable&lt;br/&gt;
     */&lt;br/&gt;
    public TestComparator() 
{
        super();
    }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    @Override&lt;br/&gt;
    public int compareTo(byte[] theirValue) {&lt;br/&gt;
        if (theirValue&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; == (byte)1) &lt;/p&gt;
{
            // If the column match was done before evaluating the filter, we should never get here.
            throw new RuntimeException(&quot;I only expect (byte)2 in col2, not (byte)1 from col1&quot;);
        }
&lt;p&gt;        if (theirValue&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; == (byte)2) &lt;/p&gt;
{
            return 0;
        }
&lt;p&gt;        else return 1;&lt;br/&gt;
    }&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;When only one column should be retrieved, this can be worked around by using a SingleColumnValueFilter instead of the ValueFilter.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12499604">HBASE-3562</key>
            <summary>ValueFilter is being evaluated before performing the column match</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="evertot">Evert Arckens</reporter>
                        <labels>
                    </labels>
                <created>Thu, 24 Feb 2011 16:02:14 +0000</created>
                <updated>Thu, 17 Nov 2016 02:21:27 +0000</updated>
                                            <version>0.90.0</version>
                    <version>0.94.7</version>
                                                    <component>Filters</component>
                        <due></due>
                            <votes>2</votes>
                                    <watches>8</watches>
                                                                <comments>
                            <comment id="13011096" author="stack" created="Fri, 25 Mar 2011 04:41:50 +0000"  >&lt;p&gt;Do you have a fix Evert?  (This might be a bit tricky to fix).&lt;/p&gt;</comment>
                            <comment id="13011175" author="evertot" created="Fri, 25 Mar 2011 12:21:59 +0000"  >&lt;p&gt;In ScanQueryMatcher.match I would do the columns.checkColumn call first and only if that returns MatchCode.INCLUDE execute the filters. I think this would be more efficient as well since calculating to skip a column or not will usually be faster than evaluating one ore more filters.&lt;/p&gt;

&lt;p&gt;However, in the code is mentioned explicitly : &lt;br/&gt;
/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Filters should be checked before checking column trackers. If we do&lt;/li&gt;
	&lt;li&gt;otherwise, as was previously being done, ColumnTracker may increment its&lt;/li&gt;
	&lt;li&gt;counter for even that KV which may be discarded later on by Filter. This&lt;/li&gt;
	&lt;li&gt;would lead to incorrect results in certain cases.&lt;br/&gt;
 */&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;It is not completely clear to me what the exact purpose of the counter on the ColumnTracker is or what the problem would be if it was incremented.&lt;br/&gt;
Maybe calling ((ExplicitColumnTracker)columns).doneWithColumn (like is done in getNextRowOrNextColumn) explicitly when a filter skips a column can help here?&lt;/p&gt;</comment>
                            <comment id="13011248" author="streamy" created="Fri, 25 Mar 2011 15:47:02 +0000"  >&lt;p&gt;The counter in ColumnTracker is responsible for tracking setMaxVersions.  You may have queried for only the latest version, so once the ColumnTracker sees a given column, it will reject subsequent version of that columns.  Currently there&apos;s no way for the CT to know that subsequent filters actually prevented it from being returned so it should not be included in the count of returned versions.&lt;/p&gt;

&lt;p&gt;We would need to introduce something like &lt;tt&gt;skippedPreviousKeyValue&lt;/tt&gt; that could be sent back to the CT so it could undo the previous count.&lt;/p&gt;</comment>
                            <comment id="13012444" author="evertot" created="Tue, 29 Mar 2011 11:59:53 +0000"  >&lt;p&gt;The attached file contains a patch with a proposed solution which comes down to :&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;In ScanQueryMatcher perform the checkColumn call first&lt;/li&gt;
	&lt;li&gt;If that call would return &apos;INCLUDE&apos;, don&apos;t update the counters or timestamp yet in the ColumnTracker&lt;/li&gt;
	&lt;li&gt;But let the ScanQueryMatcher evaluate the filter&lt;/li&gt;
	&lt;li&gt;If after evaluating the filter the column is still considered to be included, call includeLatestColumn on the ColumnTracker which will update the counters or timestamp at that moment&lt;/li&gt;
	&lt;li&gt;If there is no filter to be evaluated, the call to includeLatestColumn should be done by default&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;What do you think? Does this look like a good solution? Or did I miss something?&lt;/p&gt;


&lt;p&gt;Evert&lt;/p&gt;</comment>
                            <comment id="13014748" author="streamy" created="Fri, 1 Apr 2011 17:04:34 +0000"  >&lt;p&gt;Thanks for looking into this Evert.  This is definitely some tricky stuff.&lt;/p&gt;

&lt;p&gt;A few comments on your patch...&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Our convention in conditionals is to put the variable first.  I find it a little tricky to read the code when the constant is first.  For example:
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (MatchCode.INCLUDE == mc)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;should be&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (mc == MatchCode.INCLUDE)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;(And all the other places where you have this type of logic)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The unit test &lt;tt&gt;TestColumnMatchAndFilterOrder&lt;/tt&gt; is clever how you check correctness, but I think it would be good to actually do a read query and verify the results for a few different combinations of the query to prove correctness of the overall algorithm.  Other changes to SQM down the road might change more behavior / order of operations, so this test may no longer apply or give full coverage for correctness.  Having some tests which don&apos;t rely on the precise server-side interactions but rather confirm the end results will be more applicable as we move forward.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;You have some lines that are &amp;gt; 80 characters, especially in some of the javadoc.  Just wrap that so all lines are &amp;lt;= 80 chars.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;There was a comment in SQM that described why the filter was checked first.  Can you write some inline comments to describe how this works now?  There are a couple lines at the end but it will be useful to have some explanation on why this has changed and what the behavior is now.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Is there any particular reason that you had includeLatestColumn take timestamp as a parameter?  The timestamp is passed in the check call, and we could just hang on to that.  It just feels a little strange to me since you should never pass a different timestamp, and the tracker can know which was the latest column.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Overall this is really solid!  Great work Evert!&lt;/p&gt;</comment>
                            <comment id="13017371" author="evertot" created="Fri, 8 Apr 2011 10:00:40 +0000"  >&lt;p&gt;Jonathan, &lt;br/&gt;
I&apos;m making the changes you propose.&lt;br/&gt;
Concerning the unit tests however, I&apos;m not sure if an end-result test is usefull or what exactly to test in an end result test.&lt;br/&gt;
After all, the result from a read query will be the same, no matter if the column is selected first or the filter is applied first. It is only that if the filter would be applied first it should be able to run against any value from any column (i.e. it should be robust). But that&apos;s something I guess is already covered by the test I included.&lt;/p&gt;

&lt;p&gt;Can you go into a bit more detail of what kind of tests you think would be usefull?&lt;/p&gt;</comment>
                            <comment id="13026383" author="streamy" created="Thu, 28 Apr 2011 17:23:44 +0000"  >&lt;p&gt;Sorry for the delay in getting back.&lt;/p&gt;

&lt;p&gt;The test looks very implementation specific and is dependent on how things are executed server-side.  That is a good thing.&lt;/p&gt;

&lt;p&gt;What I&apos;m proposing is an additional, functional-level test that explicitly tests the bad behavior and verifies the Result is as expected (rather than relying on a custom comparator).&lt;/p&gt;

&lt;p&gt;Looking at your test in more detail, it is good, but took me some time to fully grok why it made sense.  Some additional comments might suffice, or perhaps just an additional assert at the end of the actual Result from the get() with an explanation.  At this point, feel free to keep things as is if I&apos;m not making sense &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13704813" author="fgaule" created="Wed, 10 Jul 2013 17:45:53 +0000"  >&lt;p&gt;Hi everyone, &lt;br/&gt;
I&apos;m facing a similar issue. &lt;br/&gt;
I&apos;m requesting a number of contiguous columns using #addColumn and a FilterList expecting to be applied to the columns i request. But, the filters are being applied to all columns PLUS the next one to the last one i requested. &lt;/p&gt;

&lt;p&gt;As Workaround, setting a ColumnRangeFilter seems to solve the problem.   &lt;/p&gt;</comment>
                            <comment id="15671544" author="esteban" created="Wed, 16 Nov 2016 20:36:42 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=Apache9&quot; class=&quot;user-hover&quot; rel=&quot;Apache9&quot;&gt;Duo Zhang&lt;/a&gt; any thoughts on this? There seems that the unit tests in the patch would be helpful and there is an addition to the ColumnTracker that might be helpful in other cases.&lt;/p&gt;</comment>
                            <comment id="15672429" author="apache9" created="Thu, 17 Nov 2016 02:21:27 +0000"  >&lt;p&gt;Do you mean we should commit the UTs in this patch?&lt;/p&gt;

&lt;p&gt;Now in master, we will call columns.checkColumn before evaluating filter so I think the problem described here is gone. But in general, I think we should also count versions before evaluating filters. The current implementation(filter then count versions) may returns different results on the same data set due to major compaction.&lt;/p&gt;

&lt;p&gt;Think of this. You set maxVersions to 3, and there are 4 versions. Your filter will filter out the 3 newer versions, so you will get the oldest version when doing a get or scan. And here comes a major compaction, the oldest version is reclaimed. At this time you will get nothing when doing the same get or scan.&lt;/p&gt;

&lt;p&gt;We need to fix this I think although this is an &apos;incompatible change&apos;.&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12657351">HBASE-8930</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12989123">HBASE-16225</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12474871" name="HBASE-3562.patch" size="13220" author="evertot" created="Tue, 29 Mar 2011 11:59:53 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 25 Mar 2011 04:41:50 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>26917</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i02bov:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11495</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>