<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:56:50 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-8607/HBASE-8607.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-8607] Allow custom filters and coprocessors to be updated for a region server without requiring a restart</title>
                <link>https://issues.apache.org/jira/browse/HBASE-8607</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;One solution to allowing custom filters and coprocessors to be updated for a region server without requiring a restart might be to run the HBase server in an OSGi container (maybe there are other approaches as well?). Typically, applications that use coprocessors and custom filters also have shared classes underneath, so putting the burden on the user to include some kind of version name in the class is not adequate. Including the version name in the package might work in some cases (at least until dependent jars start to change as well), but is cumbersome and overburdens the app developer.&lt;/p&gt;

&lt;p&gt;Regardless of what approach is taken, we&apos;d need to define the life cycle of the coprocessors and custom filters when a new version is loaded. For example, in-flight invocations could continue to use the old version while new invocations would use the new ones. Once the in-flight invocations are complete, the old code/jar could be unloaded.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12649232">HBASE-8607</key>
            <summary>Allow custom filters and coprocessors to be updated for a region server without requiring a restart</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="juwi">Julian Wissmann</assignee>
                                    <reporter username="giacomotaylor">James Taylor</reporter>
                        <labels>
                    </labels>
                <created>Fri, 24 May 2013 00:06:59 +0000</created>
                <updated>Fri, 14 Nov 2014 16:32:31 +0000</updated>
                                                                            <component>regionserver</component>
                        <due></due>
                            <votes>2</votes>
                                    <watches>17</watches>
                                                                <comments>
                            <comment id="13671896" author="giacomotaylor" created="Fri, 31 May 2013 23:32:37 +0000"  >&lt;p&gt;My thinking is that an OSGi container would allow a new version of a coprocessor (and/or custom filter) jar to be loaded. Class conflicts between the old jar and the new jar would no longer be a problem - you&apos;d never need to unload the old jar. Instead, future HBase operations that invoke the coprocessor would cause the newly loaded jar to be used instead of the older one. I&apos;m not sure if this is possible or not. The whole idea would be to prevent a rolling restart or region close/reopen.&lt;/p&gt;</comment>
                            <comment id="13672006" author="apurtell" created="Sat, 1 Jun 2013 07:22:50 +0000"  >&lt;p&gt;As far as I know, OSGi does not support hot class replacement, but you can shut down, reload, and restart bundles/subsystems. This will only work as far as the interfaces and objects exchanged between the bundle and everything else doesn&apos;t change. For this to be possible with coprocessors, we would need to I guess refactor the server into a bundle then have coprocessors and filters also be structured and loaded as a bundle. As an alternative to hosting HBase itself in an OSGi runtime, we might embed the runtime as the coprocessor host and refactor only coprocessors and filters as bundles. So that would imply some kind of filter host environment too or a merging of filters and coprocessors. &lt;/p&gt;

&lt;p&gt;That is not a problem per se but an incompatible change and major surgery. We should prototype this if serious to see if an OSGi runtime (such as Apache Felix) can actually reliably do this. I look at Eclipse as an example of OSGi in action and wonder. When designing coprocessors we felt it easier and more reliable to require a process reload - guaranteed to work under every circumstance. &lt;/p&gt;

&lt;p&gt;As to whether or not we should do a quick reload, which might possibly be minimized to a close then reopen of a region when a coprocessor is reloaded, consider the circumstances of hot reload of a coprocessor in a regionserver with many ops in flight. What will the internal state of the coprocessor look like? Will there be cross-op dependencies? Currently at the hook points we enumerate a CopyOnWriteList to find installed coprocessors. The swap of the old coprocessor instance for the new will be fast and lockless but will happen at an arbitrary point in the op stream and for some brief period of time old and new instances will be simultaneously active. Replace this with OSGi particulars and the coprocessor side issues don&apos;t change. For this reason I think it best to have the coprocessor lifecycle tied to the region or regionserver lifecycle anyway. &lt;/p&gt;</comment>
                            <comment id="13672007" author="apurtell" created="Sat, 1 Jun 2013 07:27:43 +0000"  >&lt;p&gt;Another option is to consider external coprocessor hosts. Then a reload is a process restart but involving only the coprocessor / child JVM. That is &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4047&quot; title=&quot;[Coprocessors] Generic external process host&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4047&quot;&gt;HBASE-4047&lt;/a&gt;. &lt;/p&gt;</comment>
                            <comment id="13672059" author="stack" created="Sat, 1 Jun 2013 11:29:55 +0000"  >&lt;p&gt;If a CP were in an external process, the Interface would have to be more coarse than it is currently, right?  CPs would not be able to be as intimate as they are now if their invocation requires a trip to an external process?&lt;/p&gt;</comment>
                            <comment id="13672100" author="apurtell" created="Sat, 1 Jun 2013 13:21:42 +0000"  >&lt;p&gt;External coprocessors wouldn&apos;t have arbitrary access to regionserver internals. There might be a way to keep them inline with RS processing as observers as we have now though, maybe using a shared memory channel. I&apos;d not want to say without trying something out and measuring what we can get. It would be safe to assume OSGi/in process as always having more access and bandwidth. &lt;/p&gt;</comment>
                            <comment id="13672287" author="apurtell" created="Sat, 1 Jun 2013 22:56:57 +0000"  >&lt;p&gt;Something might worth trying out is an OSGi socket as coprocessor. Like with &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4047&quot; title=&quot;[Coprocessors] Generic external process host&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4047&quot;&gt;HBASE-4047&lt;/a&gt; where one side of the umbilical is a &quot;normal&quot; coprocessor, here that is instead a shim for another piece of code that is (re)loaded as a bundle. Would give us a sense of how workable embedding an OSGi runtime and reloading a coprocessor might be. &lt;/p&gt;</comment>
                            <comment id="13672799" author="stack" created="Mon, 3 Jun 2013 03:56:25 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=andrew.purtell%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;andrew.purtell@gmail.com&quot;&gt;Andrew Purtell&lt;/a&gt; I like the direction you suggest; would proof out two concepts in the one go (osgi and moving cp hosting out of the regionserver).&lt;/p&gt;</comment>
                            <comment id="13672938" author="nkeywal" created="Mon, 3 Jun 2013 09:15:58 +0000"  >&lt;p&gt;Running the coprocessor within the region server removes the problem of managing the life cycle of two different processes, with all the questions of &quot;the coprocessor takes time, is it dead? Is it gc-ing?&quot; (with the same questions on the coprocessor side: &quot;I&apos;m not called, why?&quot;). &lt;/p&gt;

&lt;p&gt;btw, do we manage today the fact that we can have conflicts between hbase third parties and the coprocessor ones?&lt;/p&gt;

&lt;p&gt;While OSGi is nice (and allows more features on the long term), I also think that the rolling restart should work well enough (or should be made working well enough) for most cases, as it shares a lot of code with stuff like balance or recovery.&lt;/p&gt;</comment>
                            <comment id="13673005" author="apurtell" created="Mon, 3 Jun 2013 10:58:57 +0000"  >&lt;blockquote&gt;&lt;p&gt;I like the direction you suggest; would proof out two concepts in the one go (osgi and moving cp hosting out of the regionserver).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt; It would demonstrate if an OSGi runtime can be embedded and if CPs hosted by it can be unloaded or reloaded, but everything would all still be in the same process.&lt;/p&gt;</comment>
                            <comment id="13673845" author="giacomotaylor" created="Tue, 4 Jun 2013 00:18:05 +0000"  >&lt;p&gt;To a large degree, Phoenix gets it&apos;s performance from being able to run inside the JVM of the region server, so if I understand this idea, we&apos;d lose that with this approach.&lt;/p&gt;

&lt;p&gt;I&apos;m no OSGi expert, but I talked with some folks here, and it seems that we could do what we want through OSGi and swap in new jars without requiring a rolling restart. &lt;/p&gt;

&lt;p&gt;Might be worth a visit here to explore? I&apos;m happy to set something up.&lt;/p&gt;
</comment>
                            <comment id="13674004" author="ndimiduk" created="Tue, 4 Jun 2013 03:53:42 +0000"  >&lt;blockquote&gt;&lt;p&gt;Running the coprocessor within the region server removes the problem of managing the life cycle of two different processes, with all the questions of &quot;the coprocessor takes time, is it dead? Is it gc-ing?&quot; (with the same questions on the coprocessor side: &quot;I&apos;m not called, why?&quot;).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Coprocessors remain a reasonably advanced feature. I think the benefits to a novice user of running coprocessors as a managed child process out-weight the pains (which are easily worked around) for an advanced user.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;There might be a way to keep them inline with RS processing as observers as we have now though, maybe using a shared memory channel.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This post &lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; is an inspiring read for anyone considering an external process implementation. We would require some work to achieve the word alignment that&apos;s critical to the performance numbers posted here, but I think it&apos;s worth a shot.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;: &lt;a href=&quot;http://psy-lob-saw.blogspot.co.uk/2013/04/lock-free-ipc-queue.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://psy-lob-saw.blogspot.co.uk/2013/04/lock-free-ipc-queue.html&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13674183" author="apurtell" created="Tue, 4 Jun 2013 08:50:04 +0000"  >&lt;p&gt;James, I think you may have missed some discussion further up on this issue. Specifically:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Something might worth trying out is an OSGi socket as coprocessor. Like with &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4047&quot; title=&quot;[Coprocessors] Generic external process host&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4047&quot;&gt;HBASE-4047&lt;/a&gt; where one side of the umbilical is a &quot;normal&quot; coprocessor, here that is instead a shim for another piece of code that is (re)loaded as a bundle. Would give us a sense of how workable embedding an OSGi runtime and reloading a coprocessor might be.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Stated a different way, we create a coprocessor that embeds an OSGi runtime, perhaps Apache Felix. This coprocessor is just a shell. It is configured to load an OSGi bundle, from another path. Handlers for all upcalls are delegated to the loaded bundle. We can expose an Endpoint for triggering bundle reload. So, sure, we can play around with this and see if it works, without changing anything core, since the OSGi glue would be a coprocessor itself. What do you think? Meet up about this some time around HBaseCon?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I&apos;m no OSGi expert, but I talked with some folks here, and it seems that we could do what we want through OSGi and swap in new jars without requiring a rolling restart.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Can you (or one of your folks) address this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As to whether or not we should do a quick reload, which might possibly be minimized to a close then reopen of a region when a coprocessor is reloaded, consider the circumstances of hot reload of a coprocessor in a regionserver with many ops in flight. What will the internal state of the coprocessor look like? Will there be cross-op dependencies? Currently at the hook points we enumerate a CopyOnWriteList to find installed coprocessors. The swap of the old coprocessor instance for the new will be fast and lockless but will happen at an arbitrary point in the op stream and for some brief period of time old and new instances will be simultaneously active. Replace this with OSGi particulars and the coprocessor side issues don&apos;t change. For this reason I think it best to have the coprocessor lifecycle tied to the region or regionserver lifecycle anyway.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What happens if a scan is in progress and Phoenix is upgraded? The new instance would not have been around when the scanner was opened, yet it will start getting upcalls from scanner.next(). Do we need any special considerations for this? Or can we say that Phoenix, or any other coprocessor reloaded this way, must handle this somehow through state sharing between instances?&lt;/p&gt;</comment>
                            <comment id="14184667" author="juwi" created="Sun, 26 Oct 2014 21:24:38 +0000"  >&lt;p&gt;Andrew, your suggestion sounds really interesting. I&apos;ve just been thinking about it for a while in order to estimate how big an effort prototyping this would be. The way I understand it, the idea is, that we have an OSGi Coprocessor, that the regular coprocessors are registered to as an OSGi Service. However, for this to work, there will either need to be a Service Registry on each Region or we go with Distributed OSGi and dump it in the client. Either way, there also needs to be a mechanism to check service availability on the Regions form the client side.&lt;/p&gt;

&lt;p&gt;Right now, I&apos;d consider the version with each region server holding its own service registry to be quite feasible. I&apos;m thinking the following approach:&lt;br/&gt;
The OSGi Coprocessor wil discover Bundles, the only service provided by the Bundle will actually be starting discovered coprocessors with its own environment. That way the client side wil be rather clean and the actual coprocessors will behave as usual (their own protocol and client) thus allowing for the OSGi Coprocessor to be rather simple and maximizing flexibility. The only required client side functionality will then be representing the Service Registry and starting region side services by name (at least I can&apos;t think of another way considering that protobuf is in the middle of it). &lt;/p&gt;

&lt;p&gt;Any more thoughts on this?&lt;/p&gt;</comment>
                            <comment id="14189229" author="apurtell" created="Wed, 29 Oct 2014 23:07:42 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=juwi&quot; class=&quot;user-hover&quot; rel=&quot;juwi&quot;&gt;Julian Wissmann&lt;/a&gt;, the approach you describe sounds good to me. I don&apos;t think anyone else has spent substantial time thinking through the problem. If you&apos;d like to take this one we&apos;d be happy to review a patch/proposal. &lt;/p&gt;</comment>
                            <comment id="14210032" author="juwi" created="Thu, 13 Nov 2014 17:13:03 +0000"  >&lt;p&gt;Hi,&lt;br/&gt;
Sorry about the late reply. Time is a little scarce at the moment.&lt;br/&gt;
It&apos;ll take me a few weeks to get this going as it will really just be a little side project, but sure, I&apos;ll be happy to work on this and provide a patch.&lt;/p&gt;</comment>
                            <comment id="14212450" author="juwi" created="Fri, 14 Nov 2014 16:32:31 +0000"  >&lt;p&gt;I just began implementing. Getting Felix into HBase currently looks like the easy part. First of all I need to work on Felix a bit though. I want it to be able to load corocessors from HDFS. So my first order priority is to get HDFS support into Felix fileInstall. So while doing this, I&apos;ll have to talk to the Felix people to see if this is a feature that they are willing to incorporate or if this will reside in HBase.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 1 Jun 2013 07:22:50 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>329559</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            2 years, 5 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1kuvr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>329894</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310230" key="com.atlassian.jira.plugin.system.customfieldtypes:textfield">
                        <customfieldname>Tags</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Phoenix</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                </customfields>
    </item>
</channel>
</rss>