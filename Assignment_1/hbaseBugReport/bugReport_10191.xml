<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 20:11:22 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-10191/HBASE-10191.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-10191] Move large arena storage off heap</title>
                <link>https://issues.apache.org/jira/browse/HBASE-10191</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;Even with the improved G1 GC in Java 7, Java processes that want to address large regions of memory while also providing low high-percentile latencies continue to be challenged. Fundamentally, a Java server process that has high data throughput and also tight latency SLAs will be stymied by the fact that the JVM does not provide a fully concurrent collector. There is simply not enough throughput to copy data during GC under safepoint (all application threads suspended) within available time bounds. This is increasingly an issue for HBase users operating under dual pressures: 1. tight response SLAs, 2. the increasing amount of RAM available in &quot;commodity&quot; server configurations, because GC load is roughly proportional to heap size.&lt;/p&gt;

&lt;p&gt;We can address this using parallel strategies. We should talk with the Java platform developer community about the possibility of a fully concurrent collector appearing in OpenJDK somehow. Set aside the question of if this is too little too late, if one becomes available the benefit will be immediate though subject to qualification for production, and transparent in terms of code changes. However in the meantime we need an answer for Java versions already in production. This requires we move the large arena allocations off heap, those being the blockcache and memstore. On other JIRAs recently there has been related discussion about combining the blockcache and memstore (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-9399&quot; title=&quot;Up the memstore flush size&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-9399&quot;&gt;&lt;del&gt;HBASE-9399&lt;/del&gt;&lt;/a&gt;) and on flushing memstore into blockcache (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5311&quot; title=&quot;Allow inmemory Memstore compactions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5311&quot;&gt;HBASE-5311&lt;/a&gt;), which is related work. We should build off heap allocation for memstore and blockcache, perhaps a unified pool for both, and plumb through zero copy direct access to these allocations (via direct buffers) through the read and write I/O paths. This may require the construction of classes that provide object views over data contained within direct buffers. This is something else we could talk with the Java platform developer community about - it could be possible to provide language level object views over off heap memory, on heap objects could hold references to objects backed by off heap memory but not vice versa, maybe facilitated by new intrinsics in Unsafe. Again we need an answer for today also. We should investigate what existing libraries may be available in this regard. Key will be avoiding marshalling/unmarshalling costs. At most we should be copying primitives out of the direct buffers to register or stack locations until finally copying data to construct protobuf Messages. A related issue there is &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-9794&quot; title=&quot;KeyValues / cells backed by buffer fragments&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-9794&quot;&gt;HBASE-9794&lt;/a&gt;, which proposes scatter-gather access to KeyValues when constructing RPC messages. We should see how far we can get with that and also zero copy construction of protobuf Messages backed by direct buffer allocations. Some amount of native code may be required.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12685275">HBASE-10191</key>
            <summary>Move large arena storage off heap</summary>
                <type id="14" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/genericissue.png">Umbrella</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="apurtell">Andrew Purtell</reporter>
                        <labels>
                    </labels>
                <created>Tue, 17 Dec 2013 23:27:32 +0000</created>
                <updated>Fri, 8 Aug 2014 20:04:45 +0000</updated>
                                                                                <due></due>
                            <votes>0</votes>
                                    <watches>43</watches>
                                                                                                            <comments>
                            <comment id="13851145" author="ndimiduk" created="Wed, 18 Dec 2013 00:10:46 +0000"  >&lt;p&gt;Apparently you&apos;re reading my mind &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Nicely articulated &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=apurtell&quot; class=&quot;user-hover&quot; rel=&quot;apurtell&quot;&gt;Andrew Purtell&lt;/a&gt;. I&apos;d like to see a body of evidence that points to specific components which make meaningful sense for moving off-heap. Memstore and BlockCache are commonly cited as the offending components, but I&apos;ve not seen anyone present conclusive profiling results making this clear. Nor is there clear advice regarding at what point a heap becomes too large. I&apos;ve started work to track down some read data here on both of these points before pressing forward with recommendations.&lt;/p&gt;

&lt;p&gt;See also &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=nkeywal&quot; class=&quot;user-hover&quot; rel=&quot;nkeywal&quot;&gt;Nicolas Liochon&lt;/a&gt;&apos;s recent profiling work reducing the GC burden imposed by the protobuf RPC implementation. This is an example where a major offender isn&apos;t on the above short-list. I am excited work toward and experiment with an entirely off-heap data flow, at least for the read path (HDFS -&amp;gt; BlockCache -&amp;gt; RPC send buffer)!&lt;/p&gt;</comment>
                            <comment id="13851148" author="apurtell" created="Wed, 18 Dec 2013 00:17:18 +0000"  >&lt;blockquote&gt;&lt;p&gt;Memstore and BlockCache are commonly cited as the offending components, but I&apos;ve not seen anyone present conclusive profiling results making this clear&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s abundantly clear once using heaps larger than ~8 GB that collection pauses under safepoint blow out latency SLAs at the high percentiles. Why would we need heaps larger than this? To take direct advantage of large server RAM. Memstore and blockcache are then the largest allocators of heap memory. If we move them off heap, they can &quot;soak up&quot; most of the available RAM, leaving remaining heap demand relatively small - this is the idea.&lt;/p&gt;

&lt;p&gt;Edit: Phrasing&lt;/p&gt;</comment>
                            <comment id="13851154" author="vrodionov" created="Wed, 18 Dec 2013 00:26:24 +0000"  >&lt;p&gt;This will require the whole data flow redesign in HBase. Currently, the minimum (and maximum) data exchange element in HBase&apos;s internal pipeline is KeyValue, which is heavy, on-heap (byte array backed) data structure. Moving data allocations to off-heap is a half a problem, another one is how to avoid copy-data-on-read and copy data on write (from/to off heap). Serialization is quite expensive. &lt;/p&gt;</comment>
                            <comment id="13851990" author="vrodionov" created="Wed, 18 Dec 2013 18:25:23 +0000"  >&lt;blockquote&gt;
&lt;p&gt;It&apos;s abundantly clear once using heaps larger than ~8 GB that collection pauses under safepoint blow out latency SLAs at the high percentiles.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What HBase version are you using? No bucket cache yet?&lt;/p&gt;</comment>
                            <comment id="13852031" author="apurtell" created="Wed, 18 Dec 2013 19:07:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;What HBase version are you using? No bucket cache yet?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Trunk, what is now 0.98. &lt;/p&gt;

&lt;p&gt;As you point out above, serialization/deserialization costs limit the bucket cache, which is why I propose the goal of direct operation on allocations backed by off-heap memory. This has to be approached in stages. &lt;/p&gt;

&lt;p&gt;The bucket cache encourages looking at this approach. Although you&apos;ll see reduced throughput, it will smooth out the latency tail and allow the blockcache to address RAM without increasing heap size, which also helps smooth out the latency tail with respect to collection pause distribution. However, using large heaps e.g. 128+ GB mixed generation collections exceeding the ZooKeeper heartbeat timeout are inevitable under mixed read+write load, nothing mitigates that sufficiently that I have found. &lt;/p&gt;</comment>
                            <comment id="13852086" author="vrodionov" created="Wed, 18 Dec 2013 19:46:40 +0000"  >&lt;blockquote&gt;
&lt;p&gt;The bucket cache encourages looking at this approach. Although you&apos;ll see reduced throughput, it will smooth out the latency tail and allow the blockcache to address RAM without increasing heap size, which also helps smooth out the latency tail with respect to collection pause distribution. However, using large heaps e.g. 128+ GB mixed generation collections exceeding the ZooKeeper heartbeat timeout are inevitable under mixed read+write load, nothing mitigates that sufficiently that I have found.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It looks like you have done some bucket cache research and tests. Are there any numbers available? We are considering upgrading to 0.96 release and bucket cache is the major attraction for us. According to you, its not that usable or it does not give any performance advantage?  I really doubt, that 80GB on heap block cache is viable alternative to off heap cache in mixed read/write load scenario even in Java7 with G1. &lt;/p&gt;

&lt;p&gt;One thing to note: having serialization barrier has one huge advantage over direct off heap access. You can compress blocks in off heap. For our application compression ratio is close to 4. &lt;/p&gt;</comment>
                            <comment id="13852093" author="apurtell" created="Wed, 18 Dec 2013 19:57:30 +0000"  >&lt;p&gt;It is on my to do list to produce a technical report, but my time is quite constrained and that item is not close to the top of the list. As always, you should evaluate HBase using your application and environment. You may be quite happy with 0.96, with or without the bucket cache.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;having serialization barrier has one huge advantage over direct off heap access. You can compress blocks in off heap&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s a great point. I would actually like to operate on an encoded block representation from disk to socket. This is a trick in memory databases have been using for years, and will let us push through the memory wall, but that is several steps down a long road. The scope of this JIRA is described in the &apos;Description&apos; field above.&lt;/p&gt;</comment>
                            <comment id="13852328" author="stack" created="Wed, 18 Dec 2013 23:47:01 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=apurtell&quot; class=&quot;user-hover&quot; rel=&quot;apurtell&quot;&gt;Andrew Purtell&lt;/a&gt; There are a couple of off-heap experiments ongoing.  This JIRA covers memstore and blockcache allocations.  Seems like we need a larger umbrella issue than this allows?  If you agree I&apos;ll open one because would be useful be able to tie all effots.  Good on you &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=apurtell&quot; class=&quot;user-hover&quot; rel=&quot;apurtell&quot;&gt;Andrew Purtell&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13852333" author="apurtell" created="Wed, 18 Dec 2013 23:52:09 +0000"  >&lt;p&gt;If you want to reparent this somewhere that&apos;s fine with me &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;. We&apos;re going to start with memstore and blockcache (likely a unified pool) and go from there based on results. If there are other things going on would be good to put them all together so we can try to coordinate.&lt;/p&gt;</comment>
                            <comment id="13852436" author="mcorgan" created="Thu, 19 Dec 2013 01:15:51 +0000"  >&lt;p&gt;Something to keep in mind is that GC pauses can be influenced as much or more by the number of live objects as they can by the raw size of the heap.  32GB of block cache could be made of only 1mm 32KB blocks.  This particular 32GB of memory may not stop the world for very long.  It&apos;s all the small remaining objects that are keeping the garbage collector busy, and I bet the biggest culprit here is the individual KeyValues in the memstores.&lt;/p&gt;

&lt;p&gt;MemstoreLAB combines the backing arrays into big chunks to reduce heap fragmentation, but there is still one object per KeyValue, and each object needs to be considered by the collector.  A big heap has big memstores, which have lots of KeyValues - possibly far more than the 1mm blocks in the block cache.  A big advantage of flattening the memstores into blocks of key values is that you might be reducing ~500 KeyValues to a single block object.  This 500x reduction in objects strikes me as a significant GC pause improvement that is independent from off-heap techniques.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Moving blocks off-heap and operating on them directly will be very cool.  DataBlockEncoders should be able to read off-heap blocks similarly to how they do now, namely, copying only the modified bytes from the previous cell into an array buffer.  Vladimir makes a good point that it would be tough to match the scan performance of unencoded data, so that would need some thinking.&lt;/p&gt;</comment>
                            <comment id="13852645" author="stack" created="Thu, 19 Dec 2013 05:55:05 +0000"  >&lt;p&gt;If we supplied DFSClient our own DBB, then maybe we could read from dfs and put into an offheap blockcache w/o going over the heap (see &lt;a href=&quot;https://issues.apache.org/jira/browse/HDFS-2834&quot; title=&quot;ByteBuffer-based read API for DFSInputStream&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HDFS-2834&quot;&gt;&lt;del&gt;HDFS-2834&lt;/del&gt;&lt;/a&gt; &quot;ByteBuffer-based read API for DFSInputStream&quot;)&lt;/p&gt;</comment>
                            <comment id="13906456" author="apurtell" created="Thu, 20 Feb 2014 01:36:00 +0000"  >&lt;p&gt;I&apos;m looking at Netty 4&apos;s netty-buffer module (&lt;a href=&quot;http://netty.io/4.0/api/io/netty/buffer/package-summary.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://netty.io/4.0/api/io/netty/buffer/package-summary.html&lt;/a&gt;), which has some nice properties, including composite buffers, arena allocation, dynamic buffer resizing, and reference counting, never mind dev and testing by another community. I also like it because you can plug in your own allocators and specialize the abstract ByteBuf base type. More on this later.&lt;/p&gt;

&lt;p&gt;When I get closer to seeing what exactly needs to be done I will post a design doc. Current thinking follows. Below the term &apos;buffer&apos; currently means Netty ByteBufs or derived classes backed by off-heap allocated direct buffers.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Write&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;When coming in from RPC, cells are laid out by codecs into cellbocks in buffers and the cellblocks/buffers are handed to the memstore. Netty&apos;s allocation arenas replace the MemstoreLAB. The memstore data structure evolves into an index over cellblocks.&lt;/p&gt;

&lt;p&gt;Per &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mcorgan&quot; class=&quot;user-hover&quot; rel=&quot;mcorgan&quot;&gt;Matt Corgan&lt;/a&gt;&apos;s comment above, we should think about how the memstore index can be built with fewer object allocations than the number of cells in the memstore, yet be in the ballpark with efficiency of concurrent access. A tall order. CSLM wouldn&apos;t be the right choice as it allocates at least one list entry per key, but we could punt and use it initially and make a replacement datastructure as a follow on task.&lt;/p&gt;

&lt;p&gt;Cellblocks in memstore should be amenable to flushing to disk as a gathering write. This may mean cellblocks have the same internal structure as HFile blocks and we reuse all of the block encoder machinery (and simplify them in the process).&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Read&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;We feed down buffers to HDFS to fill with file block data. We pick which pool to get a buffer from for a read depending on family caching strategy. Pools could be backed by arenas that match up with LRU policy strata, with a common pool/arena for noncaching reads. (Or for noncaching reads, can we optionally use a new API for getting buffers up from HDFS, perhaps backed by the pinned shared RAM cache, since we know we will be referring to the contents only briefly?) It will be important to get reference counting right as we will be servicing scans while attempting to evict. Related, eviction of a block may not immediately return a buffer to a pool, if there is more than one block in a buffer.&lt;/p&gt;

&lt;p&gt;We maintain new metrics on numbers of buffers allocated, stats on arenas, stats on wastage and internal fragmentation of the buffers, etc, and use these to guide optimizations and refinements.&lt;/p&gt;

&lt;p&gt;This should require fewer changes than the write side since we are already set up for dealing with cellblocks. Design points to optimize would be minimizing the number and size of data copies, minimizing the number of on-heap object allocations, and on disk encoding suitable as an efficient in-memory representation.&lt;/p&gt;</comment>
                            <comment id="13906599" author="lhofhansl" created="Thu, 20 Feb 2014 04:38:31 +0000"  >&lt;p&gt;My office neighbor used to work on a proprietary Java database, and he says they used 128GB or even 192GB Java heaps and larger all the time without any significant GC impact.&lt;/p&gt;

&lt;p&gt;(non moving) Collection times are not a function of the heap size but rather of heap complexity, i.e. the number of objects to track (HBase also produces a lot of garbage, but that is short lived and can be quickly collected by a moving collector for the young gen).&lt;br/&gt;
With memstoreLAB and the block cache HBase already does a good job on this. Even as is currently, if we fill an entire 128GB of heap with 64k blocks from the blockcache that would only be about 2m objects.&lt;br/&gt;
Now, if we want &amp;lt; 100ms latency area we need to rethink things; that will generally be very difficult in current Java.&lt;/p&gt;

&lt;p&gt;While we move all-or-nothing everything out of the Java heap, we should also investigate whether we can make the GC&apos;s life easier, yet.&lt;/p&gt;

&lt;p&gt;Edit: Edited for clarity.&lt;/p&gt;</comment>
                            <comment id="13906612" author="apurtell" created="Thu, 20 Feb 2014 05:02:34 +0000"  >&lt;p&gt;I intend to prototype something so we don&apos;t have to argue supposition. &lt;/p&gt;

&lt;p&gt;Yes enabling sub 100 ms collections at 95th or 99th is an important consideration. We also want to consider addressing up 1 TB of usable memory without loading up cores with redundant work / multiple processes. &lt;/p&gt;

&lt;p&gt;Some GC overheads are a linear function of the heap size, at least for G1. &lt;/p&gt;</comment>
                            <comment id="13906682" author="lhofhansl" created="Thu, 20 Feb 2014 06:52:38 +0000"  >&lt;p&gt;Yeah, was talking about CMS and definitely less than 1TB.&lt;/p&gt;

&lt;p&gt;Please do not read my comment as criticism, this is very important work.&lt;br/&gt;
No doubt you can drive max latency down significantly by going off heap, at the same time are probably a lot of further improvement we make to current HBase in the heap allocation area.&lt;/p&gt;</comment>
                            <comment id="13907299" author="vrodionov" created="Thu, 20 Feb 2014 18:44:21 +0000"  >&lt;blockquote&gt;
&lt;p&gt;We also want to consider addressing up 1 TB of usable memory without loading up cores with redundant work / multiple processes. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;6TB of RAM. &lt;br/&gt;
&lt;a href=&quot;http://www.supermicro.nl/newsroom/pressreleases/2014/press140218_4U_4-Way.cfm&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.supermicro.nl/newsroom/pressreleases/2014/press140218_4U_4-Way.cfm&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Collection times are not a function of the heap size but rather of heap complexity, i.e. the number of objects to track &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Heap compaction is a function of a heap size (at least in CMS).&lt;/p&gt;</comment>
                            <comment id="13907889" author="lhofhansl" created="Fri, 21 Feb 2014 02:38:13 +0000"  >&lt;blockquote&gt;&lt;p&gt;Heap compaction is a function of a heap size (at least in CMS).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not to start a long, tangential argument here... Last I looked CMS was non-compacting, and thus the only relevant metric is the number of objects to trace, not their size. A 100G heap with 10000 objects is far easier to manage than a 100G heap with 100 million objects.&lt;/p&gt;</comment>
                            <comment id="13907925" author="vrodionov" created="Fri, 21 Feb 2014 03:39:26 +0000"  >&lt;p&gt;Right, CMS is not compacting but, nevertheless, compaction happens from time to time (Full GC) and it is a function of a heap size.&lt;/p&gt;</comment>
                            <comment id="13907967" author="lhofhansl" created="Fri, 21 Feb 2014 05:00:37 +0000"  >&lt;p&gt;(not if all objects are of roughly the same size then you will never need a full GC)&lt;/p&gt;

&lt;p&gt;In any case, nobody is arguing (at least I am not) that 1T or more (6T? Wow) should be managed off-heap with contemporary Hotspot JVMs. I&apos;m looking forward to what Andrew and folks will produce here.&lt;/p&gt;</comment>
                            <comment id="13908002" author="mcorgan" created="Fri, 21 Feb 2014 06:14:20 +0000"  >&lt;p&gt;I hate to continue the tangent, but I&apos;d add that even the occasional compaction that CMS triggers is dependent on how many objects need to be compacted.  It&apos;s because &quot;random&quot; access memory isn&apos;t as random anymore because there are enormous speed boosts when copying long swaths of sequential memory.  So compacting 100 1GB slabs should be far faster than compacting 1 billion 100B KeyValues that are scattered around the heap.  I also wonder if there&apos;s a slab size big enough that hotspot won&apos;t bother moving it during a compaction (but i have no idea).&lt;/p&gt;

&lt;p&gt;Separately, one of the reasons Nick and I thought ByteRange should be an interface was that we could back it with varying implementations including arrays, HeapByteBuffers, DirectByteBuffers, netty ByteBufs, etc.  A utility similar to IOUtils.copy could help optimizing the copies between the different implementations.  Another advantage of using it as the primary interface is that its internal compareTo method uses hbase-friendly unsigned byte comparison, making it easy to put ByteRanges into traditional sorted collections like TreeSet/CSLM without passing an external comparator.&lt;/p&gt;

&lt;p&gt;I could see using an allocator based on huge on or off-heap slabs where smaller pages/blocks are referenced by reusable ByteRanges.  The allocator could recycle memory by continuously picking the least utilized slab and copying (moving) its occupied ByteRanges to the slab at the head of the queue.  This would provide constant compaction via fast sequential copying.&lt;/p&gt;</comment>
                            <comment id="13909235" author="stack" created="Sat, 22 Feb 2014 04:41:48 +0000"  >&lt;p&gt;(Good discussion going on here)&lt;/p&gt;

&lt;p&gt;How then to have KeyValues/Cells w/o calling them out as individual objects?  Keep cellblocks of KeyValues/Cells w/ a CellScanner to read over 64k blocks of them?   For MemStore, once we hit some upper bound &amp;#8211; say 64k, 1M? &amp;#8211; &apos;flush&apos; it to an inmemory, sorted, cellblock?  Reading, we&apos;d consult the (small) CSLM memstore and some tiering of cellblocks?&lt;/p&gt;</comment>
                            <comment id="13909242" author="lhofhansl" created="Sat, 22 Feb 2014 04:58:42 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5311&quot; title=&quot;Allow inmemory Memstore compactions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5311&quot;&gt;HBASE-5311&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-9440&quot; title=&quot;Pass blocks of KVs from HFile scanner to the StoreFileScanner and up&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-9440&quot;&gt;HBASE-9440&lt;/a&gt; have related discussion. If we&apos;re smart we can build all these things such that they work on- and off heap.&lt;/p&gt;</comment>
                            <comment id="13917352" author="apurtell" created="Sun, 2 Mar 2014 10:29:12 +0000"  >&lt;blockquote&gt;&lt;p&gt;(Matt Corgan) I could see using an allocator based on huge on or off-heap slabs where smaller pages/blocks are referenced by reusable ByteRanges. The allocator could recycle memory by continuously picking the least utilized slab and copying (moving) its occupied ByteRanges to the slab at the head of the queue. This would provide constant compaction via fast sequential copying.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We could make the investment of writing our own slab allocator. Experiments with Netty 4 ByteBufs are in part about seeing if we can re-use open source in production already rather than redo the work. On the other hand, it could be a crucial component so maybe it&apos;s necessary to have complete control. Perhaps we can move additional comments on this sub-topic over to &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10573&quot; title=&quot;Use Netty 4&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10573&quot;&gt;&lt;del&gt;HBASE-10573&lt;/del&gt;&lt;/a&gt;?&lt;/p&gt;</comment>
                            <comment id="13917682" author="mcorgan" created="Mon, 3 Mar 2014 01:58:48 +0000"  >&lt;p&gt;&lt;blockquote&gt;&lt;p&gt;How then to have KeyValues/Cells w/o calling them out as individual objects? ....  For MemStore, once we hit some upper bound &#8211; say 64k, 1M? &#8211; &apos;flush&apos; it to an inmemory, sorted, cellblock? Reading, we&apos;d consult the (small) CSLM memstore and some tiering of cellblocks?&lt;/p&gt;&lt;/blockquote&gt;I think there&apos;s been talk of this before, and it makes sense to me.  It&apos;s basically creating small in-memory HFiles that can be compacted several times in memory without going to disk, and holding on to the WAL entries until they do go to disk.  We&apos;d get huge space savings from reduction in objects, references, and repetition via block encoding.  The problem is that if you have hundreds of 1MB in-memory HFiles, then it becomes too expensive to merge them all (via KVHeap) when scanning.  A possible solution is to subdivide the memstore into &quot;stripes&quot; (probably smaller than the stripe compaction stripes) and periodically compact the in-memory stripes.  It sounds complicated compared to the current memstore, but it&apos;s probably simpler than other parts of hbase because you don&apos;t have to deal with IOExceptions, retries, etc.&lt;/p&gt;</comment>
                            <comment id="13917703" author="apurtell" created="Mon, 3 Mar 2014 02:55:06 +0000"  >&lt;blockquote&gt;&lt;p&gt;The problem is that if you have hundreds of 1MB in-memory HFiles, then it becomes too expensive to merge them all (via KVHeap) when scanning. A possible solution is to subdivide the memstore into &quot;stripes&quot; (probably smaller than the stripe compaction stripes) and periodically compact the in-memory stripes&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Anoop, Ram, and I were throwing around ideas of making in-memory HFiles out of memstore snapshots, and then doing in-memory compaction over them. If we have off-heap backing for memstore we could potentially carry larger snapshots (in memory HFiles resulting from a few merged memstore snapshots) leading to less frequent flushes and significantly less write amplification overall. &lt;/p&gt;</comment>
                            <comment id="13918407" author="stack" created="Mon, 3 Mar 2014 18:46:18 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mcorgan&quot; class=&quot;user-hover&quot; rel=&quot;mcorgan&quot;&gt;Matt Corgan&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It&apos;s basically creating small in-memory HFiles that can be compacted several times in memory without going to disk, and holding on to the WAL entries until they do go to disk.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Pardon dumb questions, &quot;creating small in-memory HFiles...&quot;  &amp;#8211; from a small CSLM that does the sort for us?  Or, I remember talking to Martin Thompson once trying to ask how  he&apos;d go about the MemStore &apos;problem&apos; and I&apos;m sure he didn&apos;t follow what I was on about (I was doing a crappy job explaining I&apos;m sure),, but other than his usual adage of try everything and measure, he suggested just trying a sort on the fly... Are you thinking the same Matt?  So we&apos;d keep around Cells and then once we had a batch or if after some nanos had elapsed, we&apos;d do a merge sort w/ current set of in-memory edits and then put in place the new sorted &apos;in-memory-hfile&apos; and up the mvcc read point so it was readable?  Once they got to a certain size we&apos;d do like we do now with snapshot and start up a new foreground set of edits to merge into?&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;...and holding on to the WAL entries until they do go to disk&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What you thinking here?  Would be good if the WAL system was not related to the MemStore system (though chatting w/ &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=liyin&quot; class=&quot;user-hover&quot; rel=&quot;liyin&quot;&gt;Liyin Tang&lt;/a&gt; recently, he had an idea that would make the WAL sync more &apos;live&apos; if WAL sync updated mvcc (mvcc and seqid being tied).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Anoop, Ram, and I were throwing around ideas of making in-memory HFiles out of memstore snapshots....&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Would be sweet if the value at least was not on heap....   Sounds like nice experiment Andrew.&lt;/p&gt;

</comment>
                            <comment id="13918632" author="mcorgan" created="Mon, 3 Mar 2014 22:06:43 +0000"  >&lt;p&gt;&lt;blockquote&gt;&lt;p&gt;&quot;creating small in-memory HFiles...&quot; &#8211; from a small CSLM that does the sort for us?&lt;/p&gt;&lt;/blockquote&gt;yes, that is all i meant.  The CSLM would remain small because it gets flushed more often.  I don&apos;t doubt there are better ways to do it than the CSLM (like the deferred sorting you mention), but even just shrinking the size of the CSLM would be an improvement without having to re-think the memstore&apos;s concurrency mechanisms.&lt;/p&gt;

&lt;p&gt;Let&apos;s say you have a 500MB memstore limit, and that encodes (not compresses) to 100MB.  You could:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;split it into 10 stripes, each with ~50MB limit, and flush each of the 10 stripes (to memory) individually
	&lt;ul&gt;
		&lt;li&gt;you probably have a performance boost already because 10 50MB CSLMs is better than 1 500MB CSLM&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;for a given stripe, flush the CSLM each time it reaches 25MB, which will spit out 5MB encoded &quot;memory hfile&quot; to the off-heap storage&lt;/li&gt;
	&lt;li&gt;optionally compact a stripe&apos;s &quot;memory hfiles&quot; in the background to increase read performance&lt;/li&gt;
	&lt;li&gt;when a stripe has 25MB CSLM + 5 encoded snapshots, flush/compact the whole thing to disk&lt;/li&gt;
	&lt;li&gt;&quot;release&quot; the WAL entries for the stripe&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;On the WAL entries, i was just pointing out that you can no longer release the WAL entries when you flush the CSLM.  You have to hold on to the WAL entries until you flush the &quot;memory hfiles&quot; to disk.&lt;/p&gt;</comment>
                            <comment id="13920599" author="ram_krish" created="Wed, 5 Mar 2014 07:17:16 +0000"  >&lt;blockquote&gt;&lt;p&gt;Would be sweet if the value at least was not on heap&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, this could be a nice one. So I think before doing this the usage of Cell should be in place.&lt;/p&gt;
{Got added by mistake.}</comment>
                            <comment id="13925530" author="carp84" created="Mon, 10 Mar 2014 07:57:30 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mcorgan&quot; class=&quot;user-hover&quot; rel=&quot;mcorgan&quot;&gt;Matt Corgan&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;I find you ever had a discussion long ago in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3484&quot; title=&quot;Replace memstore&amp;#39;s ConcurrentSkipListMap with our own implementation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3484&quot;&gt;HBASE-3484&lt;/a&gt; (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3484?focusedCommentId=13410934&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13410934&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;here&lt;/a&gt;), but it seems no further progress since then. And &lt;span class=&quot;error&quot;&gt;&amp;#91;~mcorban&amp;#93;&lt;/span&gt; I find you have more detailed design thought now according to your above comment, so I&apos;m wondering whether you have done some real work to implement this design? Or any plan?&lt;/p&gt;

&lt;p&gt;Actually I think the design you proposed is kind of different from the JIRA topic here or in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3484&quot; title=&quot;Replace memstore&amp;#39;s ConcurrentSkipListMap with our own implementation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3484&quot;&gt;HBASE-3484&lt;/a&gt;, since it&apos;s more like an in-memory-flush to reduce memory fragmentation rather than &quot;move off heap&quot;. I&apos;m wondering whether it would be better to open another JIRA to make the discussion more explicit, while leaving the &quot;off heap&quot; discussion here?&lt;/p&gt;

&lt;p&gt;I&apos;ve been watching this thread or say this topic for some while and now we&apos;ve decided to do similar improvement to our online hbase service here, so I&apos;d really like to work together with community to complete the design and implementation of the &quot;in-memory-flush&quot; stuff. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I&apos;m totally new face here in this discussion, so please kindly forgive me if I&apos;ve stated anything naive. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13925606" author="anoop.hbase" created="Mon, 10 Mar 2014 09:52:17 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=carp84&quot; class=&quot;user-hover&quot; rel=&quot;carp84&quot;&gt;Yu Li&lt;/a&gt;  I am working on this stuff of CellBlocks.  (Yes in memory flushes) Coding wise mostly it is done and will do perf tests also.  Some time I had worked in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3484&quot; title=&quot;Replace memstore&amp;#39;s ConcurrentSkipListMap with our own implementation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3484&quot;&gt;HBASE-3484&lt;/a&gt; but later dropped.  Ya here along with Off heap , the discussion of CellBlocks also came in.  This can greatly reduce the issue we face today with CSLM (When there are too many KVs in it).  We are parallely working on the Off heap stuff also. My code is like in a combined form now. Let me seperate it out.  Also see &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10648&quot; title=&quot;Pluggable Memstore&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10648&quot;&gt;&lt;del&gt;HBASE-10648&lt;/del&gt;&lt;/a&gt; which will allow us to have different MemStore impls.&lt;/p&gt;</comment>
                            <comment id="13925850" author="mcorgan" created="Mon, 10 Mar 2014 16:21:05 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=carp84&quot; class=&quot;user-hover&quot; rel=&quot;carp84&quot;&gt;Yu Li&lt;/a&gt; you&apos;re right, flushing the memstore to memory is a separate issue than off-heap storage, but it&apos;s important to mention here so off-heap storage can be designed to support it.  My comments about splitting the memstore into stripes could also be a separate issue since it&apos;s just an improvement that saves you some in-memory compaction work on non-uniform data distributions.&lt;/p&gt;</comment>
                            <comment id="13925855" author="carp84" created="Mon, 10 Mar 2014 16:26:10 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;Thanks for the info, really good to know the progress, I almost started to do the impl by myself. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; It&apos;s also great to see the patch of making MemStore impls pluggable almost ready. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;My code is like in a combined form now. Let me seperate it out.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I guess the code changes about CellBlocks would base on &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10648&quot; title=&quot;Pluggable Memstore&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10648&quot;&gt;&lt;del&gt;HBASE-10648&lt;/del&gt;&lt;/a&gt;? I searched but found no seperate JIRA for this CellBlocks impl, would you create one after separating the code out? Really cannot wait to take a look at it. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13925861" author="carp84" created="Mon, 10 Mar 2014 16:32:41 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mcorgan&quot; class=&quot;user-hover&quot; rel=&quot;mcorgan&quot;&gt;Matt Corgan&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;Got it, thanks for the explanation &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13925889" author="anoop.hbase" created="Mon, 10 Mar 2014 16:55:42 +0000"  >&lt;blockquote&gt;&lt;p&gt;would you create one &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10713&quot; title=&quot;A MemStore implementation with in memory flushes to CellBlocks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10713&quot;&gt;&lt;del&gt;HBASE-10713&lt;/del&gt;&lt;/a&gt;.  Will come up with patch soon. Welcome ur suggestions.  Pls keep all such discussions under this new jira issue&lt;/p&gt;</comment>
                            <comment id="13944209" author="apurtell" created="Sat, 22 Mar 2014 19:56:54 +0000"  >&lt;p&gt;Just for documentary purposes at this point, since the implementation is early and has a long way to go, but RedHat recently announced ongoing work on a new GC called Shenandoah, with the stated goals &quot;Reduce GC pause times on extremely large heaps by doing evacuation work concurrently with Java threads and making pause times independent of heap size.&quot;. &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;JEP: &lt;a href=&quot;http://openjdk.java.net/jeps/189&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://openjdk.java.net/jeps/189&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;Project: &lt;a href=&quot;http://icedtea.classpath.org/shenandoah/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://icedtea.classpath.org/shenandoah/&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;Source: &lt;a href=&quot;http://icedtea.classpath.org/hg/shenandoah&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://icedtea.classpath.org/hg/shenandoah&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12721207">HBASE-11351</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12699803">HBASE-10713</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12701842">HBASE-10771</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12732878">HBASE-11710</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12689118">HBASE-10353</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12540674">HBASE-5311</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12728339">HDFS-6709</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12666404">HBASE-9399</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12674359">HBASE-9794</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12685483">HBASE-10204</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                            <subtask id="12698100">HBASE-10648</subtask>
                            <subtask id="12700634">HBASE-10719</subtask>
                            <subtask id="12701449">HBASE-10750</subtask>
                            <subtask id="12701877">HBASE-10772</subtask>
                            <subtask id="12701878">HBASE-10773</subtask>
                            <subtask id="12696134">HBASE-10573</subtask>
                            <subtask id="12698350">HBASE-10655</subtask>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 18 Dec 2013 00:10:46 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>364352</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            2 years, 38 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1qsvz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>364652</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>