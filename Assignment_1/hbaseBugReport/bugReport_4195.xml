<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:16:44 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-4195/HBASE-4195.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-4195] Possible inconsistency in a memstore read after a reseek, possible performance improvement</title>
                <link>https://issues.apache.org/jira/browse/HBASE-4195</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;This follows the dicussion around &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3855&quot; title=&quot;Performance degradation of memstore because reseek is linear&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3855&quot;&gt;&lt;del&gt;HBASE-3855&lt;/del&gt;&lt;/a&gt;, and the random errors (20% failure on trunk) on the unit test org.apache.hadoop.hbase.regionserver.TestHRegion.testWritesWhileGetting&lt;/p&gt;

&lt;p&gt;I saw some points related to numIterReseek, used in the MemStoreScanner#getNext (line 690):&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;679	    protected KeyValue getNext(Iterator it) {
680	      KeyValue ret = null;
681	      long readPoint = ReadWriteConsistencyControl.getThreadReadPoint();
682	      //DebugPrint.println( &quot; MS@&quot; + hashCode() + &quot;: threadpoint = &quot; + readPoint);
683	 
684	      while (ret == null &amp;amp;&amp;amp; it.hasNext()) {
685	        KeyValue v = it.next();
686	        if (v.getMemstoreTS() &amp;lt;= readPoint) {
687	          // keep it.
688	          ret = v;
689	        }
690	        numIterReseek--;
691	        if (numIterReseek == 0) {
692	          break;
693	         }
694	      }
695	      return ret;
696	    }&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This function is called by seek, reseek, and next. The numIterReseek is only usefull for reseek.&lt;/p&gt;

&lt;p&gt;There are some issues, I am not totally sure it&apos;s the root cause of the test case error, but it could explain partly the randomness of the error, and one point is for sure a bug.&lt;/p&gt;

&lt;p&gt;1) In getNext, numIterReseek is decreased, then compared to zero. The seek function sets numIterReseek to zero before calling getNext. It means that the value will be actually negative, hence the test will always fail, and the loop will continue. It is the expected behaviour, but it&apos;s quite smart.&lt;/p&gt;

&lt;p&gt;2) In &quot;reseek&quot;, numIterReseek is not set between the loops on the two iterators. If the numIterReseek is equals to zero after the loop on the first one, the loop on the second one will never call seek, as numIterReseek will be negative.&lt;/p&gt;

&lt;p&gt;3) Still in &quot;reseek&quot;, the test to call &quot;seek&quot; is (kvsetNextRow == null &amp;amp;&amp;amp; numIterReseek == 0). In other words, if kvsetNextRow is not null when numIterReseek equals zero, numIterReseek will start to be negative at the next iteration and seek will never be called.&lt;/p&gt;

&lt;p&gt;4) You can have side effects if reseek ends with a numIterReseek &amp;gt; 0: the following calls to the &quot;next&quot; function will decrease numIterReseek to zero, and getNext will break instead of continuing the loop. As a result, later calls to next() may return null or not depending on how is configured the default value for numIterReseek.&lt;/p&gt;

&lt;p&gt;To check if the issue comes from point 4, you can set the numIterReseek to zero before returning in reseek:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;      numIterReseek = 0;
      return (kvsetNextRow != null || snapshotNextRow != null);
    }&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;On my env, on trunk, it seems to work, but as it&apos;s random I am not really sure. I also had to modify the test (I added a loop) to make it fails more often, the original test was working quite well here.&lt;/p&gt;

&lt;p&gt;It has to be confirmed that this totally fix (it could be partial or unrelated) org.apache.hadoop.hbase.regionserver.TestHRegion.testWritesWhileGetting before implementing a complete solution.&lt;/p&gt;</description>
                <environment>&lt;p&gt;all&lt;/p&gt;</environment>
        <key id="12518654">HBASE-4195</key>
            <summary>Possible inconsistency in a memstore read after a reseek, possible performance improvement</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.png">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="nkeywal">Nicolas Liochon</assignee>
                                    <reporter username="nkeywal">Nicolas Liochon</reporter>
                        <labels>
                    </labels>
                <created>Thu, 11 Aug 2011 22:17:40 +0000</created>
                <updated>Fri, 20 Nov 2015 11:53:30 +0000</updated>
                            <resolved>Fri, 16 Sep 2011 19:39:14 +0000</resolved>
                                    <version>0.90.4</version>
                                    <fixVersion>0.92.0</fixVersion>
                                    <component>regionserver</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                <comments>
                            <comment id="13083808" author="nkeywal" created="Thu, 11 Aug 2011 23:33:18 +0000"  >&lt;p&gt;FWIW, I also tried to change reseek to call &quot;seek&quot; all the time, but I have strange results (i.e. errors). I don&apos;t know if we can swap a loop of &quot;next&quot; with a single call to seek.Here is the implementation I tried;&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    public boolean reseek(KeyValue key) {
      return seek(key);
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But the test case fails (randomly). So there could be more than one issue.&lt;/p&gt;</comment>
                            <comment id="13084160" author="nkeywal" created="Fri, 12 Aug 2011 14:48:21 +0000"  >&lt;p&gt;The issue with the implementation calling only seek is that we can see &quot;writes in progress&quot;. From my understanding, it should not be the case (and at least, if it&apos;s allowed, there is an issue in the test case itself).&lt;/p&gt;

&lt;p&gt;The error is this assert: Assert.assertEquals(&quot;i=&quot; + i, expectedCount, result.size());, that&apos;s different from the one mentionned in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3855&quot; title=&quot;Performance degradation of memstore because reseek is linear&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3855&quot;&gt;&lt;del&gt;HBASE-3855&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;


&lt;p&gt;If I change the reseek implementation to something that does no call seek at all, like:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    public boolean reseek(KeyValue key) {
      while (kvsetNextRow != null &amp;amp;&amp;amp;
        comparator.compare(kvsetNextRow, key) &amp;lt; 0) {
        kvsetNextRow = getNext(kvsetIt);
      }

      while (snapshotNextRow != null &amp;amp;&amp;amp;
        comparator.compare(snapshotNextRow, key) &amp;lt; 0) {
        snapshotNextRow = getNext(snapshotIt);
      }

      numIterReseek = 0;
      return (kvsetNextRow != null || snapshotNextRow != null);
    }&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;The whole test works fine. So it seems the issue really comes from using seek. The current implementation should have the same issue I think. May be we don&apos;t see it often (or at all) because seek is not called that often because of the points mentionned in 2 &amp;amp; 3 in the analysis above.&lt;/p&gt;

&lt;p&gt;Can someone confirm that we should not see partial writes in this case?&lt;/p&gt;
</comment>
                            <comment id="13084390" author="yuzhihong@gmail.com" created="Fri, 12 Aug 2011 21:21:21 +0000"  >&lt;p&gt;I think the feature of reseek() selectively calling seek() should be governed by a config parameter until total understanding of the intricacies is reached.&lt;/p&gt;</comment>
                            <comment id="13084444" author="nkeywal" created="Fri, 12 Aug 2011 22:59:40 +0000"  >&lt;p&gt;With the current implementation, setting the config RESEEKMAX_KEY to -1 (read with conf.getInt(RESEEKMAX_KEY, RESEEKMAX_DEFAULT)&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; will have this effect. disclaimer: i did not test it.&lt;/p&gt;</comment>
                            <comment id="13084521" author="yuzhihong@gmail.com" created="Sat, 13 Aug 2011 03:14:24 +0000"  >&lt;p&gt;I think that will do the trick.&lt;br/&gt;
I propose setting RESEEKMAX_DEFAULT to -1.&lt;/p&gt;</comment>
                            <comment id="13085122" author="nkeywal" created="Mon, 15 Aug 2011 15:27:23 +0000"  >&lt;p&gt;Do you want me do write the patch?&lt;/p&gt;

&lt;p&gt;You confirm that we should not see a partial write?&lt;/p&gt;</comment>
                            <comment id="13086030" author="stack" created="Tue, 16 Aug 2011 23:05:14 +0000"  >&lt;blockquote&gt;&lt;p&gt;Can someone confirm that we should not see partial writes in this case?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If we are seeing partial writes then we are not paying attention to RWCC sequence numbers properly.  The refactored reseek is probably how the code was before hbase-3855 (I didn&apos;t check) and that code was around when RWCC was being worked out is my guess... so it probably &apos;worked&apos; (not seeing parital writes).  The new patch adding seeks may not be watching RWCC properly.&lt;/p&gt;

&lt;p&gt;You&apos;ve done some nice analysis above N.  Any chance of your seeing it home?  I will run my dumb TestHRegion test if you have any patch you&apos;d like me to try.&lt;/p&gt;
</comment>
                            <comment id="13086111" author="yuzhihong@gmail.com" created="Wed, 17 Aug 2011 04:01:38 +0000"  >&lt;p&gt;TestHRegion.testWritesWhileGetting failed in build 266:&lt;br/&gt;
&lt;a href=&quot;https://builds.apache.org/view/G-L/view/HBase/job/hbase-0.90/lastCompletedBuild/testReport/org.apache.hadoop.hbase.regionserver/TestHRegion/testWritesWhileGetting/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/view/G-L/view/HBase/job/hbase-0.90/lastCompletedBuild/testReport/org.apache.hadoop.hbase.regionserver/TestHRegion/testWritesWhileGetting/&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13086358" author="nkeywal" created="Wed, 17 Aug 2011 14:48:36 +0000"  >&lt;p&gt;I can do a simple patch (removing all the code around numIterReseek). However, it would conflict with the patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4188&quot; title=&quot;c&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4188&quot;&gt;&lt;del&gt;HBASE-4188&lt;/del&gt;&lt;/a&gt;/&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1938&quot; title=&quot;Make in-memory table scanning faster&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1938&quot;&gt;&lt;del&gt;HBASE-1938&lt;/del&gt;&lt;/a&gt;. Is it possible for you to commit this one first? &lt;/p&gt;

&lt;p&gt;Note that I have been able to make this reseek implementation fails as well by adding a Thread.sleep between the search on the two iterators. In other words, there is a race condition somewhere. It could be a conflict with the &quot;flush&quot; process. I noticed that a flush cannot happen during a put (lock on hregion.update) or a seek (lock on store), but there is nothing to prevent a reseek to take place during the snapshot. But I don&apos;t how long it will take to find the real issue behind all this, so a partial fix lowering the probability of having an issue makes sense...&lt;/p&gt;</comment>
                            <comment id="13089407" author="nkeywal" created="Tue, 23 Aug 2011 11:55:14 +0000"  >&lt;p&gt;Update: I have two other scenarios for failure, both linked to flush occuring during a get.&lt;/p&gt;

&lt;p&gt;1) With the current/optimized implementation of reseek, the set snapshot and kvset can be changed by the thread doing the flush right in the middle of the reseek. This will lead to an unconsistant state.&lt;/p&gt;

&lt;p&gt;A second effect of the flush process creating a new kvset is that the latter writes may not be seen by the MemStore scanner, as it will still be connected to the previous kvset.&lt;/p&gt;

&lt;p&gt;2) More important, and actually not linked to the reseek optimization itself, the following scenario will lead to see a write on multiple families as non atomic.&lt;/p&gt;

&lt;p&gt;t1 : put, it finishes at t2. Write a single row with multiple families.&lt;br/&gt;
t3 : get starts, it finishes at t9&lt;br/&gt;
t4 : the get continues, reads the value for the first family (scanner)&lt;br/&gt;
t5 : put, it finishes at t6. Change the values of the row previously written.&lt;br/&gt;
t7 : flush start,  it finishes at t8. &lt;br/&gt;
t9 : the get  continues, reads the value for the second family (scanner) from the FileScanner&lt;br/&gt;
t10: get finishes&lt;/p&gt;

&lt;p&gt;In this case, the get will have the values of the first write for the first families, and the value of the second write for the last families.&lt;/p&gt;

&lt;p&gt;This is due to the fact that the flush process create a file, and notifies the scanners. The scanners then refreshes their view. The notification is &quot;java synchronized&quot; with the next in the StoreFileScanner, so it does not happen during a scan within a family, but it occurs between the families within a read, as there is one scanner per family. If you add a read lock in the next() (on HRegion.updatelock), the problem does not occur, as the flush will not take place during a read.&lt;/p&gt;

&lt;p&gt;As it&apos;s a random bug, there can be other scenarios. In my environnement, when there is a failure:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;it&apos;s always with a KV with a memstoreTS equals to 0&lt;/li&gt;
	&lt;li&gt;the column is always &quot;qual1&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;As said, this second is actually not linked to the modifications on &quot;MemStoreScanner#reseek&quot;, but is linked to the flush/get parallel execution. I would tend to think that the issue happens in production as well.&lt;/p&gt;</comment>
                            <comment id="13089798" author="stack" created="Tue, 23 Aug 2011 21:52:36 +0000"  >&lt;p&gt;#2 above looks like &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2856&quot; title=&quot;TestAcidGuarantee broken on trunk &quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2856&quot;&gt;&lt;del&gt;HBASE-2856&lt;/del&gt;&lt;/a&gt; (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2856&quot; title=&quot;TestAcidGuarantee broken on trunk &quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2856&quot;&gt;&lt;del&gt;HBASE-2856&lt;/del&gt;&lt;/a&gt; is a long issue but skim it and I think you&apos;ll find it what you describe here &amp;#8211; Amit is working on this one; we chatted at the hackathon yesterday on the issue).&lt;/p&gt;

&lt;p&gt;#1 sounds bad; should we back out the reseek?&lt;/p&gt;</comment>
                            <comment id="13089856" author="nkeywal" created="Tue, 23 Aug 2011 23:08:22 +0000"  >&lt;p&gt;For #2, yes, it seems that &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2856&quot; title=&quot;TestAcidGuarantee broken on trunk &quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2856&quot;&gt;&lt;del&gt;HBASE-2856&lt;/del&gt;&lt;/a&gt; is addressing this type of issues. Problem solved then &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;For #1, note that the previous implementation will completly ignore the modifications made during the flush: the flush creates a new KV List (kvset), and this list is not seen by the MemScanner, as it uses the previous iterator. I don&apos;t know if it&apos;s an issue or not.&lt;/p&gt;

&lt;p&gt;This said, I believe it&apos;s possible to have an implementation with the same properties as the previous one, with an optimized reseek time, by keeping the pointers to the sublists in the MemStoreScanner. The &quot;reseek&quot; implementation would then become very similar to the &quot;seek&quot; one. I tested this approach, it seems to work functionally as the previous one (i.e. I fail in the case #2 mentionned above). I have not tested the reality of performance improvement, but if there is an aggreement on this approach, I can do it.&lt;/p&gt;

&lt;p&gt;The implementation of reseek would be:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    public synchronized boolean reseek(KeyValue key) {
        // kvset and snapshot will never be empty.
        // if tailSet cant find anything, SS is empty (not null).
        kvTail = kvTail.tailSet(key, true);
        snapshotTail = snapshotTail.tailSet(key, true);

        kvsetIt = kvTail.iterator();
        snapshotIt = snapshotTail.iterator();
        
        kvsetNextRow = getNext(kvsetIt);
        snapshotNextRow = getNext(snapshotIt);

        KeyValue lowest = getLowest();

        // has data := (lowest != null)
        return lowest != null;
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13090040" author="stack" created="Wed, 24 Aug 2011 07:09:26 +0000"  >&lt;blockquote&gt;&lt;p&gt;Problem solved then&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ehh... not exactly (smile)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;For #1, note that the previous implementation will completly ignore the modifications made during the flush: the flush creates a new KV List (kvset), and this list is not seen by the MemScanner, as it uses the previous iterator. I don&apos;t know if it&apos;s an issue or not.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is what we want, right?  A consistent view across the flush; definitely not part of &apos;snapshot&apos; only.&lt;/p&gt;

&lt;p&gt;Your suggested fix sounds good (we&apos;ll keep iterators on whatever the sets were when scan started in spite of a flush coming in midway through the scan?)&lt;/p&gt;</comment>
                            <comment id="13090073" author="nkeywal" created="Wed, 24 Aug 2011 08:01:29 +0000"  >&lt;p&gt;The behavior we have with the previous (or with the one I propose)&lt;br/&gt;
implementation is:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;before the flush, the MemScanner iterator points on the KV Lists of the&lt;br/&gt;
MemStore. So the &quot;put&quot; on the MemStore.kvset will be seen by the scanner.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;The flush does:&lt;br/&gt;
snapshot = kvset;&lt;br/&gt;
kvset = new SkipList();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;So after the flush, the &quot;put&quot; will be made on the new Memstore.kvset,&lt;br/&gt;
hence not visible by the existing scanner. So the  memScanner behaves&lt;br/&gt;
differently before &amp;amp; after the flush.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;But may be it&apos;s not an issue as these put could be skipped anyway by the&lt;br/&gt;
readpoint criteria ? I just don&apos;t know. This state does not last long, as&lt;br/&gt;
the Store will recreate the scanner when notified of the flush.&lt;/p&gt;


</comment>
                            <comment id="13090324" author="nkeywal" created="Wed, 24 Aug 2011 16:12:40 +0000"  >&lt;p&gt;I tested 2 cases:&lt;br/&gt;
1) The current implementation&lt;br/&gt;
2) A new one (reusing the first one logic without calling seek).&lt;/p&gt;


&lt;p&gt;Times (for public void TestHRegion#testWritesWhileGetting()) are, on a virtualized environment:&lt;/p&gt;

&lt;p&gt;Current - 26s&lt;br/&gt;
Proposed - 13s&lt;/p&gt;

&lt;p&gt;It&apos;s a little bit suprising to have a so good result, but it could be explained by the behaviour when the counter gets negative: we can have both a lot of iterations on the list + a call to seek. There is also a lot of gc related time, so it will depends on the memory available. &lt;/p&gt;

&lt;p&gt;But as a conclusion, it seems that it&apos;s interesting to use directly the search on the sublist. I will do a patch on the trunk.&lt;/p&gt;</comment>
                            <comment id="13090373" author="nkeywal" created="Wed, 24 Aug 2011 17:57:29 +0000"  >&lt;p&gt;TestHRegion: added log to help understand where the problem comes from + modification of the put thread to insert strings (easier to read).&lt;/p&gt;

&lt;p&gt;MemStore: implementation of &quot;reseek&quot; by using sublist set in &quot;seek&quot;&lt;/p&gt;</comment>
                            <comment id="13090555" author="yuzhihong@gmail.com" created="Wed, 24 Aug 2011 22:16:22 +0000"  >&lt;p&gt;+1 on patch (some extra empty lines should be removed).&lt;/p&gt;

&lt;p&gt;All tests pass.&lt;/p&gt;</comment>
                            <comment id="13090641" author="yuzhihong@gmail.com" created="Thu, 25 Aug 2011 00:25:39 +0000"  >&lt;p&gt;Consecutively run TestHRegion#testWritesWhileGetting 100 times.&lt;br/&gt;
All of which passed.&lt;/p&gt;</comment>
                            <comment id="13090791" author="stack" created="Thu, 25 Aug 2011 05:36:43 +0000"  >&lt;blockquote&gt;&lt;p&gt;But may be it&apos;s not an issue as these put could be skipped anyway by the readpoint criteria ? I just don&apos;t know. This state does not last long, as the Store will recreate the scanner when notified of the flush.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It looks like region scanner takes out a read point on construction and holds to it as scanner runs so I guess neither put would be seen (since they came in after scanner started so will have write points in excess of the read point).  I&apos;m just a tourist in this code so I could be wrong.&lt;/p&gt;

&lt;p&gt;N, so the failing TestHRegion#testWritesWhileGetting happens on the 0.90 branch only.  Do you want me to try this patch on 0.90?  We don&apos;t fail on TRUNK (Ted show this the case above and I verified it a while back).  How could this be the case when the MemStore is same in both code branches?&lt;/p&gt;


</comment>
                            <comment id="13090840" author="nkeywal" created="Thu, 25 Aug 2011 07:18:44 +0000"  >&lt;p&gt;With the current implementation, it can fails in TestHRegion at assert &quot;assertEquals(&quot;i=&quot; + i, expectedCount, result.size());&quot; when there is a mess up on the lists. It should not occur with the new implementation.&lt;/p&gt;

&lt;p&gt;The issue in the flush is shown by the assert just next to this one. It&apos;s (log added in the new patch)&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;              LOG.warn(&quot;These two KV should have the same value.&quot; +
                &quot; Previous KV:&quot; +
                previousKV + &quot;(memStoreTS:&quot; + previousKV.getMemstoreTS() + &quot;)&quot; +
                &quot;, New KV: &quot; +
                kv + &quot;(memStoreTS:&quot; + kv.getMemstoreTS() + &quot;)&quot;
              );
              assertEquals(previousKV.getValue(), thisValue);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With these modified values on testWritesWhileGetting:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    int testCount = 1000; // more iterations. Increase it more if necessary.
    // [...]
    int flushInterval = 2; // more flush
    int compactInterval = 1000 * flushInterval; // no compact (should have no impact, but...)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I produced this error on the trunk + patch proposed:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;[...]
put iteration = 1927
put iteration = 2021
These two KV should have the same value. Previous KV:row0/family4:qual99/1942/Put/vlen=4(memStoreTS:993), New KV: row0/family5:qual0/1944/Put/vlen=4(memStoreTS:0)
E
Time: 19.051
There was 1 failure:
1) testWritesWhileGetting(org.apache.hadoop.hbase.regionserver.TestHRegion)
junit.framework.AssertionFailedError: expected:&amp;lt;1942&amp;gt; but was:&amp;lt;1944&amp;gt;
	at org.apache.hadoop.hbase.HBaseTestCase.assertEquals(HBaseTestCase.java:704)
	at org.apache.hadoop.hbase.regionserver.TestHRegion.testWritesWhileGetting(TestHRegion.java:2781)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
[...]
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;May be there are more memory allocations on 0.90 and as a consequence more random interruptions caused by the GC? Note that I am doing the tests outside of Maven, but with JUnit, without specific java parameters. &lt;/p&gt;

&lt;p&gt;If worth checking that on .90 it is as well an error when the family changes (qualifier equals qual0 or qual1). May be it&apos;s something different on .90.&lt;/p&gt;

&lt;p&gt;Unfortunatly  (or not &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;) I am on vacations for a week, so I won&apos;t be able to give a hand the next days, but I will be back middle of next week.&lt;/p&gt;


</comment>
                            <comment id="13090922" author="yuzhihong@gmail.com" created="Thu, 25 Aug 2011 10:48:45 +0000"  >&lt;p&gt;Clarification for my earlier comments:&lt;br/&gt;
I performed the test (TestHRegion#testWritesWhileGetting) using the patch 20110824_4195_MemStore.patch.&lt;/p&gt;</comment>
                            <comment id="13098944" author="nkeywal" created="Wed, 7 Sep 2011 13:37:57 +0000"  >&lt;p&gt;Synthesis:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the patch on the test case itself helps to understand where the error come from, but does not change anything else&lt;/li&gt;
	&lt;li&gt;the fix on the memstore fix the menstore part.&lt;/li&gt;
	&lt;li&gt;there is still another issue, not linked to the memstore but to the flush part (see message above from 23/Aug/11)&lt;/li&gt;
	&lt;li&gt;the test cas may fail for this reason. The probability of a failure is increased by increasing the test count and lowering the flush interval&lt;/li&gt;
	&lt;li&gt;Anyway, the flush issue is already handled in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2856&quot; title=&quot;TestAcidGuarantee broken on trunk &quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2856&quot;&gt;&lt;del&gt;HBASE-2856&lt;/del&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So I think we can consider the patch as ok for the scope of this bug? @Ted : @Stack: do you agree? Do you need more info?&lt;/p&gt;</comment>
                            <comment id="13098951" author="yuzhihong@gmail.com" created="Wed, 7 Sep 2011 13:43:38 +0000"  >&lt;p&gt;I already voted +1 on latest patch.&lt;/p&gt;</comment>
                            <comment id="13099619" author="stack" created="Wed, 7 Sep 2011 22:29:52 +0000"  >&lt;p&gt;N:&lt;/p&gt;

&lt;p&gt;We should remove:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.reseekNumKeys = conf.getInt(RESEEKMAX_KEY, RESEEKMAX_DEFAULT);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and reseekNumKeys and the defines else someone will come along later and wonder what these were about?&lt;/p&gt;

&lt;p&gt;Are seek and reseek the same now?  Or it seems like they have a bunch of common code... can we factor it out to common method if so?&lt;/p&gt;


&lt;p&gt;To add to your synthesis:&lt;/p&gt;

&lt;p&gt;+ We&apos;re removing the numIterReseek facility because we get new tailSet every time we reseek.&lt;br/&gt;
+ It looks like there is nice perf. benefit if we go w/ this patch&lt;br/&gt;
+ We&apos;re fixing a bug where we may miss a Put if a flush comes in in meantime because we won&apos;t have a running Iterator on new KVSet (but maybe this is not such a big deal &amp;#8211; perhaps &amp;#8211; because its unlikely the new Put will be within the purview of the current read point?&lt;/p&gt;

&lt;p&gt;If you agree on the above changes and synthesis, no need of a new patch.  I&quot;ll do the clean up on commit.  Thanks boss.&lt;/p&gt;
</comment>
                            <comment id="13100139" author="nkeywal" created="Thu, 8 Sep 2011 07:58:59 +0000"  >&lt;p&gt;@stack: yes I am ok with all your points. Thanks! Some details below:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Are seek and reseek the same now? Or it seems like they have a bunch of common code... can we factor it out to common method if so?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The initialization of kvTail &amp;amp; snapshotTail differs, then it&apos;s the same code. There are only 6 lines of code, but I aggree, it would be cleaner if shared in a private method (this would simplify as well the improvement on peek)&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;We&apos;re fixing a bug where we may miss a Put if a flush comes in in meantime because we won&apos;t have a running Iterator on new KVSet (but maybe this is not such a big deal - perhaps - because its unlikely the new Put will be within the purview of the current read point?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s what I expect. Note that between the 3 implementations:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the initial one: it was impossible because we were just using the iterator without going back to the list.&lt;/li&gt;
	&lt;li&gt;the one currently in the tunk: possible because we&apos;re restarting from the very beginning of the list.&lt;/li&gt;
	&lt;li&gt;the proposed one; in the middle: we&apos;re not restarting from the beginning from from an intermediate point of the list.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So we&apos;re not in the same situation as we were 2 years ago, but I expect (without having done a full analysis) that the readpoint will hide this.&lt;/p&gt;

&lt;p&gt;The best of the best, in terms of performance and similarity to the initial implementation, would be to get the sub-skiplist implictly pointed by the iterator, but there is nothing in the Java API to do it today: it would require to implement a specific skip list.&lt;/p&gt;</comment>
                            <comment id="13100984" author="stack" created="Fri, 9 Sep 2011 05:00:27 +0000"  >&lt;p&gt;N&lt;/p&gt;

&lt;p&gt;Would you mind making a patch that puts common code into a single method and that heavily docs what you&apos;ve found; i.e. repeat in code your expectations above so if we want to change this code subsequently or the scope of readpoint changes, the editor will get the benefit of your rumination?&lt;/p&gt;

&lt;p&gt;Thanks boss.&lt;/p&gt;</comment>
                            <comment id="13100988" author="nkeywal" created="Fri, 9 Sep 2011 05:07:35 +0000"  >&lt;p&gt;Ok, will do (likely this week end). Do you mind if I do a single patch for this jira and for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4188&quot; title=&quot;c&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4188&quot;&gt;&lt;del&gt;HBASE-4188&lt;/del&gt;&lt;/a&gt;? They both touch MemStore seek and reseek.&lt;/p&gt;</comment>
                            <comment id="13100994" author="stack" created="Fri, 9 Sep 2011 05:18:29 +0000"  >&lt;p&gt;Sure on single patch.  Thanks.&lt;/p&gt;</comment>
                            <comment id="13105689" author="nkeywal" created="Thu, 15 Sep 2011 21:13:13 +0000"  >&lt;p&gt;Patch for 4195 and 4188, taking in account all the points mentionned above. The patch :&lt;br/&gt;
for the test case itself is recommended as well, but not mandatory.&lt;/p&gt;

&lt;p&gt;I have as well done some very minor refactoring on some functions that I was touching for the patch:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override added&lt;/li&gt;
	&lt;li&gt;getLower renamed to getLowest as in MemStore&lt;/li&gt;
	&lt;li&gt;test and temp var var removed in next()&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13105752" author="yuzhihong@gmail.com" created="Thu, 15 Sep 2011 23:06:06 +0000"  >&lt;p&gt;+1 on latest patch.&lt;br/&gt;
A few empty lines can be removed at time of commit.&lt;/p&gt;

&lt;p&gt;Ran TestHRegion#testWritesWhileGetting 101 times which all passed based on latest patch.&lt;/p&gt;</comment>
                            <comment id="13105801" author="apurtell" created="Fri, 16 Sep 2011 01:19:00 +0000"  >&lt;p&gt;Looks good, especially the new comments, +1.&lt;/p&gt;

&lt;p&gt;There is a minor typo in the comments that can be cleaned up on commit:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+      1) t&apos;s not possible to use the &apos;kvTail&apos; and &apos;snapshot&apos;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;should be&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+      1) It&apos;s not possible to use the &apos;kvTail&apos; and &apos;snapshot&apos;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13105838" author="yuzhihong@gmail.com" created="Fri, 16 Sep 2011 04:11:07 +0000"  >&lt;p&gt;Minor comment:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+      &lt;span class=&quot;code-comment&quot;&gt;// kvset and snapshot will never be &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;.
&lt;/span&gt;+      &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; tailSet can&apos;t find anything, SS is empty (not &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;).&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I think SS above should be replaced with SortedSet.&lt;/p&gt;</comment>
                            <comment id="13105846" author="yuzhihong@gmail.com" created="Fri, 16 Sep 2011 04:26:28 +0000"  >&lt;p&gt;I think the following test failure (w.r.t. MemStore.FIXED_OVERHEAD) is related to this JIRA:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
testSizes(org.apache.hadoop.hbase.io.TestHeapSize)  Time elapsed: 0.056 sec  &amp;lt;&amp;lt;&amp;lt; FAILURE!
junit.framework.AssertionFailedError: expected:&amp;lt;104&amp;gt; but was:&amp;lt;112&amp;gt;
        at junit.framework.Assert.fail(Assert.java:47)
        at junit.framework.Assert.failNotEquals(Assert.java:283)
        at junit.framework.Assert.assertEquals(Assert.java:64)
        at junit.framework.Assert.assertEquals(Assert.java:130)
        at junit.framework.Assert.assertEquals(Assert.java:136)
        at org.apache.hadoop.hbase.io.TestHeapSize.testSizes(TestHeapSize.java:272)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13105916" author="nkeywal" created="Fri, 16 Sep 2011 07:11:08 +0000"  >&lt;p&gt;I am going to check.&lt;/p&gt;

</comment>
                            <comment id="13105925" author="nkeywal" created="Fri, 16 Sep 2011 07:38:25 +0000"  >&lt;p&gt;Yes, it&apos;s because I removed a field in MemStore (the reseek counter).&lt;/p&gt;

&lt;p&gt;It seems that the fix is to change 12 to 11 in MemStore.java &lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt; 
  public final static long FIXED_OVERHEAD = ClassSize.align(
      ClassSize.OBJECT + (12 * ClassSize.REFERENCE));
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The unit test is happy after this change, do you confirm it&apos;s the right solution?&lt;/p&gt;</comment>
                            <comment id="13106063" author="yuzhihong@gmail.com" created="Fri, 16 Sep 2011 13:39:00 +0000"  >&lt;p&gt;@N:&lt;br/&gt;
You&apos;re right.&lt;br/&gt;
Patch v2 passes TestHeapSize.&lt;/p&gt;

&lt;p&gt;Let&apos;s see what Stack says about it.&lt;/p&gt;</comment>
                            <comment id="13106516" author="nkeywal" created="Fri, 16 Sep 2011 15:23:07 +0000"  >&lt;p&gt;Note that I am currently running the full unit test and checking the failures are not related to this fix. &lt;/p&gt;</comment>
                            <comment id="13106589" author="yuzhihong@gmail.com" created="Fri, 16 Sep 2011 16:52:21 +0000"  >&lt;p&gt;Test suite passed.&lt;/p&gt;</comment>
                            <comment id="13106627" author="nkeywal" created="Fri, 16 Sep 2011 17:46:25 +0000"  >&lt;p&gt;Same here, I got one failure with TestGetRowVersions, but it seems unrelated (it worked once &amp;amp; failed once).&lt;br/&gt;
Other unit tests in errors fail with and without the patch.&lt;/p&gt;</comment>
                            <comment id="13106630" author="apurtell" created="Fri, 16 Sep 2011 17:49:26 +0000"  >&lt;blockquote&gt;&lt;p&gt;Yes, it&apos;s because I removed a field in MemStore (the reseek counter). It seems that the fix is to change 12 to 11 in MemStore.java&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is the correct fix for that.&lt;/p&gt;</comment>
                            <comment id="13106718" author="nkeywal" created="Fri, 16 Sep 2011 19:05:21 +0000"  >&lt;p&gt;Thank you. What is the next step? Should I write a new patch taking into account all the different comment?&lt;/p&gt;</comment>
                            <comment id="13106727" author="yuzhihong@gmail.com" created="Fri, 16 Sep 2011 19:13:13 +0000"  >&lt;p&gt;@N:&lt;br/&gt;
4195-v2.txt has taken care of heap size issue.&lt;/p&gt;</comment>
                            <comment id="13106734" author="stack" created="Fri, 16 Sep 2011 19:16:59 +0000"  >&lt;p&gt;I can do clean up on commit N.  No need of new patch.  Let me run some tests first.&lt;/p&gt;</comment>
                            <comment id="13106737" author="nkeywal" created="Fri, 16 Sep 2011 19:20:59 +0000"  >&lt;p&gt;Ok, thank you.&lt;br/&gt;
The remaining points I saw in 4195-v2.txt  are the one mentioned above by Ted at 16/Sep/11 04:11 and by Andrew at 16/Sep/11 01:19 (modifications in the comments not in the code).&lt;/p&gt;</comment>
                            <comment id="13106749" author="stack" created="Fri, 16 Sep 2011 19:39:14 +0000"  >&lt;p&gt;Committed to TRUNK and fixed the Ted and Andrew comments on commit.  Resolving against 0.92.  I think we might want to commit this to 0.90 to get over hbase-3855.  Waiting on Andrew feedback.  Nice one N.  Thanks.&lt;/p&gt;</comment>
                            <comment id="13106750" author="yuzhihong@gmail.com" created="Fri, 16 Sep 2011 19:39:24 +0000"  >&lt;p&gt;Patch v3 addresses the two places in comments.&lt;/p&gt;</comment>
                            <comment id="13106880" author="hudson" created="Fri, 16 Sep 2011 22:35:18 +0000"  >&lt;p&gt;Integrated in HBase-TRUNK #2222 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-TRUNK/2222/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-TRUNK/2222/&lt;/a&gt;)&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4195&quot; title=&quot;Possible inconsistency in a memstore read after a reseek, possible performance improvement&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4195&quot;&gt;&lt;del&gt;HBASE-4195&lt;/del&gt;&lt;/a&gt; Possible inconsistency in a memstore read after a reseek, possible performance improvement&lt;/p&gt;

&lt;p&gt;stack : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/trunk/CHANGES.txt&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/MemStore.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15015995" author="lars_francke" created="Fri, 20 Nov 2015 11:53:30 +0000"  >&lt;p&gt;This issue was closed as part of a bulk closing operation on 2015-11-20. All issues that have been resolved and where all fixVersions have been released have been closed (following discussions on the mailing list).&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12598630">HBASE-6385</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12491524" name="20110824_4195_MemStore.patch" size="4126" author="nkeywal" created="Wed, 24 Aug 2011 17:57:29 +0000"/>
                            <attachment id="12491525" name="20110824_4195_TestHRegion.patch" size="2067" author="nkeywal" created="Wed, 24 Aug 2011 17:57:29 +0000"/>
                            <attachment id="12494694" name="20110915_4195_4188_MemStore.patch" size="9071" author="nkeywal" created="Thu, 15 Sep 2011 21:13:13 +0000"/>
                            <attachment id="12494795" name="4195-v2.txt" size="9133" author="yuzhihong@gmail.com" created="Fri, 16 Sep 2011 13:39:00 +0000"/>
                            <attachment id="12494852" name="4195-v3.txt" size="9141" author="yuzhihong@gmail.com" created="Fri, 16 Sep 2011 19:39:24 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 12 Aug 2011 21:21:21 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>27213</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310191" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Hadoop Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10343"><![CDATA[Reviewed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            1 year, 4 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i05hyv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30008</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310192" key="com.atlassian.jira.plugin.system.customfieldtypes:textarea">
                        <customfieldname>Release Note</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>This fixes the regression (identified by a random failure of test TestHRegion#testWritesWhileGetting) introduced by &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3855&quot; title=&quot;Performance degradation of memstore because reseek is linear&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3855&quot;&gt;&lt;strike&gt;HBASE-3855&lt;/strike&gt;&lt;/a&gt;. In production, the failure could occur purely randomly depending on the size of the MemStore list, or during a parallel execution of a scanner#next and a memstore flush. The fix improves the scanner reseek performance as well. The parameter &amp;quot;hbase.hregion.memstore.reseek.maxkeys&amp;quot; is not used anymore.</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>