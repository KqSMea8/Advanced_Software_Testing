<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:26:42 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-5320/HBASE-5320.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-5320] Create client API to handle HBase maintenance gracefully</title>
                <link>https://issues.apache.org/jira/browse/HBASE-5320</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;When we do HBase cluster maintenance, we typically have to manually stop or disable the client temporarily. It would be nice to have a way for the client to find out that HBase in undergoing maintenance through an appropriate API and gracefully handle it on its own.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12540870">HBASE-5320</key>
            <summary>Create client API to handle HBase maintenance gracefully</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="mikhail">Mikhail Bautin</assignee>
                                    <reporter username="mikhail">Mikhail Bautin</reporter>
                        <labels>
                    </labels>
                <created>Thu, 2 Feb 2012 02:55:18 +0000</created>
                <updated>Thu, 23 Aug 2012 04:22:25 +0000</updated>
                                                                                <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                <comments>
                            <comment id="13198519" author="lhofhansl" created="Thu, 2 Feb 2012 04:06:26 +0000"  >&lt;p&gt;We have need for this too, let me know if/how we can collaborate on this.&lt;/p&gt;</comment>
                            <comment id="13198591" author="mikhail" created="Thu, 2 Feb 2012 07:59:36 +0000"  >&lt;p&gt;Lars: collaboration would be very welcome &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I do not yet have a design in mind for this one, nor have I started actively working on this. I just noticed this missing piece in our deployment process.&lt;/p&gt;

&lt;p&gt;The main difficulty here probably lies in the fact that the master and the regionservers are all unreachable during maintenance. Therefore, there needs to be some other server to connect to in order to find out the cluster state. This server could even be shared across multiple clusters, thus unifying a piece of operational infrastructure that any company running multiple HBase clusters has to implement. Alternatively, this could be ZK-based, but the ZK instance has to be different from the one started and stopped with the HBase cluster.&lt;/p&gt;

&lt;p&gt;Please share your design ideas.&lt;/p&gt;</comment>
                            <comment id="13200611" author="lhofhansl" created="Sun, 5 Feb 2012 00:58:06 +0000"  >&lt;p&gt;I have no concrete plans, yet.&lt;br/&gt;
There are simple ideas of&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;just letting the client wait it out (blocking the client) or&lt;/li&gt;
	&lt;li&gt;just check whether ZK/Master is up, let the app react to that&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;I am not following why there needs to be another server to determine whether a service down. Or are you planning to &quot;preannounce&quot; outages through this extra server? Or to distinguish between an outage and a planned maintenance?&lt;/p&gt;</comment>
                            <comment id="13439748" author="ivarley" created="Wed, 22 Aug 2012 18:37:27 +0000"  >&lt;p&gt;Seems like something along the lines of the circuit breaker pattern would be useful in the HBase client:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In other words, whether it&apos;s planned or unplanned, inability to reach the cluster should be something the client can detect and pass along to clients. &lt;/p&gt;

&lt;p&gt;The simplest way is by throwing immediate exceptions when the client detects the cluster is unreachable (while, in the background, the client continues to attempt to reconnect). A more sophisticated way might have some API clients can check about up-ness; but, of course, then they have to check that on every call, so it&apos;s not really all that different from just throwing a specific kind of exception and having them handle that at whatever level they feel like it. The key part is maintaining that state in some central place in the client&apos;s JVM.&lt;/p&gt;

&lt;p&gt;This is tricky to get right (you don&apos;t want to be throwing exceptions if the cluster is really up and it&apos;s a false alarm!).&lt;/p&gt;</comment>
                            <comment id="13439806" author="apurtell" created="Wed, 22 Aug 2012 20:10:01 +0000"  >&lt;p&gt;Doesn&apos;t the answer when all of these issues are reduced end at async/callback based request handling? We&apos;ve started moving the client this direction internally. An explicit async API exposed on top a-la asynchbase would let the client detect unreachability (or some other error) via callback on a per request basis, this would be the canonical pattern, right?&lt;/p&gt;

&lt;p&gt;Then the client can decide, in the error callback, if it would like to reissue the request. Or not. No need for shared state.&lt;/p&gt;

&lt;p&gt;Not an argument to the above, just a question for consideration if it may be useful.&lt;/p&gt;</comment>
                            <comment id="13439809" author="apurtell" created="Wed, 22 Aug 2012 20:12:05 +0000"  >&lt;p&gt;As for the cluster state question, in Mikhail&apos;s comment above, if the ZK cluster is managed separately then we can indeed track administrative cluster states that way. The application could check that by way of an admin API, no need for the client to check such state inline (which may be expensive).&lt;/p&gt;</comment>
                            <comment id="13439843" author="nkeywal" created="Wed, 22 Aug 2012 21:02:08 +0000"  >&lt;p&gt;I think that the server states should be exposed to the client in ZK. Not only a high level &quot;cluster status&quot;, but the state of every RS.&lt;br/&gt;
There are limitations in ZK today so it&apos;s not ideal (could not scale with x000 clients), but exposing these states is typically implemented with multicast messages with the client having a read only access (while a ZK connection allows to write as well today).&lt;/p&gt;</comment>
                            <comment id="13439854" author="ivarley" created="Wed, 22 Aug 2012 21:21:18 +0000"  >&lt;p&gt;The only reason I was thinking &quot;shared state&quot; was that it lets you break the circuit cleanly for everyone, as opposed to every request having to time out individually. An async API makes it more palatable for client code to be written to tolerate this, but realistically, a lot of code wants to interact with HBase synchronously, and fail fast if the cluster is down. (Citation needed. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13439864" author="apurtell" created="Wed, 22 Aug 2012 21:32:13 +0000"  >&lt;blockquote&gt;&lt;p&gt;realistically, a lot of code wants to interact with HBase synchronously, and fail fast if the cluster is down&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sure.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;An async API makes it more palatable for client code to be written to tolerate this&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;And also for different timeouts to be set per call, like this (Scala-ish) code inspired by &lt;a href=&quot;http://mdcc.cs.berkeley.edu/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://mdcc.cs.berkeley.edu/&lt;/a&gt; :&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
val r = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Request() ({
  &lt;span class=&quot;code-comment&quot;&gt;// Ops to bundle into the request
&lt;/span&gt;}).timeout(300)  &lt;span class=&quot;code-comment&quot;&gt;// 300 ms timeout
&lt;/span&gt;.onFailure {
  &lt;span class=&quot;code-comment&quot;&gt;// Error handling &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; local failure or timeout (or unreachability)
&lt;/span&gt;}.onAccept {
  &lt;span class=&quot;code-comment&quot;&gt;// Request succeeded
&lt;/span&gt;}).&lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt;( (success, timeout) =&amp;gt; {
  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (success) &lt;span class=&quot;code-comment&quot;&gt;// Request succeeded
&lt;/span&gt;  &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-comment&quot;&gt;// Request failed (and timeout is &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; timed out)
&lt;/span&gt;})
val status = r.Execute()
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13440040" author="lhofhansl" created="Thu, 23 Aug 2012 04:21:16 +0000"  >&lt;p&gt;There are many ways to skin this cat (although I hate this expression &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ).&lt;/p&gt;

&lt;p&gt;One of the simplest is to simply allow the client to fail fast if the cluster is down (for example by reacting to ConnectionRefused conditions - which means the host was reachable, but nothing was listening on the port). I created and fixed some jira around this. But there is still room for improvement, especially in the ZK client!&lt;/p&gt;

&lt;p&gt;Similar to this would be the circuit breaker design.&lt;/p&gt;

&lt;p&gt;Another option is what Mikhail describes: An extra API to detect whether the cluster is up or not (and actually that would be needed also for the circuit breaker, since it needs a way to detect this condition).&lt;/p&gt;

&lt;p&gt;Asynchronous handling is difficult when the client is running in an AppServer, which itself is driven by (say) web requests. One can do comet style request parking and replay, but that goes only so far.&lt;/p&gt;

&lt;p&gt;That asynchronous snippet is nice, it, too, does require client side that can reliably detect an unavailable cluster while avoiding false down-indicators.&lt;/p&gt;</comment>
                            <comment id="13440041" author="lhofhansl" created="Thu, 23 Aug 2012 04:22:25 +0000"  >&lt;p&gt;And, yes, generally I think we should create an asynchronous HBase (and ZK!) client. A synchronous client can be easily layered on top of that, while the reverse is not true.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 2 Feb 2012 04:06:26 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>226224</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 years, 17 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0ht5r:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>101986</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>