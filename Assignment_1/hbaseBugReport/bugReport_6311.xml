<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:35:38 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-6311/HBASE-6311.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-6311] Data error after majorCompaction caused by keeping MVCC for opened scanners</title>
                <link>https://issues.apache.org/jira/browse/HBASE-6311</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;It is a big problem we found in 0.94, and you could reproduce the problem in Trunk using the test case I uploaded.&lt;/p&gt;

&lt;p&gt;When we do compaction, we will use region.getSmallestReadPoint() to keep MVCC for opened scanners;&lt;br/&gt;
However,It will make data mistake after majorCompaction because we will skip delete type KV but keep the put type kv in the compacted storefile.&lt;/p&gt;

&lt;p&gt;The following is the reason from code:&lt;br/&gt;
In StoreFileScanner, enforceMVCC is false when compaction, so we could read the delete type KV,&lt;br/&gt;
However, we will skip this delete type KV in ScanQueryMatcher because following code&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (kv.isDelete())
{
...
 &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (includeDeleteMarker
            &amp;amp;&amp;amp; kv.getMemstoreTS() &amp;lt;= maxReadPointToTrackVersions) {
          &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;add deletes,maxReadPointToTrackVersions=&quot;&lt;/span&gt;
              + maxReadPointToTrackVersions);
          &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.deletes.add(bytes, offset, qualLength, timestamp, type);
        }
...
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here maxReadPointToTrackVersions = region.getSmallestReadPoint();&lt;br/&gt;
and kv.getMemstoreTS() &amp;gt; maxReadPointToTrackVersions &lt;br/&gt;
So we won&apos;t add this to DeleteTracker.&lt;/p&gt;

&lt;p&gt;Why test case passed if remove the line MultiVersionConsistencyControl.setThreadReadPoint(smallestReadPoint);&lt;/p&gt;

&lt;p&gt;Because in the StoreFileScanner#skipKVsNewerThanReadpoint&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (cur.getMemstoreTS() &amp;lt;= readPoint) {
      cur.setMemstoreTS(0);
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;So if we remove the line MultiVersionConsistencyControl.setThreadReadPoint(smallestReadPoint);&lt;br/&gt;
Here readPoint is LONG.MAX_VALUE, we will set memStore ts as 0, so we will add it to DeleteTracker in ScanQueryMatcher &lt;/p&gt;


&lt;p&gt;Solution:&lt;br/&gt;
We use smallestReadPoint of region when compaction to keep MVCC for OPENED scanner, So we should retain delete type kv in output in the case(Already deleted KV is retained in output to make old opened scanner could read this KV) even if it is a majorcompaction.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12596931">HBASE-6311</key>
            <summary>Data error after majorCompaction caused by keeping MVCC for opened scanners</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.png">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="zjushch">chunhui shen</assignee>
                                    <reporter username="zjushch">chunhui shen</reporter>
                        <labels>
                    </labels>
                <created>Tue, 3 Jul 2012 03:30:13 +0000</created>
                <updated>Wed, 18 Sep 2013 22:07:31 +0000</updated>
                            <resolved>Fri, 6 Jul 2012 18:25:39 +0000</resolved>
                                    <version>0.94.0</version>
                                    <fixVersion>0.94.1</fixVersion>
                    <fixVersion>0.95.0</fixVersion>
                                    <component>regionserver</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>12</watches>
                                                                <comments>
                            <comment id="13405612" author="anoopsamjohn" created="Tue, 3 Jul 2012 04:23:31 +0000"  >&lt;p&gt;Store#compactStore(final Collection&amp;lt;StoreFile&amp;gt; filesToCompact,                               final boolean majorCompaction, final long maxId)&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// Find the smallest read point across all the Scanners.
&lt;/span&gt;    &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; smallestReadPoint = region.getSmallestReadPoint();
    MultiVersionConsistencyControl.setThreadReadPoint(smallestReadPoint);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This setting the read point is the issue? With removal of this line I am able to pass ur test case. smallestReadPoint  ideally should be used for resetting the memstoreTs. &lt;span class=&quot;error&quot;&gt;&amp;#91;Any other usages?&amp;#93;&lt;/span&gt;&lt;br/&gt;
Obviously it should not be used for deciding what to scan. Compact need to scan every thing from the files.&lt;/p&gt;
</comment>
                            <comment id="13405617" author="zjushch" created="Tue, 3 Jul 2012 04:42:03 +0000"  >&lt;p&gt;I think I has found the reason:&lt;/p&gt;

&lt;p&gt;In StoreFileScanner, enforceMVCC is false when compaction, so we could read the delete type KV,&lt;br/&gt;
However, we will skip this delete type KV in ScanQueryMatcher because following code&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
 &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (kv.isDelete())
{
...
 &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (includeDeleteMarker
            &amp;amp;&amp;amp; kv.getMemstoreTS() &amp;lt;= maxReadPointToTrackVersions) {
          &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;add deletes,maxReadPointToTrackVersions=&quot;&lt;/span&gt;
              + maxReadPointToTrackVersions);
          &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.deletes.add(bytes, offset, qualLength, timestamp, type);
        }
...
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here maxReadPointToTrackVersions = region.getSmallestReadPoint();&lt;br/&gt;
and  kv.getMemstoreTS() &amp;gt; maxReadPointToTrackVersions &lt;br/&gt;
So we won&apos;t add this to DeleteTracker.&lt;/p&gt;

&lt;p&gt;Why test case passed if remove the line MultiVersionConsistencyControl.setThreadReadPoint(smallestReadPoint);&lt;/p&gt;

&lt;p&gt;Because in the StoreFileScanner#skipKVsNewerThanReadpoint&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (cur.getMemstoreTS() &amp;lt;= readPoint) {
      cur.setMemstoreTS(0);
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt; 
&lt;p&gt;So if we remove the line MultiVersionConsistencyControl.setThreadReadPoint(smallestReadPoint);&lt;br/&gt;
Here readPoint is LONG.MAX_VALUE,  we will set memStore ts as 0, so we will add it to DeleteTracker in ScanQueryMatcher  &lt;/p&gt;</comment>
                            <comment id="13405621" author="zjushch" created="Tue, 3 Jul 2012 04:50:47 +0000"  >&lt;p&gt;Doing MultiVersionConsistencyControl.setThreadReadPoint(smallestReadPoint) in the compaction is used to ensure scanner keep MVCC after compaction,&lt;br/&gt;
But I don&apos;t know why we add the the condition( kv.getMemstoreTS() &amp;lt;= maxReadPointToTrackVersions) in the ScanQueryMatcher :&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (includeDeleteMarker
            &amp;amp;&amp;amp; kv.getMemstoreTS() &amp;lt;= maxReadPointToTrackVersions) {
          &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.deletes.add(bytes, offset, qualLength, timestamp, type);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;/** readPoint over which the KVs are unconditionally included */
  &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; maxReadPointToTrackVersions;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I think it is not accordant with the javaDoc of this variable&lt;/p&gt;</comment>
                            <comment id="13405628" author="zjushch" created="Tue, 3 Jul 2012 05:14:05 +0000"  >&lt;blockquote&gt;&lt;p&gt;But I don&apos;t know why we add the the condition( kv.getMemstoreTS() &amp;lt;= maxReadPointToTrackVersions) in the ScanQueryMatcher&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m clear about this, because we should keep old scanner see the KV even if it is already been deleted.&lt;/p&gt;

&lt;p&gt;So I think we could fix this issue as the following:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(kv.isDelete()){
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(kv.getMemstoreTS() &amp;gt; maxReadPointToTrackVersions)
&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; MatchCode.INCLUDE;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13405629" author="zjushch" created="Tue, 3 Jul 2012 05:15:19 +0000"  >&lt;p&gt;Uploading patch to fix this issue&lt;/p&gt;</comment>
                            <comment id="13405644" author="ram_krish" created="Tue, 3 Jul 2012 05:59:33 +0000"  >&lt;p&gt;@Chunhui&lt;br/&gt;
Very good catch and good analysis.  But this patch will now will now write the delete marker also even during Major compaction? Ideally the expected behaviour is the put and deleted both should not be written while major compaction. &lt;br/&gt;
So we need to add this to this.deletes.  What you feel Chunhui?&lt;/p&gt;
{Edit}&lt;br/&gt;
bq.So we need to add this to this.deletes&lt;br/&gt;
What i meant is we need to add to this.deletes so that we are able to track the put that may come in and ensure whether we should skip them or not.{Edit}</comment>
                            <comment id="13405647" author="zjushch" created="Tue, 3 Jul 2012 06:10:22 +0000"  >&lt;p&gt;@ram&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;But this patch will now write the delete marker also even during Major compaction? &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, we write the delete marker only if kv.getMemstoreTS() &amp;gt; maxReadPointToTrackVersions, because in that case, the already deleted put KV will be retained in output.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Ideally the expected behaviour is the put and deleted both should not be written while major compaction. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Assume that one scanner could read put type KV first, and then we delete this KV, but this scanner should also could read this scannner as the MVCC , If we don&apos;t write put and delete KV in majorCompaction, this scanner couldn&apos;t read the put type KV and break the MVCC, is it right?&lt;/p&gt;
</comment>
                            <comment id="13405691" author="zhihyu@ebaysf.com" created="Tue, 3 Jul 2012 08:40:27 +0000"  >&lt;p&gt;The code in ScanQueryMatcher under discussion was introduced in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5569&quot; title=&quot;Do not collect deleted KVs when they are still in use by a scanner.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5569&quot;&gt;&lt;del&gt;HBASE-5569&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="13405702" author="anoopsamjohn" created="Tue, 3 Jul 2012 09:02:24 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Assume that one scanner could read put type KV first, and then we delete this KV, but this scanner should also could read this scannner as the MVCC , If we don&apos;t write put and delete KV in majorCompaction, this scanner couldn&apos;t read the put type KV and break the MVCC, is it right?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Raises the question about MVCC. What you say is suppose a read started and at that time row r1 was there. Later this row is deleted by some other client. Still as per the MVCC this reader will be able to read this row.&lt;br/&gt;
But if in between the read (after the delete) a flush and a compact (major) happened and then only reader is reaching the row r1, it will not see r1.  Correct right Chunhui?  This is what you are telling?&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;Not sure whether this actions can really happen. but just saying theoretically&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;That makes your point valid Chunhui IMO&lt;/p&gt;

&lt;p&gt;In Chunhui&apos;s test case, if the 1st scanner &lt;span class=&quot;error&quot;&gt;&amp;#91;scanner1&amp;#93;&lt;/span&gt; is calling next() 1st time after the major compact, still he should be able to see the row.&lt;/p&gt;</comment>
                            <comment id="13405706" author="ram_krish" created="Tue, 3 Jul 2012 09:11:23 +0000"  >&lt;p&gt;If we move the scanner1.next to the last we are able to get the result because of the bug.  &lt;br/&gt;
Ideally the major compact again gets the PUT that was deleted and the same is written into the compacted file.  so the first scanner is able to read the data.&lt;/p&gt;</comment>
                            <comment id="13405783" author="zjushch" created="Tue, 3 Jul 2012 10:20:45 +0000"  >&lt;blockquote&gt;&lt;p&gt;if the 1st scanner &lt;span class=&quot;error&quot;&gt;&amp;#91;scanner1&amp;#93;&lt;/span&gt; is calling next() 1st time after the major compact, still he should be able to see the row&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I consider it is right as per the MVCC, because the scanner could read the row when opened, &lt;br/&gt;
is it so as per the MVCC?&lt;/p&gt;</comment>
                            <comment id="13405785" author="anoopsamjohn" created="Tue, 3 Jul 2012 10:27:19 +0000"  >&lt;p&gt;I am also inline with Chunhui on this. As per the MVCC the scanner should be able to see this row&lt;/p&gt;</comment>
                            <comment id="13405804" author="ram_krish" created="Tue, 3 Jul 2012 11:05:31 +0000"  >&lt;p&gt;As per MVCC the behaviour like the firstscanner should read is correct.  But when the compaction is done and the in this case the put and delete is removed, we have a new set of store files..  Now already when starting a scan we have logic &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; next(List&amp;lt;KeyValue&amp;gt; outResult, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; limit) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {

    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (checkReseek()) {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;So now i have doubt on this behaviour.  Pls correct me if am wrong.&lt;/p&gt;</comment>
                            <comment id="13406226" author="zjushch" created="Wed, 4 Jul 2012 01:23:26 +0000"  >&lt;blockquote&gt;&lt;p&gt;But when the compaction is done and the in this case the put and delete is removed&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;In this case, after the compaction the put is retained and delete is dropped without patch, so make data mistake. With the patch, the put and delete are both retained after compaction,so the firstscanner could also read this row as per MVCC.&lt;/p&gt;</comment>
                            <comment id="13406267" author="ram_krish" created="Wed, 4 Jul 2012 04:29:18 +0000"  >&lt;p&gt;@Chunhui&lt;br/&gt;
I did not mean your patch does it.  Am just saying what happens if the put/delete gets removed and we end up in an empty file.  I was just trying to do some changes to your patch and the testcase..  &lt;/p&gt;</comment>
                            <comment id="13406281" author="zjushch" created="Wed, 4 Jul 2012 05:11:34 +0000"  >&lt;p&gt;@ram&lt;br/&gt;
In order to keep MVCC for the firstscanner, we retained already deleted KV output to compacted file in current logic.&lt;/p&gt;

&lt;p&gt;What my patch do is retaining delete type KV output to compacted file also if the above happen:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(kv.getMemstoreTS() &amp;gt; maxReadPointToTrackVersions)
&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; MatchCode.INCLUDE;&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Include the delete type KV as the above code&lt;/p&gt;</comment>
                            <comment id="13406282" author="zjushch" created="Wed, 4 Jul 2012 05:14:53 +0000"  >&lt;blockquote&gt;&lt;p&gt;Am just saying what happens if the put/delete gets removed and we end up in an empty file.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We shouldn&apos;t end up in an empty file, because the put type KV should be able to read by earlier opened scanner as per MVCC&lt;/p&gt;</comment>
                            <comment id="13406839" author="ram_krish" created="Thu, 5 Jul 2012 04:27:43 +0000"  >&lt;p&gt;@All,&lt;br/&gt;
Could someone take a look at this? Seems important wrt MVCC.  &lt;/p&gt;</comment>
                            <comment id="13406847" author="zjushch" created="Thu, 5 Jul 2012 05:07:30 +0000"  >&lt;p&gt;@ram&lt;br/&gt;
What doubt do you have about my patch v2?&lt;br/&gt;
I update the test case to verify MVCC for scanners after majorCompaction.&lt;/p&gt;</comment>
                            <comment id="13406854" author="ram_krish" created="Thu, 5 Jul 2012 05:24:05 +0000"  >&lt;p&gt;@Chunhui&lt;br/&gt;
I am clear with your patch.  Your patch tries to keep MVCC concepts intact and that is what is needed.  No problem. Even Anoop also has reviewed it.&lt;br/&gt;
Just wanted others to review this because now even on major compaction we create a file with delete marker if the condition is kv.getMemstoreTS() &amp;gt; maxReadPointToTrackVersions.&lt;br/&gt;
But in a normal case we will not write delete marker on major compaction.  Is this ok? &lt;/p&gt;</comment>
                            <comment id="13406861" author="zjushch" created="Thu, 5 Jul 2012 05:40:13 +0000"  >&lt;blockquote&gt;&lt;p&gt;But in a normal case we will not write delete marker on major compaction&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, it&apos;s so&lt;/p&gt;</comment>
                            <comment id="13406871" author="lhofhansl" created="Thu, 5 Jul 2012 06:34:29 +0000"  >&lt;p&gt;Conclusion and patch look good to me. I guess in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5569&quot; title=&quot;Do not collect deleted KVs when they are still in use by a scanner.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5569&quot;&gt;&lt;del&gt;HBASE-5569&lt;/del&gt;&lt;/a&gt; I only fixed half the problem (or created it?).&lt;br/&gt;
I&apos;ll take a closer look tomorrow.&lt;/p&gt;</comment>
                            <comment id="13406875" author="lhofhansl" created="Thu, 5 Jul 2012 06:41:31 +0000"  >&lt;p&gt;I should note that this all is needed for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3584&quot; title=&quot;Allow atomic put/delete in one call&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3584&quot;&gt;&lt;del&gt;HBASE-3584&lt;/del&gt;&lt;/a&gt; (multi op transactions).&lt;/p&gt;</comment>
                            <comment id="13406881" author="hadoopqa" created="Thu, 5 Jul 2012 06:51:36 +0000"  >&lt;p&gt;-1 overall.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12535148/HBASE-6311v2.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12535148/HBASE-6311v2.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision .&lt;/p&gt;

&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 4 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 hadoop2.0.  The patch compiles against the hadoop 2.0 profile.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    -1 javac.  The applied patch generated 5 javac compiler warnings (more than the trunk&apos;s current 4 warnings).&lt;/p&gt;

&lt;p&gt;    -1 findbugs.  The patch appears to introduce 7 new Findbugs (version 1.3.9) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;     -1 core tests.  The patch failed these unit tests:&lt;br/&gt;
                       org.apache.hadoop.hbase.regionserver.TestAtomicOperation&lt;br/&gt;
                  org.apache.hadoop.hbase.replication.TestReplication&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/2325//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/2325//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/2325//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/2325//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-common.html&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/2325//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/2325//artifact/trunk/patchprocess/newPatchFindbugsWarningshbase-server.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/2325//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/2325//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="13407240" author="lhofhansl" created="Thu, 5 Jul 2012 16:20:14 +0000"  >&lt;p&gt;TestAtomicOperation failing is not a great sign.&lt;/p&gt;</comment>
                            <comment id="13407366" author="lhofhansl" created="Thu, 5 Jul 2012 18:37:09 +0000"  >&lt;p&gt;TestAtomicOperation passed locally for me.&lt;/p&gt;</comment>
                            <comment id="13407393" author="lhofhansl" created="Thu, 5 Jul 2012 18:53:27 +0000"  >&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (includeDeleteMarker
            &amp;amp;&amp;amp; kv.getMemstoreTS() &amp;lt;= maxReadPointToTrackVersions) {
          &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.deletes.add(bytes, offset, qualLength, timestamp, type);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The check here is needed, so that deleted rows are not pulled from under a scanner that started &lt;b&gt;before&lt;/b&gt; the rows were deleted (needed for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3584&quot; title=&quot;Allow atomic put/delete in one call&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3584&quot;&gt;&lt;del&gt;HBASE-3584&lt;/del&gt;&lt;/a&gt;).&lt;br/&gt;
So if kv.getMemstoreTS() &amp;gt; maxReadPointToTrackVersions the effect of the delete marker is ignored. So in case of the major compaction that delete marker should indeed be included.&lt;/p&gt;

&lt;p&gt;The only concern I&apos;d have: When would the delete marker ever be collected?&lt;/p&gt;</comment>
                            <comment id="13407670" author="zjushch" created="Fri, 6 Jul 2012 03:12:00 +0000"  >&lt;p&gt;@Lars&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;So in case of the major compaction that delete marker should indeed be included&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;For this case, we retained both put and delete marker output compacted file, so the scanner you mentioned above could read the row, and also data is correct.&lt;/p&gt;</comment>
                            <comment id="13407689" author="lhofhansl" created="Fri, 6 Jul 2012 04:13:38 +0000"  >&lt;p&gt;Yes. I was just restating the problem.&lt;br/&gt;
How about my last question: When will the delete markers now be collected?&lt;/p&gt;</comment>
                            <comment id="13407698" author="zjushch" created="Fri, 6 Jul 2012 04:37:18 +0000"  >&lt;blockquote&gt;&lt;p&gt;When will the delete markers now be collected?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Do you mean collected to compacted file or to DeleteTracker in ScanQueryMatcher?&lt;br/&gt;
We won&apos;t collected delete markers to compacted file in majorCompaction except deleted KV is also collectd to compacted file.&lt;/p&gt;

&lt;p&gt;For example through the code&lt;/p&gt;

&lt;p&gt;If a delete marker is not collected to deleteTracker because  &lt;br/&gt;
kv.getMemstoreTS()&amp;lt;=maxReadPointToTrackVersions, it must will be collected to compacted file&lt;/p&gt;</comment>
                            <comment id="13407702" author="lhofhansl" created="Fri, 6 Jul 2012 04:47:07 +0000"  >&lt;p&gt;Never mind, re-reading my question, it does not make sense.&lt;br/&gt;
Older delete marker will eventually be collected during a major compaction, so all is good.&lt;/p&gt;

&lt;p&gt;+1 on patch. If there are no objection I&apos;ll commit this tomorrow.&lt;/p&gt;

&lt;p&gt;I think this warrants for a quicker new release.&lt;/p&gt;</comment>
                            <comment id="13408179" author="ram_krish" created="Fri, 6 Jul 2012 17:47:38 +0000"  >&lt;p&gt;Lars if you are ok in retaining the deletes on major compaction I am +1 on this patch too.&lt;/p&gt;</comment>
                            <comment id="13408192" author="lhofhansl" created="Fri, 6 Jul 2012 18:07:11 +0000"  >&lt;p&gt;We&apos;re only retaining them as long as an OPEN scanner could potentially be affected by them (kv.getMemstoreTS() &amp;gt; maxReadPointToTrackVersions), so should be OK. In fact we&apos;re doing the same for all other KVs as well. In &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5569&quot; title=&quot;Do not collect deleted KVs when they are still in use by a scanner.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5569&quot;&gt;&lt;del&gt;HBASE-5569&lt;/del&gt;&lt;/a&gt; I attempted to extend that logic to deleted rows, but I forgot the delete markers.&lt;/p&gt;

&lt;p&gt;I also ran TestReplication locally. Passes. Going to commit.&lt;/p&gt;

&lt;p&gt;Thanks for the patch Chunhui and the review/discussion Ram!&lt;/p&gt;</comment>
                            <comment id="13408200" author="lhofhansl" created="Fri, 6 Jul 2012 18:25:39 +0000"  >&lt;p&gt;Committed to 0.94 and 0.96.&lt;/p&gt;</comment>
                            <comment id="13408315" author="hudson" created="Fri, 6 Jul 2012 20:56:29 +0000"  >&lt;p&gt;Integrated in HBase-0.94 #302 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-0.94/302/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-0.94/302/&lt;/a&gt;)&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-6311&quot; title=&quot;Data error after majorCompaction caused by keeping MVCC for opened scanners&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-6311&quot;&gt;&lt;del&gt;HBASE-6311&lt;/del&gt;&lt;/a&gt; Data error after majorCompaction caused by keeping MVCC for opened scanners (chunhui shen) (Revision 1358333)&lt;/p&gt;

&lt;p&gt;     Result = FAILURE&lt;br/&gt;
larsh : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/branches/0.94/src/main/java/org/apache/hadoop/hbase/regionserver/ScanQueryMatcher.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.94/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13411160" author="hudson" created="Wed, 11 Jul 2012 02:36:55 +0000"  >&lt;p&gt;Integrated in HBase-0.94-security #39 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-0.94-security/39/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-0.94-security/39/&lt;/a&gt;)&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-6311&quot; title=&quot;Data error after majorCompaction caused by keeping MVCC for opened scanners&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-6311&quot;&gt;&lt;del&gt;HBASE-6311&lt;/del&gt;&lt;/a&gt; Data error after majorCompaction caused by keeping MVCC for opened scanners (chunhui shen) (Revision 1358333)&lt;/p&gt;

&lt;p&gt;     Result = SUCCESS&lt;br/&gt;
larsh : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/branches/0.94/src/main/java/org/apache/hadoop/hbase/regionserver/ScanQueryMatcher.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.94/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13428717" author="hudson" created="Sun, 5 Aug 2012 00:51:12 +0000"  >&lt;p&gt;Integrated in HBase-0.94-security-on-Hadoop-23 #6 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-0.94-security-on-Hadoop-23/6/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-0.94-security-on-Hadoop-23/6/&lt;/a&gt;)&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-6311&quot; title=&quot;Data error after majorCompaction caused by keeping MVCC for opened scanners&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-6311&quot;&gt;&lt;del&gt;HBASE-6311&lt;/del&gt;&lt;/a&gt; Data error after majorCompaction caused by keeping MVCC for opened scanners (chunhui shen) (Revision 1358333)&lt;/p&gt;

&lt;p&gt;     Result = FAILURE&lt;br/&gt;
larsh : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/branches/0.94/src/main/java/org/apache/hadoop/hbase/regionserver/ScanQueryMatcher.java&lt;/li&gt;
	&lt;li&gt;/hbase/branches/0.94/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    </comments>
                    <attachments>
                            <attachment id="12534560" name="HBASE-6311-test.patch" size="2208" author="zjushch" created="Tue, 3 Jul 2012 03:32:05 +0000"/>
                            <attachment id="12534567" name="HBASE-6311v1.patch" size="3256" author="zjushch" created="Tue, 3 Jul 2012 05:15:19 +0000"/>
                            <attachment id="12535148" name="HBASE-6311v2.patch" size="3309" author="zjushch" created="Thu, 5 Jul 2012 05:07:30 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 3 Jul 2012 04:23:31 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>245348</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310191" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Hadoop Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10343"><![CDATA[Reviewed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 years, 19 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i067yv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>34222</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>