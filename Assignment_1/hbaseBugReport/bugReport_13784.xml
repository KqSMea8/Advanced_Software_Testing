<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 20:46:37 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-13784/HBASE-13784.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-13784] Add Async Client Table API</title>
                <link>https://issues.apache.org/jira/browse/HBASE-13784</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;With the introduction of the Async HBase RPC Client it is possible to create an Async Table API and more. This issue is focussed on creating a first async Table API so it is possible to do any non deprecated Table call in an async way.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12833010">HBASE-13784</key>
            <summary>Add Async Client Table API</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="jurmous">Jurriaan Mous</assignee>
                                    <reporter username="jurmous">Jurriaan Mous</reporter>
                        <labels>
                    </labels>
                <created>Wed, 27 May 2015 11:12:15 +0000</created>
                <updated>Fri, 14 Oct 2016 03:40:25 +0000</updated>
                                                                                <due></due>
                            <votes>0</votes>
                                    <watches>19</watches>
                                                                <comments>
                            <comment id="14560792" author="jurmous" created="Wed, 27 May 2015 11:21:33 +0000"  >&lt;p&gt;First proposal for the Async Table API. &lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Only get is currently added to Table/HTable as asyncGet method which returns a promise. I would prefer to name it get(Get) but that conflicts with the existing method. Does anybody has a nice suggestion for async method names? Or should we create a new alternative AsyncTable with the methods?&lt;/li&gt;
	&lt;li&gt;Async calls return a ResponsePromise&amp;lt;Type&amp;gt;. This Promise is directly based on the Promise of Netty which extends Java Future so it works together with the Netty EventLoop. Any other type of Future or handlers would add overhead.&lt;/li&gt;
	&lt;li&gt;Internally the Async path does not work with the Google Protobuf RpcControllers but works directly with Promises that contain all metadata and cellScanners. So no need for PayloadCarryingRpcController to handle failures or RpcCallBacks. This saves some overhead on Async communication.&lt;/li&gt;
	&lt;li&gt;Read Replicas is not implemented yet but could easily be implemented because it already works with java Futures internally.&lt;/li&gt;
	&lt;li&gt;The blocking RpcClientImpl has currently no implementation for createRpcChannel and getEventLoop. It is in my opinion best to remove the blocking implementation instead of engineering fake alternatives.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14560795" author="jurmous" created="Wed, 27 May 2015 11:26:21 +0000"  >&lt;p&gt;Forgot to mention:&lt;/p&gt;

&lt;p&gt;RemoteHTable does not have an implementation for asyncGet. It is quite a task to also make an async client for the REST gateway. This would strengthen the argument to make a separate AsyncTable interface with methods which returns Promises. But before doing so I like your opinions on the directions chosen.&lt;/p&gt;</comment>
                            <comment id="14560989" author="jurmous" created="Wed, 27 May 2015 13:50:46 +0000"  >&lt;p&gt;New patch&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Added AsyncTable interface and implementation. It is now accessible from Connection. Removed the changes to Table, HTable, HTableWrapper and RemoteHTable.&lt;/li&gt;
	&lt;li&gt;Added Exists as second possible Async call. (Very alike Get, only uses a different MessageConverter)&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14561385" author="stack" created="Wed, 27 May 2015 18:05:44 +0000"  >&lt;p&gt;First, sweet!&lt;/p&gt;

&lt;p&gt;High-level, I think adding a new AsyncTable Interface is a clean way of bringing in this new functionality. It follows nicely the Table model: get one as you need it and then close when done (lightweight). Alternatives, ones you have already pondered, would be adding a marker Interface on Table &amp;#8211; say Async &amp;#8211; but then you&apos;d have to have methods named asyncGet in your Async Interface because you can&apos;t override if only the return is different... That&apos;d be ugly.&lt;/p&gt;

&lt;p&gt;Not sure I understand all that is going on but here are a few remarks on the patch:&lt;/p&gt;

&lt;p&gt;This would be nice:&lt;/p&gt;

&lt;p&gt;&quot;38	 * TODO: this class is actually tied to one region, because most of the paths make use of&lt;br/&gt;
39	 *       the regioninfo part of location when building requests. The only reason it works for&lt;br/&gt;
40	 *       multi-region requests (e.g. batch) is that they happen to not use the region parts.&lt;br/&gt;
41	 *       This could be done cleaner (e.g. having a generic parameter and 2 derived classes,&lt;br/&gt;
42	 *       RegionCallable and actual RegionServerCallable with ServerName.&quot;&lt;/p&gt;

&lt;p&gt;...because as you note, otherwise the TableName is superfluous here: &lt;/p&gt;

&lt;p&gt;  public AbstractRegionServerCallable(Connection connection, TableName tableName, byte[] row)&lt;/p&gt;

&lt;p&gt;We need this method below?&lt;/p&gt;

&lt;p&gt;	  protected void setLocation(final HRegionLocation location) {&lt;/p&gt;

&lt;p&gt;It can&apos;t figure it out internally? Has to have it passed in?&lt;/p&gt;

&lt;p&gt;The sleep, throwable, getExceptionMessageAdditionalDetail , etc., methods were there already?&lt;/p&gt;

&lt;p&gt;Should this be set on construction?&lt;/p&gt;

&lt;p&gt;	  abstract void setClientByServiceName(ServerName serviceName) throws IOException;&lt;/p&gt;

&lt;p&gt;Get a new instance if you want to connect to a different service?&lt;/p&gt;

&lt;p&gt;What is your understanding around how timeouts work now? Have you ported the mess we have in old client where we have retries and timeouts ... with it difficult to set an overall timeout on a connection attempt?&lt;/p&gt;


&lt;p&gt;On your other comments:&lt;/p&gt;

&lt;p&gt;+ I think it fine exposing netty internals; i.e. promise &amp;#8211; it well-known (You going to hook up the listener on promise as over here &lt;a href=&quot;https://github.com/jurmous/etcd4j/blob/master/src/client/java/mousio/client/promises/ResponsePromise.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/jurmous/etcd4j/blob/master/src/client/java/mousio/client/promises/ResponsePromise.java&lt;/a&gt; &amp;#8211; smile)&lt;br/&gt;
+ Regards, &quot;It is in my opinion best to remove the blocking implementation instead of engineering fake alternatives.&quot;, and have them blocking run using async and promise? That&apos;d be fine.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sduskis&quot; class=&quot;user-hover&quot; rel=&quot;sduskis&quot;&gt;Solomon Duskis&lt;/a&gt; Any input on new AsyncTable Interface?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=louiscryan&quot; class=&quot;user-hover&quot; rel=&quot;louiscryan&quot;&gt;Louis Ryan&lt;/a&gt; This route would jibe w/ the PoC you are doing?&lt;/p&gt;



</comment>
                            <comment id="14562659" author="jurmous" created="Thu, 28 May 2015 10:40:50 +0000"  >&lt;p&gt;Thanks for your comments! &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This would be nice:&lt;br/&gt;
&quot;38	* TODO: this class is actually tied to one region, because most of the paths make use of&lt;br/&gt;
39	* the regioninfo part of location when building requests. The only reason it works for&lt;br/&gt;
40	* multi-region requests (e.g. batch) is that they happen to not use the region parts.&lt;br/&gt;
41	* This could be done cleaner (e.g. having a generic parameter and 2 derived classes,&lt;br/&gt;
42	* RegionCallable and actual RegionServerCallable with ServerName.&quot;&lt;br/&gt;
...because as you note, otherwise the TableName is superfluous here:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That comment was already in RegionServerCallable which I renamed to AbstractRegionServerCallable to be able to make an Async version which shares code. So that good suggestion falls outside of my work &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We need this method below?&lt;br/&gt;
protected void setLocation(final HRegionLocation location) {&lt;br/&gt;
It can&apos;t figure it out internally? Has to have it passed in?&lt;/p&gt;

&lt;p&gt;We need this method below?&lt;br/&gt;
protected void setLocation(final HRegionLocation location) {&lt;br/&gt;
It can&apos;t figure it out internally? Has to have it passed in?&lt;br/&gt;
The sleep, throwable, getExceptionMessageAdditionalDetail , etc., methods were there already?&lt;br/&gt;
Should this be set on construction?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It was already there in the non abstract version of the class. Changing this flow falls outside of the scope of the issue. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;abstract void setClientByServiceName(ServerName serviceName) throws IOException;&lt;br/&gt;
Get a new instance if you want to connect to a different service?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes with the blocking variants it will set a Stub on prepare and with the async variant it will set an AsyncRpcChannel internally. Those channels are currently bound to the service due to the protocol. I left it up to the implementing class to actually set the right typed properties.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is your understanding around how timeouts work now? Have you ported the mess we have in old client where we have retries and timeouts ... with it difficult to set an overall timeout on a connection attempt?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;With the work I am doing I was trying to change as little as possible to the current behaviour. The current behaviour is implemented in the new RetryingResponsePromise.&lt;br/&gt;
It is also possible to do a timer (With Netty HashedWheelTimer) on the RetryingResponsePromise so it shuts down after some amount of time of waiting. Should I add an overall timeout to the RetryingResponsePromise? (It seems I forgot to add a stop after max amount of retries has been reached in current patch)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Louis Ryan This route would jibe w/ the PoC you are doing?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I just now discovered &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=louiscryan&quot; class=&quot;user-hover&quot; rel=&quot;louiscryan&quot;&gt;Louis Ryan&lt;/a&gt; his work. From what I can see is that Louis is building a new Client and Server RPC client based on GRPC. He builds on top of some abstractions I did while creating the AsyncRpcClient so is good to see it being used further. It is nice to have a generalized implementation of the RPC layer with HTTP2, Streams and things like extra GZip ChannelEncoders. &lt;/p&gt;

&lt;p&gt;A new async client table interface would in principle not conflict with his work although to make it as efficient as possible I am exposing some  internals of the async client like its internal promise and eventloop for promise creation on top of Netty Thread pool. With the code that I see in the github and GRPC async Calls it should be possible to add those constructs to his implementation. I have already abstracted the needed methods to interfaces and since his implementation is also Netty based it should be not difficult to add the methods to his GrpcClientImpl and expose an AsyncRpcChannel implementation to communicate with.&lt;/p&gt;</comment>
                            <comment id="14562929" author="jurmous" created="Thu, 28 May 2015 14:02:02 +0000"  >&lt;p&gt;I am looking into what and how to add actions to the AsyncTable. I would like to propose a bit different and simpler Api than is currently implemented in Table. All mutations go through mutate method and batch is eliminated. (I will ignore the coprocessor calls for now until the basic Api is clear)&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;exists(Get): ResponsePromise&amp;lt;Boolean&amp;gt;&lt;/li&gt;
	&lt;li&gt;exists(List&amp;lt;Get&amp;gt;): ResponsePromise&amp;lt;Boolean[]&amp;gt;&lt;/li&gt;
	&lt;li&gt;get(Get): ResponsePromise&amp;lt;Result&amp;gt;&lt;/li&gt;
	&lt;li&gt;get(List&amp;lt;Get&amp;gt;): ResponsePromise&amp;lt;Result[]&amp;gt;&lt;/li&gt;
	&lt;li&gt;mutate(Mutation): ResponsePromise&amp;lt;Void&amp;gt; - Instead of separate Put, Delete, Increment, IncrementValue and Append methods&lt;/li&gt;
	&lt;li&gt;mutate(List&amp;lt;Mutation&amp;gt;): ResponsePromise&amp;lt;Void&amp;gt; - Will not accept Append and Increment because of nonce requirement.&lt;/li&gt;
	&lt;li&gt;mutate(RowMutations): ResponsePromise&amp;lt;Void&amp;gt; - Will not accept Append and Increment&lt;/li&gt;
	&lt;li&gt;mutate(List&amp;lt;RowMutations&amp;gt;): ResponsePromise&amp;lt;Void&amp;gt; - Will not accept Append and Increment&lt;/li&gt;
	&lt;li&gt;checkAndMutate(byte[], byte[], byte[], CompareOp, byte[], Mutation): ResponsePromise&amp;lt;Void&amp;gt; - Will not accept Append and Increment&lt;/li&gt;
	&lt;li&gt;checkAndMutate(byte[], byte[], byte[], CompareOp, byte[], RowMutations): ResponsePromise&amp;lt;Void&amp;gt; - Will not accept Append and Increment&lt;/li&gt;
	&lt;li&gt;getScanner(Scan): ResponsePromise&amp;lt;Void&amp;gt; - AsyncResultScanner&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Mutate with multiple mutations will check the writeBuffer and write packages to each region if its writeBuffer limit is reached or when there are no mutations left.&lt;/p&gt;

&lt;p&gt;Instead of the batch calls I would like to introduce a Promise that can manage multiple promises which I would like to call it PromiseKeeper.  You add the promises of multiple calls to that PromiseKeeper and if all succeed that promise fires or if one fails that promise also fails. You can then get the results from an Array in the same order as you added the promises. This is also to replace the AsyncProcess.&lt;/p&gt;

&lt;p&gt;AsyncResultScanner. Am thinking of changing the workflow of the scanner for Async to better fit an Async workflow. Instead of next calls and an internal buffer I would like to create a nextBatch call and a way to set batch size. So this way the call and the result handling are combined. A promise on each next call makes no sense.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                            <comment id="14563727" author="stack" created="Thu, 28 May 2015 21:29:37 +0000"  >&lt;blockquote&gt;&lt;p&gt;With the work I am doing I was trying to change as little as possible to the current behaviour.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Fair enough.&lt;/p&gt;

&lt;p&gt;Suggestions for what might be improved upon given your now intimate knowledge of rpc appreciated as follow ons.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Should I add an overall timeout to the RetryingResponsePromise? (It seems I forgot to add a stop after max amount of retries has been reached in current patch)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well, we have timeouts and retries now (after you fix the &apos;stop&apos; missed in current patch?) Adding another timeout in RetryingResponsePromise would be on top of these?&lt;/p&gt;

&lt;p&gt;Thanks for taking a look at &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=louiscryan&quot; class=&quot;user-hover&quot; rel=&quot;louiscryan&quot;&gt;Louis Ryan&lt;/a&gt;&apos;s work.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I would like to propose a bit different and simpler Api than is currently implemented in Table. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No objection here.&lt;/p&gt;

&lt;p&gt;We need these?&lt;/p&gt;

&lt;p&gt;mutate(List&amp;lt;Mutation&amp;gt;): ResponsePromise&amp;lt;Void&amp;gt; - Will not accept Append and Increment because of nonce requirement.&lt;br/&gt;
mutate(RowMutations): ResponsePromise&amp;lt;Void&amp;gt; - Will not accept Append and Increment&lt;br/&gt;
mutate(List&amp;lt;RowMutations&amp;gt;): ResponsePromise&amp;lt;Void&amp;gt; - Will not accept Append and Increment&lt;/p&gt;

&lt;p&gt;Is it just because Append and Increment are not Mutations? Lets fix that rather than do above?&lt;/p&gt;

&lt;p&gt;How we fix it so you don&apos;t need RowMutation and Mutation?&lt;/p&gt;

&lt;p&gt;Otherwise, all looks good (PromiseKeeping and changing scan... FYI, Scan has had a bunch of work done since you were around last ... did you notice? It should be easier to fit it to your new form that previous).&lt;/p&gt;

&lt;p&gt;Suggest you float message on dev list to get more input on your new API set.&lt;/p&gt;

&lt;p&gt;Nice work &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jurmous&quot; class=&quot;user-hover&quot; rel=&quot;jurmous&quot;&gt;Jurriaan Mous&lt;/a&gt;&lt;/p&gt;
</comment>
                            <comment id="14564485" author="jurmous" created="Fri, 29 May 2015 09:47:53 +0000"  >&lt;blockquote&gt;&lt;p&gt;Well, we have timeouts and retries now (after you fix the &apos;stop&apos; missed in current patch?) Adding another timeout in RetryingResponsePromise would be on top of these?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well I think I will currently leave the logic alone and it can always be addressed in a follow-up issue. It seems I was mistaken with forgetting end-retry and missed that I copied some code of the current retry handler into its failure handler. So currently the async retry handler works as the current sync one.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We need these?&lt;br/&gt;
mutate(List&amp;lt;Mutation&amp;gt;): ResponsePromise&amp;lt;Void&amp;gt; - Will not accept Append and Increment because of nonce requirement.&lt;br/&gt;
mutate(RowMutations): ResponsePromise&amp;lt;Void&amp;gt; - Will not accept Append and Increment&lt;br/&gt;
mutate(List&amp;lt;RowMutations&amp;gt;): ResponsePromise&amp;lt;Void&amp;gt; - Will not accept Append and Increment&lt;br/&gt;
Is it just because Append and Increment are not Mutations? Lets fix that rather than do above?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Append and Increment are mutations but I think it was chosen in the current workflow to not handle them because they are nonce dependent and thus only allowed to be sent one at a time to prevent problems.&lt;/p&gt;

&lt;p&gt;I don&apos;t entirely like that there are 4 mutate methods. There are methods needed to send multiple Mutations either grouped by row by RowMutation or just a list of mutations to be able to write buffer them. (Since it is optimal to send multiple mutations in one request) &lt;br/&gt;
Maybe we could remove this functionality completely from AsyncTable and ask people to make an async BufferedMutator if they want to send multiple mutations. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt; (PromiseKeeping and changing scan... FYI, Scan has had a bunch of work done since you were around last ... did you notice? It should be easier to fit it to your new form that previous).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I am not aware of all changes so will certainly take a deeper look into those before trying to fit in an async workflow.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Suggest you float message on dev list to get more input on your new API set.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Will do!&lt;/p&gt;</comment>
                            <comment id="14564548" author="jurmous" created="Fri, 29 May 2015 10:36:03 +0000"  >&lt;p&gt;I sent out a mail to the mailinglist. Below my latest suggestion as I also added it to the mail. This version also includes a suggestion for the Coprocessor calls.&lt;/p&gt;

&lt;p&gt;I am currently proposing the following methods in the simpler AsyncTable interface:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;exists(Get): ResponsePromise&amp;lt;Boolean&amp;gt;&lt;/li&gt;
	&lt;li&gt;exists(List&amp;lt;Get&amp;gt;): ResponsePromise&amp;lt;Boolean[]&amp;gt;&lt;/li&gt;
	&lt;li&gt;get(Get): ResponsePromise&amp;lt;Result&amp;gt;&lt;/li&gt;
	&lt;li&gt;get(List&amp;lt;Get&amp;gt;): ResponsePromise&amp;lt;Result[]&amp;gt;&lt;/li&gt;
	&lt;li&gt;mutate(Mutation): ResponsePromise&amp;lt;Void&amp;gt; - Instead of separate Put, Delete, Increment, IncrementValue and Append methods&lt;/li&gt;
	&lt;li&gt;checkAndMutate(byte[], byte[], byte[], CompareOp, byte[], Mutation): ResponsePromise&amp;lt;Void&amp;gt; - Will not accept Append and Increment&lt;/li&gt;
	&lt;li&gt;checkAndMutate(byte[], byte[], byte[], CompareOp, byte[], RowMutations): ResponsePromise&amp;lt;Void&amp;gt; - Will not accept Append and Increment&lt;/li&gt;
	&lt;li&gt;getScanner(Scan): ResponsePromise&amp;lt;Void&amp;gt; - AsyncResultScanner&lt;/li&gt;
	&lt;li&gt;coprocessorService(byte[]): AsyncCoprocessorRpcService&lt;/li&gt;
	&lt;li&gt;coprocessorService(Class&amp;lt;T extends Service&amp;gt;, byte[] startkey, byte[] endkey, Batch.Call&amp;lt;T,R&amp;gt; callable): ResponsePromise&amp;lt;Map&amp;lt;byte[], R&amp;gt;&amp;gt;&lt;/li&gt;
	&lt;li&gt;batchCoprocessorService(Descriptors.MethodDescriptor, Message, byte[] startKey, byte[] endKey, R responsePrototype): ResponsePromise&amp;lt;Map&amp;lt;byte[], R&amp;gt;&amp;gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;To send multiple mutations you need to use a BufferedMutator which handles writeBuffers internally. I will look into making it possible to use it with Promises.&lt;/p&gt;

&lt;p&gt;Batch operations will be able to be done by a PromiseKeeper which is a promise to which other promises can be added.&lt;/p&gt;

&lt;p&gt;There will be a new AsyncResultScanner which handles incoming batches of result. It will not be possible to do next on it since this does not makes sense in an async context. There will be however a way to request a new batch with a promise.&lt;/p&gt;</comment>
                            <comment id="14567117" author="jurmous" created="Mon, 1 Jun 2015 10:01:37 +0000"  >&lt;ul&gt;
	&lt;li&gt;Added mutate to AsyncTable to support Put/Delete/Append/Increment&lt;/li&gt;
	&lt;li&gt;Refactored RpcRetryingCallerWithReadReplicas to work async so it can also be used in async context&lt;/li&gt;
	&lt;li&gt;Fixed issues with cancelation flow.&lt;/li&gt;
	&lt;li&gt;Added a SinglePromiseKeeper which is now used within RpcRetryingCallerWithReadReplicas&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14567275" author="jurmous" created="Mon, 1 Jun 2015 13:03:43 +0000"  >&lt;ul&gt;
	&lt;li&gt;Added PromiseKeeper&lt;/li&gt;
	&lt;li&gt;Added get and exists with List&amp;lt;Get&amp;gt; call&lt;/li&gt;
	&lt;li&gt;Added checkAndMutate calls.&lt;/li&gt;
	&lt;li&gt;Added tests&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;(Still missing: Scan and Coprocessor calls)&lt;/p&gt;

&lt;p&gt;I am thinking of letting HTable use the AsyncTable methods where the promise is called directly. Primarily so all the existing tests also test the new code but it will also probably give a better performance because of some removed abstractions from the Async RPC client. Is this ok?&lt;/p&gt;</comment>
                            <comment id="14568143" author="stack" created="Mon, 1 Jun 2015 22:27:38 +0000"  >&lt;blockquote&gt;&lt;p&gt;I am thinking of letting HTable use the AsyncTable methods where the promise is called directly.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry for being dumb but can you give example &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jurmous&quot; class=&quot;user-hover&quot; rel=&quot;jurmous&quot;&gt;Jurriaan Mous&lt;/a&gt; ? Thanks.&lt;/p&gt;
</comment>
                            <comment id="14569155" author="jurmous" created="Tue, 2 Jun 2015 14:29:16 +0000"  >&lt;ul&gt;
	&lt;li&gt;Added Coprocessor calls (coprocessorService and batchCoprocessorService)&lt;/li&gt;
	&lt;li&gt;RegionCoprocessorRpcChannel is now Async internally&lt;/li&gt;
	&lt;li&gt;A new KeyedPromiseKeeper for promises which need to be sorted on for example Region keys&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Remaining: the Scans, BufferedMutator and a new Table implementation which uses AsyncTable internally.&lt;/p&gt;</comment>
                            <comment id="14569166" author="jurmous" created="Tue, 2 Jun 2015 14:32:36 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt; I am still a bit doubting. I am thinking of either making a clean Table implementation using AsyncTable internally or using the AsyncTable already within HTable itself. I would then call the async method within the sync table call to fetch the promise. Something like the code below.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  @Override
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Result get(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Get get) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
    &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; asyncTable.get(get).get();
    } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
      &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; InterruptedIOException(e.getMessage());
    } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (ExecutionException e) {
      &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; (IOException) e.getCause();
    }
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For a new Table implementation to work within the tests I have to make sure Connection returns the new implementation and all relevant tests work through fetching a table through Connection. This way I am certain the new Api is all ok against all existing tests. It is too difficult to replicate all the Api tests.&lt;/p&gt;</comment>
                            <comment id="14571911" author="stack" created="Thu, 4 Jun 2015 00:42:29 +0000"  >&lt;blockquote&gt;&lt;p&gt;I am thinking of either making a clean Table implementation using AsyncTable internally or using the AsyncTable already within HTable itself.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok. Yes, it would be nice if you could slot in your AsyncTable everywhere to make sure it works in &apos;sync&apos; mode blocking on the promise. Can you use junit parameterize (&lt;a href=&quot;http://junit.org/apidocs/org/junit/runners/Parameterized.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://junit.org/apidocs/org/junit/runners/Parameterized.html&lt;/a&gt;) so tests run with current HTable implementation and then again with your Async&apos;d HTable Implementation?&lt;/p&gt;

&lt;p&gt;You could choose a few of the important client-side junits and have the work in the two modes?&lt;/p&gt;

&lt;p&gt;Looking at TestFromClientSide, probably the biggest client-side set of tests, it still has a bunch of deprecated &apos;new HTable&apos; usage. I could help by doing cleanup on this test so it all went via Connection to get Table instances..  Would then have to jigger Connection and ConnectionFactory per parameterized run to return pure HTable for one run as it does now and then your fancy async&apos;y version for the next run. &lt;/p&gt;

&lt;p&gt;If you make a list of junit test suites you&apos;d like to parameterize and note obstacles to your getting your AsyncTable in under them, I can help with unblocking your obstacles.&lt;/p&gt;

&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jurmous&quot; class=&quot;user-hover&quot; rel=&quot;jurmous&quot;&gt;Jurriaan Mous&lt;/a&gt;&lt;/p&gt;



</comment>
                            <comment id="14571913" author="stack" created="Thu, 4 Jun 2015 00:43:44 +0000"  >&lt;p&gt;If you want feedback on current state of patch, add it to reviews.apache.org and paste link here and I (or others) can you a bit of feedback. Thanks.&lt;/p&gt;</comment>
                            <comment id="14580350" author="jurmous" created="Wed, 10 Jun 2015 10:21:11 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Ok. Yes, it would be nice if you could slot in your AsyncTable everywhere to make sure it works in &apos;sync&apos; mode blocking on the promise. Can you use junit parameterize (&lt;a href=&quot;http://junit.org/apidocs/org/junit/runners/Parameterized.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://junit.org/apidocs/org/junit/runners/Parameterized.html&lt;/a&gt;) so tests run with current HTable implementation and then again with your Async&apos;d HTable Implementation?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Somehow I didn&apos;t yet know of the Parameterized Junit tests. It seems like a good solution for this problem. I will look into it.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If you want feedback on current state of patch, add it to reviews.apache.org and paste link here and I (or others) can you a bit of feedback. Thanks.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Will do with the next patch.&lt;/p&gt;</comment>
                            <comment id="14580365" author="jurmous" created="Wed, 10 Jun 2015 10:32:42 +0000"  >&lt;ul&gt;
	&lt;li&gt;Refactored ScannerCallable and ScannerCallableWithReplicas so they work Async internally. Current ClientScanners use them and current tests work.&lt;/li&gt;
	&lt;li&gt;Created new Async variants of the ClientScanners and added them to AsyncTable.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;AsyncTable Api now has all planned calls.&lt;/p&gt;

&lt;p&gt;Left to do: BufferedMutator, an internally async Table implementation and tests that use it.&lt;/p&gt;

&lt;p&gt;Question: What is a good name for the PromiseKeepers? I learned it is a loaded term.&lt;/p&gt;

&lt;p&gt;Review:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/35292/diff/#&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/35292/diff/#&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14580899" author="stack" created="Wed, 10 Jun 2015 18:10:41 +0000"  >&lt;blockquote&gt;&lt;p&gt;Question: What is a good name for the PromiseKeepers? I learned it is a loaded term.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Don&apos;t worry about it. It is generic. I just cited a specific instance of a once rising culturally &apos;interesting&apos; use of the term.&lt;/p&gt;</comment>
                            <comment id="14583666" author="jurmous" created="Fri, 12 Jun 2015 16:44:06 +0000"  >&lt;ul&gt;
	&lt;li&gt;Fixed review issues&lt;/li&gt;
	&lt;li&gt;Renamed ResponsePromise to Future.&lt;/li&gt;
	&lt;li&gt;Remove exist calls&lt;/li&gt;
	&lt;li&gt;Added a new TableImpl for a sync version.&lt;/li&gt;
	&lt;li&gt;Added batchCoprocessorService with callback call&lt;/li&gt;
	&lt;li&gt;Added mutate with RowMutations&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14585796" author="jurmous" created="Mon, 15 Jun 2015 11:17:58 +0000"  >&lt;blockquote&gt;&lt;p&gt;When we thinking asynctable would show up? 1.3 or 2.0? It is too late for 1.2. It is likely too disruptive for 1.3.. though if all tests pass and asynctable is additive and doesn&apos;t significantly disturb blocking HTable implementation, it could come in for 1.3.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;(I put reply here)&lt;/p&gt;

&lt;p&gt;One thing that is not done with this patch is that we need to delete the sync RpcClient implementation. I am thinking to make a separate patch for that. (Currently there are some TODOs in the patch where implementations are missing) Many async internals will fail with that client handling the calls. Maybe AsyncRpcClient is now faster since it removes an abstraction layer. The current code does disturb a bit of the replica and the Scanner code. (ScannerCallable, ScannerCallableWithReplica is used within current code) &lt;/p&gt;

&lt;p&gt;So replacing the default RpcClient without fallback together with some changes internally in scans is maybe to disruptive for 1.3. Or maybe we can do some performance tests before really deciding. What is the current schedule for 2.0 and 1.3?&lt;/p&gt;

&lt;p&gt;I await the landing of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-13893&quot; title=&quot;Replace HTable with Table in client tests&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-13893&quot;&gt;&lt;del&gt;HBASE-13893&lt;/del&gt;&lt;/a&gt; before continuing the work on this patch. I need the changes to the tests so I can implement the Async Table tests.&lt;/p&gt;</comment>
                            <comment id="14586062" author="jurmous" created="Mon, 15 Jun 2015 13:55:39 +0000"  >&lt;p&gt;Added &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-13902&quot; title=&quot;Remove Sync RpcClientImpl&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-13902&quot;&gt;HBASE-13902&lt;/a&gt; to remove the Sync RpcClientImpl which is needed for this issue to land.&lt;/p&gt;</comment>
                            <comment id="14587889" author="jurmous" created="Tue, 16 Jun 2015 11:19:02 +0000"  >&lt;ul&gt;
	&lt;li&gt;Implemented Async Channels and RpcChannels in RpcClientImpl so the RpcClientImpl also can do Async calls now. It works on top of a Netty EventLoop.&lt;/li&gt;
	&lt;li&gt;Renamed EventLoop methods to EventExecutor methods to use the most generic possible type.&lt;/li&gt;
	&lt;li&gt;Async Scanners now return null when they are out of results instead of need to call isDone().&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14697975" author="stack" created="Sat, 15 Aug 2015 00:00:40 +0000"  >&lt;p&gt;I owe you a review &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jurmous&quot; class=&quot;user-hover&quot; rel=&quot;jurmous&quot;&gt;Jurriaan Mous&lt;/a&gt;? (Was out, sorry).&lt;/p&gt;</comment>
                            <comment id="15265728" author="jurmous" created="Sun, 1 May 2016 11:25:45 +0000"  >&lt;p&gt;I want to finish the work on this patch. Currently it is not compatible with the latest master. &lt;/p&gt;

&lt;p&gt;I now want to break it up to several sub issues so the work gets committed more easily. It is possible to break up the patch in several subtasks like refactoring some of the classes so they can be reused, add the needed extra calls to the RPC Clients, remove RpcControllerFactory from all the scans, some smaller code enhancements etc. So expect some smaller issues referring to this issue in the coming time. The good thing is that some (or very maybe all) parts can be considered for the 1.x branch.&lt;/p&gt;</comment>
                            <comment id="15266221" author="hudson" created="Mon, 2 May 2016 08:22:37 +0000"  >&lt;p&gt;FAILURE: Integrated in HBase-Trunk_matrix #885 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-Trunk_matrix/885/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-Trunk_matrix/885/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15744&quot; title=&quot;Port over small format/text improvements from HBASE-13784&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15744&quot;&gt;&lt;del&gt;HBASE-15744&lt;/del&gt;&lt;/a&gt; Port over small format/text improvements from &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-13784&quot; title=&quot;Add Async Client Table API&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-13784&quot;&gt;HBASE-13784&lt;/a&gt; (stack: rev 15631a76f5404728ee7f9683668038700f3cda4a)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/RpcClient.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/RpcRetryingCallerWithReadReplicas.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestFromClientSide.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/RpcRetryingCaller.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                                                <inwardlinks description="is blocked by">
                                        <issuelink>
            <issuekey id="12979751">HBASE-16041</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12997824">HBASE-16432</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                            <outwardlinks description="incorporates">
                                        <issuelink>
            <issuekey id="12971870">HBASE-15875</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12965886">HBASE-15798</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12956828">HBASE-15610</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12964147">HBASE-15745</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12965812">HBASE-15793</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12974125">HBASE-15921</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12964143">HBASE-15744</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13012229">HBASE-16833</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12739279" name="ClientScanner-class-diagram.png" size="121704" author="jurmous" created="Fri, 12 Jun 2015 16:44:06 +0000"/>
                            <attachment id="12735599" name="HBASE-13784-v1.patch" size="154692" author="jurmous" created="Wed, 27 May 2015 13:50:46 +0000"/>
                            <attachment id="12736535" name="HBASE-13784-v2.patch" size="181365" author="jurmous" created="Mon, 1 Jun 2015 10:03:19 +0000"/>
                            <attachment id="12736550" name="HBASE-13784-v3.patch" size="208460" author="jurmous" created="Mon, 1 Jun 2015 13:03:43 +0000"/>
                            <attachment id="12736849" name="HBASE-13784-v4.patch" size="257804" author="jurmous" created="Tue, 2 Jun 2015 14:29:16 +0000"/>
                            <attachment id="12738793" name="HBASE-13784-v5.patch" size="444343" author="jurmous" created="Wed, 10 Jun 2015 10:32:42 +0000"/>
                            <attachment id="12739280" name="HBASE-13784-v6.patch" size="466817" author="jurmous" created="Fri, 12 Jun 2015 16:44:06 +0000"/>
                            <attachment id="12739843" name="HBASE-13784-v7.patch" size="479449" author="jurmous" created="Tue, 16 Jun 2015 11:19:02 +0000"/>
                            <attachment id="12735578" name="HBASE-13784.patch" size="145820" author="jurmous" created="Wed, 27 May 2015 11:21:33 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 27 May 2015 18:05:44 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            32 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2f8zz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>