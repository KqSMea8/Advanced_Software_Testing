<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:15:05 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-4015/HBASE-4015.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-4015] Refactor the TimeoutMonitor to make it less racy</title>
                <link>https://issues.apache.org/jira/browse/HBASE-4015</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;The current implementation of the TimeoutMonitor acts like a race condition generator, mostly making things worse rather than better. It does it&apos;s own thing for a while without caring for what&apos;s happening in the rest of the master.&lt;/p&gt;

&lt;p&gt;The first thing that needs to happen is that the regions should not be processed in one big batch, because that sometimes can take minutes to process (meanwhile a region that timed out opening might have opened, then what happens is it will be reassigned by the TimeoutMonitor generating the never ending PENDING_OPEN situation).&lt;/p&gt;

&lt;p&gt;Those operations should also be done more atomically, although I&apos;m not sure how to do it in a scalable way in this case.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12511169">HBASE-4015</key>
            <summary>Refactor the TimeoutMonitor to make it less racy</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12501743">HBASE-3669</parent>
                                    <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.png">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="ram_krish">ramkrishna.s.vasudevan</assignee>
                                    <reporter username="jdcryans">Jean-Daniel Cryans</reporter>
                        <labels>
                    </labels>
                <created>Tue, 21 Jun 2011 21:19:34 +0000</created>
                <updated>Fri, 20 Nov 2015 11:56:03 +0000</updated>
                            <resolved>Thu, 8 Sep 2011 17:07:56 +0000</resolved>
                                    <version>0.90.3</version>
                                    <fixVersion>0.92.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                <comments>
                            <comment id="13072162" author="yuzhihong@gmail.com" created="Thu, 28 Jul 2011 03:56:28 +0000"  >&lt;p&gt;Shall we punt this to 0.94 ?&lt;/p&gt;</comment>
                            <comment id="13072166" author="stack" created="Thu, 28 Jul 2011 04:06:16 +0000"  >&lt;p&gt;No.  Too important.&lt;/p&gt;</comment>
                            <comment id="13079990" author="yuzhihong@gmail.com" created="Fri, 5 Aug 2011 14:23:02 +0000"  >&lt;p&gt;Nice writeup, Ramkrishna.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;If the RE_ALLOCATE state gets timeout we will again call RE_ALLOCATE with new RS address.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;What if timeout happens for all available region servers ?&lt;br/&gt;
We should prevent region from bouncing endlessly.&lt;/p&gt;</comment>
                            <comment id="13080006" author="ram_krish" created="Fri, 5 Aug 2011 15:12:58 +0000"  >&lt;p&gt;@Ted,&lt;br/&gt;
Thanks for your review and comments.&lt;br/&gt;
So the point here is if the Region is not getting assigned(or allocated) at all even after changing the state to RE_ALLOCATE many times do we throw some error?&lt;br/&gt;
So the number of times RE_ALLOCATE is done should be configurable after which we need to throw error.  Correct me if am wrong Ted.&lt;/p&gt;</comment>
                            <comment id="13080036" author="yuzhihong@gmail.com" created="Fri, 5 Aug 2011 15:52:46 +0000"  >&lt;p&gt;I would choose total number of region servers to be the limit beyond which master stops assigning the same region.&lt;/p&gt;</comment>
                            <comment id="13080355" author="yuzhihong@gmail.com" created="Sat, 6 Aug 2011 04:54:15 +0000"  >&lt;blockquote&gt;&lt;p&gt;Also if the RS1 which was not able to process OFFLINE to OPENING finds that its state has changed to RE_ALLOCATE ...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I think there is a short window for race condition here:&lt;br/&gt;
1. master tries to change state to RE_ALLOCATE&lt;br/&gt;
2. RS1 recovers and tries to change state to OPENING&lt;br/&gt;
1 and 2 may happen at the same time.&lt;/p&gt;</comment>
                            <comment id="13080402" author="ram_krish" created="Sat, 6 Aug 2011 11:59:04 +0000"  >&lt;p&gt;@Ted,&lt;br/&gt;
I got your point.  Actually we are planning to lookup once again after setting any state so that whatever was the intended state that has really been set in the ZK.&lt;br/&gt;
If master tries to change to RE_ALLOCATE it will issue the command to ZK.  By the time the RS would have changed it to OPENING.&lt;/p&gt;

&lt;p&gt;Now the master will once again check if the state is RE_ALLOCATE .  If yes the operation is successful if not(RS has changed to OPENING) the master will update his inmemory state to OPENING and will wait on this state to change.&lt;br/&gt;
Similar is the case with RS.&lt;/p&gt;

&lt;p&gt;(Even checking for the version also can be done by comparing with the version that was got from ZK and the version that the Master or RS has really intended to set).&lt;/p&gt;

&lt;p&gt;In one of the ZK LeaderElection algo we did something similar to this.  One guy will create a sequential node.  Will know what is the node he created.&lt;br/&gt;
If someother guy at the same time has created another sequential node in the same path just before the first guy had created, the first guy&apos;s node id will be greater than the second guy apparently the second guy wins the race.&lt;/p&gt;

&lt;p&gt;Is it fine Ted? Do correct me if this is wrong.  Also if i could figure something better i would post it.  Thanks Ted.&lt;/p&gt;</comment>
                            <comment id="13080407" author="yuzhihong@gmail.com" created="Sat, 6 Aug 2011 14:06:23 +0000"  >&lt;p&gt;The verification of state is what I was thinking.&lt;br/&gt;
Good job Ramkrishna.&lt;/p&gt;</comment>
                            <comment id="13081859" author="stack" created="Tue, 9 Aug 2011 19:26:10 +0000"  >&lt;p&gt;I like this diagram of yours Ram.&lt;/p&gt;

&lt;p&gt;Do we need new RS_ALLOCATE state?  Could we just have OFFLINE plus your suggestion of adding RS name so its OFFLINE+RS_TO_OPEN_REGION_ON?  What happens if we assign the region back to RS1 (it can happen).&lt;/p&gt;</comment>
                            <comment id="13082242" author="ram_krish" created="Wed, 10 Aug 2011 09:15:19 +0000"  >&lt;p&gt;@Stack, &lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;Do we need new RS_ALLOCATE state? Could we just have OFFLINE plus your suggestion of adding RS name so its OFFLINE+RS_TO_OPEN_REGION_ON?
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Yes this may also be possible.  But we thought of introducing a new state so that there is a clear distinction whether reallocation has happened or not and also handling of the new state may be cleaner than changing the behaviour in the existing state.&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;What happens if we assign the region back to RS1 (it can happen).
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Yes.  we have considered this scenario also.  If the region is reallocated to the same RS there are two flows&lt;/p&gt;

&lt;p&gt;-&amp;gt; If the state is OPENING in zk but it is still not added to online regions list in RS then any subsequent call from MASTER to RS with RE_ALLOCATE state will succeed but the previous processing from OPENING to OPEN will fail.&lt;br/&gt;
-&amp;gt; In the second case if the region is added to the online regions list then the RS will say ALREADY_OPENED and before removing from RIT in master we will check if the node is deleted if not it will not be removed from RIT. Hence the state will be in  PENDING_OPEN so subsequent timeout monitor call will handle it.&lt;/p&gt;

&lt;p&gt;Pls provide your suggestions.&lt;/p&gt;</comment>
                            <comment id="13082353" author="ram_krish" created="Wed, 10 Aug 2011 14:04:02 +0000"  >&lt;p&gt;I have not written any testcases to cover this.  Planning to write a testcase.  hopefully will write one covering the scenarios.&lt;/p&gt;</comment>
                            <comment id="13082370" author="yuzhihong@gmail.com" created="Wed, 10 Aug 2011 14:42:52 +0000"  >&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+      CatalogTracker catalogTracker, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; ExecutorService service, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; java.util.concurrent.ExecutorService threadPoolExecutorService)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Wrap line please.&lt;br/&gt;
Why do we use two ExecutorService classes ?&lt;/p&gt;</comment>
                            <comment id="13082463" author="ram_krish" created="Wed, 10 Aug 2011 16:49:16 +0000"  >&lt;p&gt;Thanks for the comments Ted.&lt;br/&gt;
sorry for missing this line wrap &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
One executor service is part of hbase, the other one is needed for future task execution.  I went through the code of ExecutorService in hbase.  It was used to do some eventhandling.  &lt;br/&gt;
So i thought of using Java threadpool executor service.&lt;/p&gt;</comment>
                            <comment id="13082559" author="stack" created="Wed, 10 Aug 2011 18:49:53 +0000"  >&lt;blockquote&gt;&lt;p&gt;But we thought of introducing a new state so that there is a clear distinction whether reallocation has happened or not and also handling of the new state may be cleaner than changing the behaviour in the existing state.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I would not be worried about changing current states.  All of this stuff is transient in zk and it&apos;ll be in 0.92 requiring restart so change the states.&lt;/p&gt;

&lt;p&gt;Adding new REALLOC state seems gratuitous (I don&apos;t see the diff from OFFLINE; OFFLINE+servername might help in some cases).  More states make it harder to chase down all transition scenarios.&lt;/p&gt;

&lt;p&gt;Looking at the diagram again, I&apos;m not sure it addresses the issue.&lt;/p&gt;

&lt;p&gt;Do we even need the new state to address the core timeout monitor race issue?  The regionserver already is careful about checking states AND version number; i.e. if not expected state it will give up on opening or if not expected version it will close a region it has already opened.&lt;/p&gt;

&lt;p&gt;The core prob. as per J-D above is that state transitions happen fine out on the regionserver but the master lags processing them; meantime the timeout monitor runs and presumes since its not seen the transition (that is likely in queue to process), it preempts znode setting it OFFLINE.&lt;/p&gt;


</comment>
                            <comment id="13082970" author="ram_krish" created="Thu, 11 Aug 2011 07:06:26 +0000"  >&lt;p&gt;@Stack&lt;br/&gt;
Thanks for your review.&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;The core prob. as per J-D above is that state transitions happen fine out on the regionserver but the master lags processing them; meantime the timeout monitor runs and presumes since its not seen the transition (that is likely in queue to process), it preempts znode setting it OFFLINE.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I would like to clarify one problem here&lt;br/&gt;
-&amp;gt;Timeout monitor &lt;font color=&quot;red&quot;&gt;DOESNOT&lt;/font&gt; preempt an znode to OFFLINE if in PENDING_OPEN state.&lt;br/&gt;
&apos; assign(e.getKey(), false, e.getValue());&apos;&lt;br/&gt;
Here we pass false for the setOfflineInZK.&lt;br/&gt;
If you see the comments in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3937&quot; title=&quot;Region PENDING-OPEN timeout with un-expected ZK node state leads to an endless loop&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3937&quot;&gt;&lt;del&gt;HBASE-3937&lt;/del&gt;&lt;/a&gt; JD had pointed out like making this &lt;font color=&quot;red&quot;&gt;&apos;true&apos; will lead to double assignment.&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Our soln has been drafted after carefully analysing and reproducing based on JD&apos;s comment in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3937&quot; title=&quot;Region PENDING-OPEN timeout with un-expected ZK node state leads to an endless loop&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3937&quot;&gt;&lt;del&gt;HBASE-3937&lt;/del&gt;&lt;/a&gt; &lt;br/&gt;
and logs from the issue.&lt;/p&gt;


&lt;p&gt;I would like to discuss on logs the of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3937&quot; title=&quot;Region PENDING-OPEN timeout with un-expected ZK node state leads to an endless loop&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3937&quot;&gt;&lt;del&gt;HBASE-3937&lt;/del&gt;&lt;/a&gt; to be more specific on why the change has been done like this.&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;RS1 logs
========
2011-05-20 15:48:02,879 DEBUG org.apache.hadoop.hbase.zookeeper.ZKAssign: regionserver:20020-0x3300c164fe0002c Successfully transitioned node d7555a12586e6c788ca55017224b5a51 from M_ZK_REGION_OFFLINE to RS_ZK_REGION_OPENING
2011-05-20 15:48:02,879 DEBUG org.apache.hadoop.hbase.regionserver.HRegion: Opening region: REGION =&amp;gt; {NAME =&amp;gt; &apos;ufdr,010066,1305873715825.9361f58931a310a62c15f501ce3261b6.&apos;, STARTKEY =&amp;gt; &apos;010066&apos;, ENDKEY =&amp;gt; &apos;010068&apos;, ENCODED =&amp;gt; 9361f58931a310a62c15f501ce3261b6, TABLE =&amp;gt; {{NAME =&amp;gt; &apos;ufdr&apos;, FAMILIES =&amp;gt; [{NAME =&amp;gt; &apos;value&apos;, BLOOMFILTER =&amp;gt; &apos;NONE&apos;, REPLICATION_SCOPE =&amp;gt; &apos;0&apos;, VERSIONS =&amp;gt; &apos;3&apos;, COMPRESSION =&amp;gt; &apos;GZ&apos;, TTL =&amp;gt; &apos;432000&apos;, BLOCKSIZE =&amp;gt; &apos;65536&apos;, IN_MEMORY =&amp;gt; &apos;false&apos;, BLOCKCACHE =&amp;gt; &apos;true&apos;}]}}
2011-05-20 15:48:02,879 DEBUG org.apache.hadoop.hbase.regionserver.HRegion: Opening region: REGION =&amp;gt; {NAME =&amp;gt; &apos;ufdr,001570,1305873689710.d7555a12586e6c788ca55017224b5a51.&apos;, STARTKEY =&amp;gt; &apos;001570&apos;, ENDKEY =&amp;gt; &apos;001572&apos;, ENCODED =&amp;gt; d7555a12586e6c788ca55017224b5a51, TABLE =&amp;gt; {{NAME =&amp;gt; &apos;ufdr&apos;, FAMILIES =&amp;gt; [{NAME =&amp;gt; &apos;value&apos;, BLOOMFILTER =&amp;gt; &apos;NONE&apos;, REPLICATION_SCOPE =&amp;gt; &apos;0&apos;, VERSIONS =&amp;gt; &apos;3&apos;, COMPRESSION =&amp;gt; &apos;GZ&apos;, TTL =&amp;gt; &apos;432000&apos;, BLOCKSIZE =&amp;gt; &apos;65536&apos;, IN_MEMORY =&amp;gt; &apos;false&apos;, BLOCKCACHE =&amp;gt; &apos;true&apos;}]}}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;

2011-05-20 15:49:58,134 ERROR org.apache.hadoop.hbase.regionserver.handler.OpenRegionHandler: Failed open of region=ufdr,010066,1305873715825.9361f58931a310a62c15f501ce3261b6.
java.io.IOException: Exception occured while connecting to the server
	at com.huawei.isap.ump.ha.client.RPCRetryAndSwitchInvoker.retryOperation(RPCRetryAndSwitchInvoker.java:162)
	at com.huawei.isap.ump.ha.client.RPCRetryAndSwitchInvoker.handleFailure(RPCRetryAndSwitchInvoker.java:118)
	at com.huawei.isap.ump.ha.client.RPCRetryAndSwitchInvoker.invoke(RPCRetryAndSwitchInvoker.java:95)
	at $Proxy6.getFileInfo(Unknown Source)
	at org.apache.hadoop.hdfs.DFSClient.getFileInfo(DFSClient.java:889)
	at org.apache.hadoop.hdfs.DistributedFileSystem.getFileStatus(DistributedFileSystem.java:724)
	at org.apache.hadoop.fs.FileSystem.exists(FileSystem.java:812)
	at org.apache.hadoop.hbase.regionserver.HRegion.checkRegioninfoOnFilesystem(HRegion.java:409)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;RS1 logs (Failed to open here)
==============================
2011-05-20 17:00:37,753 WARN org.apache.hadoop.hbase.regionserver.handler.OpenRegionHandler: Failed transition from OFFLINE to OPENING for region=9361f58931a310a62c15f501ce3261b6
2011-05-20 17:00:37,753 WARN org.apache.hadoop.hbase.regionserver.handler.OpenRegionHandler: Region was hijacked? It no longer exists, encodedName=9361f58931a310a62c15f501ce3261b6
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;RS2 logs (Failed to open here)
=============================
2011-05-20 16:54:41,385 WARN org.apache.hadoop.hbase.regionserver.handler.OpenRegionHandler: Failed transition from OFFLINE to OPENING for region=9361f58931a310a62c15f501ce3261b6
2011-05-20 16:54:41,385 WARN org.apache.hadoop.hbase.regionserver.handler.OpenRegionHandler: Region was hijacked? It no longer exists, encodedName=9361f58931a310a62c15f501ce3261b6
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;RS3 logs (Failed to open here)
==============================
2011-05-20 16:45:29,477 WARN org.apache.hadoop.hbase.regionserver.handler.OpenRegionHandler: Failed transition from OFFLINE to OPENING for region=d7555a12586e6c788ca55017224b5a51
2011-05-20 16:45:29,477 WARN org.apache.hadoop.hbase.regionserver.handler.OpenRegionHandler: Region was hijacked? It no longer exists, encodedName=d7555a12586e6c788ca55017224b5a51
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here the state of the node is changed from OFFLINE to OPENING.&lt;br/&gt;
But before the operation has failed the Timeoutmonitor deducts it but thinks it to be PENDING_OPEN though&lt;br/&gt;
the change has happened to RS_OPENING in ZNode.&lt;br/&gt;
May be if it had found it to be OPENING then it would have moved it to OFFLINE state in znode.&lt;/p&gt;

&lt;p&gt;As master doesnot preempt to OFFLINE and the master in memory state is PENDING_OPEN(Here there is no one to remove the RIT so the timoutmonitor continues to deduct as PENDING_OPEN), everytime this region is considered to be hijacked and no one processes&lt;br/&gt;
it.  Even if the request goes to the same RS.&lt;/p&gt;

&lt;p&gt;I just want to reiterate the comments given by JD in the defect &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3937&quot; title=&quot;Region PENDING-OPEN timeout with un-expected ZK node state leads to an endless loop&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3937&quot;&gt;&lt;del&gt;HBASE-3937&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt; It should not create a list of unassigns and assigns, since by the time the list is processed the situation probably changed (I witnessed that a lot).
 This means the action should be taken as we go through first loop.&apos;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; This is what our patch does.  No batch processing is done.  We try to take action as and when we deduct a timeout has occured.&lt;br/&gt;
 But again this may not be fool proof. Because there is a chance like as in the above case the timeout&lt;br/&gt;
 deducts it to be PENDING_OPEN but as we dont move the node to OFFLINE(In master&apos;s memory the state&lt;br/&gt;
 is PENDING_OPEN) the RS will say the region is hijacked&lt;br/&gt;
 as it cannot transit from OFFLINE to OPENING and hence the problem prevails.&lt;/p&gt;


&lt;p&gt; Coming back to JD&apos;s comments again&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt; One of the major issues is the lack of atomicity, so any action taken should first check the current state, keep the version number, decide of the corrective measure and update the znode by expecting the version it first got.
 &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt; Now comes the issue of how to know the exact state that the znode is currently in and what action to take.&lt;br/&gt;
 If we again move to OFFLINE then there may be problem of double assignment.&lt;br/&gt;
 So we need to manage with some versions as JD told.  &lt;br/&gt;
 Here instead of versions we opted for a new state following are the reasons&lt;/p&gt;
 &lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;	// Initialize the znode version.
      this.version =
        ZKAssign.transitionNodeOpening(server.getZooKeeper(),
          regionInfo, server.getServerName());
 &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; -&amp;gt;RS doesnt have any previous version history here.  So comparing the new OFFLINE state and the&lt;br/&gt;
 prev offline state may be tricky.(needs some tweaking)&lt;br/&gt;
 -&amp;gt;Introducing an intermediate state here would bring more clarity to the code and system.&lt;br/&gt;
 Thats why we planned to introduce RE_ALLOCATE. Adding the servername is an additional precaution.&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;If the updating of the znode is successful, we know for sure that the operation will be seen by the region servers.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt; So now what we do is deduct timeout, try moving the state of znode to a RE_ALLOCATE.&lt;br/&gt;
 If really successfull all the RS will know that some updation has happened.&lt;br/&gt;
 Now another RS(or same RS) has the chance to operate on this new state and will not say as hijacked.&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;If it&apos;s not successful, the situation needs to be reassessed.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; If changing state to RE_ALLOCATE is not successful then what. Now master is aware the RS has operated on the region and changed it to another state may to OPENING or OPENED.&lt;/p&gt;

&lt;p&gt; As we cannot move the state to OFFLINE in zknode we are forced to have some mechanism between&lt;br/&gt;
 the RS and master to handle this problem.  Hence the new state RE_ALLOCATE came into&lt;br/&gt;
 picture.&lt;/p&gt;

&lt;p&gt; Thus our current implementation not only address the time lag but also clear atomicity is maintained.&lt;/p&gt;

&lt;p&gt;Stack, am i clear in my explanation?&lt;br/&gt;
Actually before proposing the soln we went thro JD&apos;s comments analysed the logs and then we wnated&lt;br/&gt;
to take care of all the comments as per JD and infact reproduced all the problems.&lt;/p&gt;</comment>
                            <comment id="13082974" author="ram_krish" created="Thu, 11 Aug 2011 07:09:58 +0000"  >&lt;p&gt;Stack&lt;/p&gt;

&lt;p&gt;After seeing the explanation if you still feel OFFLINE state+RS address will be better, i will dig in more into it and check the value addition and let you know.&lt;/p&gt;</comment>
                            <comment id="13083965" author="stack" created="Fri, 12 Aug 2011 06:15:12 +0000"  >&lt;blockquote&gt;&lt;p&gt;Timeout monitor DOESNOT preempt an znode to OFFLINE if in PENDING_OPEN state.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok.&lt;/p&gt;

&lt;p&gt;I think I understand now.  The addition of new state breaks the move to OPENING because the check for a previous OFFLINE state will fail... so the RS will no proceed with the open.&lt;/p&gt;

&lt;p&gt;But in fig (iii) in your doc. you check previous state is REALLOCATE? How is this case different from the fig &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; where you check for OFFLINE?  Won&apos;t your code have to check for both REALLOCATE and OFFLINE and the presence of either mean its ok to procede to OPENING (and then aren&apos;t REALLOCATE and OFFLINE the &apos;same&apos; state because the presence of either will mean proceed to OPENING?).&lt;/p&gt;

&lt;p&gt;I suppose the presence of the RS name will help.  If its the &apos;same&apos; name, then we can proceed to OPENING and so what if OFFLINE was hijacked and became a REALLOCATE.  If they are not the same, then we&apos;d abort the open.&lt;/p&gt;

&lt;p&gt;So, why not just add machine name to OFFLINE?  Then we don&apos;t need REALLOCATE state? (Ideally it would be best if master told the regionserver the version of the znode to expect when it goes to move the znode to OPENING but that looks hard to pass from the master over to the RS EventHandlers).&lt;/p&gt;

&lt;p&gt;So, figuring how to do deal with timeout of regions in PENDING_OPEN is one aspect of this issue, right?  The verification of state over in timeout monitor before acting is another aspect?&lt;/p&gt;

&lt;p&gt;You are working on TRUNK Ram? (I believe it acts a little differently from 0.90 because of recent work done in here).&lt;/p&gt;

&lt;p&gt;Good stuff Ram.  Thanks for digging into this.&lt;/p&gt;</comment>
                            <comment id="13084007" author="ram_krish" created="Fri, 12 Aug 2011 08:51:24 +0000"  >&lt;blockquote&gt;&lt;p&gt;You are working on TRUNK Ram?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes Stack&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Won&apos;t your code have to check for both REALLOCATE and OFFLINE and the presence of either mean its ok to procede to OPENING (and then aren&apos;t REALLOCATE and OFFLINE the &apos;same&apos; state because the presence of either will mean proceed to OPENING?).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes this is what my patch does.  But why we do the same operation for both state?&lt;br/&gt;
this is because previously if there is a change in state other than OFFLINE while moving to OPENING we were aborting, now this an additional state which says its ok to go to OPENING if you find me in RE_ALLOCATE and if the server name in me is same as your RS address. This avoids the problem of unnecessary region getting hijacked though the RS was doing his work correctly.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So, why not just add machine name to OFFLINE? Then we don&apos;t need REALLOCATE state? &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This you have already told like currently there is no version that is passed from master to rs. Thats why a new state.  If this had been possible then OFFLINE with version passed by master would have been sufficient.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So, figuring how to do deal with timeout of regions in PENDING_OPEN is one aspect of this issue, right? The verification of state over in timeout monitor before acting is another aspect?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes stack.. we have covered both these aspects and also the points told by JD.  Taking action on timeout immediately and a mechanism for both master and RS to know what happened as part of timeout and who ever wins the race succeeds.  &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;(I believe it acts a little differently from 0.90 because of recent work done in here).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Reg timeout monitor the one major change is now the CLSOING state node is created by master itself and it was done by RS as in 0.90.  Apart from this i dint find any big difference till now. As part of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4083&quot; title=&quot;If Enable table is not completed and is partial, then scanning of the table is not working &quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4083&quot;&gt;&lt;del&gt;HBASE-4083&lt;/del&gt;&lt;/a&gt; we have introduced the return types from Open RegionHandler which takes care of scenarios where a race condition happens between the master changes to RE_ALLOCATE by the time the RS has moved to OPENED.&lt;/p&gt;
</comment>
                            <comment id="13084060" author="ram_krish" created="Fri, 12 Aug 2011 12:17:29 +0000"  >&lt;p&gt;@Stack,&lt;br/&gt;
Was seeing the possibility of using OFFLINE state.  Thought of few things&lt;br/&gt;
-&amp;gt; Now we need to change behaviour in all the cases in timeoutmonitor to preempt the node to OFFLINE with RS name.&lt;br/&gt;
-&amp;gt;Before changing to OFFLINE see what is the state in RS.  If still OFFLINE/OPENING change it to OFFLINE+Servername address&lt;br/&gt;
-&amp;gt;After changing it to OFFLINE get the latest version and pass it to the RS from Master which inturn goes to the OpenRegionHandler.  &lt;br/&gt;
-&amp;gt;This will be needed when we transit from OFFLINE to OPENING to ensure whether the current transition from OFFLINE to OPENING is for timeout call or previous OFFLINE to OPENING did not happen.&lt;br/&gt;
-&amp;gt;also the servername is necessary to avoid processing of the transition by the RS who is no longer owner of the znode.&lt;br/&gt;
-&amp;gt;And even in normal flow(normal assign flow) we need to add the servername of RS along with OFFLINE who will process the unassigned node&lt;/p&gt;

&lt;p&gt;These will be the highlevel changes that we need to make in the current patch if we need to avoid the new state.  &lt;/p&gt;</comment>
                            <comment id="13084333" author="streamy" created="Fri, 12 Aug 2011 19:52:32 +0000"  >&lt;p&gt;Sorry I&apos;m a little late to this discussion but I like the idea of not adding a new state.  Instead, we can just pass the znode version number in the RPC to the regionservers.  Or encode the servername in the znode.&lt;/p&gt;</comment>
                            <comment id="13085521" author="ram_krish" created="Tue, 16 Aug 2011 04:26:30 +0000"  >&lt;p&gt;@Jonathan&lt;br/&gt;
Thanks for your comments.&lt;br/&gt;
I will implement the changes so that we dont have a new state and will upload a new patch asap.&lt;/p&gt;</comment>
                            <comment id="13085527" author="stack" created="Tue, 16 Aug 2011 04:52:25 +0000"  >&lt;p&gt;@Jon I took a look at passing the seqno and its really invasive &amp;#8211; as written, writing, its hard to get the seqno &amp;#8211; and then passing it over rpc to RS and then down into the executor that does the open would require changing all method sigs and RS interfaces.  That said, it would make for the most robust implementation; for sure we&apos;d not need a new state.&lt;/p&gt;

&lt;p&gt;@Ram Perhaps we can work on this together?  You on for doing the passing of the seqno?  I&apos;d like to help.&lt;/p&gt;</comment>
                            <comment id="13085533" author="ram_krish" created="Tue, 16 Aug 2011 05:08:48 +0000"  >&lt;p&gt;@Stack&lt;/p&gt;

&lt;p&gt;I am ready to work together &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.  Stack as in my previous comment I just got an highlevel points to be done if we stick with OFFLINE state itself. But I have not yet started my implementation.&lt;br/&gt;
So whats your idea Stack? Can i start digging as how many changes do we need to make if we go with OFFLINE state and what are the interface changes etc.  Or you have anything else in mind ?&lt;/p&gt;</comment>
                            <comment id="13085535" author="stack" created="Tue, 16 Aug 2011 05:09:40 +0000"  >&lt;p&gt;@Ram&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Reg timeout monitor the one major change is now the CLSOING state node is created by master itself and it was done by RS as in 0.90. Apart from this i dint find any big difference till now.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You are right I believe.&lt;/p&gt;

&lt;p&gt;Do you think we need your proposal of 12/Aug/11 12:17 if the master passes znode version on open?&lt;/p&gt;</comment>
                            <comment id="13085543" author="stack" created="Tue, 16 Aug 2011 05:42:02 +0000"  >&lt;blockquote&gt;&lt;p&gt;So whats your idea Stack? Can i start digging as how many changes do we need to make if we go with OFFLINE state and what are the interface changes etc.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That sounds good to me.  I took a look and what I saw was that setting OFFLINE state, its currently not easy getting back the znode seqid; might have to add something here.  Then, the seqid would have to be passed over the rpc when we do open region.  I&apos;d say add a new open region method, one that takes two args &amp;#8211; the region name and the seqid.. leave the old one in place and use -1 or something to flag an open where no seqid has been passed (maybe shell wants to do an open region and it won&apos;t have the seqid).  Then I&apos;d pass the seqid down into the openhandler....  Then use it checking the znode seqid when we check OFFLINE.&lt;/p&gt;

&lt;p&gt;Something like that.&lt;/p&gt;

&lt;p&gt;Good on you Ram.&lt;/p&gt;</comment>
                            <comment id="13085841" author="ram_krish" created="Tue, 16 Aug 2011 16:55:59 +0000"  >&lt;p&gt;@Stack,&lt;br/&gt;
Have made the basic changes as discussed.  Will verify scenarios and will upload the patch sooner.&lt;/p&gt;</comment>
                            <comment id="13087051" author="ram_krish" created="Thu, 18 Aug 2011 15:12:50 +0000"  >&lt;p&gt;@Stack&lt;br/&gt;
Completed the overall changes with OFFLINE state.(I think so) &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
Will upload the patch tomorrow for your review.  Thanks in advance.&lt;/p&gt;</comment>
                            <comment id="13087120" author="stack" created="Thu, 18 Aug 2011 17:08:01 +0000"  >&lt;p&gt;@Ram You are a good man.&lt;/p&gt;</comment>
                            <comment id="13087759" author="ram_krish" created="Fri, 19 Aug 2011 15:23:48 +0000"  >&lt;p&gt;@Stack&lt;br/&gt;
I have uploaded the patch with soln as discussed.  The OFFLINE state is used now instead of new state.&lt;/p&gt;

&lt;p&gt;But Stack, from my side I feel the prev implementation was much easier and cleaner.  Pls check both the patches and provide your comments.  Thanks.&lt;/p&gt;</comment>
                            <comment id="13088368" author="yuzhihong@gmail.com" created="Sun, 21 Aug 2011 14:03:46 +0000"  >&lt;p&gt;Patch 2 is much bigger.&lt;br/&gt;
Personally I think adding a new state is simpler to code / maintain than changing openRegion() signature in HRegionInterface - considering the other region related methods don&apos;t require version parameter.&lt;/p&gt;</comment>
                            <comment id="13090021" author="stack" created="Wed, 24 Aug 2011 06:19:16 +0000"  >&lt;p&gt;@Ted In most other state transitions, we have the znode version to hand (we previously read the znode state).  Its this one operation where we are transferring region ownership from master to regionserver that has the hole.  A new state &quot;seems&quot; to be a patch on the actual problem but I could be convinced otherwise (Looking at Ram&apos;s diagram the new state seemed cleaner but I had sneaking suspicion that the new state introduces a bunch of new conditions not dealt with in the diagram).&lt;/p&gt;

&lt;p&gt;On the patch (Thanks for digging in here Ram):&lt;/p&gt;

&lt;p&gt;Why the special handling of meta regions here:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-        regionsInTransition.put(encodedRegionName, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RegionState(
-            regionInfo, RegionState.State.OPENING,
-            data.getStamp(), data.getOrigin()));
+        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) {
+          regionsInTransition.put(encodedRegionName, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RegionState(regionInfo,
+              RegionState.State.OPENING, data.getStamp(), data.getOrigin()));
+          processOpeningState(regionInfo);
+          &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
+        }
+        regionsInTransition.put(encodedRegionName, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RegionState(regionInfo,
+            RegionState.State.OPENING, data.getStamp(), data.getOrigin()));
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;FYI, IIRC, regionInfo.isMetaRegion() is true if .META. or &lt;del&gt;ROOT&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;This is ok, not setting a watcher here?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+      RegionTransitionData dataInZNode = ZKAssign.getDataNoWatch(watcher, node,
+          stat);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here you might want to add logging whether or not its a reallocate:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-      LOG.info(&lt;span class=&quot;code-quote&quot;&gt;&quot;Table &quot;&lt;/span&gt; + tableName + (disabled? &lt;span class=&quot;code-quote&quot;&gt;&quot; disabled;&quot;&lt;/span&gt;: &lt;span class=&quot;code-quote&quot;&gt;&quot; disabling;&quot;&lt;/span&gt;) +
-        &lt;span class=&quot;code-quote&quot;&gt;&quot; skipping assign of &quot;&lt;/span&gt; + region.getRegionNameAsString());
+      LOG.info(&lt;span class=&quot;code-quote&quot;&gt;&quot;Table &quot;&lt;/span&gt; + tableName + (disabled ? &lt;span class=&quot;code-quote&quot;&gt;&quot; disabled;&quot;&lt;/span&gt; : &lt;span class=&quot;code-quote&quot;&gt;&quot; disabling;&quot;&lt;/span&gt;)
+          + &lt;span class=&quot;code-quote&quot;&gt;&quot; skipping assign of &quot;&lt;/span&gt; + region.getRegionNameAsString());
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;FYI, I prefer the previous style where the &apos;+&apos; is at the end of the line; it flags reader that there is more to come.... (IMO).&lt;/p&gt;

&lt;p&gt;What is happening here?  Who will have set realloc true?  The timeout monitor?  So who then will set it to OFFLINE?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-      LOG.debug(&lt;span class=&quot;code-quote&quot;&gt;&quot;Forcing OFFLINE; was=&quot;&lt;/span&gt; + state);
-      state.update(RegionState.State.OFFLINE);
+      &lt;span class=&quot;code-comment&quot;&gt;// If invoked from timeout monitor donot force it to OFFLINE. Based on the
&lt;/span&gt;+      &lt;span class=&quot;code-comment&quot;&gt;// state
&lt;/span&gt;+      &lt;span class=&quot;code-comment&quot;&gt;// we will decide &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; to change in-memory state to OFFLINE or not.
&lt;/span&gt;+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!isReAllocate) {
+        LOG.debug(&lt;span class=&quot;code-quote&quot;&gt;&quot;Forcing OFFLINE; was=&quot;&lt;/span&gt; + state);
+        state.update(RegionState.State.OFFLINE);
+      }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When would this happen:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)
+        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;i.e... it would come back w/ -1?&lt;/p&gt;

&lt;p&gt;Style: If multiple lines, it needs curly brackets (Would suggest leaving stuff like this alone)&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (plan == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;; &lt;span class=&quot;code-comment&quot;&gt;// Should get reassigned later when RIT times out.
&lt;/span&gt;+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (plan == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)
+        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;; &lt;span class=&quot;code-comment&quot;&gt;// Should get reassigned later when RIT times out.&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;At the other extreme, its fine to fix stuff like this where its w/o spaces around the &apos;+&apos; operator:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(LOG.isDebugEnabled()){
-              LOG.debug(&lt;span class=&quot;code-quote&quot;&gt;&quot;The unassigned node &quot;&lt;/span&gt;+encodedRegionName+&lt;span class=&quot;code-quote&quot;&gt;&quot; doesnot exist.&quot;&lt;/span&gt;);
+            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (LOG.isDebugEnabled()) {
+              LOG.debug(&lt;span class=&quot;code-quote&quot;&gt;&quot;The unassigned node &quot;&lt;/span&gt; + encodedRegionName
+                  + &lt;span class=&quot;code-quote&quot;&gt;&quot; doesnot exist.&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(though you could separate the &apos;doesnot&apos; into &apos;does not&apos;&lt;/p&gt;

&lt;p&gt;This kinda change just bloats your patch (making Ted think it does more than it does &amp;#8211; smile):&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-        LOG.warn(&lt;span class=&quot;code-quote&quot;&gt;&quot;Failed assignment of &quot;&lt;/span&gt; +
-          state.getRegion().getRegionNameAsString() + &lt;span class=&quot;code-quote&quot;&gt;&quot; to &quot;&lt;/span&gt; +
-          plan.getDestination() + &lt;span class=&quot;code-quote&quot;&gt;&quot;, trying to assign elsewhere instead; &quot;&lt;/span&gt; +
-          &lt;span class=&quot;code-quote&quot;&gt;&quot;retry=&quot;&lt;/span&gt; + i, t);
+        LOG.warn(&lt;span class=&quot;code-quote&quot;&gt;&quot;Failed assignment of &quot;&lt;/span&gt;
+            + state.getRegion().getRegionNameAsString() + &lt;span class=&quot;code-quote&quot;&gt;&quot; to &quot;&lt;/span&gt;
+            + plan.getDestination() + &lt;span class=&quot;code-quote&quot;&gt;&quot;, trying to assign elsewhere instead; &quot;&lt;/span&gt;
+            + &lt;span class=&quot;code-quote&quot;&gt;&quot;retry=&quot;&lt;/span&gt; + i, t);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ditto&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-          LOG.warn(&lt;span class=&quot;code-quote&quot;&gt;&quot;Unable to find a viable location to assign region &quot;&lt;/span&gt; +
-            state.getRegion().getRegionNameAsString());
+          LOG.warn(&lt;span class=&quot;code-quote&quot;&gt;&quot;Unable to find a viable location to assign region &quot;&lt;/span&gt;
+              + state.getRegion().getRegionNameAsString());
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Does the param &apos;isReAllocate&apos; mean method was called from timeout monitor?  If so, it probably warrants a different name?&lt;/p&gt;

&lt;p&gt;What is going to happen if we return -1 because of below?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (versionOfOfflineNode == -1) {
+        LOG.warn(&lt;span class=&quot;code-quote&quot;&gt;&quot;Attempted to create/force node into OFFLINE state before &quot;&lt;/span&gt;
+            + &lt;span class=&quot;code-quote&quot;&gt;&quot;completing assignment but failed to &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; so &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; &quot;&lt;/span&gt; + state);
+        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; -1;
       }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;+1 on refactor of timeout breaking out the method actOnTimeout.&lt;/p&gt;

&lt;p&gt;Did you change anything in way timeout monitor works?&lt;/p&gt;

&lt;p&gt;This is interesting:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;enum&lt;/span&gt; TimeOutOperationType {
+    ASSIGN, UNASSIGN;
+  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We have timeout types.  How does this work?  Is this an in-memory master state only?  What happens if master crashes?  Will new master need to know these two new states?&lt;/p&gt;

&lt;p&gt;Why are we passing AssignmentManager a threadPoolExecutorService?  Its used by timeout monitor?  Should creation of the executor service just live in the timeout monitor and be constructed there rather than up in master and passed in?  Or is it that you need to be able to shut it down when master goes down?&lt;/p&gt;

&lt;p&gt;Add a comment on TimeOutManagerCallable class saying what its for.&lt;/p&gt;

&lt;p&gt;This is great:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!transitionZookeeperOfflineToOpening(encodedName,
+          versionOfOfflineNode)) {
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;... over on the RS.&lt;/p&gt;

&lt;p&gt;Is this code copy paste from the method above it?  The version that does not take a znode version?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; RegionOpeningState openRegion(HRegionInfo region, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; expectedVersion)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If so, we should fix that.&lt;/p&gt;

&lt;p&gt;This patch needs closer review and I&apos;d like to know how this executor service in timeout monitor solve races we&apos;ve seen (it move operations out of line w/ processing of the actual timeout event?) but I&apos;m thinking this patch looks good; just what the doctor ordered, at least around passing of the version.  What are your reservations Ram?  How hard would it be to add tests?&lt;/p&gt;

&lt;p&gt;Good stuff.&lt;/p&gt;
</comment>
                            <comment id="13090025" author="yuzhihong@gmail.com" created="Wed, 24 Aug 2011 06:39:36 +0000"  >&lt;p&gt;In TRUNK, HRegionInfo.isMetaRegion() only checks for .META.&lt;/p&gt;</comment>
                            <comment id="13090026" author="stack" created="Wed, 24 Aug 2011 06:46:05 +0000"  >&lt;blockquote&gt;&lt;p&gt;In TRUNK, HRegionInfo.isMetaRegion() only checks for .META.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thanks.&lt;/p&gt;</comment>
                            <comment id="13090031" author="ram_krish" created="Wed, 24 Aug 2011 07:03:13 +0000"  >&lt;p&gt;Thanks for your comments Ted and Stack.&lt;/p&gt;
{bq}
&lt;p&gt;Why the special handling of meta regions here:&lt;br/&gt;
This is for the issue &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;.  I should have commented in this JIRA also about this. &lt;br/&gt;
All the formatting issues i will address it.&lt;br/&gt;
I will explain in detail the major race conditions and which parts of PATCH-2 handles corresponding scenarios.&lt;/p&gt;



</comment>
                            <comment id="13090032" author="yuzhihong@gmail.com" created="Wed, 24 Aug 2011 07:05:24 +0000"  >&lt;p&gt;At line 1098 in AssignmentManager.java, calling assign(state, setOfflineInZK, forceNewPlan, isReAllocate) would suffice:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!isReAllocate) {
        assign(state, setOfflineInZK, forceNewPlan);
      } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
        assign(state, setOfflineInZK, forceNewPlan, isReAllocate);
      }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
</comment>
                            <comment id="13090034" author="yuzhihong@gmail.com" created="Wed, 24 Aug 2011 07:06:56 +0000"  >&lt;p&gt;@Ramkrishna:&lt;br/&gt;
Can you publish patch 2 on reviewboard for further comments ?&lt;/p&gt;</comment>
                            <comment id="13090056" author="yuzhihong@gmail.com" created="Wed, 24 Aug 2011 07:28:32 +0000"  >&lt;p&gt;There are 4 files which patch-2 didn&apos;t cleanly apply on.&lt;br/&gt;
Producing an updated patch based on version 2 would help reviewers navigate the changes.&lt;/p&gt;</comment>
                            <comment id="13090069" author="ram_krish" created="Wed, 24 Aug 2011 07:57:25 +0000"  >&lt;p&gt;@Ted&lt;br/&gt;
Fine.. i will do that.  The patch has become outdated.&lt;br/&gt;
I will update and send it to review board.&lt;/p&gt;</comment>
                            <comment id="13091795" author="jiraposter@reviews.apache.org" created="Fri, 26 Aug 2011 14:23:28 +0000"  >
&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/1668/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;

&lt;p&gt;(Updated 2011-08-26 14:23:24.757551)&lt;/p&gt;


&lt;p&gt;Review request for Ted Yu, Michael Stack, Jean-Daniel Cryans, and Jonathan Gray.&lt;/p&gt;


&lt;p&gt;Summary (updated)&lt;br/&gt;
-------&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; - updated patch.&lt;/p&gt;


&lt;p&gt;        invokeTimeOutManager(regionState.getRegion(),&lt;br/&gt;
            TimeOutOperationType.ASSIGN);&lt;/p&gt;

&lt;p&gt;Instead of storing the state when timeout was deducted we process it&lt;br/&gt;
using future task.&lt;br/&gt;
================================================================&lt;/p&gt;

&lt;p&gt;      case RS_ZK_REGION_OPENING:&lt;br/&gt;
        // TODO: Could check if it was on deadServers.  If it was, then we could&lt;br/&gt;
        // do what happens in TimeoutMonitor when it sees this condition.&lt;/p&gt;

&lt;p&gt;        // Just insert region into RIT&lt;br/&gt;
        // If this never updates the timeout will trigger new assignment&lt;br/&gt;
        if (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) &lt;/p&gt;
{
          regionsInTransition.put(encodedRegionName, new RegionState(
              regionInfo, RegionState.State.OPENING, data.getStamp(), data
                  .getOrigin()));
          processOpeningState(regionInfo);
          break;
        }
&lt;p&gt;        regionsInTransition.put(encodedRegionName, new RegionState(regionInfo,&lt;br/&gt;
            RegionState.State.OPENING, data.getStamp(), data.getOrigin()));&lt;br/&gt;
        break;&lt;/p&gt;

&lt;p&gt;This change is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;. META and ROOT table need not wait till timeout&lt;br/&gt;
======================================================================&lt;/p&gt;

&lt;p&gt;In forceRegionStateToOffline()&lt;/p&gt;

&lt;p&gt;    } else {&lt;br/&gt;
      // If invoked from timeout monitor donot force it to OFFLINE. Based on the&lt;br/&gt;
      // state we will decide if to change in-memory state to OFFLINE or not.  It will&lt;br/&gt;
      // be done before setting the znode to OFFLINE state.&lt;br/&gt;
      if (!timeOutMonitorReAllocate) &lt;/p&gt;
{
        LOG.debug(&quot;Forcing OFFLINE; was=&quot; + state);
        state.update(RegionState.State.OFFLINE);
      }
&lt;p&gt;If the timeout monitor tries to reallcoate the node then dont make&lt;br/&gt;
the inmemory state to OFFLINE.&lt;br/&gt;
But the noraml assign flow doesnot expect the inmemory state to OFFLINE.&lt;br/&gt;
Hence the above change.  This is continued with the check in &lt;br/&gt;
assign()&lt;br/&gt;
int setOfflineInZooKeeper(final RegionState state,&lt;br/&gt;
      boolean timeOutMonitorReAllocate) {&lt;br/&gt;
    // If invoked from timeoutmonitor the current state in memory need not be&lt;br/&gt;
    // OFFLINE.  &lt;br/&gt;
    if (!timeOutMonitorReAllocate &amp;amp;&amp;amp; !state.isClosed() &amp;amp;&amp;amp; !state.isOffline()) &lt;/p&gt;
{
          this.master.abort(&quot;Unexpected state trying to OFFLINE; &quot; + state,
          new IllegalStateException());
      return -1;
    }
&lt;p&gt;======================================================================&lt;/p&gt;

&lt;p&gt;    boolean allowCreation = false;&lt;br/&gt;
    // If the isReAllocate is true and the current state is PENDING_OPEN&lt;br/&gt;
    // or OPENING then update the inmemory state to PENDING_OPEN. This is&lt;br/&gt;
    // important because&lt;br/&gt;
    // if timeoutmonitor deducts that a region was in OPENING state for a long&lt;br/&gt;
    // time but by the&lt;br/&gt;
    // time timeout monitor tranits the node to OFFLINE the RS would have opened&lt;br/&gt;
    // the node and the&lt;br/&gt;
    // state in znode will be RS_ZK_REGION_OPENED. Inorder to invoke the&lt;br/&gt;
    // OpenedRegionHandler&lt;br/&gt;
    // we expect the inmemeory state to be PENDING_OPEN or OPENING.&lt;br/&gt;
    // For all other cases we can change the inmemory state to OFFLINE.&lt;br/&gt;
    if (timeOutMonitorReAllocate&lt;br/&gt;
        &amp;amp;&amp;amp; (state.getState().equals(RegionState.State.PENDING_OPEN) || state&lt;br/&gt;
            .getState().equals(RegionState.State.OPENING))) &lt;/p&gt;
{
      state.update(RegionState.State.PENDING_OPEN);
      allowCreation = false;
    }
&lt;p&gt; else &lt;/p&gt;
{
      state.update(RegionState.State.OFFLINE);
      allowCreation = true;
    }
&lt;p&gt;This change is quite tricky.  &lt;br/&gt;
In normal assign flow the unassigned node for the region will not be present&lt;br/&gt;
Hence we need to allow the creation of the node newly.&lt;br/&gt;
But in timeout monitor case we will have the node present in some state hence &lt;br/&gt;
we decide whether to create node newly or not inside ZKAssign.createOrForceNodeOffline&lt;/p&gt;

&lt;p&gt;The above code also updates the inmemory state of OFFLINE or PENDING_OPEN&lt;br/&gt;
which was not update in the previous forceRegionStateToOffline() call.&lt;br/&gt;
==============================================================================&lt;br/&gt;
In ZKAssign.java()&lt;br/&gt;
    if (version == -1) {&lt;br/&gt;
      // If timeoutmonitor deducts a node to be in OPENING state but before it&lt;br/&gt;
      // could&lt;br/&gt;
      // transit to OFFLINE state if RS had opened the region then the Master&lt;br/&gt;
      // deletes the&lt;br/&gt;
      // assigned region znode. In that case the znode will not exist. So we&lt;br/&gt;
      // should not&lt;br/&gt;
      // create the znode again which will lead to double assignment.&lt;br/&gt;
      if (timeOutMonitorReAllocate &amp;amp;&amp;amp; !allowCreation) &lt;/p&gt;
{
        return -1;
      }
&lt;p&gt;this part prevents double assignment&lt;br/&gt;
If timeoutmonitor tries to force to OFFLINE state an existing region which was in RIT&lt;br/&gt;
but before it could do that if the node was opened then openedregionhandler will delete&lt;br/&gt;
the node hence we should not create the node again.&lt;/p&gt;

&lt;p&gt;=======================================================================================&lt;br/&gt;
In ZkAssign.java()&lt;br/&gt;
    } else {&lt;br/&gt;
      RegionTransitionData curDataInZNode = ZKAssign.getDataNoWatch(zkw, region&lt;br/&gt;
          .getEncodedName(), stat);&lt;br/&gt;
      // Do not move the node to OFFLINE if znode is in any of the following&lt;br/&gt;
      // state.&lt;br/&gt;
      // Because these are already executed states.&lt;br/&gt;
      if (timeOutMonitorReAllocate &amp;amp;&amp;amp; null != curDataInZNode) {&lt;br/&gt;
        EventType eventType = curDataInZNode.getEventType();&lt;br/&gt;
        if (eventType.equals(EventType.RS_ZK_REGION_CLOSING)&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; eventType.equals(EventType.RS_ZK_REGION_CLOSED)&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; eventType.equals(EventType.RS_ZK_REGION_OPENED)) 
{
          return -1;
        }
&lt;p&gt;      }&lt;br/&gt;
This check prevents from moving the node to OFFLINE state if just before&lt;br/&gt;
the node is tried to force to OFFLINE the RS would have changed the state &lt;br/&gt;
to either CLOSING or CLOSED or OPENED.  now again moving to OFFLINE&lt;br/&gt;
will lead to douoble assignment and will an additional operaition.&lt;/p&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;====================================================================================&lt;br/&gt;
In ZKassign.java()&lt;br/&gt;
      boolean setData = false;&lt;br/&gt;
      try &lt;/p&gt;
{
        setData = ZKUtil.setData(zkw, node, data.getBytes(), version);
        // Setdata throws KeeperException which aborts the Master. So we are
        // catching it here.
        // If just before setting the znode to OFFLINE if the RS has made any
        // change to the
        // znode state then we need to return -1.
      }
&lt;p&gt; catch (KeeperException kpe) &lt;/p&gt;
{
        LOG.info(&quot;Version mismatch while setting the node to OFFLINE state.&quot;);
        return -1;
      }
&lt;p&gt;This change is actually to avoid the master from abortng. If the forceful OFFLINE is in&lt;br/&gt;
progrss but just before setting the RS has changed the state.&lt;br/&gt;
Then the setData will fail leading to master abort.&lt;br/&gt;
Hence we are catching the exception.&lt;br/&gt;
====================================================================================&lt;/p&gt;

&lt;p&gt;In assignmentManager.java&lt;br/&gt;
+      if (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)&lt;br/&gt;
+        return;&lt;br/&gt;
This is nothing but the refactoring done in the existing code.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (setOfflineInZK &amp;amp;&amp;amp; !setOfflineInZooKeeper(state)) return;&lt;br/&gt;
So if setting the version is unsuccessful return.&lt;br/&gt;
=====================================================================================&lt;br/&gt;
In ZKassign.java()&lt;br/&gt;
// the below check ensure that double assignment doesnot happen.&lt;br/&gt;
    // When the node is created for the first time then the expected version&lt;br/&gt;
    // that is&lt;br/&gt;
    // passed will be -1 and the version in znode will be 0.&lt;br/&gt;
    // In all other cases the version in znode will be &amp;gt; 0.&lt;br/&gt;
    else if (beginState.equals(EventType.M_ZK_REGION_OFFLINE)&lt;br/&gt;
        &amp;amp;&amp;amp; endState.equals(EventType.RS_ZK_REGION_OPENING)&lt;br/&gt;
        &amp;amp;&amp;amp; expectedVersion == -1 &amp;amp;&amp;amp; stat.getVersion() != 0) 
{
      LOG.warn(zkw.prefix(&quot;Attempt to transition the &quot; + &quot;unassigned node for &quot;
          + encoded + &quot; from &quot; + beginState + &quot; to &quot; + endState + &quot; failed, &quot;
          + &quot;the node existed but was version &quot; + stat.getVersion()
          + &quot; not the expected version &quot; + expectedVersion));
      return -1;
    }
&lt;p&gt;As the comment explains when the node is created for first time the expectedversion will&lt;br/&gt;
be -1 but the actual version will be 0.  Here the scenario is&lt;br/&gt;
If RS1 has not tranitioned the node from OFFLINE to OPENING if&lt;br/&gt;
RS2 gets the call from Master after forcefully chaning to OFFLINE the&lt;br/&gt;
Rs2 will take the control of the node.&lt;br/&gt;
At that time if RS1 starts transmitting the node then we should not allow&lt;br/&gt;
it.&lt;br/&gt;
===============================================================================&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;.&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-4015&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;Diffs&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/a&gt; 1161985 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt; 1161985 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt; 1161985 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt; 1161985 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt; 1161985 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt; 1161985 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt; PRE-CREATION &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt; 1161985 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/a&gt; 1161985 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;

&lt;p&gt;Diff: &lt;a href=&quot;https://reviews.apache.org/r/1668/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;Testing&lt;br/&gt;
-------&lt;/p&gt;

&lt;p&gt;Yes.  But could not add new test case.&lt;br/&gt;
TestMasterFailOver is passing with the current changes also.&lt;/p&gt;


&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;ramkrishna&lt;/p&gt;
</comment>
                            <comment id="13091796" author="ram_krish" created="Fri, 26 Aug 2011 14:28:58 +0000"  >&lt;p&gt;The patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt; is also present in the same one.&lt;/p&gt;</comment>
                            <comment id="13091798" author="ram_krish" created="Fri, 26 Aug 2011 14:35:50 +0000"  >&lt;blockquote&gt;&lt;p&gt;Why are we passing AssignmentManager a threadPoolExecutorService? Its used by timeout monitor? Should creation of the executor service just live in the timeout monitor and be constructed there rather than up in master and passed in? Or is it that you need to be able to shut it down when master goes down?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes it is to shutdown the threadpoolexecutor service.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;+  public static enum TimeOutOperationType {
+    ASSIGN, UNASSIGN;
+  }&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This is only an indication for the timeoutmanager callable to know whether to assign or unassign &lt;/p&gt;

&lt;p&gt;Formatting issues in previous patch has also been taken care.&lt;/p&gt;</comment>
                            <comment id="13092148" author="jiraposter@reviews.apache.org" created="Sat, 27 Aug 2011 00:21:28 +0000"  >
&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/1668/#review1666&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#review1666&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;


&lt;p&gt;Looks great Ram.  WOuld be hard to write a test for this I think.  What do you think?&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3719&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3719&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    White space.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3720&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3720&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Is it the RS that is creating the OFFLINE node or is it the master that does this and RS moves the region from OFFLINE to OPENING?  No need to say &apos;passed by the master&apos;&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3721&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3721&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Is this correct?  The open is async w/ the states of opening done up in zk w/ master noticing the last &amp;#8211; right?  The return is whether or not the request to open was accepted?&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3722&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3722&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    ws&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3723&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3723&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    ws&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3724&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3724&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    ws&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3725&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3725&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    ws&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3726&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3726&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    So, whats this special-handling of catalog tables about?  Want to add comment why it is so?&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3727&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3727&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Todd would say don&apos;t bother adding javadoc if it says nothing other than repeat param names.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3728&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3728&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    This is a better name for this param though why does this method need to know who is calling it?  Perhaps there is a better name?  timedout?  What you think Ram?&lt;/p&gt;

&lt;p&gt;    Do you mean &apos;reassign&apos; when you say &apos;reallocate&apos;&lt;/p&gt;

&lt;p&gt;    So maybe use &apos;reassign&apos; instead of &apos;timedout&apos;?&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3729&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3729&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    ws&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3730&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3730&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    ws&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3731&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3731&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    When do we do this?  Where do we do the change of in-memory state?&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3732&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3732&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    ws&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3733&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3733&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    yeah, why should this method care where its called from so would suggest removing timeoutMonitor from main and name param for condition under which this method is being called.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3738&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3738&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Good.  So if an open comes in on a table that is being disabled, we&apos;ll skip... thats right.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3734&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3734&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    ws&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3736&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3736&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    ws&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3737&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3737&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Excellent&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3739&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3739&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    ws&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3740&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3740&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    ws&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3745&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3745&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    maybe &apos;allowZNodeCreation&apos; instead?&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3742&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3742&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    When you say &apos;deducts&apos; do you mean to use the current tense?  If so, that&apos;d be &apos;deduces&apos;.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3741&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3741&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Can you fix up this comment so it aligns a bit better?&lt;/p&gt;

&lt;p&gt;    There is some misspelling in this paragraph that you might want to fix?&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3744&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3744&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Can you format this a little better?  Have first line end with &amp;amp;&amp;amp; and then second line end with ||.  The state.getState....should be on a single line ... make it easier to read rather than split over two lines.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3746&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3746&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    So, what you think will happen next?  We&apos;ll fail the assign?  Region will be stuck?&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3748&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3748&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Its good breaking down this method....&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3749&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3749&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    FYI, I prefer the former formatting where the arg was all on one line rather than split over two.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3750&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3750&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    good&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3751&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3751&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    ws&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3752&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3752&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Did you change these Excecutors to verify that the state that caused their being queued still holds before they actually run?  That would be important I&apos;d think if you have not done it that is.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3753&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3753&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    ws&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3754&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3754&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    why extra lines down here?&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3755&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3755&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    ws&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3756&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3756&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    ws&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3757&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3757&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    ws&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3758&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3758&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    ws&lt;/p&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Michael&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;On 2011-08-26 14:23:24, ramkrishna vasudevan wrote:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is an automatically generated e-mail. To reply, visit:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://reviews.apache.org/r/1668/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;(Updated 2011-08-26 14:23:24)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Review request for Ted Yu, Michael Stack, Jean-Daniel Cryans, and Jonathan Gray.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Summary&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; - updated patch.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;invokeTimeOutManager(regionState.getRegion(),&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TimeOutOperationType.ASSIGN);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Instead of storing the state when timeout was deducted we process it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;using future task.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;case RS_ZK_REGION_OPENING:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// TODO: Could check if it was on deadServers.  If it was, then we could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// do what happens in TimeoutMonitor when it sees this condition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Just insert region into RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If this never updates the timeout will trigger new assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) {
bq.            regionsInTransition.put(encodedRegionName, new RegionState(
bq.                regionInfo, RegionState.State.OPENING, data.getStamp(), data
bq.                    .getOrigin()));
bq.            processOpeningState(regionInfo);
bq.            break;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;regionsInTransition.put(encodedRegionName, new RegionState(regionInfo,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionState.State.OPENING, data.getStamp(), data.getOrigin()));&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;break;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;. META and ROOT table need not wait till timeout&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In forceRegionStateToOffline()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeout monitor donot force it to OFFLINE. Based on the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state we will decide if to change in-memory state to OFFLINE or not.  It will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// be done before setting the znode to OFFLINE state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate) {
bq.          LOG.debug(&quot;Forcing OFFLINE; was=&quot; + state);
bq.          state.update(RegionState.State.OFFLINE);
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If the timeout monitor tries to reallcoate the node then dont make&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But the noraml assign flow doesnot expect the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence the above change.  This is continued with the check in &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;assign()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;int setOfflineInZooKeeper(final RegionState state,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean timeOutMonitorReAllocate) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeoutmonitor the current state in memory need not be&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OFFLINE.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate &amp;amp;&amp;amp; !state.isClosed() &amp;amp;&amp;amp; !state.isOffline()) {
bq.            this.master.abort(&quot;Unexpected state trying to OFFLINE; &quot; + state,
bq.            new IllegalStateException());
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean allowCreation = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If the isReAllocate is true and the current state is PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// or OPENING then update the inmemory state to PENDING_OPEN. This is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// important because&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// if timeoutmonitor deducts that a region was in OPENING state for a long&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time but by the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time timeout monitor tranits the node to OFFLINE the RS would have opened&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the node and the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state in znode will be RS_ZK_REGION_OPENED. Inorder to invoke the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OpenedRegionHandler&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// we expect the inmemeory state to be PENDING_OPEN or OPENING.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// For all other cases we can change the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; (state.getState().equals(RegionState.State.PENDING_OPEN) || state&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getState().equals(RegionState.State.OPENING))) {
bq.        state.update(RegionState.State.PENDING_OPEN);
bq.        allowCreation = false;
bq.      } else {
bq.        state.update(RegionState.State.OFFLINE);
bq.        allowCreation = true;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is quite tricky.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In normal assign flow the unassigned node for the region will not be present&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we need to allow the creation of the node newly.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But in timeout monitor case we will have the node present in some state hence &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;we decide whether to create node newly or not inside ZKAssign.createOrForceNodeOffline&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;The above code also updates the inmemory state of OFFLINE or PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;which was not update in the previous forceRegionStateToOffline() call.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;==============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (version == -1) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If timeoutmonitor deducts a node to be in OPENING state but before it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// transit to OFFLINE state if RS had opened the region then the Master&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// deletes the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// assigned region znode. In that case the znode will not exist. So we&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// should not&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// create the znode again which will lead to double assignment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; !allowCreation) {
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;this part prevents double assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If timeoutmonitor tries to force to OFFLINE state an existing region which was in RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;but before it could do that if the node was opened then openedregionhandler will delete&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node hence we should not create the node again.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=======================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZkAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionTransitionData curDataInZNode = ZKAssign.getDataNoWatch(zkw, region&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getEncodedName(), stat);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Do not move the node to OFFLINE if znode is in any of the following&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Because these are already executed states.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; null != curDataInZNode) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;EventType eventType = curDataInZNode.getEventType();&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (eventType.equals(EventType.RS_ZK_REGION_CLOSING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_CLOSED)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_OPENED)) {
bq.            return -1;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;}&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This check prevents from moving the node to OFFLINE state if just before&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node is tried to force to OFFLINE the RS would have changed the state &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;to either CLOSING or CLOSED or OPENED.  now again moving to OFFLINE&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;will lead to douoble assignment and will an additional operaition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean setData = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;try {
bq.          setData = ZKUtil.setData(zkw, node, data.getBytes(), version);
bq.          // Setdata throws KeeperException which aborts the Master. So we are
bq.          // catching it here.
bq.          // If just before setting the znode to OFFLINE if the RS has made any
bq.          // change to the
bq.          // znode state then we need to return -1.
bq.        } catch (KeeperException kpe) {
bq.          LOG.info(&quot;Version mismatch while setting the node to OFFLINE state.&quot;);
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is actually to avoid the master from abortng. If the forceful OFFLINE is in&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;progrss but just before setting the RS has changed the state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Then the setData will fail leading to master abort.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we are catching the exception.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In assignmentManager.java&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+      if (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+        return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is nothing but the refactoring done in the existing code.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-     if (setOfflineInZK &amp;amp;&amp;amp; !setOfflineInZooKeeper(state)) return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;So if setting the version is unsuccessful return.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the below check ensure that double assignment doesnot happen.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// When the node is created for the first time then the expected version&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// that is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// passed will be -1 and the version in znode will be 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// In all other cases the version in znode will be &amp;gt; 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;else if (beginState.equals(EventType.M_ZK_REGION_OFFLINE)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; endState.equals(EventType.RS_ZK_REGION_OPENING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; expectedVersion == -1 &amp;amp;&amp;amp; stat.getVersion() != 0) {
bq.        LOG.warn(zkw.prefix(&quot;Attempt to transition the &quot; + &quot;unassigned node for &quot;
bq.            + encoded + &quot; from &quot; + beginState + &quot; to &quot; + endState + &quot; failed, &quot;
bq.            + &quot;the node existed but was version &quot; + stat.getVersion()
bq.            + &quot; not the expected version &quot; + expectedVersion));
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;As the comment explains when the node is created for first time the expectedversion will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;be -1 but the actual version will be 0.  Here the scenario is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If RS1 has not tranitioned the node from OFFLINE to OPENING if&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RS2 gets the call from Master after forcefully chaning to OFFLINE the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Rs2 will take the control of the node.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;At that time if RS1 starts transmitting the node then we should not allow&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;===============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-4015&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diffs&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt; PRE-CREATION &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diff: &lt;a href=&quot;https://reviews.apache.org/r/1668/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Testing&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Yes.  But could not add new test case.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TestMasterFailOver is passing with the current changes also.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Thanks,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;ramkrishna&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
</comment>
                            <comment id="13092171" author="jiraposter@reviews.apache.org" created="Sat, 27 Aug 2011 02:57:29 +0000"  >
&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/1668/#review1668&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#review1668&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3770&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3770&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    The two strings can be concatenated:&lt;br/&gt;
     region close&quot;, &lt;/p&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Ted&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;On 2011-08-26 14:23:24, ramkrishna vasudevan wrote:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is an automatically generated e-mail. To reply, visit:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://reviews.apache.org/r/1668/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;(Updated 2011-08-26 14:23:24)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Review request for Ted Yu, Michael Stack, Jean-Daniel Cryans, and Jonathan Gray.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Summary&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; - updated patch.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;invokeTimeOutManager(regionState.getRegion(),&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TimeOutOperationType.ASSIGN);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Instead of storing the state when timeout was deducted we process it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;using future task.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;case RS_ZK_REGION_OPENING:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// TODO: Could check if it was on deadServers.  If it was, then we could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// do what happens in TimeoutMonitor when it sees this condition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Just insert region into RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If this never updates the timeout will trigger new assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) {
bq.            regionsInTransition.put(encodedRegionName, new RegionState(
bq.                regionInfo, RegionState.State.OPENING, data.getStamp(), data
bq.                    .getOrigin()));
bq.            processOpeningState(regionInfo);
bq.            break;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;regionsInTransition.put(encodedRegionName, new RegionState(regionInfo,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionState.State.OPENING, data.getStamp(), data.getOrigin()));&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;break;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;. META and ROOT table need not wait till timeout&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In forceRegionStateToOffline()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeout monitor donot force it to OFFLINE. Based on the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state we will decide if to change in-memory state to OFFLINE or not.  It will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// be done before setting the znode to OFFLINE state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate) {
bq.          LOG.debug(&quot;Forcing OFFLINE; was=&quot; + state);
bq.          state.update(RegionState.State.OFFLINE);
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If the timeout monitor tries to reallcoate the node then dont make&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But the noraml assign flow doesnot expect the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence the above change.  This is continued with the check in &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;assign()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;int setOfflineInZooKeeper(final RegionState state,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean timeOutMonitorReAllocate) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeoutmonitor the current state in memory need not be&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OFFLINE.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate &amp;amp;&amp;amp; !state.isClosed() &amp;amp;&amp;amp; !state.isOffline()) {
bq.            this.master.abort(&quot;Unexpected state trying to OFFLINE; &quot; + state,
bq.            new IllegalStateException());
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean allowCreation = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If the isReAllocate is true and the current state is PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// or OPENING then update the inmemory state to PENDING_OPEN. This is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// important because&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// if timeoutmonitor deducts that a region was in OPENING state for a long&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time but by the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time timeout monitor tranits the node to OFFLINE the RS would have opened&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the node and the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state in znode will be RS_ZK_REGION_OPENED. Inorder to invoke the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OpenedRegionHandler&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// we expect the inmemeory state to be PENDING_OPEN or OPENING.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// For all other cases we can change the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; (state.getState().equals(RegionState.State.PENDING_OPEN) || state&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getState().equals(RegionState.State.OPENING))) {
bq.        state.update(RegionState.State.PENDING_OPEN);
bq.        allowCreation = false;
bq.      } else {
bq.        state.update(RegionState.State.OFFLINE);
bq.        allowCreation = true;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is quite tricky.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In normal assign flow the unassigned node for the region will not be present&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we need to allow the creation of the node newly.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But in timeout monitor case we will have the node present in some state hence &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;we decide whether to create node newly or not inside ZKAssign.createOrForceNodeOffline&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;The above code also updates the inmemory state of OFFLINE or PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;which was not update in the previous forceRegionStateToOffline() call.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;==============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (version == -1) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If timeoutmonitor deducts a node to be in OPENING state but before it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// transit to OFFLINE state if RS had opened the region then the Master&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// deletes the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// assigned region znode. In that case the znode will not exist. So we&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// should not&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// create the znode again which will lead to double assignment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; !allowCreation) {
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;this part prevents double assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If timeoutmonitor tries to force to OFFLINE state an existing region which was in RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;but before it could do that if the node was opened then openedregionhandler will delete&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node hence we should not create the node again.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=======================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZkAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionTransitionData curDataInZNode = ZKAssign.getDataNoWatch(zkw, region&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getEncodedName(), stat);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Do not move the node to OFFLINE if znode is in any of the following&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Because these are already executed states.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; null != curDataInZNode) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;EventType eventType = curDataInZNode.getEventType();&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (eventType.equals(EventType.RS_ZK_REGION_CLOSING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_CLOSED)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_OPENED)) {
bq.            return -1;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;}&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This check prevents from moving the node to OFFLINE state if just before&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node is tried to force to OFFLINE the RS would have changed the state &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;to either CLOSING or CLOSED or OPENED.  now again moving to OFFLINE&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;will lead to douoble assignment and will an additional operaition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean setData = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;try {
bq.          setData = ZKUtil.setData(zkw, node, data.getBytes(), version);
bq.          // Setdata throws KeeperException which aborts the Master. So we are
bq.          // catching it here.
bq.          // If just before setting the znode to OFFLINE if the RS has made any
bq.          // change to the
bq.          // znode state then we need to return -1.
bq.        } catch (KeeperException kpe) {
bq.          LOG.info(&quot;Version mismatch while setting the node to OFFLINE state.&quot;);
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is actually to avoid the master from abortng. If the forceful OFFLINE is in&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;progrss but just before setting the RS has changed the state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Then the setData will fail leading to master abort.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we are catching the exception.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In assignmentManager.java&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+      if (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+        return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is nothing but the refactoring done in the existing code.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-     if (setOfflineInZK &amp;amp;&amp;amp; !setOfflineInZooKeeper(state)) return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;So if setting the version is unsuccessful return.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the below check ensure that double assignment doesnot happen.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// When the node is created for the first time then the expected version&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// that is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// passed will be -1 and the version in znode will be 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// In all other cases the version in znode will be &amp;gt; 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;else if (beginState.equals(EventType.M_ZK_REGION_OFFLINE)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; endState.equals(EventType.RS_ZK_REGION_OPENING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; expectedVersion == -1 &amp;amp;&amp;amp; stat.getVersion() != 0) {
bq.        LOG.warn(zkw.prefix(&quot;Attempt to transition the &quot; + &quot;unassigned node for &quot;
bq.            + encoded + &quot; from &quot; + beginState + &quot; to &quot; + endState + &quot; failed, &quot;
bq.            + &quot;the node existed but was version &quot; + stat.getVersion()
bq.            + &quot; not the expected version &quot; + expectedVersion));
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;As the comment explains when the node is created for first time the expectedversion will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;be -1 but the actual version will be 0.  Here the scenario is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If RS1 has not tranitioned the node from OFFLINE to OPENING if&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RS2 gets the call from Master after forcefully chaning to OFFLINE the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Rs2 will take the control of the node.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;At that time if RS1 starts transmitting the node then we should not allow&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;===============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-4015&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diffs&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt; PRE-CREATION &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diff: &lt;a href=&quot;https://reviews.apache.org/r/1668/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Testing&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Yes.  But could not add new test case.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TestMasterFailOver is passing with the current changes also.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Thanks,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;ramkrishna&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
</comment>
                            <comment id="13092281" author="jiraposter@reviews.apache.org" created="Sat, 27 Aug 2011 11:52:37 +0000"  >
&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/1668/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;

&lt;p&gt;(Updated 2011-08-27 11:51:16.491607)&lt;/p&gt;


&lt;p&gt;Review request for Ted Yu, Michael Stack, Jean-Daniel Cryans, and Jonathan Gray.&lt;/p&gt;


&lt;p&gt;Summary&lt;br/&gt;
-------&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; - updated patch.&lt;/p&gt;


&lt;p&gt;        invokeTimeOutManager(regionState.getRegion(),&lt;br/&gt;
            TimeOutOperationType.ASSIGN);&lt;/p&gt;

&lt;p&gt;Instead of storing the state when timeout was deducted we process it&lt;br/&gt;
using future task.&lt;br/&gt;
================================================================&lt;/p&gt;

&lt;p&gt;      case RS_ZK_REGION_OPENING:&lt;br/&gt;
        // TODO: Could check if it was on deadServers.  If it was, then we could&lt;br/&gt;
        // do what happens in TimeoutMonitor when it sees this condition.&lt;/p&gt;

&lt;p&gt;        // Just insert region into RIT&lt;br/&gt;
        // If this never updates the timeout will trigger new assignment&lt;br/&gt;
        if (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) &lt;/p&gt;
{
          regionsInTransition.put(encodedRegionName, new RegionState(
              regionInfo, RegionState.State.OPENING, data.getStamp(), data
                  .getOrigin()));
          processOpeningState(regionInfo);
          break;
        }
&lt;p&gt;        regionsInTransition.put(encodedRegionName, new RegionState(regionInfo,&lt;br/&gt;
            RegionState.State.OPENING, data.getStamp(), data.getOrigin()));&lt;br/&gt;
        break;&lt;/p&gt;

&lt;p&gt;This change is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;. META and ROOT table need not wait till timeout&lt;br/&gt;
======================================================================&lt;/p&gt;

&lt;p&gt;In forceRegionStateToOffline()&lt;/p&gt;

&lt;p&gt;    } else {&lt;br/&gt;
      // If invoked from timeout monitor donot force it to OFFLINE. Based on the&lt;br/&gt;
      // state we will decide if to change in-memory state to OFFLINE or not.  It will&lt;br/&gt;
      // be done before setting the znode to OFFLINE state.&lt;br/&gt;
      if (!timeOutMonitorReAllocate) &lt;/p&gt;
{
        LOG.debug(&quot;Forcing OFFLINE; was=&quot; + state);
        state.update(RegionState.State.OFFLINE);
      }
&lt;p&gt;If the timeout monitor tries to reallcoate the node then dont make&lt;br/&gt;
the inmemory state to OFFLINE.&lt;br/&gt;
But the noraml assign flow doesnot expect the inmemory state to OFFLINE.&lt;br/&gt;
Hence the above change.  This is continued with the check in &lt;br/&gt;
assign()&lt;br/&gt;
int setOfflineInZooKeeper(final RegionState state,&lt;br/&gt;
      boolean timeOutMonitorReAllocate) {&lt;br/&gt;
    // If invoked from timeoutmonitor the current state in memory need not be&lt;br/&gt;
    // OFFLINE.  &lt;br/&gt;
    if (!timeOutMonitorReAllocate &amp;amp;&amp;amp; !state.isClosed() &amp;amp;&amp;amp; !state.isOffline()) &lt;/p&gt;
{
          this.master.abort(&quot;Unexpected state trying to OFFLINE; &quot; + state,
          new IllegalStateException());
      return -1;
    }
&lt;p&gt;======================================================================&lt;/p&gt;

&lt;p&gt;    boolean allowCreation = false;&lt;br/&gt;
    // If the isReAllocate is true and the current state is PENDING_OPEN&lt;br/&gt;
    // or OPENING then update the inmemory state to PENDING_OPEN. This is&lt;br/&gt;
    // important because&lt;br/&gt;
    // if timeoutmonitor deducts that a region was in OPENING state for a long&lt;br/&gt;
    // time but by the&lt;br/&gt;
    // time timeout monitor tranits the node to OFFLINE the RS would have opened&lt;br/&gt;
    // the node and the&lt;br/&gt;
    // state in znode will be RS_ZK_REGION_OPENED. Inorder to invoke the&lt;br/&gt;
    // OpenedRegionHandler&lt;br/&gt;
    // we expect the inmemeory state to be PENDING_OPEN or OPENING.&lt;br/&gt;
    // For all other cases we can change the inmemory state to OFFLINE.&lt;br/&gt;
    if (timeOutMonitorReAllocate&lt;br/&gt;
        &amp;amp;&amp;amp; (state.getState().equals(RegionState.State.PENDING_OPEN) || state&lt;br/&gt;
            .getState().equals(RegionState.State.OPENING))) &lt;/p&gt;
{
      state.update(RegionState.State.PENDING_OPEN);
      allowCreation = false;
    }
&lt;p&gt; else &lt;/p&gt;
{
      state.update(RegionState.State.OFFLINE);
      allowCreation = true;
    }
&lt;p&gt;This change is quite tricky.  &lt;br/&gt;
In normal assign flow the unassigned node for the region will not be present&lt;br/&gt;
Hence we need to allow the creation of the node newly.&lt;br/&gt;
But in timeout monitor case we will have the node present in some state hence &lt;br/&gt;
we decide whether to create node newly or not inside ZKAssign.createOrForceNodeOffline&lt;/p&gt;

&lt;p&gt;The above code also updates the inmemory state of OFFLINE or PENDING_OPEN&lt;br/&gt;
which was not update in the previous forceRegionStateToOffline() call.&lt;br/&gt;
==============================================================================&lt;br/&gt;
In ZKAssign.java()&lt;br/&gt;
    if (version == -1) {&lt;br/&gt;
      // If timeoutmonitor deducts a node to be in OPENING state but before it&lt;br/&gt;
      // could&lt;br/&gt;
      // transit to OFFLINE state if RS had opened the region then the Master&lt;br/&gt;
      // deletes the&lt;br/&gt;
      // assigned region znode. In that case the znode will not exist. So we&lt;br/&gt;
      // should not&lt;br/&gt;
      // create the znode again which will lead to double assignment.&lt;br/&gt;
      if (timeOutMonitorReAllocate &amp;amp;&amp;amp; !allowCreation) &lt;/p&gt;
{
        return -1;
      }
&lt;p&gt;this part prevents double assignment&lt;br/&gt;
If timeoutmonitor tries to force to OFFLINE state an existing region which was in RIT&lt;br/&gt;
but before it could do that if the node was opened then openedregionhandler will delete&lt;br/&gt;
the node hence we should not create the node again.&lt;/p&gt;

&lt;p&gt;=======================================================================================&lt;br/&gt;
In ZkAssign.java()&lt;br/&gt;
    } else {&lt;br/&gt;
      RegionTransitionData curDataInZNode = ZKAssign.getDataNoWatch(zkw, region&lt;br/&gt;
          .getEncodedName(), stat);&lt;br/&gt;
      // Do not move the node to OFFLINE if znode is in any of the following&lt;br/&gt;
      // state.&lt;br/&gt;
      // Because these are already executed states.&lt;br/&gt;
      if (timeOutMonitorReAllocate &amp;amp;&amp;amp; null != curDataInZNode) {&lt;br/&gt;
        EventType eventType = curDataInZNode.getEventType();&lt;br/&gt;
        if (eventType.equals(EventType.RS_ZK_REGION_CLOSING)&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; eventType.equals(EventType.RS_ZK_REGION_CLOSED)&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; eventType.equals(EventType.RS_ZK_REGION_OPENED)) 
{
          return -1;
        }
&lt;p&gt;      }&lt;br/&gt;
This check prevents from moving the node to OFFLINE state if just before&lt;br/&gt;
the node is tried to force to OFFLINE the RS would have changed the state &lt;br/&gt;
to either CLOSING or CLOSED or OPENED.  now again moving to OFFLINE&lt;br/&gt;
will lead to douoble assignment and will an additional operaition.&lt;/p&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;====================================================================================&lt;br/&gt;
In ZKassign.java()&lt;br/&gt;
      boolean setData = false;&lt;br/&gt;
      try &lt;/p&gt;
{
        setData = ZKUtil.setData(zkw, node, data.getBytes(), version);
        // Setdata throws KeeperException which aborts the Master. So we are
        // catching it here.
        // If just before setting the znode to OFFLINE if the RS has made any
        // change to the
        // znode state then we need to return -1.
      }
&lt;p&gt; catch (KeeperException kpe) &lt;/p&gt;
{
        LOG.info(&quot;Version mismatch while setting the node to OFFLINE state.&quot;);
        return -1;
      }
&lt;p&gt;This change is actually to avoid the master from abortng. If the forceful OFFLINE is in&lt;br/&gt;
progrss but just before setting the RS has changed the state.&lt;br/&gt;
Then the setData will fail leading to master abort.&lt;br/&gt;
Hence we are catching the exception.&lt;br/&gt;
====================================================================================&lt;/p&gt;

&lt;p&gt;In assignmentManager.java&lt;br/&gt;
+      if (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)&lt;br/&gt;
+        return;&lt;br/&gt;
This is nothing but the refactoring done in the existing code.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (setOfflineInZK &amp;amp;&amp;amp; !setOfflineInZooKeeper(state)) return;&lt;br/&gt;
So if setting the version is unsuccessful return.&lt;br/&gt;
=====================================================================================&lt;br/&gt;
In ZKassign.java()&lt;br/&gt;
// the below check ensure that double assignment doesnot happen.&lt;br/&gt;
    // When the node is created for the first time then the expected version&lt;br/&gt;
    // that is&lt;br/&gt;
    // passed will be -1 and the version in znode will be 0.&lt;br/&gt;
    // In all other cases the version in znode will be &amp;gt; 0.&lt;br/&gt;
    else if (beginState.equals(EventType.M_ZK_REGION_OFFLINE)&lt;br/&gt;
        &amp;amp;&amp;amp; endState.equals(EventType.RS_ZK_REGION_OPENING)&lt;br/&gt;
        &amp;amp;&amp;amp; expectedVersion == -1 &amp;amp;&amp;amp; stat.getVersion() != 0) 
{
      LOG.warn(zkw.prefix(&quot;Attempt to transition the &quot; + &quot;unassigned node for &quot;
          + encoded + &quot; from &quot; + beginState + &quot; to &quot; + endState + &quot; failed, &quot;
          + &quot;the node existed but was version &quot; + stat.getVersion()
          + &quot; not the expected version &quot; + expectedVersion));
      return -1;
    }
&lt;p&gt;As the comment explains when the node is created for first time the expectedversion will&lt;br/&gt;
be -1 but the actual version will be 0.  Here the scenario is&lt;br/&gt;
If RS1 has not tranitioned the node from OFFLINE to OPENING if&lt;br/&gt;
RS2 gets the call from Master after forcefully chaning to OFFLINE the&lt;br/&gt;
Rs2 will take the control of the node.&lt;br/&gt;
At that time if RS1 starts transmitting the node then we should not allow&lt;br/&gt;
it.&lt;br/&gt;
===============================================================================&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;.&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-4015&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;Diffs (updated)&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt; 1162313 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt; 1162313 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt; 1162313 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt; 1162313 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt; PRE-CREATION &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt; 1162313 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/a&gt; 1162313 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt; 1162313 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/a&gt; 1162313 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt; 1162313 &lt;/p&gt;

&lt;p&gt;Diff: &lt;a href=&quot;https://reviews.apache.org/r/1668/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;Testing&lt;br/&gt;
-------&lt;/p&gt;

&lt;p&gt;Yes.  But could not add new test case.&lt;br/&gt;
TestMasterFailOver is passing with the current changes also.&lt;/p&gt;


&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;ramkrishna&lt;/p&gt;
</comment>
                            <comment id="13092283" author="jiraposter@reviews.apache.org" created="Sat, 27 Aug 2011 12:00:38 +0000"  >

&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 02:55:47, Ted Yu wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 2362&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line2362&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line2362&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     The two strings can be concatenated:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;      region close&quot;,&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;done&lt;/p&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ramkrishna&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/1668/#review1668&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#review1668&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;


&lt;p&gt;On 2011-08-27 11:51:16, ramkrishna vasudevan wrote:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is an automatically generated e-mail. To reply, visit:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://reviews.apache.org/r/1668/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;(Updated 2011-08-27 11:51:16)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Review request for Ted Yu, Michael Stack, Jean-Daniel Cryans, and Jonathan Gray.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Summary&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; - updated patch.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;invokeTimeOutManager(regionState.getRegion(),&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TimeOutOperationType.ASSIGN);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Instead of storing the state when timeout was deducted we process it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;using future task.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;case RS_ZK_REGION_OPENING:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// TODO: Could check if it was on deadServers.  If it was, then we could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// do what happens in TimeoutMonitor when it sees this condition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Just insert region into RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If this never updates the timeout will trigger new assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) {
bq.            regionsInTransition.put(encodedRegionName, new RegionState(
bq.                regionInfo, RegionState.State.OPENING, data.getStamp(), data
bq.                    .getOrigin()));
bq.            processOpeningState(regionInfo);
bq.            break;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;regionsInTransition.put(encodedRegionName, new RegionState(regionInfo,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionState.State.OPENING, data.getStamp(), data.getOrigin()));&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;break;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;. META and ROOT table need not wait till timeout&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In forceRegionStateToOffline()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeout monitor donot force it to OFFLINE. Based on the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state we will decide if to change in-memory state to OFFLINE or not.  It will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// be done before setting the znode to OFFLINE state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate) {
bq.          LOG.debug(&quot;Forcing OFFLINE; was=&quot; + state);
bq.          state.update(RegionState.State.OFFLINE);
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If the timeout monitor tries to reallcoate the node then dont make&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But the noraml assign flow doesnot expect the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence the above change.  This is continued with the check in &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;assign()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;int setOfflineInZooKeeper(final RegionState state,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean timeOutMonitorReAllocate) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeoutmonitor the current state in memory need not be&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OFFLINE.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate &amp;amp;&amp;amp; !state.isClosed() &amp;amp;&amp;amp; !state.isOffline()) {
bq.            this.master.abort(&quot;Unexpected state trying to OFFLINE; &quot; + state,
bq.            new IllegalStateException());
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean allowCreation = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If the isReAllocate is true and the current state is PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// or OPENING then update the inmemory state to PENDING_OPEN. This is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// important because&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// if timeoutmonitor deducts that a region was in OPENING state for a long&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time but by the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time timeout monitor tranits the node to OFFLINE the RS would have opened&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the node and the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state in znode will be RS_ZK_REGION_OPENED. Inorder to invoke the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OpenedRegionHandler&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// we expect the inmemeory state to be PENDING_OPEN or OPENING.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// For all other cases we can change the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; (state.getState().equals(RegionState.State.PENDING_OPEN) || state&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getState().equals(RegionState.State.OPENING))) {
bq.        state.update(RegionState.State.PENDING_OPEN);
bq.        allowCreation = false;
bq.      } else {
bq.        state.update(RegionState.State.OFFLINE);
bq.        allowCreation = true;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is quite tricky.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In normal assign flow the unassigned node for the region will not be present&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we need to allow the creation of the node newly.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But in timeout monitor case we will have the node present in some state hence &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;we decide whether to create node newly or not inside ZKAssign.createOrForceNodeOffline&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;The above code also updates the inmemory state of OFFLINE or PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;which was not update in the previous forceRegionStateToOffline() call.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;==============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (version == -1) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If timeoutmonitor deducts a node to be in OPENING state but before it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// transit to OFFLINE state if RS had opened the region then the Master&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// deletes the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// assigned region znode. In that case the znode will not exist. So we&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// should not&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// create the znode again which will lead to double assignment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; !allowCreation) {
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;this part prevents double assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If timeoutmonitor tries to force to OFFLINE state an existing region which was in RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;but before it could do that if the node was opened then openedregionhandler will delete&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node hence we should not create the node again.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=======================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZkAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionTransitionData curDataInZNode = ZKAssign.getDataNoWatch(zkw, region&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getEncodedName(), stat);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Do not move the node to OFFLINE if znode is in any of the following&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Because these are already executed states.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; null != curDataInZNode) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;EventType eventType = curDataInZNode.getEventType();&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (eventType.equals(EventType.RS_ZK_REGION_CLOSING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_CLOSED)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_OPENED)) {
bq.            return -1;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;}&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This check prevents from moving the node to OFFLINE state if just before&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node is tried to force to OFFLINE the RS would have changed the state &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;to either CLOSING or CLOSED or OPENED.  now again moving to OFFLINE&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;will lead to douoble assignment and will an additional operaition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean setData = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;try {
bq.          setData = ZKUtil.setData(zkw, node, data.getBytes(), version);
bq.          // Setdata throws KeeperException which aborts the Master. So we are
bq.          // catching it here.
bq.          // If just before setting the znode to OFFLINE if the RS has made any
bq.          // change to the
bq.          // znode state then we need to return -1.
bq.        } catch (KeeperException kpe) {
bq.          LOG.info(&quot;Version mismatch while setting the node to OFFLINE state.&quot;);
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is actually to avoid the master from abortng. If the forceful OFFLINE is in&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;progrss but just before setting the RS has changed the state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Then the setData will fail leading to master abort.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we are catching the exception.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In assignmentManager.java&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+      if (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+        return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is nothing but the refactoring done in the existing code.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-     if (setOfflineInZK &amp;amp;&amp;amp; !setOfflineInZooKeeper(state)) return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;So if setting the version is unsuccessful return.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the below check ensure that double assignment doesnot happen.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// When the node is created for the first time then the expected version&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// that is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// passed will be -1 and the version in znode will be 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// In all other cases the version in znode will be &amp;gt; 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;else if (beginState.equals(EventType.M_ZK_REGION_OFFLINE)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; endState.equals(EventType.RS_ZK_REGION_OPENING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; expectedVersion == -1 &amp;amp;&amp;amp; stat.getVersion() != 0) {
bq.        LOG.warn(zkw.prefix(&quot;Attempt to transition the &quot; + &quot;unassigned node for &quot;
bq.            + encoded + &quot; from &quot; + beginState + &quot; to &quot; + endState + &quot; failed, &quot;
bq.            + &quot;the node existed but was version &quot; + stat.getVersion()
bq.            + &quot; not the expected version &quot; + expectedVersion));
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;As the comment explains when the node is created for first time the expectedversion will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;be -1 but the actual version will be 0.  Here the scenario is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If RS1 has not tranitioned the node from OFFLINE to OPENING if&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RS2 gets the call from Master after forcefully chaning to OFFLINE the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Rs2 will take the control of the node.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;At that time if RS1 starts transmitting the node then we should not allow&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;===============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-4015&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diffs&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt; PRE-CREATION &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diff: &lt;a href=&quot;https://reviews.apache.org/r/1668/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Testing&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Yes.  But could not add new test case.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TestMasterFailOver is passing with the current changes also.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Thanks,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;ramkrishna&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
</comment>
                            <comment id="13092285" author="jiraposter@reviews.apache.org" created="Sat, 27 Aug 2011 12:04:37 +0000"  >

&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; Looks great Ram.  WOuld be hard to write a test for this I think.  What do you think?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes Stack.  I tried but could not. If you can give some suggestions i could do that.&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt;, line 345&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35892#file35892line345&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35892#file35892line345&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     White space.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt;, line 349&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35892#file35892line349&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35892#file35892line349&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     Is it the RS that is creating the OFFLINE node or is it the master that does this and RS moves the region from OFFLINE to OPENING?  No need to say &apos;passed by the master&apos;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;updated the comment&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt;, line 351&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35892#file35892line351&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35892#file35892line351&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     Is this correct?  The open is async w/ the states of opening done up in zk w/ master noticing the last &amp;#8211; right?  The return is whether or not the request to open was accepted?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;updated the comment.&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt;, line 354&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35892#file35892line354&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35892#file35892line354&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     ws&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt;, line 359&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35892#file35892line359&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35892#file35892line359&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     ws&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 148&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line148&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line148&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     ws&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 160&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line160&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line160&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     ws&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 410&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line410&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line410&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     So, whats this special-handling of catalog tables about?  Want to add comment why it is so?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;added suitable comment.  This is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1034&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1034&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1034&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     Todd would say don&apos;t bother adding javadoc if it says nothing other than repeat param names.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1045&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1045&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1045&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     This is a better name for this param though why does this method need to know who is calling it?  Perhaps there is a better name?  timedout?  What you think Ram?&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     Do you mean &apos;reassign&apos; when you say &apos;reallocate&apos;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     So maybe use &apos;reassign&apos; instead of &apos;timedout&apos;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;renamed to reassign. And only in the calling method i have docuemented about this variable.&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1235&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1235&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1235&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     ws&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed.&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1249&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1249&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1249&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     ws&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1264&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1264&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1264&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     When do we do this?  Where do we do the change of in-memory state?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;added suitable comment.&lt;br/&gt;
Actually the original state is updated just before making the node to OFFLINE state.&lt;br/&gt;
It is done in setOfflineInZooKeeper()&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1277&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1277&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1277&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     ws&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;remove&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1281&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1281&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1281&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     yeah, why should this method care where its called from so would suggest removing timeoutMonitor from main and name param for condition under which this method is being called.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;changed to reassign&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1299&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1299&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1299&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     ws&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1304&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1304&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1304&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     ws&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1380&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1380&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1380&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     ws&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1390&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1390&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1390&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     ws&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1396&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1396&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1396&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     maybe &apos;allowZNodeCreation&apos; instead?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;done&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1400&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1400&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1400&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     When you say &apos;deducts&apos; do you mean to use the current tense?  If so, that&apos;d be &apos;deduces&apos;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;changed to deduces.&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1407&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1407&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1407&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     Can you fix up this comment so it aligns a bit better?&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     There is some misspelling in this paragraph that you might want to fix?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;updated the comment. Pls let me know if it is fine.&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1408&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1408&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1408&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     Can you format this a little better?  Have first line end with &amp;amp;&amp;amp; and then second line end with ||.  The state.getState....should be on a single line ... make it easier to read rather than split over two lines.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;done&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1424&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1424&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line1424&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     So, what you think will happen next?  We&apos;ll fail the assign?  Region will be stuck?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Stack, this step is the same as in the previous code.&lt;br/&gt;
I think if the state is not changed agin Timeout will try to assign it.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if(!ZKAssign.createOrForceNodeOffline(master.getZooKeeper(),&lt;/li&gt;
	&lt;li&gt;state.getRegion(), this.master.getServerName())) {&lt;/li&gt;
	&lt;li&gt;LOG.warn(&quot;Attempted to create/force node into OFFLINE state before &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;completing assignment but failed to do so for &quot; + state);&lt;/li&gt;
	&lt;li&gt;return false;&lt;/li&gt;
&lt;/ul&gt;



&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 2351&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line2351&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line2351&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     FYI, I prefer the former formatting where the arg was all on one line rather than split over two.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;done&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 2386&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line2386&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line2386&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     ws&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt;, line 185&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35894#file35894line185&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35894#file35894line185&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     ws&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt;, line 58&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35896#file35896line58&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35896#file35896line58&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     why extra lines down here?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt;, line 2329&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35897#file35897line2329&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35897#file35897line2329&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     ws&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt;, line 55&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35899#file35899line55&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35899#file35899line55&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     ws&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt;, line 236&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35901#file35901line236&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35901#file35901line236&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     ws&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt;, line 761&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35901#file35901line761&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35901#file35901line761&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     ws&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;removed&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 00:20:23, Michael Stack wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 2423&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line2423&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/1/?file=35893#file35893line2423&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     Did you change these Excecutors to verify that the state that caused their being queued still holds before they actually run?  That would be important I&apos;d think if you have not done it that is.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes stack just before we change the allow the new assignment to start the states has been&lt;br/&gt;
verified and only then we have proceeded with forcing the node to OFFLINE once again.&lt;/p&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ramkrishna&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/1668/#review1666&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#review1666&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;


&lt;p&gt;On 2011-08-27 11:51:16, ramkrishna vasudevan wrote:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is an automatically generated e-mail. To reply, visit:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://reviews.apache.org/r/1668/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;(Updated 2011-08-27 11:51:16)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Review request for Ted Yu, Michael Stack, Jean-Daniel Cryans, and Jonathan Gray.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Summary&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; - updated patch.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;invokeTimeOutManager(regionState.getRegion(),&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TimeOutOperationType.ASSIGN);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Instead of storing the state when timeout was deducted we process it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;using future task.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;case RS_ZK_REGION_OPENING:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// TODO: Could check if it was on deadServers.  If it was, then we could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// do what happens in TimeoutMonitor when it sees this condition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Just insert region into RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If this never updates the timeout will trigger new assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) {
bq.            regionsInTransition.put(encodedRegionName, new RegionState(
bq.                regionInfo, RegionState.State.OPENING, data.getStamp(), data
bq.                    .getOrigin()));
bq.            processOpeningState(regionInfo);
bq.            break;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;regionsInTransition.put(encodedRegionName, new RegionState(regionInfo,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionState.State.OPENING, data.getStamp(), data.getOrigin()));&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;break;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;. META and ROOT table need not wait till timeout&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In forceRegionStateToOffline()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeout monitor donot force it to OFFLINE. Based on the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state we will decide if to change in-memory state to OFFLINE or not.  It will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// be done before setting the znode to OFFLINE state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate) {
bq.          LOG.debug(&quot;Forcing OFFLINE; was=&quot; + state);
bq.          state.update(RegionState.State.OFFLINE);
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If the timeout monitor tries to reallcoate the node then dont make&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But the noraml assign flow doesnot expect the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence the above change.  This is continued with the check in &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;assign()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;int setOfflineInZooKeeper(final RegionState state,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean timeOutMonitorReAllocate) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeoutmonitor the current state in memory need not be&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OFFLINE.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate &amp;amp;&amp;amp; !state.isClosed() &amp;amp;&amp;amp; !state.isOffline()) {
bq.            this.master.abort(&quot;Unexpected state trying to OFFLINE; &quot; + state,
bq.            new IllegalStateException());
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean allowCreation = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If the isReAllocate is true and the current state is PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// or OPENING then update the inmemory state to PENDING_OPEN. This is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// important because&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// if timeoutmonitor deducts that a region was in OPENING state for a long&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time but by the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time timeout monitor tranits the node to OFFLINE the RS would have opened&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the node and the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state in znode will be RS_ZK_REGION_OPENED. Inorder to invoke the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OpenedRegionHandler&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// we expect the inmemeory state to be PENDING_OPEN or OPENING.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// For all other cases we can change the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; (state.getState().equals(RegionState.State.PENDING_OPEN) || state&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getState().equals(RegionState.State.OPENING))) {
bq.        state.update(RegionState.State.PENDING_OPEN);
bq.        allowCreation = false;
bq.      } else {
bq.        state.update(RegionState.State.OFFLINE);
bq.        allowCreation = true;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is quite tricky.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In normal assign flow the unassigned node for the region will not be present&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we need to allow the creation of the node newly.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But in timeout monitor case we will have the node present in some state hence &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;we decide whether to create node newly or not inside ZKAssign.createOrForceNodeOffline&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;The above code also updates the inmemory state of OFFLINE or PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;which was not update in the previous forceRegionStateToOffline() call.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;==============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (version == -1) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If timeoutmonitor deducts a node to be in OPENING state but before it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// transit to OFFLINE state if RS had opened the region then the Master&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// deletes the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// assigned region znode. In that case the znode will not exist. So we&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// should not&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// create the znode again which will lead to double assignment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; !allowCreation) {
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;this part prevents double assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If timeoutmonitor tries to force to OFFLINE state an existing region which was in RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;but before it could do that if the node was opened then openedregionhandler will delete&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node hence we should not create the node again.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=======================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZkAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionTransitionData curDataInZNode = ZKAssign.getDataNoWatch(zkw, region&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getEncodedName(), stat);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Do not move the node to OFFLINE if znode is in any of the following&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Because these are already executed states.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; null != curDataInZNode) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;EventType eventType = curDataInZNode.getEventType();&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (eventType.equals(EventType.RS_ZK_REGION_CLOSING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_CLOSED)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_OPENED)) {
bq.            return -1;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;}&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This check prevents from moving the node to OFFLINE state if just before&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node is tried to force to OFFLINE the RS would have changed the state &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;to either CLOSING or CLOSED or OPENED.  now again moving to OFFLINE&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;will lead to douoble assignment and will an additional operaition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean setData = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;try {
bq.          setData = ZKUtil.setData(zkw, node, data.getBytes(), version);
bq.          // Setdata throws KeeperException which aborts the Master. So we are
bq.          // catching it here.
bq.          // If just before setting the znode to OFFLINE if the RS has made any
bq.          // change to the
bq.          // znode state then we need to return -1.
bq.        } catch (KeeperException kpe) {
bq.          LOG.info(&quot;Version mismatch while setting the node to OFFLINE state.&quot;);
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is actually to avoid the master from abortng. If the forceful OFFLINE is in&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;progrss but just before setting the RS has changed the state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Then the setData will fail leading to master abort.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we are catching the exception.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In assignmentManager.java&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+      if (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+        return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is nothing but the refactoring done in the existing code.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-     if (setOfflineInZK &amp;amp;&amp;amp; !setOfflineInZooKeeper(state)) return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;So if setting the version is unsuccessful return.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the below check ensure that double assignment doesnot happen.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// When the node is created for the first time then the expected version&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// that is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// passed will be -1 and the version in znode will be 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// In all other cases the version in znode will be &amp;gt; 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;else if (beginState.equals(EventType.M_ZK_REGION_OFFLINE)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; endState.equals(EventType.RS_ZK_REGION_OPENING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; expectedVersion == -1 &amp;amp;&amp;amp; stat.getVersion() != 0) {
bq.        LOG.warn(zkw.prefix(&quot;Attempt to transition the &quot; + &quot;unassigned node for &quot;
bq.            + encoded + &quot; from &quot; + beginState + &quot; to &quot; + endState + &quot; failed, &quot;
bq.            + &quot;the node existed but was version &quot; + stat.getVersion()
bq.            + &quot; not the expected version &quot; + expectedVersion));
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;As the comment explains when the node is created for first time the expectedversion will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;be -1 but the actual version will be 0.  Here the scenario is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If RS1 has not tranitioned the node from OFFLINE to OPENING if&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RS2 gets the call from Master after forcefully chaning to OFFLINE the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Rs2 will take the control of the node.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;At that time if RS1 starts transmitting the node then we should not allow&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;===============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-4015&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diffs&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt; PRE-CREATION &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diff: &lt;a href=&quot;https://reviews.apache.org/r/1668/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Testing&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Yes.  But could not add new test case.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TestMasterFailOver is passing with the current changes also.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Thanks,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;ramkrishna&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
</comment>
                            <comment id="13092313" author="yuzhihong@gmail.com" created="Sat, 27 Aug 2011 15:24:21 +0000"  >&lt;p&gt;@Ramkrishna:&lt;br/&gt;
If you have access to a real cluster, can you do the following:&lt;br/&gt;
1. create a table and load it with data so that it has over 400 regions&lt;br/&gt;
2. continue writing/reading the table and trigger region splits&lt;br/&gt;
3. issue balancer command&lt;br/&gt;
You can instrument TimeoutMonitor to record stats for occurrences of timeouts&lt;br/&gt;
At the end of test, use hbck to check consistency&lt;/p&gt;

&lt;p&gt;Thanks&lt;/p&gt;</comment>
                            <comment id="13092317" author="jiraposter@reviews.apache.org" created="Sat, 27 Aug 2011 15:46:37 +0000"  >
&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/1668/#review1672&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#review1672&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3807&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3807&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    The three states should be placed on three lines with proper indentation.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment3808&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment3808&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    versionOfTheOffline seems to be copied from a variable name. Please split it into 4 words: version of the offline&lt;/p&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Ted&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;On 2011-08-27 11:51:16, ramkrishna vasudevan wrote:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is an automatically generated e-mail. To reply, visit:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://reviews.apache.org/r/1668/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;(Updated 2011-08-27 11:51:16)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Review request for Ted Yu, Michael Stack, Jean-Daniel Cryans, and Jonathan Gray.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Summary&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; - updated patch.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;invokeTimeOutManager(regionState.getRegion(),&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TimeOutOperationType.ASSIGN);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Instead of storing the state when timeout was deducted we process it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;using future task.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;case RS_ZK_REGION_OPENING:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// TODO: Could check if it was on deadServers.  If it was, then we could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// do what happens in TimeoutMonitor when it sees this condition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Just insert region into RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If this never updates the timeout will trigger new assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) {
bq.            regionsInTransition.put(encodedRegionName, new RegionState(
bq.                regionInfo, RegionState.State.OPENING, data.getStamp(), data
bq.                    .getOrigin()));
bq.            processOpeningState(regionInfo);
bq.            break;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;regionsInTransition.put(encodedRegionName, new RegionState(regionInfo,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionState.State.OPENING, data.getStamp(), data.getOrigin()));&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;break;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;. META and ROOT table need not wait till timeout&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In forceRegionStateToOffline()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeout monitor donot force it to OFFLINE. Based on the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state we will decide if to change in-memory state to OFFLINE or not.  It will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// be done before setting the znode to OFFLINE state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate) {
bq.          LOG.debug(&quot;Forcing OFFLINE; was=&quot; + state);
bq.          state.update(RegionState.State.OFFLINE);
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If the timeout monitor tries to reallcoate the node then dont make&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But the noraml assign flow doesnot expect the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence the above change.  This is continued with the check in &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;assign()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;int setOfflineInZooKeeper(final RegionState state,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean timeOutMonitorReAllocate) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeoutmonitor the current state in memory need not be&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OFFLINE.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate &amp;amp;&amp;amp; !state.isClosed() &amp;amp;&amp;amp; !state.isOffline()) {
bq.            this.master.abort(&quot;Unexpected state trying to OFFLINE; &quot; + state,
bq.            new IllegalStateException());
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean allowCreation = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If the isReAllocate is true and the current state is PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// or OPENING then update the inmemory state to PENDING_OPEN. This is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// important because&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// if timeoutmonitor deducts that a region was in OPENING state for a long&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time but by the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time timeout monitor tranits the node to OFFLINE the RS would have opened&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the node and the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state in znode will be RS_ZK_REGION_OPENED. Inorder to invoke the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OpenedRegionHandler&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// we expect the inmemeory state to be PENDING_OPEN or OPENING.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// For all other cases we can change the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; (state.getState().equals(RegionState.State.PENDING_OPEN) || state&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getState().equals(RegionState.State.OPENING))) {
bq.        state.update(RegionState.State.PENDING_OPEN);
bq.        allowCreation = false;
bq.      } else {
bq.        state.update(RegionState.State.OFFLINE);
bq.        allowCreation = true;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is quite tricky.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In normal assign flow the unassigned node for the region will not be present&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we need to allow the creation of the node newly.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But in timeout monitor case we will have the node present in some state hence &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;we decide whether to create node newly or not inside ZKAssign.createOrForceNodeOffline&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;The above code also updates the inmemory state of OFFLINE or PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;which was not update in the previous forceRegionStateToOffline() call.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;==============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (version == -1) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If timeoutmonitor deducts a node to be in OPENING state but before it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// transit to OFFLINE state if RS had opened the region then the Master&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// deletes the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// assigned region znode. In that case the znode will not exist. So we&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// should not&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// create the znode again which will lead to double assignment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; !allowCreation) {
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;this part prevents double assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If timeoutmonitor tries to force to OFFLINE state an existing region which was in RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;but before it could do that if the node was opened then openedregionhandler will delete&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node hence we should not create the node again.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=======================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZkAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionTransitionData curDataInZNode = ZKAssign.getDataNoWatch(zkw, region&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getEncodedName(), stat);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Do not move the node to OFFLINE if znode is in any of the following&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Because these are already executed states.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; null != curDataInZNode) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;EventType eventType = curDataInZNode.getEventType();&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (eventType.equals(EventType.RS_ZK_REGION_CLOSING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_CLOSED)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_OPENED)) {
bq.            return -1;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;}&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This check prevents from moving the node to OFFLINE state if just before&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node is tried to force to OFFLINE the RS would have changed the state &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;to either CLOSING or CLOSED or OPENED.  now again moving to OFFLINE&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;will lead to douoble assignment and will an additional operaition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean setData = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;try {
bq.          setData = ZKUtil.setData(zkw, node, data.getBytes(), version);
bq.          // Setdata throws KeeperException which aborts the Master. So we are
bq.          // catching it here.
bq.          // If just before setting the znode to OFFLINE if the RS has made any
bq.          // change to the
bq.          // znode state then we need to return -1.
bq.        } catch (KeeperException kpe) {
bq.          LOG.info(&quot;Version mismatch while setting the node to OFFLINE state.&quot;);
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is actually to avoid the master from abortng. If the forceful OFFLINE is in&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;progrss but just before setting the RS has changed the state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Then the setData will fail leading to master abort.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we are catching the exception.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In assignmentManager.java&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+      if (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+        return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is nothing but the refactoring done in the existing code.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-     if (setOfflineInZK &amp;amp;&amp;amp; !setOfflineInZooKeeper(state)) return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;So if setting the version is unsuccessful return.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the below check ensure that double assignment doesnot happen.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// When the node is created for the first time then the expected version&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// that is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// passed will be -1 and the version in znode will be 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// In all other cases the version in znode will be &amp;gt; 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;else if (beginState.equals(EventType.M_ZK_REGION_OFFLINE)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; endState.equals(EventType.RS_ZK_REGION_OPENING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; expectedVersion == -1 &amp;amp;&amp;amp; stat.getVersion() != 0) {
bq.        LOG.warn(zkw.prefix(&quot;Attempt to transition the &quot; + &quot;unassigned node for &quot;
bq.            + encoded + &quot; from &quot; + beginState + &quot; to &quot; + endState + &quot; failed, &quot;
bq.            + &quot;the node existed but was version &quot; + stat.getVersion()
bq.            + &quot; not the expected version &quot; + expectedVersion));
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;As the comment explains when the node is created for first time the expectedversion will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;be -1 but the actual version will be 0.  Here the scenario is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If RS1 has not tranitioned the node from OFFLINE to OPENING if&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RS2 gets the call from Master after forcefully chaning to OFFLINE the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Rs2 will take the control of the node.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;At that time if RS1 starts transmitting the node then we should not allow&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;===============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-4015&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diffs&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt; PRE-CREATION &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diff: &lt;a href=&quot;https://reviews.apache.org/r/1668/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Testing&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Yes.  But could not add new test case.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TestMasterFailOver is passing with the current changes also.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Thanks,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;ramkrishna&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
</comment>
                            <comment id="13092648" author="ram_krish" created="Mon, 29 Aug 2011 05:59:03 +0000"  >&lt;p&gt;@Ted&lt;br/&gt;
I will do the testing as you have told. Thanks&lt;/p&gt;</comment>
                            <comment id="13092792" author="jiraposter@reviews.apache.org" created="Mon, 29 Aug 2011 12:11:37 +0000"  >

&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 15:45:25, Ted Yu wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt;, line 350&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/2/?file=36049#file36049line350&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/2/?file=36049#file36049line350&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     The three states should be placed on three lines with proper indentation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;updated&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-08-27 15:45:25, Ted Yu wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1379&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/2/?file=36050#file36050line1379&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/2/?file=36050#file36050line1379&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     versionOfTheOffline seems to be copied from a variable name. Please split it into 4 words: version of the offline&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;updated&lt;/p&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ramkrishna&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/1668/#review1672&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#review1672&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;


&lt;p&gt;On 2011-08-27 11:51:16, ramkrishna vasudevan wrote:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is an automatically generated e-mail. To reply, visit:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://reviews.apache.org/r/1668/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;(Updated 2011-08-27 11:51:16)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Review request for Ted Yu, Michael Stack, Jean-Daniel Cryans, and Jonathan Gray.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Summary&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; - updated patch.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;invokeTimeOutManager(regionState.getRegion(),&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TimeOutOperationType.ASSIGN);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Instead of storing the state when timeout was deducted we process it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;using future task.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;case RS_ZK_REGION_OPENING:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// TODO: Could check if it was on deadServers.  If it was, then we could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// do what happens in TimeoutMonitor when it sees this condition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Just insert region into RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If this never updates the timeout will trigger new assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) {
bq.            regionsInTransition.put(encodedRegionName, new RegionState(
bq.                regionInfo, RegionState.State.OPENING, data.getStamp(), data
bq.                    .getOrigin()));
bq.            processOpeningState(regionInfo);
bq.            break;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;regionsInTransition.put(encodedRegionName, new RegionState(regionInfo,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionState.State.OPENING, data.getStamp(), data.getOrigin()));&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;break;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;. META and ROOT table need not wait till timeout&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In forceRegionStateToOffline()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeout monitor donot force it to OFFLINE. Based on the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state we will decide if to change in-memory state to OFFLINE or not.  It will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// be done before setting the znode to OFFLINE state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate) {
bq.          LOG.debug(&quot;Forcing OFFLINE; was=&quot; + state);
bq.          state.update(RegionState.State.OFFLINE);
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If the timeout monitor tries to reallcoate the node then dont make&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But the noraml assign flow doesnot expect the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence the above change.  This is continued with the check in &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;assign()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;int setOfflineInZooKeeper(final RegionState state,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean timeOutMonitorReAllocate) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeoutmonitor the current state in memory need not be&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OFFLINE.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate &amp;amp;&amp;amp; !state.isClosed() &amp;amp;&amp;amp; !state.isOffline()) {
bq.            this.master.abort(&quot;Unexpected state trying to OFFLINE; &quot; + state,
bq.            new IllegalStateException());
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean allowCreation = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If the isReAllocate is true and the current state is PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// or OPENING then update the inmemory state to PENDING_OPEN. This is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// important because&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// if timeoutmonitor deducts that a region was in OPENING state for a long&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time but by the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time timeout monitor tranits the node to OFFLINE the RS would have opened&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the node and the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state in znode will be RS_ZK_REGION_OPENED. Inorder to invoke the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OpenedRegionHandler&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// we expect the inmemeory state to be PENDING_OPEN or OPENING.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// For all other cases we can change the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; (state.getState().equals(RegionState.State.PENDING_OPEN) || state&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getState().equals(RegionState.State.OPENING))) {
bq.        state.update(RegionState.State.PENDING_OPEN);
bq.        allowCreation = false;
bq.      } else {
bq.        state.update(RegionState.State.OFFLINE);
bq.        allowCreation = true;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is quite tricky.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In normal assign flow the unassigned node for the region will not be present&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we need to allow the creation of the node newly.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But in timeout monitor case we will have the node present in some state hence &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;we decide whether to create node newly or not inside ZKAssign.createOrForceNodeOffline&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;The above code also updates the inmemory state of OFFLINE or PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;which was not update in the previous forceRegionStateToOffline() call.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;==============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (version == -1) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If timeoutmonitor deducts a node to be in OPENING state but before it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// transit to OFFLINE state if RS had opened the region then the Master&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// deletes the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// assigned region znode. In that case the znode will not exist. So we&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// should not&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// create the znode again which will lead to double assignment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; !allowCreation) {
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;this part prevents double assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If timeoutmonitor tries to force to OFFLINE state an existing region which was in RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;but before it could do that if the node was opened then openedregionhandler will delete&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node hence we should not create the node again.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=======================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZkAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionTransitionData curDataInZNode = ZKAssign.getDataNoWatch(zkw, region&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getEncodedName(), stat);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Do not move the node to OFFLINE if znode is in any of the following&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Because these are already executed states.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; null != curDataInZNode) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;EventType eventType = curDataInZNode.getEventType();&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (eventType.equals(EventType.RS_ZK_REGION_CLOSING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_CLOSED)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_OPENED)) {
bq.            return -1;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;}&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This check prevents from moving the node to OFFLINE state if just before&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node is tried to force to OFFLINE the RS would have changed the state &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;to either CLOSING or CLOSED or OPENED.  now again moving to OFFLINE&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;will lead to douoble assignment and will an additional operaition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean setData = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;try {
bq.          setData = ZKUtil.setData(zkw, node, data.getBytes(), version);
bq.          // Setdata throws KeeperException which aborts the Master. So we are
bq.          // catching it here.
bq.          // If just before setting the znode to OFFLINE if the RS has made any
bq.          // change to the
bq.          // znode state then we need to return -1.
bq.        } catch (KeeperException kpe) {
bq.          LOG.info(&quot;Version mismatch while setting the node to OFFLINE state.&quot;);
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is actually to avoid the master from abortng. If the forceful OFFLINE is in&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;progrss but just before setting the RS has changed the state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Then the setData will fail leading to master abort.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we are catching the exception.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In assignmentManager.java&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+      if (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+        return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is nothing but the refactoring done in the existing code.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-     if (setOfflineInZK &amp;amp;&amp;amp; !setOfflineInZooKeeper(state)) return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;So if setting the version is unsuccessful return.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the below check ensure that double assignment doesnot happen.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// When the node is created for the first time then the expected version&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// that is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// passed will be -1 and the version in znode will be 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// In all other cases the version in znode will be &amp;gt; 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;else if (beginState.equals(EventType.M_ZK_REGION_OFFLINE)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; endState.equals(EventType.RS_ZK_REGION_OPENING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; expectedVersion == -1 &amp;amp;&amp;amp; stat.getVersion() != 0) {
bq.        LOG.warn(zkw.prefix(&quot;Attempt to transition the &quot; + &quot;unassigned node for &quot;
bq.            + encoded + &quot; from &quot; + beginState + &quot; to &quot; + endState + &quot; failed, &quot;
bq.            + &quot;the node existed but was version &quot; + stat.getVersion()
bq.            + &quot; not the expected version &quot; + expectedVersion));
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;As the comment explains when the node is created for first time the expectedversion will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;be -1 but the actual version will be 0.  Here the scenario is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If RS1 has not tranitioned the node from OFFLINE to OPENING if&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RS2 gets the call from Master after forcefully chaning to OFFLINE the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Rs2 will take the control of the node.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;At that time if RS1 starts transmitting the node then we should not allow&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;===============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-4015&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diffs&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt; PRE-CREATION &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt; 1162313 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diff: &lt;a href=&quot;https://reviews.apache.org/r/1668/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Testing&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Yes.  But could not add new test case.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TestMasterFailOver is passing with the current changes also.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Thanks,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;ramkrishna&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
</comment>
                            <comment id="13092793" author="jiraposter@reviews.apache.org" created="Mon, 29 Aug 2011 12:11:39 +0000"  >
&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/1668/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;

&lt;p&gt;(Updated 2011-08-29 12:11:23.781032)&lt;/p&gt;


&lt;p&gt;Review request for Ted Yu, Michael Stack, Jean-Daniel Cryans, and Jonathan Gray.&lt;/p&gt;


&lt;p&gt;Summary&lt;br/&gt;
-------&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; - updated patch.&lt;/p&gt;


&lt;p&gt;        invokeTimeOutManager(regionState.getRegion(),&lt;br/&gt;
            TimeOutOperationType.ASSIGN);&lt;/p&gt;

&lt;p&gt;Instead of storing the state when timeout was deducted we process it&lt;br/&gt;
using future task.&lt;br/&gt;
================================================================&lt;/p&gt;

&lt;p&gt;      case RS_ZK_REGION_OPENING:&lt;br/&gt;
        // TODO: Could check if it was on deadServers.  If it was, then we could&lt;br/&gt;
        // do what happens in TimeoutMonitor when it sees this condition.&lt;/p&gt;

&lt;p&gt;        // Just insert region into RIT&lt;br/&gt;
        // If this never updates the timeout will trigger new assignment&lt;br/&gt;
        if (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) &lt;/p&gt;
{
          regionsInTransition.put(encodedRegionName, new RegionState(
              regionInfo, RegionState.State.OPENING, data.getStamp(), data
                  .getOrigin()));
          processOpeningState(regionInfo);
          break;
        }
&lt;p&gt;        regionsInTransition.put(encodedRegionName, new RegionState(regionInfo,&lt;br/&gt;
            RegionState.State.OPENING, data.getStamp(), data.getOrigin()));&lt;br/&gt;
        break;&lt;/p&gt;

&lt;p&gt;This change is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;. META and ROOT table need not wait till timeout&lt;br/&gt;
======================================================================&lt;/p&gt;

&lt;p&gt;In forceRegionStateToOffline()&lt;/p&gt;

&lt;p&gt;    } else {&lt;br/&gt;
      // If invoked from timeout monitor donot force it to OFFLINE. Based on the&lt;br/&gt;
      // state we will decide if to change in-memory state to OFFLINE or not.  It will&lt;br/&gt;
      // be done before setting the znode to OFFLINE state.&lt;br/&gt;
      if (!timeOutMonitorReAllocate) &lt;/p&gt;
{
        LOG.debug(&quot;Forcing OFFLINE; was=&quot; + state);
        state.update(RegionState.State.OFFLINE);
      }
&lt;p&gt;If the timeout monitor tries to reallcoate the node then dont make&lt;br/&gt;
the inmemory state to OFFLINE.&lt;br/&gt;
But the noraml assign flow doesnot expect the inmemory state to OFFLINE.&lt;br/&gt;
Hence the above change.  This is continued with the check in &lt;br/&gt;
assign()&lt;br/&gt;
int setOfflineInZooKeeper(final RegionState state,&lt;br/&gt;
      boolean timeOutMonitorReAllocate) {&lt;br/&gt;
    // If invoked from timeoutmonitor the current state in memory need not be&lt;br/&gt;
    // OFFLINE.  &lt;br/&gt;
    if (!timeOutMonitorReAllocate &amp;amp;&amp;amp; !state.isClosed() &amp;amp;&amp;amp; !state.isOffline()) &lt;/p&gt;
{
          this.master.abort(&quot;Unexpected state trying to OFFLINE; &quot; + state,
          new IllegalStateException());
      return -1;
    }
&lt;p&gt;======================================================================&lt;/p&gt;

&lt;p&gt;    boolean allowCreation = false;&lt;br/&gt;
    // If the isReAllocate is true and the current state is PENDING_OPEN&lt;br/&gt;
    // or OPENING then update the inmemory state to PENDING_OPEN. This is&lt;br/&gt;
    // important because&lt;br/&gt;
    // if timeoutmonitor deducts that a region was in OPENING state for a long&lt;br/&gt;
    // time but by the&lt;br/&gt;
    // time timeout monitor tranits the node to OFFLINE the RS would have opened&lt;br/&gt;
    // the node and the&lt;br/&gt;
    // state in znode will be RS_ZK_REGION_OPENED. Inorder to invoke the&lt;br/&gt;
    // OpenedRegionHandler&lt;br/&gt;
    // we expect the inmemeory state to be PENDING_OPEN or OPENING.&lt;br/&gt;
    // For all other cases we can change the inmemory state to OFFLINE.&lt;br/&gt;
    if (timeOutMonitorReAllocate&lt;br/&gt;
        &amp;amp;&amp;amp; (state.getState().equals(RegionState.State.PENDING_OPEN) || state&lt;br/&gt;
            .getState().equals(RegionState.State.OPENING))) &lt;/p&gt;
{
      state.update(RegionState.State.PENDING_OPEN);
      allowCreation = false;
    }
&lt;p&gt; else &lt;/p&gt;
{
      state.update(RegionState.State.OFFLINE);
      allowCreation = true;
    }
&lt;p&gt;This change is quite tricky.  &lt;br/&gt;
In normal assign flow the unassigned node for the region will not be present&lt;br/&gt;
Hence we need to allow the creation of the node newly.&lt;br/&gt;
But in timeout monitor case we will have the node present in some state hence &lt;br/&gt;
we decide whether to create node newly or not inside ZKAssign.createOrForceNodeOffline&lt;/p&gt;

&lt;p&gt;The above code also updates the inmemory state of OFFLINE or PENDING_OPEN&lt;br/&gt;
which was not update in the previous forceRegionStateToOffline() call.&lt;br/&gt;
==============================================================================&lt;br/&gt;
In ZKAssign.java()&lt;br/&gt;
    if (version == -1) {&lt;br/&gt;
      // If timeoutmonitor deducts a node to be in OPENING state but before it&lt;br/&gt;
      // could&lt;br/&gt;
      // transit to OFFLINE state if RS had opened the region then the Master&lt;br/&gt;
      // deletes the&lt;br/&gt;
      // assigned region znode. In that case the znode will not exist. So we&lt;br/&gt;
      // should not&lt;br/&gt;
      // create the znode again which will lead to double assignment.&lt;br/&gt;
      if (timeOutMonitorReAllocate &amp;amp;&amp;amp; !allowCreation) &lt;/p&gt;
{
        return -1;
      }
&lt;p&gt;this part prevents double assignment&lt;br/&gt;
If timeoutmonitor tries to force to OFFLINE state an existing region which was in RIT&lt;br/&gt;
but before it could do that if the node was opened then openedregionhandler will delete&lt;br/&gt;
the node hence we should not create the node again.&lt;/p&gt;

&lt;p&gt;=======================================================================================&lt;br/&gt;
In ZkAssign.java()&lt;br/&gt;
    } else {&lt;br/&gt;
      RegionTransitionData curDataInZNode = ZKAssign.getDataNoWatch(zkw, region&lt;br/&gt;
          .getEncodedName(), stat);&lt;br/&gt;
      // Do not move the node to OFFLINE if znode is in any of the following&lt;br/&gt;
      // state.&lt;br/&gt;
      // Because these are already executed states.&lt;br/&gt;
      if (timeOutMonitorReAllocate &amp;amp;&amp;amp; null != curDataInZNode) {&lt;br/&gt;
        EventType eventType = curDataInZNode.getEventType();&lt;br/&gt;
        if (eventType.equals(EventType.RS_ZK_REGION_CLOSING)&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; eventType.equals(EventType.RS_ZK_REGION_CLOSED)&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; eventType.equals(EventType.RS_ZK_REGION_OPENED)) 
{
          return -1;
        }
&lt;p&gt;      }&lt;br/&gt;
This check prevents from moving the node to OFFLINE state if just before&lt;br/&gt;
the node is tried to force to OFFLINE the RS would have changed the state &lt;br/&gt;
to either CLOSING or CLOSED or OPENED.  now again moving to OFFLINE&lt;br/&gt;
will lead to douoble assignment and will an additional operaition.&lt;/p&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;====================================================================================&lt;br/&gt;
In ZKassign.java()&lt;br/&gt;
      boolean setData = false;&lt;br/&gt;
      try &lt;/p&gt;
{
        setData = ZKUtil.setData(zkw, node, data.getBytes(), version);
        // Setdata throws KeeperException which aborts the Master. So we are
        // catching it here.
        // If just before setting the znode to OFFLINE if the RS has made any
        // change to the
        // znode state then we need to return -1.
      }
&lt;p&gt; catch (KeeperException kpe) &lt;/p&gt;
{
        LOG.info(&quot;Version mismatch while setting the node to OFFLINE state.&quot;);
        return -1;
      }
&lt;p&gt;This change is actually to avoid the master from abortng. If the forceful OFFLINE is in&lt;br/&gt;
progrss but just before setting the RS has changed the state.&lt;br/&gt;
Then the setData will fail leading to master abort.&lt;br/&gt;
Hence we are catching the exception.&lt;br/&gt;
====================================================================================&lt;/p&gt;

&lt;p&gt;In assignmentManager.java&lt;br/&gt;
+      if (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)&lt;br/&gt;
+        return;&lt;br/&gt;
This is nothing but the refactoring done in the existing code.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (setOfflineInZK &amp;amp;&amp;amp; !setOfflineInZooKeeper(state)) return;&lt;br/&gt;
So if setting the version is unsuccessful return.&lt;br/&gt;
=====================================================================================&lt;br/&gt;
In ZKassign.java()&lt;br/&gt;
// the below check ensure that double assignment doesnot happen.&lt;br/&gt;
    // When the node is created for the first time then the expected version&lt;br/&gt;
    // that is&lt;br/&gt;
    // passed will be -1 and the version in znode will be 0.&lt;br/&gt;
    // In all other cases the version in znode will be &amp;gt; 0.&lt;br/&gt;
    else if (beginState.equals(EventType.M_ZK_REGION_OFFLINE)&lt;br/&gt;
        &amp;amp;&amp;amp; endState.equals(EventType.RS_ZK_REGION_OPENING)&lt;br/&gt;
        &amp;amp;&amp;amp; expectedVersion == -1 &amp;amp;&amp;amp; stat.getVersion() != 0) 
{
      LOG.warn(zkw.prefix(&quot;Attempt to transition the &quot; + &quot;unassigned node for &quot;
          + encoded + &quot; from &quot; + beginState + &quot; to &quot; + endState + &quot; failed, &quot;
          + &quot;the node existed but was version &quot; + stat.getVersion()
          + &quot; not the expected version &quot; + expectedVersion));
      return -1;
    }
&lt;p&gt;As the comment explains when the node is created for first time the expectedversion will&lt;br/&gt;
be -1 but the actual version will be 0.  Here the scenario is&lt;br/&gt;
If RS1 has not tranitioned the node from OFFLINE to OPENING if&lt;br/&gt;
RS2 gets the call from Master after forcefully chaning to OFFLINE the&lt;br/&gt;
Rs2 will take the control of the node.&lt;br/&gt;
At that time if RS1 starts transmitting the node then we should not allow&lt;br/&gt;
it.&lt;br/&gt;
===============================================================================&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;.&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-4015&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;Diffs (updated)&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt; 1161985 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt; 1161985 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt; 1161985 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt; 1161985 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt; PRE-CREATION &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt; 1161985 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/a&gt; 1161985 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt; 1161985 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/a&gt; 1161985 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt; 1161985 &lt;/p&gt;

&lt;p&gt;Diff: &lt;a href=&quot;https://reviews.apache.org/r/1668/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;Testing&lt;br/&gt;
-------&lt;/p&gt;

&lt;p&gt;Yes.  But could not add new test case.&lt;br/&gt;
TestMasterFailOver is passing with the current changes also.&lt;/p&gt;


&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;ramkrishna&lt;/p&gt;
</comment>
                            <comment id="13096126" author="ram_krish" created="Fri, 2 Sep 2011 16:56:41 +0000"  >&lt;p&gt;The following tests were performed&lt;/p&gt;

&lt;p&gt;The cluster has 3 nodes.&lt;br/&gt;
Created some 4000+ regions.  And i followed the startegy like&lt;/p&gt;

&lt;p&gt;Initially create regions&lt;/p&gt;

&lt;p&gt;Balancer will balance the regions across all the three.&lt;/p&gt;

&lt;p&gt;Using a script kill the RS in these 3 nodes at fixed time.(at different time intervals).&lt;/p&gt;

&lt;p&gt;Then start it after sometime.&lt;/p&gt;

&lt;p&gt;Sometimes once all the 3 RS are up invoke the balancer command manually.&lt;/p&gt;

&lt;p&gt;While balancing kill one of the RS which was the destination during balancer calculation.&lt;br/&gt;
Again bring it up.&lt;/p&gt;

&lt;p&gt;The number of regions remained constant and every time the Timeout detected it was able to overcome it with no issues at all.&lt;/p&gt;

&lt;p&gt;I also calculated some metrics&lt;/p&gt;

&lt;p&gt;There were instance were 144, 249,1334, 30 regions were timed out.&lt;br/&gt;
For any timeout region to be monitored and completed it took at the max 1.5 sec minimum being 0.35 secs.&lt;/p&gt;

&lt;p&gt;The following logs shows the scenario where the timeout monitor tries to assign a node to OFFLINE but by the time the node is changed to OPENED by RS.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
2011-09-02 18:15:55,621 INFO org.apache.hadoop.hbase.master.AssignmentManager: Region has been PENDING_OPEN &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; too &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt;, reassigning region=testram2,9970,1314962425951.b7a45cf31651d5cbba682ae24b83bf88.
2011-09-02 18:15:55,709 INFO org.mortbay.log: Timeout detected &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; the region testram2,9970,1314962425951.b7a45cf31651d5cbba682ae24b83bf88. at Fri Sep 02 18:15:55 IST 2011
2011-09-02 18:15:55,942 DEBUG org.apache.hadoop.hbase.zookeeper.ZKAssign: master:60000-0x13229c29f830010 Creating (or updating) unassigned node &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; b7a45cf31651d5cbba682ae24b83bf88 with OFFLINE state


2011-09-02 18:15:55,967 INFO org.apache.hadoop.hbase.zookeeper.ZKAssign: Current data in znode .region=testram2,9970,1314962425951.b7a45cf31651d5cbba682ae24b83bf88., origin=HOST-10-18-52-198,60020,1314967317396, state=RS_ZK_REGION_OPENED
2011-09-02 18:15:55,996 WARN org.apache.hadoop.hbase.master.AssignmentManager: Attempted to create/force node into OFFLINE state before completing assignment but failed to &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; so &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; testram2,9970,1314962425951.b7a45cf31651d5cbba682ae24b83bf88. state=PENDING_OPEN, ts=1314967555942, server=&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;

 


2011-09-02 18:15:55,999 INFO org.mortbay.log: Time taken to complete the action on timeout &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; the reigon testram2,9970,1314962425951.b7a45cf31651d5cbba682ae24b83bf88.291
2011-09-02 18:16:24,115 DEBUG org.apache.hadoop.hbase.master.AssignmentManager: Handling transition=RS_ZK_REGION_OPENED, server=HOST-10-18-52-198,60020,1314967317396, region=b7a45cf31651d5cbba682ae24b83bf88, which is more than 15 seconds late
2011-09-02 18:16:24,122 DEBUG org.apache.hadoop.hbase.zookeeper.ZKAssign: master:60000-0x13229c29f830010 Successfully deleted unassigned node &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; region b7a45cf31651d5cbba682ae24b83bf88 in expected state RS_ZK_REGION_OPENED
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13097006" author="yuzhihong@gmail.com" created="Mon, 5 Sep 2011 05:11:49 +0000"  >&lt;p&gt;+1 on patch.&lt;br/&gt;
Nice work Ramkrishna.&lt;/p&gt;</comment>
                            <comment id="13097008" author="ram_krish" created="Mon, 5 Sep 2011 05:17:54 +0000"  >&lt;p&gt;I ran the hbck tool.  The result shows 0 inconsistencies.  Infact over the week end gave a long run.  Killing different RS.&lt;/p&gt;

&lt;p&gt;Ran the HBCK tool and the results were positive.  Also restarted the entire cluster and again ran HBCK even then the HBCK showed no&lt;br/&gt;
inconsistencies. &lt;br/&gt;
Thanks Ted and Stack for your review.&lt;/p&gt;</comment>
                            <comment id="13097009" author="tlipcon" created="Mon, 5 Sep 2011 05:20:46 +0000"  >&lt;p&gt;Is it really impossible to write any test cases for this?&lt;/p&gt;</comment>
                            <comment id="13097144" author="ram_krish" created="Mon, 5 Sep 2011 13:54:38 +0000"  >&lt;p&gt;I tried to write testcases to simulate the scenario for timeout monitor,&lt;br/&gt;
Based on the state in RIT we need to decide the operations.  So I tried like before assigning some regions start a thread that has gets the reference to assignement manager and gets the list of RITS(checking the state of RIT in a loop). Based on the state is PENDING_OPEN or OPENING try changing the state in znode to CLOSING.&lt;br/&gt;
Now when we try to check the status there is no guarentee that the moment we get the status and when the RS will process it to OPENED.&lt;/p&gt;

&lt;p&gt;Trying to do something similar to TestMasterFailOver.  But in TestMasterFailOver the Master is aborted and then we do the changes to the znode.&lt;br/&gt;
But when the master is running, the operation of assigning regions is asynchronous and we cannot gurantee reliability.&lt;/p&gt;</comment>
                            <comment id="13098605" author="jiraposter@reviews.apache.org" created="Wed, 7 Sep 2011 05:39:09 +0000"  >
&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/1668/#review1778&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#review1778&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;


&lt;p&gt;I have some feedback below.  On how to write a test, I&apos;m not sure how &amp;#8211; so many systems are touched.  We&apos;d need to break out AM so it standalone but that is too much to ask of this patch.  Good work Ram.  Thanks for persevering with this one.&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4056&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4056&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    I see.  You have full path here to distingush from o.a.h.h.executor.ExecutorService.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4057&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4057&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    I wonder about passing this in rather than create it in AM on construction?  If you need to do a close on the ExecutorService, add a close to AM and have the host of the AM class call the close on the way out?  Otherwise, you are exposing the implementation.  If you need configuration setting up the ExecutorService, you have the conf object by doing master.getConfiguration?  There may be other reasons for passing in the ExecutorService that I&apos;m not seeing... Above is just a thought.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4058&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4058&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    How do we know this will not result in a double assignment?  What if the .META. is OPENING and the master crashes.   A new master comes up but meantime the .META. has moved to OPENED and here we will assign the new .META. out without checking if .META. successfully OPENED? &lt;/p&gt;

&lt;p&gt;    Should we at least check the znode again before going ahead with assign?  Should we actually try grabbing the znode completely before we reassign so if .META. is opening, it will fail to complete?&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4059&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4059&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Thanks for making this little method disableRegionIfInRIT&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4060&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4060&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    If you make a new patch, can you fix formatting of this comment?  Its strange the way its broke over a number of lines.&lt;/p&gt;

&lt;p&gt;    So, the flag here is &apos;reassign&apos;.  Does that mean &apos;called from timeout monitor&apos;?  If so, its not clear (Change name of flag or at least fixup javadoc).  Else this comment is hard to understand.  But even so, do we care where its called from?  All thats important is if we are to reassign or not (What if we figure we need to set reassign to true elsewhere than in timeout monitor?  Then this comment would be extra confusing?)&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4062&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4062&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    This is great.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4063&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4063&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Should this method be called isDisabledOrDisabling?  Then a reader will expect the boolean return.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4064&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4064&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    This javadoc is better in that it says the flag &apos;reassign&apos; is set if we were invoked by timeout monitor.   Is it important that we&apos;re called by the timeout monitor?   Do we need to know about the caller when this method is run?  What if we decide to call this method from elsewhere than from timeout monitor? &lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4065&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4065&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Again is it important that we know we are being called from timeout monitor?  What does it mean when we are called from timeout monitor?  Is it that we are trying to interrupt normal processing because it seems to have failed?  If so, &apos;reassign&apos; may be the wrong name for this flag?  Would &apos;hijack&apos; be a better flag name?  Or &apos;appropriate&apos; or some such?&lt;/p&gt;

&lt;p&gt;    Sorry for harping on the flag name Ram.  If you have good names that convey intent/purpose, it makes it easier on the reader.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4066&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4066&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Can you fix formatting of this comment?&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4067&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4067&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Should we change znode state here?  Read it, get the znode id and try to change it.  If we fail, then RS still has control?&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4068&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4068&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Making a new method is good here.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4069&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4069&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    This is nice.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4070&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4070&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Try not to make these changes going forward (you are moving the + from end of line to start of next line and thats all &amp;#8211; it bulks up your patch unnecessarily).&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4071&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4071&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Nice.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4072&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4072&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Does doing this clear the watch on the znode such that we will not notice if it moves from OPENING to OPENED?&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4073&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4073&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Is there something wrong here?  The comment says do not make znode OFFLINE, wait on timeout monitor, but we are queuing up an ASSIGN it looks like?&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4074&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4074&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Yeah, I wonder if this even belongs out here.  Just have it inside in AM?&lt;/p&gt;

&lt;p&gt;    Do we even call close on it?  Should we?&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4075&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4075&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    No biggie but you could have written this as:&lt;/p&gt;

&lt;p&gt;    return (versionOfflineNode == -1)? openRegion(region): openRegion(region, versionOffilneNode);&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4077&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4077&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    I&apos;d suggest you move the enum here from AM rather than have this strange import of an inner type.&lt;/p&gt;

&lt;p&gt;    Maybe you&apos;d have two classes in here.  AssignCallable and UnassignCallable then no need of the enum?&lt;/p&gt;

&lt;p&gt;    For this class name, do you think we need TimeOutManager in its name?  In fact, is there a TimeoutManager?   It seems to be the ExcecutorService?  Or is it the method invokeTimeoutManager?&lt;/p&gt;

&lt;p&gt;    Seems like method should be something like invoke and you queue AssignCallable or UnassignCallable?&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4076&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4076&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    misspelling&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4078&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4078&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    I think I asked this already and I should check the response above, but is there any duplication here with current openRegion?  Should we factor out common code?&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4079&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4079&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    For sure this method should not know about timeout monitor.  This is a class in another package from master AM code.  Should this flag be named &apos;hijack&apos; or &apos;appropriate&apos; or &apos;preempt&apos;&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4082&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4082&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    You do not javadoc your return.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4080&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4080&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Can you clean up the formatting on this comment?  Do we need to know about timeout monitor in here?&lt;/p&gt;




&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4081&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4081&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Should this check be done up in timeout monitor or in a callable so its not inline?  If it still is in OPENING state up in timeout monitor, then come in here?  Just a suggestion (May not be a good one).&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4083&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4083&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Is it correct adding 1?&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4084&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4084&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    This is a strange location for a comment...  I&apos;d say put it into the else clause.&lt;/p&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Michael&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;On 2011-08-29 12:11:23, ramkrishna vasudevan wrote:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is an automatically generated e-mail. To reply, visit:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://reviews.apache.org/r/1668/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;(Updated 2011-08-29 12:11:23)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Review request for Ted Yu, Michael Stack, Jean-Daniel Cryans, and Jonathan Gray.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Summary&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; - updated patch.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;invokeTimeOutManager(regionState.getRegion(),&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TimeOutOperationType.ASSIGN);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Instead of storing the state when timeout was deducted we process it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;using future task.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;case RS_ZK_REGION_OPENING:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// TODO: Could check if it was on deadServers.  If it was, then we could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// do what happens in TimeoutMonitor when it sees this condition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Just insert region into RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If this never updates the timeout will trigger new assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) {
bq.            regionsInTransition.put(encodedRegionName, new RegionState(
bq.                regionInfo, RegionState.State.OPENING, data.getStamp(), data
bq.                    .getOrigin()));
bq.            processOpeningState(regionInfo);
bq.            break;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;regionsInTransition.put(encodedRegionName, new RegionState(regionInfo,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionState.State.OPENING, data.getStamp(), data.getOrigin()));&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;break;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;. META and ROOT table need not wait till timeout&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In forceRegionStateToOffline()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeout monitor donot force it to OFFLINE. Based on the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state we will decide if to change in-memory state to OFFLINE or not.  It will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// be done before setting the znode to OFFLINE state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate) {
bq.          LOG.debug(&quot;Forcing OFFLINE; was=&quot; + state);
bq.          state.update(RegionState.State.OFFLINE);
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If the timeout monitor tries to reallcoate the node then dont make&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But the noraml assign flow doesnot expect the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence the above change.  This is continued with the check in &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;assign()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;int setOfflineInZooKeeper(final RegionState state,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean timeOutMonitorReAllocate) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeoutmonitor the current state in memory need not be&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OFFLINE.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate &amp;amp;&amp;amp; !state.isClosed() &amp;amp;&amp;amp; !state.isOffline()) {
bq.            this.master.abort(&quot;Unexpected state trying to OFFLINE; &quot; + state,
bq.            new IllegalStateException());
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean allowCreation = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If the isReAllocate is true and the current state is PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// or OPENING then update the inmemory state to PENDING_OPEN. This is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// important because&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// if timeoutmonitor deducts that a region was in OPENING state for a long&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time but by the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time timeout monitor tranits the node to OFFLINE the RS would have opened&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the node and the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state in znode will be RS_ZK_REGION_OPENED. Inorder to invoke the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OpenedRegionHandler&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// we expect the inmemeory state to be PENDING_OPEN or OPENING.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// For all other cases we can change the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; (state.getState().equals(RegionState.State.PENDING_OPEN) || state&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getState().equals(RegionState.State.OPENING))) {
bq.        state.update(RegionState.State.PENDING_OPEN);
bq.        allowCreation = false;
bq.      } else {
bq.        state.update(RegionState.State.OFFLINE);
bq.        allowCreation = true;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is quite tricky.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In normal assign flow the unassigned node for the region will not be present&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we need to allow the creation of the node newly.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But in timeout monitor case we will have the node present in some state hence &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;we decide whether to create node newly or not inside ZKAssign.createOrForceNodeOffline&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;The above code also updates the inmemory state of OFFLINE or PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;which was not update in the previous forceRegionStateToOffline() call.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;==============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (version == -1) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If timeoutmonitor deducts a node to be in OPENING state but before it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// transit to OFFLINE state if RS had opened the region then the Master&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// deletes the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// assigned region znode. In that case the znode will not exist. So we&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// should not&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// create the znode again which will lead to double assignment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; !allowCreation) {
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;this part prevents double assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If timeoutmonitor tries to force to OFFLINE state an existing region which was in RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;but before it could do that if the node was opened then openedregionhandler will delete&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node hence we should not create the node again.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=======================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZkAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionTransitionData curDataInZNode = ZKAssign.getDataNoWatch(zkw, region&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getEncodedName(), stat);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Do not move the node to OFFLINE if znode is in any of the following&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Because these are already executed states.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; null != curDataInZNode) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;EventType eventType = curDataInZNode.getEventType();&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (eventType.equals(EventType.RS_ZK_REGION_CLOSING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_CLOSED)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_OPENED)) {
bq.            return -1;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;}&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This check prevents from moving the node to OFFLINE state if just before&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node is tried to force to OFFLINE the RS would have changed the state &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;to either CLOSING or CLOSED or OPENED.  now again moving to OFFLINE&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;will lead to douoble assignment and will an additional operaition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean setData = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;try {
bq.          setData = ZKUtil.setData(zkw, node, data.getBytes(), version);
bq.          // Setdata throws KeeperException which aborts the Master. So we are
bq.          // catching it here.
bq.          // If just before setting the znode to OFFLINE if the RS has made any
bq.          // change to the
bq.          // znode state then we need to return -1.
bq.        } catch (KeeperException kpe) {
bq.          LOG.info(&quot;Version mismatch while setting the node to OFFLINE state.&quot;);
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is actually to avoid the master from abortng. If the forceful OFFLINE is in&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;progrss but just before setting the RS has changed the state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Then the setData will fail leading to master abort.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we are catching the exception.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In assignmentManager.java&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+      if (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+        return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is nothing but the refactoring done in the existing code.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-     if (setOfflineInZK &amp;amp;&amp;amp; !setOfflineInZooKeeper(state)) return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;So if setting the version is unsuccessful return.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the below check ensure that double assignment doesnot happen.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// When the node is created for the first time then the expected version&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// that is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// passed will be -1 and the version in znode will be 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// In all other cases the version in znode will be &amp;gt; 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;else if (beginState.equals(EventType.M_ZK_REGION_OFFLINE)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; endState.equals(EventType.RS_ZK_REGION_OPENING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; expectedVersion == -1 &amp;amp;&amp;amp; stat.getVersion() != 0) {
bq.        LOG.warn(zkw.prefix(&quot;Attempt to transition the &quot; + &quot;unassigned node for &quot;
bq.            + encoded + &quot; from &quot; + beginState + &quot; to &quot; + endState + &quot; failed, &quot;
bq.            + &quot;the node existed but was version &quot; + stat.getVersion()
bq.            + &quot; not the expected version &quot; + expectedVersion));
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;As the comment explains when the node is created for first time the expectedversion will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;be -1 but the actual version will be 0.  Here the scenario is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If RS1 has not tranitioned the node from OFFLINE to OPENING if&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RS2 gets the call from Master after forcefully chaning to OFFLINE the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Rs2 will take the control of the node.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;At that time if RS1 starts transmitting the node then we should not allow&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;===============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-4015&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diffs&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt; PRE-CREATION &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diff: &lt;a href=&quot;https://reviews.apache.org/r/1668/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Testing&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Yes.  But could not add new test case.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TestMasterFailOver is passing with the current changes also.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Thanks,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;ramkrishna&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
</comment>
                            <comment id="13098828" author="jiraposter@reviews.apache.org" created="Wed, 7 Sep 2011 10:15:10 +0000"  >
&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/1668/#review1783&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#review1783&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4098&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4098&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Now i have moved it into AM itself.  &lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4099&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4099&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    If you see the implementation of processOpeningState it is same as the handling of the previous OPENING state handling by timeout monitor.   Just that now we call it immediately instead of timeout monitor acting on it.&lt;/p&gt;

&lt;p&gt;    &quot;Should we at least check the znode again before going ahead with assign? &quot;&lt;/p&gt;

&lt;p&gt;    Now for the possibility of the znode moving to OPENED state before we try to assign to a new RS, our new logic of mulitiple checks that we do before a node can be forcefully moved to OFFLINE will handle the scenario that you have told.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4100&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4100&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    changed the method name&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4101&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4101&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    formatting done and the variable name has been changed from reassign to hijackAndPreempt.&lt;/p&gt;

&lt;p&gt;    Stack last time you asked to change the variable name to reassign &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4102&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4102&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    invoke from timeout monitor has been removed everywhere.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4103&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4103&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    done&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4104&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4104&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    done&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4105&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4105&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Before we try changing the znode state if some failure happens then it means RS succeeded.  So in this place we need not change the RS state. Correct me if am wrong &lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4106&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4106&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    Next time will not repeat.  When we refactor a piece of code to a new api and apply format on that the formatter does this.&lt;br/&gt;
    Sometimes it gets missed out stack. Sorry&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4107&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4107&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    This is an existing code.  just the code has been moved into a method&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4108&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4108&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    done&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4109&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4109&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    done&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4110&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4110&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    done&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4111&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4111&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    done&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4112&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4112&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    done&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4113&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4113&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    done&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4114&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4114&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    This statement will increment the version number.  But the stat object is got before this step.&lt;br/&gt;
    hence on successful creation of the node with offline state we create a new watcher and so the version+1 will give me the current exact version in the node.&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4115&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4115&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    done&lt;/p&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ramkrishna&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;On 2011-08-29 12:11:23, ramkrishna vasudevan wrote:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is an automatically generated e-mail. To reply, visit:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://reviews.apache.org/r/1668/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;(Updated 2011-08-29 12:11:23)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Review request for Ted Yu, Michael Stack, Jean-Daniel Cryans, and Jonathan Gray.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Summary&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; - updated patch.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;invokeTimeOutManager(regionState.getRegion(),&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TimeOutOperationType.ASSIGN);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Instead of storing the state when timeout was deducted we process it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;using future task.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;case RS_ZK_REGION_OPENING:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// TODO: Could check if it was on deadServers.  If it was, then we could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// do what happens in TimeoutMonitor when it sees this condition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Just insert region into RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If this never updates the timeout will trigger new assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) {
bq.            regionsInTransition.put(encodedRegionName, new RegionState(
bq.                regionInfo, RegionState.State.OPENING, data.getStamp(), data
bq.                    .getOrigin()));
bq.            processOpeningState(regionInfo);
bq.            break;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;regionsInTransition.put(encodedRegionName, new RegionState(regionInfo,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionState.State.OPENING, data.getStamp(), data.getOrigin()));&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;break;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;. META and ROOT table need not wait till timeout&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In forceRegionStateToOffline()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeout monitor donot force it to OFFLINE. Based on the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state we will decide if to change in-memory state to OFFLINE or not.  It will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// be done before setting the znode to OFFLINE state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate) {
bq.          LOG.debug(&quot;Forcing OFFLINE; was=&quot; + state);
bq.          state.update(RegionState.State.OFFLINE);
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If the timeout monitor tries to reallcoate the node then dont make&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But the noraml assign flow doesnot expect the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence the above change.  This is continued with the check in &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;assign()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;int setOfflineInZooKeeper(final RegionState state,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean timeOutMonitorReAllocate) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeoutmonitor the current state in memory need not be&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OFFLINE.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate &amp;amp;&amp;amp; !state.isClosed() &amp;amp;&amp;amp; !state.isOffline()) {
bq.            this.master.abort(&quot;Unexpected state trying to OFFLINE; &quot; + state,
bq.            new IllegalStateException());
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean allowCreation = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If the isReAllocate is true and the current state is PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// or OPENING then update the inmemory state to PENDING_OPEN. This is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// important because&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// if timeoutmonitor deducts that a region was in OPENING state for a long&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time but by the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time timeout monitor tranits the node to OFFLINE the RS would have opened&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the node and the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state in znode will be RS_ZK_REGION_OPENED. Inorder to invoke the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OpenedRegionHandler&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// we expect the inmemeory state to be PENDING_OPEN or OPENING.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// For all other cases we can change the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; (state.getState().equals(RegionState.State.PENDING_OPEN) || state&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getState().equals(RegionState.State.OPENING))) {
bq.        state.update(RegionState.State.PENDING_OPEN);
bq.        allowCreation = false;
bq.      } else {
bq.        state.update(RegionState.State.OFFLINE);
bq.        allowCreation = true;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is quite tricky.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In normal assign flow the unassigned node for the region will not be present&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we need to allow the creation of the node newly.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But in timeout monitor case we will have the node present in some state hence &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;we decide whether to create node newly or not inside ZKAssign.createOrForceNodeOffline&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;The above code also updates the inmemory state of OFFLINE or PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;which was not update in the previous forceRegionStateToOffline() call.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;==============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (version == -1) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If timeoutmonitor deducts a node to be in OPENING state but before it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// transit to OFFLINE state if RS had opened the region then the Master&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// deletes the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// assigned region znode. In that case the znode will not exist. So we&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// should not&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// create the znode again which will lead to double assignment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; !allowCreation) {
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;this part prevents double assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If timeoutmonitor tries to force to OFFLINE state an existing region which was in RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;but before it could do that if the node was opened then openedregionhandler will delete&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node hence we should not create the node again.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=======================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZkAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionTransitionData curDataInZNode = ZKAssign.getDataNoWatch(zkw, region&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getEncodedName(), stat);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Do not move the node to OFFLINE if znode is in any of the following&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Because these are already executed states.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; null != curDataInZNode) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;EventType eventType = curDataInZNode.getEventType();&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (eventType.equals(EventType.RS_ZK_REGION_CLOSING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_CLOSED)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_OPENED)) {
bq.            return -1;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;}&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This check prevents from moving the node to OFFLINE state if just before&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node is tried to force to OFFLINE the RS would have changed the state &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;to either CLOSING or CLOSED or OPENED.  now again moving to OFFLINE&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;will lead to douoble assignment and will an additional operaition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean setData = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;try {
bq.          setData = ZKUtil.setData(zkw, node, data.getBytes(), version);
bq.          // Setdata throws KeeperException which aborts the Master. So we are
bq.          // catching it here.
bq.          // If just before setting the znode to OFFLINE if the RS has made any
bq.          // change to the
bq.          // znode state then we need to return -1.
bq.        } catch (KeeperException kpe) {
bq.          LOG.info(&quot;Version mismatch while setting the node to OFFLINE state.&quot;);
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is actually to avoid the master from abortng. If the forceful OFFLINE is in&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;progrss but just before setting the RS has changed the state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Then the setData will fail leading to master abort.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we are catching the exception.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In assignmentManager.java&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+      if (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+        return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is nothing but the refactoring done in the existing code.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-     if (setOfflineInZK &amp;amp;&amp;amp; !setOfflineInZooKeeper(state)) return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;So if setting the version is unsuccessful return.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the below check ensure that double assignment doesnot happen.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// When the node is created for the first time then the expected version&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// that is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// passed will be -1 and the version in znode will be 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// In all other cases the version in znode will be &amp;gt; 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;else if (beginState.equals(EventType.M_ZK_REGION_OFFLINE)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; endState.equals(EventType.RS_ZK_REGION_OPENING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; expectedVersion == -1 &amp;amp;&amp;amp; stat.getVersion() != 0) {
bq.        LOG.warn(zkw.prefix(&quot;Attempt to transition the &quot; + &quot;unassigned node for &quot;
bq.            + encoded + &quot; from &quot; + beginState + &quot; to &quot; + endState + &quot; failed, &quot;
bq.            + &quot;the node existed but was version &quot; + stat.getVersion()
bq.            + &quot; not the expected version &quot; + expectedVersion));
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;As the comment explains when the node is created for first time the expectedversion will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;be -1 but the actual version will be 0.  Here the scenario is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If RS1 has not tranitioned the node from OFFLINE to OPENING if&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RS2 gets the call from Master after forcefully chaning to OFFLINE the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Rs2 will take the control of the node.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;At that time if RS1 starts transmitting the node then we should not allow&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;===============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-4015&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diffs&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt; PRE-CREATION &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diff: &lt;a href=&quot;https://reviews.apache.org/r/1668/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Testing&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Yes.  But could not add new test case.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TestMasterFailOver is passing with the current changes also.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Thanks,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;ramkrishna&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
</comment>
                            <comment id="13098959" author="jiraposter@reviews.apache.org" created="Wed, 7 Sep 2011 13:56:10 +0000"  >
&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/1668/#review1786&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#review1786&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;&lt;br/&gt;
&amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/#comment4116&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#comment4116&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    I think preempt alone would suffice.&lt;br/&gt;
    We don&apos;t need to place hijack and preempt together.&lt;/p&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Ted&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;On 2011-08-29 12:11:23, ramkrishna vasudevan wrote:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is an automatically generated e-mail. To reply, visit:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://reviews.apache.org/r/1668/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;(Updated 2011-08-29 12:11:23)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Review request for Ted Yu, Michael Stack, Jean-Daniel Cryans, and Jonathan Gray.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Summary&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; - updated patch.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;invokeTimeOutManager(regionState.getRegion(),&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TimeOutOperationType.ASSIGN);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Instead of storing the state when timeout was deducted we process it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;using future task.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;case RS_ZK_REGION_OPENING:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// TODO: Could check if it was on deadServers.  If it was, then we could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// do what happens in TimeoutMonitor when it sees this condition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Just insert region into RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If this never updates the timeout will trigger new assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) {
bq.            regionsInTransition.put(encodedRegionName, new RegionState(
bq.                regionInfo, RegionState.State.OPENING, data.getStamp(), data
bq.                    .getOrigin()));
bq.            processOpeningState(regionInfo);
bq.            break;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;regionsInTransition.put(encodedRegionName, new RegionState(regionInfo,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionState.State.OPENING, data.getStamp(), data.getOrigin()));&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;break;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;. META and ROOT table need not wait till timeout&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In forceRegionStateToOffline()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeout monitor donot force it to OFFLINE. Based on the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state we will decide if to change in-memory state to OFFLINE or not.  It will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// be done before setting the znode to OFFLINE state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate) {
bq.          LOG.debug(&quot;Forcing OFFLINE; was=&quot; + state);
bq.          state.update(RegionState.State.OFFLINE);
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If the timeout monitor tries to reallcoate the node then dont make&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But the noraml assign flow doesnot expect the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence the above change.  This is continued with the check in &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;assign()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;int setOfflineInZooKeeper(final RegionState state,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean timeOutMonitorReAllocate) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeoutmonitor the current state in memory need not be&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OFFLINE.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate &amp;amp;&amp;amp; !state.isClosed() &amp;amp;&amp;amp; !state.isOffline()) {
bq.            this.master.abort(&quot;Unexpected state trying to OFFLINE; &quot; + state,
bq.            new IllegalStateException());
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean allowCreation = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If the isReAllocate is true and the current state is PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// or OPENING then update the inmemory state to PENDING_OPEN. This is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// important because&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// if timeoutmonitor deducts that a region was in OPENING state for a long&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time but by the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time timeout monitor tranits the node to OFFLINE the RS would have opened&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the node and the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state in znode will be RS_ZK_REGION_OPENED. Inorder to invoke the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OpenedRegionHandler&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// we expect the inmemeory state to be PENDING_OPEN or OPENING.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// For all other cases we can change the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; (state.getState().equals(RegionState.State.PENDING_OPEN) || state&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getState().equals(RegionState.State.OPENING))) {
bq.        state.update(RegionState.State.PENDING_OPEN);
bq.        allowCreation = false;
bq.      } else {
bq.        state.update(RegionState.State.OFFLINE);
bq.        allowCreation = true;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is quite tricky.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In normal assign flow the unassigned node for the region will not be present&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we need to allow the creation of the node newly.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But in timeout monitor case we will have the node present in some state hence &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;we decide whether to create node newly or not inside ZKAssign.createOrForceNodeOffline&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;The above code also updates the inmemory state of OFFLINE or PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;which was not update in the previous forceRegionStateToOffline() call.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;==============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (version == -1) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If timeoutmonitor deducts a node to be in OPENING state but before it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// transit to OFFLINE state if RS had opened the region then the Master&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// deletes the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// assigned region znode. In that case the znode will not exist. So we&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// should not&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// create the znode again which will lead to double assignment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; !allowCreation) {
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;this part prevents double assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If timeoutmonitor tries to force to OFFLINE state an existing region which was in RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;but before it could do that if the node was opened then openedregionhandler will delete&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node hence we should not create the node again.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=======================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZkAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionTransitionData curDataInZNode = ZKAssign.getDataNoWatch(zkw, region&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getEncodedName(), stat);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Do not move the node to OFFLINE if znode is in any of the following&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Because these are already executed states.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; null != curDataInZNode) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;EventType eventType = curDataInZNode.getEventType();&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (eventType.equals(EventType.RS_ZK_REGION_CLOSING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_CLOSED)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_OPENED)) {
bq.            return -1;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;}&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This check prevents from moving the node to OFFLINE state if just before&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node is tried to force to OFFLINE the RS would have changed the state &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;to either CLOSING or CLOSED or OPENED.  now again moving to OFFLINE&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;will lead to douoble assignment and will an additional operaition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean setData = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;try {
bq.          setData = ZKUtil.setData(zkw, node, data.getBytes(), version);
bq.          // Setdata throws KeeperException which aborts the Master. So we are
bq.          // catching it here.
bq.          // If just before setting the znode to OFFLINE if the RS has made any
bq.          // change to the
bq.          // znode state then we need to return -1.
bq.        } catch (KeeperException kpe) {
bq.          LOG.info(&quot;Version mismatch while setting the node to OFFLINE state.&quot;);
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is actually to avoid the master from abortng. If the forceful OFFLINE is in&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;progrss but just before setting the RS has changed the state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Then the setData will fail leading to master abort.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we are catching the exception.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In assignmentManager.java&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+      if (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+        return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is nothing but the refactoring done in the existing code.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-     if (setOfflineInZK &amp;amp;&amp;amp; !setOfflineInZooKeeper(state)) return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;So if setting the version is unsuccessful return.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the below check ensure that double assignment doesnot happen.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// When the node is created for the first time then the expected version&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// that is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// passed will be -1 and the version in znode will be 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// In all other cases the version in znode will be &amp;gt; 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;else if (beginState.equals(EventType.M_ZK_REGION_OFFLINE)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; endState.equals(EventType.RS_ZK_REGION_OPENING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; expectedVersion == -1 &amp;amp;&amp;amp; stat.getVersion() != 0) {
bq.        LOG.warn(zkw.prefix(&quot;Attempt to transition the &quot; + &quot;unassigned node for &quot;
bq.            + encoded + &quot; from &quot; + beginState + &quot; to &quot; + endState + &quot; failed, &quot;
bq.            + &quot;the node existed but was version &quot; + stat.getVersion()
bq.            + &quot; not the expected version &quot; + expectedVersion));
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;As the comment explains when the node is created for first time the expectedversion will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;be -1 but the actual version will be 0.  Here the scenario is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If RS1 has not tranitioned the node from OFFLINE to OPENING if&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RS2 gets the call from Master after forcefully chaning to OFFLINE the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Rs2 will take the control of the node.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;At that time if RS1 starts transmitting the node then we should not allow&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;===============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-4015&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diffs&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt; PRE-CREATION &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diff: &lt;a href=&quot;https://reviews.apache.org/r/1668/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Testing&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Yes.  But could not add new test case.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TestMasterFailOver is passing with the current changes also.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Thanks,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;ramkrishna&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
</comment>
                            <comment id="13098991" author="jiraposter@reviews.apache.org" created="Wed, 7 Sep 2011 14:35:10 +0000"  >

&lt;blockquote&gt;&lt;p&gt;On 2011-09-07 13:55:00, Ted Yu wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1260&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/3/?file=36181#file36181line1260&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/3/?file=36181#file36181line1260&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     I think preempt alone would suffice.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     We don&apos;t need to place hijack and preempt together.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I can do this on commit .. no need to change Ram.&lt;/p&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Michael&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/1668/#review1786&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#review1786&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;


&lt;p&gt;On 2011-08-29 12:11:23, ramkrishna vasudevan wrote:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is an automatically generated e-mail. To reply, visit:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://reviews.apache.org/r/1668/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;(Updated 2011-08-29 12:11:23)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Review request for Ted Yu, Michael Stack, Jean-Daniel Cryans, and Jonathan Gray.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Summary&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; - updated patch.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;invokeTimeOutManager(regionState.getRegion(),&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TimeOutOperationType.ASSIGN);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Instead of storing the state when timeout was deducted we process it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;using future task.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;case RS_ZK_REGION_OPENING:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// TODO: Could check if it was on deadServers.  If it was, then we could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// do what happens in TimeoutMonitor when it sees this condition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Just insert region into RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If this never updates the timeout will trigger new assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) {
bq.            regionsInTransition.put(encodedRegionName, new RegionState(
bq.                regionInfo, RegionState.State.OPENING, data.getStamp(), data
bq.                    .getOrigin()));
bq.            processOpeningState(regionInfo);
bq.            break;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;regionsInTransition.put(encodedRegionName, new RegionState(regionInfo,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionState.State.OPENING, data.getStamp(), data.getOrigin()));&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;break;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;. META and ROOT table need not wait till timeout&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In forceRegionStateToOffline()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeout monitor donot force it to OFFLINE. Based on the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state we will decide if to change in-memory state to OFFLINE or not.  It will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// be done before setting the znode to OFFLINE state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate) {
bq.          LOG.debug(&quot;Forcing OFFLINE; was=&quot; + state);
bq.          state.update(RegionState.State.OFFLINE);
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If the timeout monitor tries to reallcoate the node then dont make&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But the noraml assign flow doesnot expect the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence the above change.  This is continued with the check in &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;assign()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;int setOfflineInZooKeeper(final RegionState state,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean timeOutMonitorReAllocate) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeoutmonitor the current state in memory need not be&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OFFLINE.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate &amp;amp;&amp;amp; !state.isClosed() &amp;amp;&amp;amp; !state.isOffline()) {
bq.            this.master.abort(&quot;Unexpected state trying to OFFLINE; &quot; + state,
bq.            new IllegalStateException());
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean allowCreation = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If the isReAllocate is true and the current state is PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// or OPENING then update the inmemory state to PENDING_OPEN. This is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// important because&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// if timeoutmonitor deducts that a region was in OPENING state for a long&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time but by the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time timeout monitor tranits the node to OFFLINE the RS would have opened&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the node and the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state in znode will be RS_ZK_REGION_OPENED. Inorder to invoke the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OpenedRegionHandler&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// we expect the inmemeory state to be PENDING_OPEN or OPENING.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// For all other cases we can change the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; (state.getState().equals(RegionState.State.PENDING_OPEN) || state&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getState().equals(RegionState.State.OPENING))) {
bq.        state.update(RegionState.State.PENDING_OPEN);
bq.        allowCreation = false;
bq.      } else {
bq.        state.update(RegionState.State.OFFLINE);
bq.        allowCreation = true;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is quite tricky.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In normal assign flow the unassigned node for the region will not be present&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we need to allow the creation of the node newly.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But in timeout monitor case we will have the node present in some state hence &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;we decide whether to create node newly or not inside ZKAssign.createOrForceNodeOffline&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;The above code also updates the inmemory state of OFFLINE or PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;which was not update in the previous forceRegionStateToOffline() call.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;==============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (version == -1) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If timeoutmonitor deducts a node to be in OPENING state but before it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// transit to OFFLINE state if RS had opened the region then the Master&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// deletes the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// assigned region znode. In that case the znode will not exist. So we&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// should not&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// create the znode again which will lead to double assignment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; !allowCreation) {
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;this part prevents double assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If timeoutmonitor tries to force to OFFLINE state an existing region which was in RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;but before it could do that if the node was opened then openedregionhandler will delete&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node hence we should not create the node again.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=======================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZkAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionTransitionData curDataInZNode = ZKAssign.getDataNoWatch(zkw, region&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getEncodedName(), stat);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Do not move the node to OFFLINE if znode is in any of the following&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Because these are already executed states.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; null != curDataInZNode) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;EventType eventType = curDataInZNode.getEventType();&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (eventType.equals(EventType.RS_ZK_REGION_CLOSING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_CLOSED)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_OPENED)) {
bq.            return -1;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;}&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This check prevents from moving the node to OFFLINE state if just before&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node is tried to force to OFFLINE the RS would have changed the state &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;to either CLOSING or CLOSED or OPENED.  now again moving to OFFLINE&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;will lead to douoble assignment and will an additional operaition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean setData = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;try {
bq.          setData = ZKUtil.setData(zkw, node, data.getBytes(), version);
bq.          // Setdata throws KeeperException which aborts the Master. So we are
bq.          // catching it here.
bq.          // If just before setting the znode to OFFLINE if the RS has made any
bq.          // change to the
bq.          // znode state then we need to return -1.
bq.        } catch (KeeperException kpe) {
bq.          LOG.info(&quot;Version mismatch while setting the node to OFFLINE state.&quot;);
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is actually to avoid the master from abortng. If the forceful OFFLINE is in&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;progrss but just before setting the RS has changed the state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Then the setData will fail leading to master abort.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we are catching the exception.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In assignmentManager.java&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+      if (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+        return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is nothing but the refactoring done in the existing code.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-     if (setOfflineInZK &amp;amp;&amp;amp; !setOfflineInZooKeeper(state)) return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;So if setting the version is unsuccessful return.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the below check ensure that double assignment doesnot happen.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// When the node is created for the first time then the expected version&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// that is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// passed will be -1 and the version in znode will be 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// In all other cases the version in znode will be &amp;gt; 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;else if (beginState.equals(EventType.M_ZK_REGION_OFFLINE)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; endState.equals(EventType.RS_ZK_REGION_OPENING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; expectedVersion == -1 &amp;amp;&amp;amp; stat.getVersion() != 0) {
bq.        LOG.warn(zkw.prefix(&quot;Attempt to transition the &quot; + &quot;unassigned node for &quot;
bq.            + encoded + &quot; from &quot; + beginState + &quot; to &quot; + endState + &quot; failed, &quot;
bq.            + &quot;the node existed but was version &quot; + stat.getVersion()
bq.            + &quot; not the expected version &quot; + expectedVersion));
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;As the comment explains when the node is created for first time the expectedversion will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;be -1 but the actual version will be 0.  Here the scenario is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If RS1 has not tranitioned the node from OFFLINE to OPENING if&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RS2 gets the call from Master after forcefully chaning to OFFLINE the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Rs2 will take the control of the node.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;At that time if RS1 starts transmitting the node then we should not allow&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;===============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-4015&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diffs&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt; PRE-CREATION &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diff: &lt;a href=&quot;https://reviews.apache.org/r/1668/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Testing&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Yes.  But could not add new test case.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TestMasterFailOver is passing with the current changes also.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Thanks,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;ramkrishna&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
</comment>
                            <comment id="13098995" author="jiraposter@reviews.apache.org" created="Wed, 7 Sep 2011 14:41:10 +0000"  >

&lt;blockquote&gt;&lt;p&gt;On 2011-09-07 10:13:44, ramkrishna vasudevan wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 415&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/3/?file=36181#file36181line415&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/3/?file=36181#file36181line415&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     If you see the implementation of processOpeningState it is same as the handling of the previous OPENING state handling by timeout monitor.   Just that now we call it immediately instead of timeout monitor acting on it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &quot;Should we at least check the znode again before going ahead with assign? &quot;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     Now for the possibility of the znode moving to OPENED state before we try to assign to a new RS, our new logic of mulitiple checks that we do before a node can be forcefully moved to OFFLINE will handle the scenario that you have told.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;ok&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-09-07 10:13:44, ramkrishna vasudevan wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 1260&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/3/?file=36181#file36181line1260&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/3/?file=36181#file36181line1260&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     formatting done and the variable name has been changed from reassign to hijackAndPreempt.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     Stack last time you asked to change the variable name to reassign &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry if I did.  I thought I was commenting on use of word &apos;realloc&apos; when it seemed like you meant reassign.  I think I spent more time reviewing this time than I did last time.&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2011-09-07 10:13:44, ramkrishna vasudevan wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt;, line 2335&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;https://reviews.apache.org/r/1668/diff/3/?file=36181#file36181line2335&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff/3/?file=36181#file36181line2335&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     Next time will not repeat.  When we refactor a piece of code to a new api and apply format on that the formatter does this.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     Sometimes it gets missed out stack. Sorry&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No worries.  For next time.&lt;/p&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Michael&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/1668/#review1783&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#review1783&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;


&lt;p&gt;On 2011-08-29 12:11:23, ramkrishna vasudevan wrote:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is an automatically generated e-mail. To reply, visit:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://reviews.apache.org/r/1668/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;(Updated 2011-08-29 12:11:23)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Review request for Ted Yu, Michael Stack, Jean-Daniel Cryans, and Jonathan Gray.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Summary&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; - updated patch.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;invokeTimeOutManager(regionState.getRegion(),&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TimeOutOperationType.ASSIGN);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Instead of storing the state when timeout was deducted we process it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;using future task.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;case RS_ZK_REGION_OPENING:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// TODO: Could check if it was on deadServers.  If it was, then we could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// do what happens in TimeoutMonitor when it sees this condition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Just insert region into RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If this never updates the timeout will trigger new assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) {
bq.            regionsInTransition.put(encodedRegionName, new RegionState(
bq.                regionInfo, RegionState.State.OPENING, data.getStamp(), data
bq.                    .getOrigin()));
bq.            processOpeningState(regionInfo);
bq.            break;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;regionsInTransition.put(encodedRegionName, new RegionState(regionInfo,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionState.State.OPENING, data.getStamp(), data.getOrigin()));&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;break;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;. META and ROOT table need not wait till timeout&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In forceRegionStateToOffline()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeout monitor donot force it to OFFLINE. Based on the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state we will decide if to change in-memory state to OFFLINE or not.  It will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// be done before setting the znode to OFFLINE state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate) {
bq.          LOG.debug(&quot;Forcing OFFLINE; was=&quot; + state);
bq.          state.update(RegionState.State.OFFLINE);
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If the timeout monitor tries to reallcoate the node then dont make&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But the noraml assign flow doesnot expect the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence the above change.  This is continued with the check in &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;assign()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;int setOfflineInZooKeeper(final RegionState state,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean timeOutMonitorReAllocate) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeoutmonitor the current state in memory need not be&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OFFLINE.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate &amp;amp;&amp;amp; !state.isClosed() &amp;amp;&amp;amp; !state.isOffline()) {
bq.            this.master.abort(&quot;Unexpected state trying to OFFLINE; &quot; + state,
bq.            new IllegalStateException());
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean allowCreation = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If the isReAllocate is true and the current state is PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// or OPENING then update the inmemory state to PENDING_OPEN. This is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// important because&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// if timeoutmonitor deducts that a region was in OPENING state for a long&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time but by the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time timeout monitor tranits the node to OFFLINE the RS would have opened&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the node and the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state in znode will be RS_ZK_REGION_OPENED. Inorder to invoke the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OpenedRegionHandler&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// we expect the inmemeory state to be PENDING_OPEN or OPENING.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// For all other cases we can change the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; (state.getState().equals(RegionState.State.PENDING_OPEN) || state&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getState().equals(RegionState.State.OPENING))) {
bq.        state.update(RegionState.State.PENDING_OPEN);
bq.        allowCreation = false;
bq.      } else {
bq.        state.update(RegionState.State.OFFLINE);
bq.        allowCreation = true;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is quite tricky.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In normal assign flow the unassigned node for the region will not be present&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we need to allow the creation of the node newly.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But in timeout monitor case we will have the node present in some state hence &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;we decide whether to create node newly or not inside ZKAssign.createOrForceNodeOffline&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;The above code also updates the inmemory state of OFFLINE or PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;which was not update in the previous forceRegionStateToOffline() call.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;==============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (version == -1) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If timeoutmonitor deducts a node to be in OPENING state but before it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// transit to OFFLINE state if RS had opened the region then the Master&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// deletes the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// assigned region znode. In that case the znode will not exist. So we&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// should not&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// create the znode again which will lead to double assignment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; !allowCreation) {
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;this part prevents double assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If timeoutmonitor tries to force to OFFLINE state an existing region which was in RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;but before it could do that if the node was opened then openedregionhandler will delete&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node hence we should not create the node again.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=======================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZkAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionTransitionData curDataInZNode = ZKAssign.getDataNoWatch(zkw, region&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getEncodedName(), stat);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Do not move the node to OFFLINE if znode is in any of the following&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Because these are already executed states.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; null != curDataInZNode) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;EventType eventType = curDataInZNode.getEventType();&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (eventType.equals(EventType.RS_ZK_REGION_CLOSING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_CLOSED)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_OPENED)) {
bq.            return -1;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;}&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This check prevents from moving the node to OFFLINE state if just before&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node is tried to force to OFFLINE the RS would have changed the state &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;to either CLOSING or CLOSED or OPENED.  now again moving to OFFLINE&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;will lead to douoble assignment and will an additional operaition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean setData = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;try {
bq.          setData = ZKUtil.setData(zkw, node, data.getBytes(), version);
bq.          // Setdata throws KeeperException which aborts the Master. So we are
bq.          // catching it here.
bq.          // If just before setting the znode to OFFLINE if the RS has made any
bq.          // change to the
bq.          // znode state then we need to return -1.
bq.        } catch (KeeperException kpe) {
bq.          LOG.info(&quot;Version mismatch while setting the node to OFFLINE state.&quot;);
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is actually to avoid the master from abortng. If the forceful OFFLINE is in&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;progrss but just before setting the RS has changed the state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Then the setData will fail leading to master abort.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we are catching the exception.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In assignmentManager.java&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+      if (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+        return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is nothing but the refactoring done in the existing code.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-     if (setOfflineInZK &amp;amp;&amp;amp; !setOfflineInZooKeeper(state)) return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;So if setting the version is unsuccessful return.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the below check ensure that double assignment doesnot happen.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// When the node is created for the first time then the expected version&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// that is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// passed will be -1 and the version in znode will be 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// In all other cases the version in znode will be &amp;gt; 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;else if (beginState.equals(EventType.M_ZK_REGION_OFFLINE)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; endState.equals(EventType.RS_ZK_REGION_OPENING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; expectedVersion == -1 &amp;amp;&amp;amp; stat.getVersion() != 0) {
bq.        LOG.warn(zkw.prefix(&quot;Attempt to transition the &quot; + &quot;unassigned node for &quot;
bq.            + encoded + &quot; from &quot; + beginState + &quot; to &quot; + endState + &quot; failed, &quot;
bq.            + &quot;the node existed but was version &quot; + stat.getVersion()
bq.            + &quot; not the expected version &quot; + expectedVersion));
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;As the comment explains when the node is created for first time the expectedversion will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;be -1 but the actual version will be 0.  Here the scenario is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If RS1 has not tranitioned the node from OFFLINE to OPENING if&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RS2 gets the call from Master after forcefully chaning to OFFLINE the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Rs2 will take the control of the node.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;At that time if RS1 starts transmitting the node then we should not allow&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;===============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-4015&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diffs&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/a&gt; PRE-CREATION &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt; 1161985 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diff: &lt;a href=&quot;https://reviews.apache.org/r/1668/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Testing&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Yes.  But could not add new test case.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TestMasterFailOver is passing with the current changes also.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Thanks,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;ramkrishna&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
</comment>
                            <comment id="13099048" author="jiraposter@reviews.apache.org" created="Wed, 7 Sep 2011 15:54:10 +0000"  >
&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/1668/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;

&lt;p&gt;(Updated 2011-09-07 15:52:26.864199)&lt;/p&gt;


&lt;p&gt;Review request for Ted Yu, Michael Stack, Jean-Daniel Cryans, and Jonathan Gray.&lt;/p&gt;


&lt;p&gt;Changes&lt;br/&gt;
-------&lt;/p&gt;

&lt;p&gt;Updated the patch as per the review comments.&lt;br/&gt;
Changed hijackAndPreempt to hijack.&lt;/p&gt;


&lt;p&gt;Summary&lt;br/&gt;
-------&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; - updated patch.&lt;/p&gt;


&lt;p&gt;        invokeTimeOutManager(regionState.getRegion(),&lt;br/&gt;
            TimeOutOperationType.ASSIGN);&lt;/p&gt;

&lt;p&gt;Instead of storing the state when timeout was deducted we process it&lt;br/&gt;
using future task.&lt;br/&gt;
================================================================&lt;/p&gt;

&lt;p&gt;      case RS_ZK_REGION_OPENING:&lt;br/&gt;
        // TODO: Could check if it was on deadServers.  If it was, then we could&lt;br/&gt;
        // do what happens in TimeoutMonitor when it sees this condition.&lt;/p&gt;

&lt;p&gt;        // Just insert region into RIT&lt;br/&gt;
        // If this never updates the timeout will trigger new assignment&lt;br/&gt;
        if (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) &lt;/p&gt;
{
          regionsInTransition.put(encodedRegionName, new RegionState(
              regionInfo, RegionState.State.OPENING, data.getStamp(), data
                  .getOrigin()));
          processOpeningState(regionInfo);
          break;
        }
&lt;p&gt;        regionsInTransition.put(encodedRegionName, new RegionState(regionInfo,&lt;br/&gt;
            RegionState.State.OPENING, data.getStamp(), data.getOrigin()));&lt;br/&gt;
        break;&lt;/p&gt;

&lt;p&gt;This change is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;. META and ROOT table need not wait till timeout&lt;br/&gt;
======================================================================&lt;/p&gt;

&lt;p&gt;In forceRegionStateToOffline()&lt;/p&gt;

&lt;p&gt;    } else {&lt;br/&gt;
      // If invoked from timeout monitor donot force it to OFFLINE. Based on the&lt;br/&gt;
      // state we will decide if to change in-memory state to OFFLINE or not.  It will&lt;br/&gt;
      // be done before setting the znode to OFFLINE state.&lt;br/&gt;
      if (!timeOutMonitorReAllocate) &lt;/p&gt;
{
        LOG.debug(&quot;Forcing OFFLINE; was=&quot; + state);
        state.update(RegionState.State.OFFLINE);
      }
&lt;p&gt;If the timeout monitor tries to reallcoate the node then dont make&lt;br/&gt;
the inmemory state to OFFLINE.&lt;br/&gt;
But the noraml assign flow doesnot expect the inmemory state to OFFLINE.&lt;br/&gt;
Hence the above change.  This is continued with the check in &lt;br/&gt;
assign()&lt;br/&gt;
int setOfflineInZooKeeper(final RegionState state,&lt;br/&gt;
      boolean timeOutMonitorReAllocate) {&lt;br/&gt;
    // If invoked from timeoutmonitor the current state in memory need not be&lt;br/&gt;
    // OFFLINE.  &lt;br/&gt;
    if (!timeOutMonitorReAllocate &amp;amp;&amp;amp; !state.isClosed() &amp;amp;&amp;amp; !state.isOffline()) &lt;/p&gt;
{
          this.master.abort(&quot;Unexpected state trying to OFFLINE; &quot; + state,
          new IllegalStateException());
      return -1;
    }
&lt;p&gt;======================================================================&lt;/p&gt;

&lt;p&gt;    boolean allowCreation = false;&lt;br/&gt;
    // If the isReAllocate is true and the current state is PENDING_OPEN&lt;br/&gt;
    // or OPENING then update the inmemory state to PENDING_OPEN. This is&lt;br/&gt;
    // important because&lt;br/&gt;
    // if timeoutmonitor deducts that a region was in OPENING state for a long&lt;br/&gt;
    // time but by the&lt;br/&gt;
    // time timeout monitor tranits the node to OFFLINE the RS would have opened&lt;br/&gt;
    // the node and the&lt;br/&gt;
    // state in znode will be RS_ZK_REGION_OPENED. Inorder to invoke the&lt;br/&gt;
    // OpenedRegionHandler&lt;br/&gt;
    // we expect the inmemeory state to be PENDING_OPEN or OPENING.&lt;br/&gt;
    // For all other cases we can change the inmemory state to OFFLINE.&lt;br/&gt;
    if (timeOutMonitorReAllocate&lt;br/&gt;
        &amp;amp;&amp;amp; (state.getState().equals(RegionState.State.PENDING_OPEN) || state&lt;br/&gt;
            .getState().equals(RegionState.State.OPENING))) &lt;/p&gt;
{
      state.update(RegionState.State.PENDING_OPEN);
      allowCreation = false;
    }
&lt;p&gt; else &lt;/p&gt;
{
      state.update(RegionState.State.OFFLINE);
      allowCreation = true;
    }
&lt;p&gt;This change is quite tricky.  &lt;br/&gt;
In normal assign flow the unassigned node for the region will not be present&lt;br/&gt;
Hence we need to allow the creation of the node newly.&lt;br/&gt;
But in timeout monitor case we will have the node present in some state hence &lt;br/&gt;
we decide whether to create node newly or not inside ZKAssign.createOrForceNodeOffline&lt;/p&gt;

&lt;p&gt;The above code also updates the inmemory state of OFFLINE or PENDING_OPEN&lt;br/&gt;
which was not update in the previous forceRegionStateToOffline() call.&lt;br/&gt;
==============================================================================&lt;br/&gt;
In ZKAssign.java()&lt;br/&gt;
    if (version == -1) {&lt;br/&gt;
      // If timeoutmonitor deducts a node to be in OPENING state but before it&lt;br/&gt;
      // could&lt;br/&gt;
      // transit to OFFLINE state if RS had opened the region then the Master&lt;br/&gt;
      // deletes the&lt;br/&gt;
      // assigned region znode. In that case the znode will not exist. So we&lt;br/&gt;
      // should not&lt;br/&gt;
      // create the znode again which will lead to double assignment.&lt;br/&gt;
      if (timeOutMonitorReAllocate &amp;amp;&amp;amp; !allowCreation) &lt;/p&gt;
{
        return -1;
      }
&lt;p&gt;this part prevents double assignment&lt;br/&gt;
If timeoutmonitor tries to force to OFFLINE state an existing region which was in RIT&lt;br/&gt;
but before it could do that if the node was opened then openedregionhandler will delete&lt;br/&gt;
the node hence we should not create the node again.&lt;/p&gt;

&lt;p&gt;=======================================================================================&lt;br/&gt;
In ZkAssign.java()&lt;br/&gt;
    } else {&lt;br/&gt;
      RegionTransitionData curDataInZNode = ZKAssign.getDataNoWatch(zkw, region&lt;br/&gt;
          .getEncodedName(), stat);&lt;br/&gt;
      // Do not move the node to OFFLINE if znode is in any of the following&lt;br/&gt;
      // state.&lt;br/&gt;
      // Because these are already executed states.&lt;br/&gt;
      if (timeOutMonitorReAllocate &amp;amp;&amp;amp; null != curDataInZNode) {&lt;br/&gt;
        EventType eventType = curDataInZNode.getEventType();&lt;br/&gt;
        if (eventType.equals(EventType.RS_ZK_REGION_CLOSING)&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; eventType.equals(EventType.RS_ZK_REGION_CLOSED)&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; eventType.equals(EventType.RS_ZK_REGION_OPENED)) 
{
          return -1;
        }
&lt;p&gt;      }&lt;br/&gt;
This check prevents from moving the node to OFFLINE state if just before&lt;br/&gt;
the node is tried to force to OFFLINE the RS would have changed the state &lt;br/&gt;
to either CLOSING or CLOSED or OPENED.  now again moving to OFFLINE&lt;br/&gt;
will lead to douoble assignment and will an additional operaition.&lt;/p&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;====================================================================================&lt;br/&gt;
In ZKassign.java()&lt;br/&gt;
      boolean setData = false;&lt;br/&gt;
      try &lt;/p&gt;
{
        setData = ZKUtil.setData(zkw, node, data.getBytes(), version);
        // Setdata throws KeeperException which aborts the Master. So we are
        // catching it here.
        // If just before setting the znode to OFFLINE if the RS has made any
        // change to the
        // znode state then we need to return -1.
      }
&lt;p&gt; catch (KeeperException kpe) &lt;/p&gt;
{
        LOG.info(&quot;Version mismatch while setting the node to OFFLINE state.&quot;);
        return -1;
      }
&lt;p&gt;This change is actually to avoid the master from abortng. If the forceful OFFLINE is in&lt;br/&gt;
progrss but just before setting the RS has changed the state.&lt;br/&gt;
Then the setData will fail leading to master abort.&lt;br/&gt;
Hence we are catching the exception.&lt;br/&gt;
====================================================================================&lt;/p&gt;

&lt;p&gt;In assignmentManager.java&lt;br/&gt;
+      if (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)&lt;br/&gt;
+        return;&lt;br/&gt;
This is nothing but the refactoring done in the existing code.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (setOfflineInZK &amp;amp;&amp;amp; !setOfflineInZooKeeper(state)) return;&lt;br/&gt;
So if setting the version is unsuccessful return.&lt;br/&gt;
=====================================================================================&lt;br/&gt;
In ZKassign.java()&lt;br/&gt;
// the below check ensure that double assignment doesnot happen.&lt;br/&gt;
    // When the node is created for the first time then the expected version&lt;br/&gt;
    // that is&lt;br/&gt;
    // passed will be -1 and the version in znode will be 0.&lt;br/&gt;
    // In all other cases the version in znode will be &amp;gt; 0.&lt;br/&gt;
    else if (beginState.equals(EventType.M_ZK_REGION_OFFLINE)&lt;br/&gt;
        &amp;amp;&amp;amp; endState.equals(EventType.RS_ZK_REGION_OPENING)&lt;br/&gt;
        &amp;amp;&amp;amp; expectedVersion == -1 &amp;amp;&amp;amp; stat.getVersion() != 0) 
{
      LOG.warn(zkw.prefix(&quot;Attempt to transition the &quot; + &quot;unassigned node for &quot;
          + encoded + &quot; from &quot; + beginState + &quot; to &quot; + endState + &quot; failed, &quot;
          + &quot;the node existed but was version &quot; + stat.getVersion()
          + &quot; not the expected version &quot; + expectedVersion));
      return -1;
    }
&lt;p&gt;As the comment explains when the node is created for first time the expectedversion will&lt;br/&gt;
be -1 but the actual version will be 0.  Here the scenario is&lt;br/&gt;
If RS1 has not tranitioned the node from OFFLINE to OPENING if&lt;br/&gt;
RS2 gets the call from Master after forcefully chaning to OFFLINE the&lt;br/&gt;
Rs2 will take the control of the node.&lt;br/&gt;
At that time if RS1 starts transmitting the node then we should not allow&lt;br/&gt;
it.&lt;br/&gt;
===============================================================================&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;.&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-4015&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;Diffs (updated)&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt; 1166224 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignCallable.java&lt;/a&gt; PRE-CREATION &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt; 1166224 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt; 1166224 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt; 1166224 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/UnAssignCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/UnAssignCallable.java&lt;/a&gt; PRE-CREATION &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt; 1166224 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/a&gt; 1166224 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt; 1166224 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/a&gt; 1166224 &lt;br/&gt;
  &lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt; 1166224 &lt;/p&gt;

&lt;p&gt;Diff: &lt;a href=&quot;https://reviews.apache.org/r/1668/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;Testing&lt;br/&gt;
-------&lt;/p&gt;

&lt;p&gt;Yes.  But could not add new test case.&lt;br/&gt;
TestMasterFailOver is passing with the current changes also.&lt;/p&gt;


&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;ramkrishna&lt;/p&gt;
</comment>
                            <comment id="13099224" author="jiraposter@reviews.apache.org" created="Wed, 7 Sep 2011 19:04:09 +0000"  >
&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/1668/#review1798&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#review1798&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;

&lt;p&gt;Ship it!&lt;/p&gt;


&lt;p&gt;I think this patch at a minimum narrows the races significantly, enough to warrant application.  Writing a test is a little tough.  If we could standup an AssignmentManager outside of its hosting Master context, that&apos;d help.  Then we could set the AM and AM.TimeoutManager in competition over znode states.  This is something to do but I&apos;d say in another issue.&lt;/p&gt;

&lt;p&gt;I&apos;d say we should let this issue hang out there another 24 hours in case anyone else has an opinion before we go ahead commit.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Michael&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;On 2011-09-07 15:52:26, ramkrishna vasudevan wrote:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is an automatically generated e-mail. To reply, visit:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://reviews.apache.org/r/1668/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;(Updated 2011-09-07 15:52:26)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Review request for Ted Yu, Michael Stack, Jean-Daniel Cryans, and Jonathan Gray.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Summary&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; - updated patch.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;invokeTimeOutManager(regionState.getRegion(),&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TimeOutOperationType.ASSIGN);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Instead of storing the state when timeout was deducted we process it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;using future task.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;case RS_ZK_REGION_OPENING:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// TODO: Could check if it was on deadServers.  If it was, then we could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// do what happens in TimeoutMonitor when it sees this condition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Just insert region into RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If this never updates the timeout will trigger new assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) {
bq.            regionsInTransition.put(encodedRegionName, new RegionState(
bq.                regionInfo, RegionState.State.OPENING, data.getStamp(), data
bq.                    .getOrigin()));
bq.            processOpeningState(regionInfo);
bq.            break;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;regionsInTransition.put(encodedRegionName, new RegionState(regionInfo,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionState.State.OPENING, data.getStamp(), data.getOrigin()));&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;break;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;. META and ROOT table need not wait till timeout&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In forceRegionStateToOffline()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeout monitor donot force it to OFFLINE. Based on the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state we will decide if to change in-memory state to OFFLINE or not.  It will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// be done before setting the znode to OFFLINE state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate) {
bq.          LOG.debug(&quot;Forcing OFFLINE; was=&quot; + state);
bq.          state.update(RegionState.State.OFFLINE);
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If the timeout monitor tries to reallcoate the node then dont make&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But the noraml assign flow doesnot expect the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence the above change.  This is continued with the check in &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;assign()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;int setOfflineInZooKeeper(final RegionState state,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean timeOutMonitorReAllocate) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeoutmonitor the current state in memory need not be&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OFFLINE.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate &amp;amp;&amp;amp; !state.isClosed() &amp;amp;&amp;amp; !state.isOffline()) {
bq.            this.master.abort(&quot;Unexpected state trying to OFFLINE; &quot; + state,
bq.            new IllegalStateException());
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean allowCreation = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If the isReAllocate is true and the current state is PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// or OPENING then update the inmemory state to PENDING_OPEN. This is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// important because&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// if timeoutmonitor deducts that a region was in OPENING state for a long&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time but by the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time timeout monitor tranits the node to OFFLINE the RS would have opened&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the node and the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state in znode will be RS_ZK_REGION_OPENED. Inorder to invoke the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OpenedRegionHandler&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// we expect the inmemeory state to be PENDING_OPEN or OPENING.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// For all other cases we can change the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; (state.getState().equals(RegionState.State.PENDING_OPEN) || state&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getState().equals(RegionState.State.OPENING))) {
bq.        state.update(RegionState.State.PENDING_OPEN);
bq.        allowCreation = false;
bq.      } else {
bq.        state.update(RegionState.State.OFFLINE);
bq.        allowCreation = true;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is quite tricky.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In normal assign flow the unassigned node for the region will not be present&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we need to allow the creation of the node newly.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But in timeout monitor case we will have the node present in some state hence &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;we decide whether to create node newly or not inside ZKAssign.createOrForceNodeOffline&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;The above code also updates the inmemory state of OFFLINE or PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;which was not update in the previous forceRegionStateToOffline() call.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;==============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (version == -1) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If timeoutmonitor deducts a node to be in OPENING state but before it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// transit to OFFLINE state if RS had opened the region then the Master&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// deletes the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// assigned region znode. In that case the znode will not exist. So we&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// should not&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// create the znode again which will lead to double assignment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; !allowCreation) {
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;this part prevents double assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If timeoutmonitor tries to force to OFFLINE state an existing region which was in RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;but before it could do that if the node was opened then openedregionhandler will delete&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node hence we should not create the node again.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=======================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZkAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionTransitionData curDataInZNode = ZKAssign.getDataNoWatch(zkw, region&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getEncodedName(), stat);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Do not move the node to OFFLINE if znode is in any of the following&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Because these are already executed states.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; null != curDataInZNode) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;EventType eventType = curDataInZNode.getEventType();&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (eventType.equals(EventType.RS_ZK_REGION_CLOSING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_CLOSED)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_OPENED)) {
bq.            return -1;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;}&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This check prevents from moving the node to OFFLINE state if just before&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node is tried to force to OFFLINE the RS would have changed the state &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;to either CLOSING or CLOSED or OPENED.  now again moving to OFFLINE&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;will lead to douoble assignment and will an additional operaition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean setData = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;try {
bq.          setData = ZKUtil.setData(zkw, node, data.getBytes(), version);
bq.          // Setdata throws KeeperException which aborts the Master. So we are
bq.          // catching it here.
bq.          // If just before setting the znode to OFFLINE if the RS has made any
bq.          // change to the
bq.          // znode state then we need to return -1.
bq.        } catch (KeeperException kpe) {
bq.          LOG.info(&quot;Version mismatch while setting the node to OFFLINE state.&quot;);
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is actually to avoid the master from abortng. If the forceful OFFLINE is in&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;progrss but just before setting the RS has changed the state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Then the setData will fail leading to master abort.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we are catching the exception.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In assignmentManager.java&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+      if (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+        return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is nothing but the refactoring done in the existing code.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-     if (setOfflineInZK &amp;amp;&amp;amp; !setOfflineInZooKeeper(state)) return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;So if setting the version is unsuccessful return.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the below check ensure that double assignment doesnot happen.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// When the node is created for the first time then the expected version&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// that is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// passed will be -1 and the version in znode will be 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// In all other cases the version in znode will be &amp;gt; 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;else if (beginState.equals(EventType.M_ZK_REGION_OFFLINE)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; endState.equals(EventType.RS_ZK_REGION_OPENING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; expectedVersion == -1 &amp;amp;&amp;amp; stat.getVersion() != 0) {
bq.        LOG.warn(zkw.prefix(&quot;Attempt to transition the &quot; + &quot;unassigned node for &quot;
bq.            + encoded + &quot; from &quot; + beginState + &quot; to &quot; + endState + &quot; failed, &quot;
bq.            + &quot;the node existed but was version &quot; + stat.getVersion()
bq.            + &quot; not the expected version &quot; + expectedVersion));
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;As the comment explains when the node is created for first time the expectedversion will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;be -1 but the actual version will be 0.  Here the scenario is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If RS1 has not tranitioned the node from OFFLINE to OPENING if&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RS2 gets the call from Master after forcefully chaning to OFFLINE the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Rs2 will take the control of the node.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;At that time if RS1 starts transmitting the node then we should not allow&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;===============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-4015&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diffs&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignCallable.java&lt;/a&gt; PRE-CREATION &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/UnAssignCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/UnAssignCallable.java&lt;/a&gt; PRE-CREATION &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diff: &lt;a href=&quot;https://reviews.apache.org/r/1668/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Testing&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Yes.  But could not add new test case.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TestMasterFailOver is passing with the current changes also.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Thanks,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;ramkrishna&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
</comment>
                            <comment id="13099230" author="jiraposter@reviews.apache.org" created="Wed, 7 Sep 2011 19:14:09 +0000"  >
&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/1668/#review1800&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/#review1800&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;


&lt;p&gt;This patch is hard to review as it&apos;s very shotgun surgery-y, but that&apos;s probably because of the nature of the required change.&lt;/p&gt;

&lt;p&gt;I&apos;d like to know more about the testing that was done. How many regions on how many nodes?&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Jean-Daniel&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;On 2011-09-07 15:52:26, ramkrishna vasudevan wrote:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is an automatically generated e-mail. To reply, visit:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://reviews.apache.org/r/1668/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----------------------------------------------------------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;(Updated 2011-09-07 15:52:26)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Review request for Ted Yu, Michael Stack, Jean-Daniel Cryans, and Jonathan Gray.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Summary&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; - updated patch.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;invokeTimeOutManager(regionState.getRegion(),&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TimeOutOperationType.ASSIGN);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Instead of storing the state when timeout was deducted we process it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;using future task.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;case RS_ZK_REGION_OPENING:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// TODO: Could check if it was on deadServers.  If it was, then we could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// do what happens in TimeoutMonitor when it sees this condition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Just insert region into RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If this never updates the timeout will trigger new assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (regionInfo.isMetaRegion() || regionInfo.isRootRegion()) {
bq.            regionsInTransition.put(encodedRegionName, new RegionState(
bq.                regionInfo, RegionState.State.OPENING, data.getStamp(), data
bq.                    .getOrigin()));
bq.            processOpeningState(regionInfo);
bq.            break;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;regionsInTransition.put(encodedRegionName, new RegionState(regionInfo,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionState.State.OPENING, data.getStamp(), data.getOrigin()));&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;break;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4203&quot; title=&quot;While master restarts and if the META region&amp;#39;s state is OPENING then master cannot assign META until timeout monitor deducts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4203&quot;&gt;&lt;del&gt;HBASE-4203&lt;/del&gt;&lt;/a&gt;. META and ROOT table need not wait till timeout&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In forceRegionStateToOffline()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeout monitor donot force it to OFFLINE. Based on the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state we will decide if to change in-memory state to OFFLINE or not.  It will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// be done before setting the znode to OFFLINE state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate) {
bq.          LOG.debug(&quot;Forcing OFFLINE; was=&quot; + state);
bq.          state.update(RegionState.State.OFFLINE);
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If the timeout monitor tries to reallcoate the node then dont make&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But the noraml assign flow doesnot expect the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence the above change.  This is continued with the check in &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;assign()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;int setOfflineInZooKeeper(final RegionState state,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean timeOutMonitorReAllocate) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If invoked from timeoutmonitor the current state in memory need not be&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OFFLINE.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (!timeOutMonitorReAllocate &amp;amp;&amp;amp; !state.isClosed() &amp;amp;&amp;amp; !state.isOffline()) {
bq.            this.master.abort(&quot;Unexpected state trying to OFFLINE; &quot; + state,
bq.            new IllegalStateException());
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;======================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean allowCreation = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If the isReAllocate is true and the current state is PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// or OPENING then update the inmemory state to PENDING_OPEN. This is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// important because&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// if timeoutmonitor deducts that a region was in OPENING state for a long&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time but by the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// time timeout monitor tranits the node to OFFLINE the RS would have opened&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the node and the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state in znode will be RS_ZK_REGION_OPENED. Inorder to invoke the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// OpenedRegionHandler&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// we expect the inmemeory state to be PENDING_OPEN or OPENING.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// For all other cases we can change the inmemory state to OFFLINE.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; (state.getState().equals(RegionState.State.PENDING_OPEN) || state&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getState().equals(RegionState.State.OPENING))) {
bq.        state.update(RegionState.State.PENDING_OPEN);
bq.        allowCreation = false;
bq.      } else {
bq.        state.update(RegionState.State.OFFLINE);
bq.        allowCreation = true;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is quite tricky.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In normal assign flow the unassigned node for the region will not be present&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we need to allow the creation of the node newly.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But in timeout monitor case we will have the node present in some state hence &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;we decide whether to create node newly or not inside ZKAssign.createOrForceNodeOffline&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;The above code also updates the inmemory state of OFFLINE or PENDING_OPEN&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;which was not update in the previous forceRegionStateToOffline() call.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;==============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (version == -1) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// If timeoutmonitor deducts a node to be in OPENING state but before it&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// could&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// transit to OFFLINE state if RS had opened the region then the Master&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// deletes the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// assigned region znode. In that case the znode will not exist. So we&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// should not&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// create the znode again which will lead to double assignment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; !allowCreation) {
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;this part prevents double assignment&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If timeoutmonitor tries to force to OFFLINE state an existing region which was in RIT&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;but before it could do that if the node was opened then openedregionhandler will delete&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node hence we should not create the node again.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=======================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZkAssign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;} else {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RegionTransitionData curDataInZNode = ZKAssign.getDataNoWatch(zkw, region&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;.getEncodedName(), stat);&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Do not move the node to OFFLINE if znode is in any of the following&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// Because these are already executed states.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (timeOutMonitorReAllocate &amp;amp;&amp;amp; null != curDataInZNode) {&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;EventType eventType = curDataInZNode.getEventType();&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;if (eventType.equals(EventType.RS_ZK_REGION_CLOSING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_CLOSED)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;|| eventType.equals(EventType.RS_ZK_REGION_OPENED)) {
bq.            return -1;
bq.          }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;}&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This check prevents from moving the node to OFFLINE state if just before&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the node is tried to force to OFFLINE the RS would have changed the state &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;to either CLOSING or CLOSED or OPENED.  now again moving to OFFLINE&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;will lead to douoble assignment and will an additional operaition.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;boolean setData = false;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;try {
bq.          setData = ZKUtil.setData(zkw, node, data.getBytes(), version);
bq.          // Setdata throws KeeperException which aborts the Master. So we are
bq.          // catching it here.
bq.          // If just before setting the znode to OFFLINE if the RS has made any
bq.          // change to the
bq.          // znode state then we need to return -1.
bq.        } catch (KeeperException kpe) {
bq.          LOG.info(&quot;Version mismatch while setting the node to OFFLINE state.&quot;);
bq.          return -1;
bq.        }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This change is actually to avoid the master from abortng. If the forceful OFFLINE is in&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;progrss but just before setting the RS has changed the state.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Then the setData will fail leading to master abort.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hence we are catching the exception.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In assignmentManager.java&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+      if (setOfflineInZK &amp;amp;&amp;amp; versionOfOfflineNode == -1)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+        return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This is nothing but the refactoring done in the existing code.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-     if (setOfflineInZK &amp;amp;&amp;amp; !setOfflineInZooKeeper(state)) return;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;So if setting the version is unsuccessful return.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;=====================================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In ZKassign.java()&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// the below check ensure that double assignment doesnot happen.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// When the node is created for the first time then the expected version&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// that is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// passed will be -1 and the version in znode will be 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;// In all other cases the version in znode will be &amp;gt; 0.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;else if (beginState.equals(EventType.M_ZK_REGION_OFFLINE)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; endState.equals(EventType.RS_ZK_REGION_OPENING)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;amp;&amp;amp; expectedVersion == -1 &amp;amp;&amp;amp; stat.getVersion() != 0) {
bq.        LOG.warn(zkw.prefix(&quot;Attempt to transition the &quot; + &quot;unassigned node for &quot;
bq.            + encoded + &quot; from &quot; + beginState + &quot; to &quot; + endState + &quot; failed, &quot;
bq.            + &quot;the node existed but was version &quot; + stat.getVersion()
bq.            + &quot; not the expected version &quot; + expectedVersion));
bq.        return -1;
bq.      }&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;As the comment explains when the node is created for first time the expectedversion will&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;be -1 but the actual version will be 0.  Here the scenario is&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If RS1 has not tranitioned the node from OFFLINE to OPENING if&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;RS2 gets the call from Master after forcefully chaning to OFFLINE the&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Rs2 will take the control of the node.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;At that time if RS1 starts transmitting the node then we should not allow&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;===============================================================================&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-4015&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diffs&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-----&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignCallable.java&lt;/a&gt; PRE-CREATION &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/UnAssignCallable.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/UnAssignCallable.java&lt;/a&gt; PRE-CREATION &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://svn.apache.org/repos/asf/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/a&gt; 1166224 &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Diff: &lt;a href=&quot;https://reviews.apache.org/r/1668/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/1668/diff&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Testing&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;-------&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Yes.  But could not add new test case.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;TestMasterFailOver is passing with the current changes also.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Thanks,&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;ramkrishna&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
</comment>
                            <comment id="13099266" author="yuzhihong@gmail.com" created="Wed, 7 Sep 2011 20:00:26 +0000"  >&lt;p&gt;@J-D:&lt;br/&gt;
See Ramkrishna&apos;s comment @ 02/Sep/11 16:56&lt;/p&gt;</comment>
                            <comment id="13099637" author="jdcryans" created="Wed, 7 Sep 2011 23:01:00 +0000"  >&lt;p&gt;@Ted, thanks I didn&apos;t see it amid the rest.&lt;/p&gt;

&lt;p&gt;@Ram, did you insert any data in those regions before killing the RSs? Replaying the edits usually a good chunk of time for the region to be reopened. You could also try doing a worst case cold startup by killing -9 all HBase components at the same time (more or less) and then restarting them all (also after data was added). Finally you could try setting a super low timeout setting, like 5 seconds, to trigger RIT timeouts by the hundreds.&lt;/p&gt;</comment>
                            <comment id="13100367" author="ram_krish" created="Thu, 8 Sep 2011 14:53:26 +0000"  >&lt;p&gt;@J-D&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;You could also try doing a worst case cold startup by killing -9 all HBase components at the same time (more or less) and then restarting them all (also after data was added). Finally you could try setting a super low timeout setting, like 5 seconds, to trigger RIT timeouts by the hundreds.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I conducted the tests again particularly with 5 secs time out. Killed the cluster, started again, Randomly killed RS -&amp;gt; invoked balancer command also.&lt;br/&gt;
I was able to get back all the regions (4003 regions) among 3 RS.&lt;br/&gt;
hbck result was also positive&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;***** The number of timed out regions **** 938
***** The number of timed out regions **** 270
***** The number of timed out regions **** 673
***** The number of timed out regions **** 269
***** The number of timed out regions **** 941
***** The number of timed out regions **** 942
***** The number of timed out regions **** 941
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;Summary:
  -ROOT- is okay.
    Number of regions: 1
    Deployed on:  HOST-10-18-52-253,60020,1315480076091
  .META. is okay.
    Number of regions: 1
    Deployed on:  HOST-10-18-52-253,60020,1315480076091
  testram2 is okay.
    Number of regions: 4001
    Deployed on:  HOST-10-18-52-108,60020,1315480229321 HOST-10-18-52-253,60020,1315480076091
0 inconsistencies detected.
Status: OK
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13100438" author="jdcryans" created="Thu, 8 Sep 2011 16:40:03 +0000"  >&lt;p&gt;Perfect!&lt;/p&gt;</comment>
                            <comment id="13100459" author="stack" created="Thu, 8 Sep 2011 17:07:56 +0000"  >&lt;p&gt;Applied to TRUNK.  We should consider doing a version of this on branch.  J-D points out it changes the HRegionInterface.  Maybe if we put the change on the end in branch we&apos;ll be able to do rolling restarts up to 0.90.5.  I&apos;ll open new issue to look into this.&lt;/p&gt;

&lt;p&gt;Thanks for persevering with the patch Ram.&lt;/p&gt;</comment>
                            <comment id="13100573" author="stack" created="Thu, 8 Sep 2011 18:51:42 +0000"  >&lt;p&gt;Sorry.  I bungled the commit.  Ram pointed out that the latest attached here is not the right patch to apply.  I should have gotten the patch from RB.  I had to make two attempts at fixup.  My third application hopefully is correct (I&apos;m sure Ram will let me know if it is not).  Thanks for staying on top of this Ram.&lt;/p&gt;</comment>
                            <comment id="13100645" author="hudson" created="Thu, 8 Sep 2011 19:59:40 +0000"  >&lt;p&gt;Integrated in HBase-TRUNK #2189 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-TRUNK/2189/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-TRUNK/2189/&lt;/a&gt;)&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; Refactor the TimeoutMonitor to make it less racy&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; Refactor the TimeoutMonitor to make it less racy&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; Refactor the TimeoutMonitor to make it less racy&lt;/p&gt;

&lt;p&gt;stack : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;stack : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;stack : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/trunk/CHANGES.txt&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13100737" author="hudson" created="Thu, 8 Sep 2011 22:03:50 +0000"  >&lt;p&gt;Integrated in HBase-TRUNK #2190 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-TRUNK/2190/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-TRUNK/2190/&lt;/a&gt;)&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4105&quot; title=&quot;Stargate does not support Content-Type: application/json and Content-Encoding: gzip in parallel&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4105&quot;&gt;&lt;del&gt;HBASE-4105&lt;/del&gt;&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;-Making the timeout monitor less racy; third attempt&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; Refactor the TimeoutMonitor to make it less racy &amp;#8211; REVERT.  Ram says I have applied wrong patch.  Redoing.   A SECOND TIMEsvn rm --force   src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.javasvn rm --force   src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; Refactor the TimeoutMonitor to make it less racy &amp;#8211; reapply with &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt;_reprepared_trunk_2.patch&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4015&quot; title=&quot;Refactor the TimeoutMonitor to make it less racy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4015&quot;&gt;&lt;del&gt;HBASE-4015&lt;/del&gt;&lt;/a&gt; Refactor the TimeoutMonitor to make it less racy &amp;#8211; REVERT.  Ram says I have applied wrong patch.  Redoing.&lt;/p&gt;

&lt;p&gt;stack : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignCallable.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/UnAssignCallable.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;stack : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;stack : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/trunk/CHANGES.txt&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;stack : &lt;br/&gt;
Files : &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/hbase/trunk/CHANGES.txt&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/ipc/HRegionInterface.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/AssignmentManager.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/HMaster.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/ServerManager.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/master/TimeOutManagerCallable.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenMetaHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRegionHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/regionserver/handler/OpenRootHandler.java&lt;/li&gt;
	&lt;li&gt;/hbase/trunk/src/main/java/org/apache/hadoop/hbase/zookeeper/ZKAssign.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15016648" author="lars_francke" created="Fri, 20 Nov 2015 11:56:03 +0000"  >&lt;p&gt;This issue was closed as part of a bulk closing operation on 2015-11-20. All issues that have been resolved and where all fixVersions have been released have been closed (following discussions on the mailing list).&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310010">
                    <name>Incorporates</name>
                                            <outwardlinks description="incorporates">
                                        <issuelink>
            <issuekey id="12518969">HBASE-4203</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12489973" name="HBASE-4015_1_trunk.patch" size="37272" author="ram_krish" created="Wed, 10 Aug 2011 13:41:30 +0000"/>
                            <attachment id="12490958" name="HBASE-4015_2_trunk.patch" size="46296" author="ram_krish" created="Fri, 19 Aug 2011 15:21:55 +0000"/>
                            <attachment id="12492064" name="HBASE-4015_reprepared_trunk_2.patch" size="42407" author="ram_krish" created="Mon, 29 Aug 2011 12:22:55 +0000"/>
                            <attachment id="12489474" name="Timeoutmonitor with state diagrams.pdf" size="153479" author="ram_krish" created="Fri, 5 Aug 2011 13:27:09 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 28 Jul 2011 03:56:28 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>33325</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310191" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Hadoop Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10343"><![CDATA[Reviewed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            1 year, 4 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0hozj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>101310</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>