<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:32:50 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-5993/HBASE-5993.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-5993] Add a no-read Append</title>
                <link>https://issues.apache.org/jira/browse/HBASE-5993</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4102&quot; title=&quot;atomicAppend: A put that appends to the latest version of a cell; i.e. reads current value then adds the bytes offered by the client to the tail and writes out a new entry&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4102&quot;&gt;&lt;del&gt;HBASE-4102&lt;/del&gt;&lt;/a&gt; added an atomic append.  For high performance situations, it would be helpful to be able to do appends that don&apos;t actually require a read of the existing value.  This would be useful in building a growing set of values.  Our original use case was for implementing a form of search in HBase where a cell would contain a list of document ids associated with a particular keyword for search.  However it seems like it would also be useful to provide substantial performance improvements for most Append scenarios.&lt;/p&gt;

&lt;p&gt;Within the client API, the simplest way to implement this would be to leverage the existing Append api.  If the Append is marked as setReturnResults(false), use this code path.  If result return is requested, use the existing Append implementation.  &lt;/p&gt;
</description>
                <environment></environment>
        <key id="12555027">HBASE-5993</key>
            <summary>Add a no-read Append</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.png">Critical</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="2">Won&apos;t Fix</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="pipfiddle">Jacques</reporter>
                        <labels>
                    </labels>
                <created>Sat, 12 May 2012 17:09:18 +0000</created>
                <updated>Sat, 11 Apr 2015 01:33:39 +0000</updated>
                            <resolved>Sat, 11 Apr 2015 01:33:38 +0000</resolved>
                                    <version>0.94.0</version>
                                                    <component>regionserver</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>7</watches>
                                                                <comments>
                            <comment id="13274078" author="stack" created="Sat, 12 May 2012 21:36:58 +0000"  >&lt;p&gt;Others have asked for this.  Making critical so it gets consideration.&lt;/p&gt;</comment>
                            <comment id="13274454" author="lhofhansl" created="Mon, 14 May 2012 05:19:06 +0000"  >&lt;p&gt;I might be a bit dense, but how would this work?&lt;/p&gt;

&lt;p&gt;Internally HBase always needs to read the existing value in order to append to it, as nothing is changed in place (i.e. HBase has to generate a new KV for the new value). &lt;/p&gt;</comment>
                            <comment id="13279281" author="stack" created="Fri, 18 May 2012 22:50:01 +0000"  >&lt;p&gt;@Lars Yeah, in the server, a new cell would be made of the current value plus that proffered in the incoming append&lt;/p&gt;</comment>
                            <comment id="13283144" author="lhofhansl" created="Fri, 25 May 2012 05:52:17 +0000"  >&lt;p&gt;Then I do not understand what we are proposing here. An Append that does not read the existing value is a Put, no?&lt;/p&gt;

&lt;p&gt;Maybe a patch will make it clear to me.&lt;/p&gt;</comment>
                            <comment id="13283150" author="jeason" created="Fri, 25 May 2012 06:12:06 +0000"  >&lt;p&gt;So combine the existing value and append value during reading? it was my understanding&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13284074" author="pipfiddle" created="Sat, 26 May 2012 21:59:24 +0000"  >&lt;p&gt;Exactly. If you have five megs of values in a cell and then want to append another few bytes regularly, it would be best if HBase didn&apos;t have to read the existing value every time we wanted to add a few more bytes.  Using multiple columns to psuedo accomplish this functionality creates a lot of data overhead.&lt;/p&gt;</comment>
                            <comment id="13285129" author="lhofhansl" created="Tue, 29 May 2012 21:07:30 +0000"  >&lt;p&gt;Wanna make a patch Jacques?&lt;/p&gt;</comment>
                            <comment id="13285335" author="jeason" created="Wed, 30 May 2012 02:02:54 +0000"  >&lt;p&gt;I&apos;m not against this new feature, but anyway I don&apos;t think it&apos;s a good idea to use this append API frequently w.r.t. one KeyValue. If one KeyValue need to updated regularly, why not consdering a better key-schema? &lt;br/&gt;
e.g. &lt;br/&gt;
   key-1,  value&lt;br/&gt;
   key-2,  append-value1&lt;br/&gt;
   key-3,  append-value2&lt;br/&gt;
   ..........&lt;br/&gt;
then we can combine the results from client side.&lt;br/&gt;
Back to this improvement, the only advantage is combining the results from server side is better than from client side. But we need to change the read/scan logic. One seek may come together with another serveral seeks in order to get the existing value and appended values,...&lt;br/&gt;
Maybe my understanding is not correct&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13285493" author="lhofhansl" created="Wed, 30 May 2012 08:15:23 +0000"  >&lt;p&gt;Honestly, I still do not understand what Jacques is proposing. In order to append to something you&apos;d have to read that something first. HBase has no in place updates (for a good reason). So one could:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Replace the KV if it is still in the memstore.&lt;/li&gt;
	&lt;li&gt;Store incremental changes (somewhere?) and combine upon read from HBase.&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="13285504" author="jeason" created="Wed, 30 May 2012 08:31:42 +0000"  >&lt;p&gt;One KeyValue will include 2 parts: The original value, and the appended value. So if we append new value, just add this value into the &quot;additional&quot; part(Maybe we can implement this by introducing a new KeyValue.Type).  So we need to combine the values. (@Jacques: Please correct me if I misunderstood anything).&lt;br/&gt;
I&apos;m wondering whether it is really necessary.&lt;/p&gt;</comment>
                            <comment id="13285764" author="pipfiddle" created="Wed, 30 May 2012 15:50:09 +0000"  >&lt;p&gt;The reason this can make sense is data overhead.  In a case where we are capturing a large number of small values, the KeyValue overhead is substantial.  The original use case is one where I&apos;m adding to a list of documents that contain a certain term (search index).  Let&apos;s say that each document number is a four byte int.  Right now there are two options: use the existing append which means one will become swamped with reads as the cell value grows over time (this would also wreak havoc on memstore flushes as the cell value become megabytes in size and we&apos;re just adding another four bytes once a day).  On the flipside, using separate columns creates a substantial amount of overhead for each value added.  This utility of this functionality also extends to situations where people are capturing a large sequence of small values in monitoring applications.  (Sematext are basically trying to create this functionality already with their HBaseHUT work.)  &lt;/p&gt;

&lt;p&gt;Yes, an additional KeyValue.Type is needed.  When this type is read, the return functionality goes and get all the appended values (and the last full value) and then combines them on return.  As compactions are done, the complete merged values are created.  &lt;/p&gt;

&lt;p&gt;I&apos;m swamped right now but am going to try to write up a short design doc in the next couple of weeks and get you guys to review my approach since this will have to touch a number of components.  I also need to make sure to manage edge cases like what happens if you do a no-read append and no existing value exists (probably ok--even though read back performance will be poor).  &lt;/p&gt;
</comment>
                            <comment id="13285800" author="pipfiddle" created="Wed, 30 May 2012 16:35:16 +0000"  >&lt;p&gt;The implementation of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4218&quot; title=&quot;Data Block Encoding of KeyValues  (aka delta encoding / prefix compression&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4218&quot;&gt;&lt;del&gt;HBASE-4218&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4676&quot; title=&quot;Prefix Compression - Trie data block encoding&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4676&quot;&gt;&lt;del&gt;HBASE-4676&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-6093&quot; title=&quot;Flatten timestamps during flush and compaction&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-6093&quot;&gt;&lt;del&gt;HBASE-6093&lt;/del&gt;&lt;/a&gt; reduce the storage overhead of the multicolumn approach to solving this problem.  Network bandwidth and processing overhead will still exist.  Using encoding schemes to solve this problem is nice because the changes are constrained as opposed to cross-cutting.  That being said, it seems a bit like boiling the ocean to make a cup of tea.  Let me put a design doc together and then we can reevaluate.  My intuition is that this type of functionality could open up a new set of use cases for HBase.  &lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 12 May 2012 21:36:58 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>239281</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 years, 29 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i02ffr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>12102</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>