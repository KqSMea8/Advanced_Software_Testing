<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:34:29 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-6180/HBASE-6180.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-6180] [brainstorm] Timestamp based snapshots in HBase 0.96</title>
                <link>https://issues.apache.org/jira/browse/HBASE-6180</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;Discussion ticket around doing timestamp based snapshots in HBase as an extension/follow-on work for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-6055&quot; title=&quot;Offline Snapshots in HBase 0.96&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-6055&quot;&gt;&lt;del&gt;HBASE-6055&lt;/del&gt;&lt;/a&gt;. The implementation in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-6055&quot; title=&quot;Offline Snapshots in HBase 0.96&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-6055&quot;&gt;&lt;del&gt;HBASE-6055&lt;/del&gt;&lt;/a&gt; (as originally defined) is not sufficient for real-time clusters because it requires downtime to take the snapshot. &lt;/p&gt;

&lt;p&gt;Time-stamp based snapshots should not require downtime at the cost of achieving global consistency. &lt;/p&gt;</description>
                <environment></environment>
        <key id="12559616">HBASE-6180</key>
            <summary>[brainstorm] Timestamp based snapshots in HBase 0.96</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12608718">HBASE-6866</parent>
                                    <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="jesse_yates">Jesse Yates</reporter>
                        <labels>
                    </labels>
                <created>Wed, 6 Jun 2012 22:58:48 +0000</created>
                <updated>Thu, 4 Apr 2013 00:31:03 +0000</updated>
                                                                                <due></due>
                            <votes>0</votes>
                                    <watches>11</watches>
                                                                <comments>
                            <comment id="13290554" author="jesse_yates" created="Wed, 6 Jun 2012 22:59:27 +0000"  >&lt;p&gt;Here is what I&apos;ve been thinking about for doing timestamp based snapshotting, as an extension to the work I&apos;ve been doing for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-6055&quot; title=&quot;Offline Snapshots in HBase 0.96&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-6055&quot;&gt;&lt;del&gt;HBASE-6055&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Timestamp based snapshots are a zero-downtime/non-blocking versions of taking a snapshot across a table in HBase. They should be considered &apos;fuzzy&apos; because you don&apos;t get a global view, but only as close to globally consistent as we can get with timestamps on the region servers (fuzziness is in the NTP different between RS, which defaults to max skew of 60 sec). I&apos;m going to mingle a bit of theory and implementation here, but feel free to ask questions for things that don&apos;t make sense.&lt;/p&gt;

&lt;p&gt;All the infrastructure from point-in-time snapshots (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-50&quot; title=&quot;Snapshot of table&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-50&quot;&gt;&lt;del&gt;HBASE-50&lt;/del&gt;&lt;/a&gt;) is still going to be used here: SnapshotManager on the Master, the RegionSnapshotHandler on the RS, etc. The only change is what actually happens on each of the regions when taking the snapshot and how the snapshot is managed on the Master. Also, on a lower level, the time constraints are much looser on taking the snapshot.&lt;/p&gt;

&lt;p&gt;Lets walk throughout some of the changes to the actual implementation. &lt;/p&gt;

&lt;p&gt;From a high-level, we still tell all the RS to start the snapshot. They will then dump a meta edit into the WAL with the memstore timestamp (not clear if this is necessary, but could be useful for completing snapshots on failed RS). They will then post back to ZK that they are starting the snapshot. Each RS can then go about their business adding references to all the files on the FS for the Regions involved in the snapshot. It gets a little tricky when we try to capture the in-memory state of each RS.&lt;/p&gt;

&lt;p&gt;The key here though is that we can use the Memstore&apos;s built-in snapshot functionality to avoid doing any work with the WALs and just keep track of HFiles. When flushing the Memstore takes a &quot;snapshot&quot; by just blocking for a moment to switch two pointers between the current and the new memstore. All writes before the switch go into the old memstore. All new writes go into the new memstore. The old memstore can then asynchronously be flushed to disk and on scan we just merge in the results from the old version as well as the on disk files. The benefit of this is that we basically take no down time to flush the memstore (except for corner cases where there are too many HFiles on disk already, but we can ignore that as it part of the overall HBase design). &lt;/p&gt;

&lt;p&gt;We can leverage the same mechanism but instead just make the swap time-based.&lt;/p&gt;

&lt;p&gt;When the RS gets the update to take the snapshot, it also has a timespan through which it should split writes between the memstores. For example, say we get a snapshot start notice at 10:15:00 and a prepare phase length of 80 seconds (the max skew in the cluster +20 seconds for safety - just an example). &lt;/p&gt;

&lt;p&gt;For those 80 seconds, each HRegion will then time-flush the memstore. We take a regular memstore snapshot. Just like a regular flush, this ensures that all the outstanding writes to the memstore get committed (waiting on the read point to roll forward). However, instead of immediately writing to the new store, we split writes based on timestamp between the old and the new memstore. This management is handled by the Store, which just does some simple checking on the edits coming through to see which memstore it should direct the writes (admittedly, hand-waving away some of the complexity here).&lt;/p&gt;

&lt;p&gt;Conceptually, this is like taking  snapshot, but instead of just having the snapshot be the immutable state (less the rollbacks made), we can just pass that KV set into a new MemStore that acts just like a regular memstore. Since all the high-level edits still go through the mvcc, we can keep track of the ordering in writes and the rollback mechanism on the original MemStore actually keeps its own state and the state of the snapshot-based MemStore in the correct state.&lt;/p&gt;

&lt;p&gt;At this point, we can update the master (via ZK) that we have joined the snapshot. This is not strictly necessary, but is nice since we can then track progress of a snapshot. For instance, if a RS hasn&apos;t responded in within a certain window, we can immediately fail the snapshot and assume the RS has become inoperable. Since we are using the internal flushing mechanisms to remain mostly non-blocking, we can actually skip doing this update and just notify the master when we have done the write.&lt;/p&gt;

&lt;p&gt;An alternative implementation here is to do what Jon has suggested and do a set a meta writes for the beginning and end of a snapshot. Then all you have to do is keep track of the WALs for the snapshot and replay those at the right time. However, that adds some complexity into how to restore a snapshot and may require rolling the WAL after the snapshot has been taken - a worrisome amount of complexity for something that should be entirely immutable. Since the flush can be done async and we don&apos;t block writes while waiting, it doesn&apos;t seem like a major issue to wait a little longer to complete a snapshot.&lt;/p&gt;

&lt;p&gt;Back to the dual-pointer memstore snapshot implementation, once we pass the 80 seconds, we then flush the old store to disk, add a reference to the new HFile, and then just direct all writes to the new store. Conceptually, this all seems to hang together, but the implementation is probably going to take a little more work.&lt;/p&gt;

&lt;p&gt;There is a slight overhead to writes during the snapshot window. We will need to check the timestamp of every write going into the memstore, to figure out the store it needs to be written into. However, that is just a simple timestamp comparison and shouldn&apos;t be overly burdensome to the write throughput (especially if you can take a snapshot during a low-write period).&lt;/p&gt;

&lt;p&gt;After this snapshot window, the state of the memstore will have been snapshotted and a flush will have been started. Now we can just flush this old memstore to disk as another HFile and add a reference to it for the snapshot. Its completely fine if this process takes a while because the server precedes happily, taking reads and writes like nothing is amiss because the semantics are the same as a regular flush. Once the file hits disk (and we have added references for each of the other files) we can consider the snapshot completed on that HRegion. Once that process completes for all involved HRegions on the HRegionServer we can consider the snapshot having completed the snapshot. &lt;/p&gt;

&lt;p&gt;Note that since the in memory state is all written to disk, we don&apos;t actually need to keep track of any of the HLogs. There is probably some re-jiggering here around failed Puts and the optimized write path there, but that is an implementation detail.&lt;/p&gt;

&lt;p&gt;Once all the HRegionServers have taken the snapshot (passing up the notification by joining the barrier), the Master considers the snapshot completed and can move the snapshot from the .tmp to the .snapshot directory. The complete barrier is then just a barrier for the master, rather than for the region servers since there is not coordination necessary except to determine if a snapshot failed because a RS couldn&apos;t complete (which only the master needs to keep track of, to determine if a snapshot is valid or not).&lt;/p&gt;

&lt;p&gt;There are some gotcha&apos;s with snapshotting with timestamps.&lt;/p&gt;

&lt;p&gt;Suppose you are putting writes into the future. On a regular table doing a timestamp based Scan will still not find those futures writes; the same will be true of the snapshotted table - those writes will be directed to the new store and not found in the snapshot. &lt;/p&gt;

&lt;p&gt;The only weirdness that occurs with this form of snapshots is with future/past writes - essentially any time you start messing with the timestamps. Let&apos;s look an example. At 10:15:00 you take a snapshot of a table. However, on the same table, you make a Put  - &apos;row&apos;, &apos;cf&apos;, 10:20:00, &apos;value&apos; - at 10:10:00, a put in the future but made &lt;em&gt;before&lt;/em&gt; you take a snapshot. The snapshot then precedes as expected. At some point later, you revive the snapshot and do a scan of the table with a timestamp of 10:15:00.; you won&apos;t find that earlier put (&apos;row&apos;, &apos;cf&apos;, 10:20:00, &apos;value&apos;). However, if you just do a scan for the latest version, you &lt;b&gt;will&lt;/b&gt; find that put!&lt;/p&gt;

&lt;p&gt;It gets even odder if instead of making that future put before the snapshot was taken, but instead made it &lt;em&gt;while&lt;/em&gt; the snapshot was being taken. In this case, the revived snapshot will give you different semantics. The scan of the snapshot at 10:15:00 will still give you the same answer as before, but the latest version scan &lt;em&gt;will not find&lt;/em&gt; the future Put (&apos;row&apos;, &apos;cf&apos;, 10:20:00, &apos;value&apos;). &lt;/p&gt;

&lt;p&gt;Unfortunately, these are the semantics of using timestamps over global consistency. I (and many others) feel that if you are messing with timestamps then its buyer beware. &lt;/p&gt;

&lt;p&gt;That said, there is way to get global consistency if you do mess with timestamps. If you have some centralized timestamp oracle, then this can give out strictly increasing timestamps with a lease for the timestamps.  (I&apos;ve got a long flight next week where I&apos;m hoping to pump out a basic implementation of this for hbase - no ticket, but just a little something on github). Since you know that the timestamps will expire after a given period, you just set the expiration time + fudge  as the timespan to split the memstore writes. After the expiration period you know that a timestamp is the oldest timestamp, so you can then comfortably flush the old memstore to disk, knowing that you have all the edits from that timestamp back in time. Note that you don&apos;t have the same problem as above since you only do scans in terms of the timestamps from the oracle, so future and past are really globally relative - there is no real puts too far into the future or past that are visible because all scans need to be as of a timestamp.&lt;/p&gt;</comment>
                            <comment id="13396047" author="jesse_yates" created="Mon, 18 Jun 2012 17:22:41 +0000"  >&lt;p&gt;Further recommendation for the timestamp based, swapping memstore/flush approach - distributed splits cause the WALs to be moved to another directory, causing our symlinks (via the Reference class) to become invalid. This isn&apos;t a problem if we have hardlinks, but as they aren&apos;t implemented yet and will probably take a lot work to back-port to &lt;a href=&quot;https://issues.apache.org/jira/browse/HADOOP-6216&quot; title=&quot;HDFS Web UI displays comments from dfs.exclude file and counts them as dead nodes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HADOOP-6216&quot;&gt;&lt;del&gt;HDFS-1&lt;/del&gt;&lt;/a&gt;.0, we should probably just ignore that solution. &lt;/p&gt;

&lt;p&gt;I&apos;m not convinced that the WAL edit approach that it would be any faster to take the snapshot. Further, using the WAL actually makes the restore much more complicated as you need to replay WAL files to get back to the table state - a big pain for a restoring to a read only table and generally just adding a lot of lag when you could just hook-up a bunch of immutable files.&lt;/p&gt;</comment>
                            <comment id="13396211" author="jesse_yates" created="Mon, 18 Jun 2012 20:15:43 +0000"  >&lt;p&gt;Looking at the documentation from Amazon&apos;s hosted HBase solution (&lt;a href=&quot;http://docs.amazonwebservices.com/ElasticMapReduce/latest/DeveloperGuide/emr-hbase-backup-restore.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://docs.amazonwebservices.com/ElasticMapReduce/latest/DeveloperGuide/emr-hbase-backup-restore.html&lt;/a&gt;), they provide the option to do either a --consistent view (with synchronization across all the nodes) or a globally inconsistent view (but per-node consistency).  I think keeping the &quot;current&quot; full consistency as an option is a &apos;nice to have&apos;, but making the timestamp based backup - fuzzy consistency - the default. &lt;/p&gt;</comment>
                            <comment id="13558033" author="jmhsieh" created="Sat, 19 Jan 2013 15:35:57 +0000"  >&lt;p&gt;Moved parent to &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-6866&quot; title=&quot;Timestamp consistent snapshots&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-6866&quot;&gt;HBASE-6866&lt;/a&gt; - timestamp consistent snapshots.&lt;/p&gt;</comment>
                            <comment id="13621579" author="stack" created="Thu, 4 Apr 2013 00:31:03 +0000"  >&lt;p&gt;Moving brainstorming issue out of 0.95&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                            <outwardlinks description="depends upon">
                                        <issuelink>
            <issuekey id="12556488">HBASE-6055</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 19 Jan 2013 15:35:57 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>241707</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            3 years, 37 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i02b9z:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11428</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>