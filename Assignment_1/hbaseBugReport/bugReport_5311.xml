<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:26:37 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-5311/HBASE-5311.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-5311] Allow inmemory Memstore compactions</title>
                <link>https://issues.apache.org/jira/browse/HBASE-5311</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;Just like we periodically compact the StoreFiles we should also periodically compact the MemStore.&lt;br/&gt;
During these compactions we eliminate deleted cells, expired cells, cells to removed because of version count, etc, before we even do a memstore flush.&lt;/p&gt;

&lt;p&gt;Besides the optimization that we could get from this, it should also allow us to remove the special handling of ICV, Increment, and Append (all of which use upsert logic to avoid accumulating excessive cells in the Memstore).&lt;/p&gt;

&lt;p&gt;Not targeting this.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12540674">HBASE-5311</key>
            <summary>Allow inmemory Memstore compactions</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="lhofhansl">Lars Hofhansl</reporter>
                        <labels>
                    </labels>
                <created>Wed, 1 Feb 2012 04:45:51 +0000</created>
                <updated>Fri, 28 Aug 2015 20:10:21 +0000</updated>
                                                                                <due></due>
                            <votes>0</votes>
                                    <watches>25</watches>
                                                                <comments>
                            <comment id="13197581" author="tlipcon" created="Wed, 1 Feb 2012 04:58:55 +0000"  >&lt;p&gt;Another thing I&apos;ve considered and mentioned to people, but don&apos;t think is tracked on JIRA, is to do &quot;in-memory flushes&quot;. Our memstores are ConcurrentSkipListMaps, which have the nice property of being lock-free for contending updates, but the poor property of having bad cache locality and being less efficient on the read side (beware: unsubstantiated claim). &lt;/p&gt;

&lt;p&gt;If we periodically flushed to in-memory &quot;dense&quot; storage, we&apos;d probably get a bunch of benefits:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;scans should be faster since we could order the KVs in memory according to their sort order, in a dense array (taking advantage of sequential memory access being much faster than random)&lt;/li&gt;
	&lt;li&gt;reads in general should be faster since there would be less contention on the datastructure&lt;/li&gt;
	&lt;li&gt;we could use less memory by using a more tightly packed data structure for the immutable data, or even using HFile compression methods there&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13202130" author="dhruba" created="Tue, 7 Feb 2012 07:21:29 +0000"  >&lt;p&gt;does this need to stop updates to the memstore when this compaction is occuring?&lt;/p&gt;</comment>
                            <comment id="13202178" author="tlipcon" created="Tue, 7 Feb 2012 08:55:46 +0000"  >&lt;p&gt;I don&apos;t think so... funnily enough I was just taking a break from my usually scheduled work and working on this.&lt;/p&gt;

&lt;p&gt;I don&apos;t have much so far, but my design uses some lock-free tricks to safely swap around internal pieces of the data structure. Here&apos;s a sketch of what I was hacking on:&lt;/p&gt;

&lt;p&gt;I created a lock free data structure tentatively named &quot;GatedSection&quot; which is sort of like a lock/critical section but not quite. It has the following API:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
/**
 * Return &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; the thread should be allowed to enter the critical section,
 * &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; any other thread has already closed the gate
 */
&lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; enterSection();
/**
 * Must be called by any thread that has successfully entered above
 */
void exitSection();
/**
 * Disallows any &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; threads from entering the section (&lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt; calls to
 * enterSection() will &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;). Blocks until all other threads which
 * are already in the section have called exitSection().
 * Postcondition: no threads are in the section or will be able to enter it
 * after &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; method returns.
 */
void closeGateAndFlushThreads();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If you&apos;re familiar with JVM internals, this is a little bit like how &apos;checkpoints&apos; work.&lt;/p&gt;

&lt;p&gt;I then created another data structure:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
class State {
  GatedSection gate;
  List&amp;lt;Map&amp;lt;K,V&amp;gt;&amp;gt; mapLayers; &lt;span class=&quot;code-comment&quot;&gt;// writes go to idx 0, reads merge all
&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and the overall datastructure has a &lt;tt&gt;volatile State state;&lt;/tt&gt; member.&lt;/p&gt;


&lt;p&gt;Operations which mutate the current state (eg put) then do something like:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;in a loop, try to grab a local copy of the State variable, and then enter its gate, until successful.&lt;/li&gt;
	&lt;li&gt;modify its top map layer&lt;/li&gt;
	&lt;li&gt;exit the gate&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;A &quot;flush&quot; works as follows:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;step 1: create a new top layer for writes
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;create a new State object which is identical except a new concurrent map has been inserted at the &quot;top&quot; of mapLayers&lt;/li&gt;
		&lt;li&gt;swap the volatile &quot;state&quot; pointer to the new state. At this point, writers will be writing into &lt;em&gt;either&lt;/em&gt; of the top two layers&lt;/li&gt;
		&lt;li&gt;close the &quot;gate&quot;. After the gate is closed, writers will only be writing to the &lt;em&gt;top&lt;/em&gt; layer&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;step 2: freeze the old top layer
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;create a new efficient immutable datastructure for mapLayers.get(1)  (no rush to complete this phase)&lt;/li&gt;
		&lt;li&gt;swap it into place by swapping out the volatile state object&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;A compaction works similarly to &quot;step 2&quot; above.&lt;/p&gt;


&lt;p&gt;Might be worth using a technique like fractional cascading on the &quot;mapLayers&quot; structure as well to avoid O(k log n) lookups with k layers.&lt;/p&gt;</comment>
                            <comment id="13202183" author="tlipcon" created="Tue, 7 Feb 2012 09:02:07 +0000"  >&lt;p&gt;here&apos;s what I hacked up - the only guarantee I make about this code is that it has on syntax errors &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13202193" author="tlipcon" created="Tue, 7 Feb 2012 09:30:18 +0000"  >&lt;p&gt;Apparently this technique is called read-copy-update and the concurrency primitive is an RCU lock. There might be a more clever way of implementing it in Java but it&apos;s already probably over-optimized!&lt;/p&gt;</comment>
                            <comment id="13202619" author="dhruba" created="Tue, 7 Feb 2012 18:48:26 +0000"  >&lt;p&gt;This is a cool algorithm. Will there be a GatesSection for each KeyValue in the memstore or will there be one GatedSection for the entire memstore? (I am guessing that it is the former).&lt;/p&gt;</comment>
                            <comment id="13202629" author="tlipcon" created="Tue, 7 Feb 2012 18:59:57 +0000"  >&lt;p&gt;The latter &amp;#8211; the whole memstore would be &quot;layered&quot;, I think &amp;#8211; it&apos;s basically like we do with &quot;snapshot&quot; right now, except that there are multiple layers of &quot;snapshot&quot; and we have a trickier way of doing it without locks.&lt;/p&gt;</comment>
                            <comment id="13202634" author="dhruba" created="Tue, 7 Feb 2012 19:06:01 +0000"  >&lt;p&gt;Ok, got it. thanks.&lt;/p&gt;</comment>
                            <comment id="13202771" author="zhihyu@ebaysf.com" created="Tue, 7 Feb 2012 20:54:44 +0000"  >&lt;p&gt;In enterSection():&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
      AtomicInteger i = counts[counts.length % hash];
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I think the above may produce ArrayIndexOutOfBoundsException.&lt;/p&gt;</comment>
                            <comment id="13202818" author="tlipcon" created="Tue, 7 Feb 2012 21:35:40 +0000"  >&lt;p&gt;yep, I clearly meant hash % counts.length &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Like I said, the code isn&apos;t tested at all, and is probably incorrect in more subtle ways as well! It&apos;s a long way from being useful, just wanted to post it in case Dhruba wanted to take a look.&lt;/p&gt;</comment>
                            <comment id="13203234" author="lhofhansl" created="Wed, 8 Feb 2012 03:42:04 +0000"  >&lt;p&gt;Can this legitimately happen when multiple threads call closeGateAndFlushThreads?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; (oldVal &amp;amp; GATE_CLOSED) == 0 : &lt;span class=&quot;code-quote&quot;&gt;&quot;gate already closed&quot;&lt;/span&gt;;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;Is it possible that all threads get to that point at the same time and then never finish? (Actually my guess is no, but making sure):&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// Wait &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; all counts to go to the flagged &lt;span class=&quot;code-quote&quot;&gt;&quot;zero&quot;&lt;/span&gt; value
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// (i.e &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; active threads to exit the gated section)
&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (AtomicInteger i : counts) {
  &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (i.get() != GATE_CLOSED) {
    &lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.yield();
  }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13203364" author="tlipcon" created="Wed, 8 Feb 2012 08:25:06 +0000"  >&lt;p&gt;The assumption with the code I was writing was a single &quot;flusher&quot; thread &amp;#8211; which could be enforced by making the &quot;flush/compact&quot; stuff synchronized on a separate lock. The idea is basically to allow the common case to run lockless and push all the effort to whoever wants to make updates to the data structure.&lt;/p&gt;</comment>
                            <comment id="13203776" author="lhofhansl" created="Wed, 8 Feb 2012 17:53:09 +0000"  >&lt;p&gt;Gotcha... Makes sense.&lt;/p&gt;</comment>
                            <comment id="13204049" author="rangadi" created="Wed, 8 Feb 2012 22:10:41 +0000"  >&lt;p&gt;should &apos;state&apos; be closed &lt;em&gt;before&lt;/em&gt; being updated?&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    state = newState;
    oldState.gate.closeGateAndFlushThreads();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13204055" author="tlipcon" created="Wed, 8 Feb 2012 22:16:53 +0000"  >&lt;blockquote&gt;&lt;p&gt;should &apos;state&apos; be closed before being updated?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think it matters from a correctness standpoint. If we close the old state before updating the state variable, then all concurrent accessors beginning at this point will sit and spin while any previously running accessors finish their work. If we set the new state first, then any new accessors can immediately proceed so we don&apos;t cause any &quot;hiccup&quot; in access.&lt;/p&gt;

&lt;p&gt;The semantics of this whole data structure are a little subtle though so we&apos;ll have to be careful to expose only a minimal API and clearly document where we might have strange causality relations, etc.&lt;/p&gt;</comment>
                            <comment id="13204074" author="rangadi" created="Wed, 8 Feb 2012 22:43:23 +0000"  >&lt;p&gt;yeah, theoretically stale values are expected any way. And at higher layer memstore might allow only one accessor for a key.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12685275">HBASE-10191</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12788345">HBASE-13408</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12513588" name="InternallyLayeredMap.java" size="5617" author="tlipcon" created="Tue, 7 Feb 2012 09:02:07 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 1 Feb 2012 04:58:55 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>226069</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 years, 45 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i02gcv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>12251</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>