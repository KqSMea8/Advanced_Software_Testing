<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:51:56 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-8089/HBASE-8089.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-8089] Add type support</title>
                <link>https://issues.apache.org/jira/browse/HBASE-8089</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;This proposal outlines an improvement to HBase that provides for a set of types, above and beyond the existing &quot;byte-bucket&quot; strategy. This is intended to reduce user-level duplication of effort, provide better support for 3rd-party integration, and provide an overall improved experience for developers using HBase.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12636797">HBASE-8089</key>
            <summary>Add type support</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="3" iconUrl="https://issues.apache.org/jira/images/icons/statuses/inprogress.png" description="This issue is being actively worked on at the moment by the assignee.">In Progress</status>
                    <statusCategory id="4" key="indeterminate" colorName="yellow"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="ndimiduk">Nick Dimiduk</assignee>
                                    <reporter username="ndimiduk">Nick Dimiduk</reporter>
                        <labels>
                    </labels>
                <created>Wed, 13 Mar 2013 16:18:34 +0000</created>
                <updated>Wed, 4 Dec 2013 07:45:02 +0000</updated>
                                                                            <component>Client</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>41</watches>
                                                                                                            <comments>
                            <comment id="13602784" author="ndimiduk" created="Thu, 14 Mar 2013 21:31:25 +0000"  >&lt;p&gt;I&apos;m beginning to think variable-length encoding for anything but char,byte arrays is an unnecessary micro-optimization. Instead of helping a user pack data via encoding, we should encourage the use of compression.&lt;/p&gt;</comment>
                            <comment id="13604944" author="anoopsamjohn" created="Mon, 18 Mar 2013 08:43:24 +0000"  >&lt;p&gt;ImportTSV is a very good tool used for bulk loading. We can add a type support for this tool also. When the MR reads the file lines and convert it into bytes to store into HBase, this type can be considered. We can have a sub issue for that also?&lt;/p&gt;</comment>
                            <comment id="13614767" author="ndimiduk" created="Wed, 27 Mar 2013 01:03:24 +0000"  >&lt;p&gt;Updated spec document. Supported types changed a little, and a spec is outlined for the basics.&lt;/p&gt;

&lt;p&gt;Biggest open questions include:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;should null values be required for each type or is it enough to support reading a null marker via the STRUCT/UNION implementation?&lt;/li&gt;
	&lt;li&gt;how to handle String and byte[] types. Orderly goes to great pains to encode values, Phoenix restricts the context in which they can be used.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13622862" author="ndimiduk" created="Thu, 4 Apr 2013 22:01:27 +0000"  >&lt;p&gt;Updated spec document with definitions for VARCHAR and CHAR. After discussion and deliberation, I decided to roughly follow Orderly&apos;s approach. The reasoning being: the additional computation imposed by incrementing values and (slight) storage overhead of explicit termination is worth the cost. That is, this approach places no limitation on where the user can use a {VAR,}CHAR type.&lt;/p&gt;</comment>
                            <comment id="13622904" author="yuzhihong@gmail.com" created="Thu, 4 Apr 2013 22:32:42 +0000"  >&lt;p&gt;I read the description for VARCHAR and CHAR. Looks good.&lt;/p&gt;</comment>
                            <comment id="13628465" author="owen.omalley" created="Wed, 10 Apr 2013 23:57:50 +0000"  >&lt;p&gt;Nick,&lt;br/&gt;
  ORC gets a lot of mileage by doing type-specific compression. In particular, the integer columns use a vint representation (protobuf vint encoding) and run length encoding. The string columns use an adaptive dictionary (the writer switches between dictionary or direct encoding based on the 100k initial values) approach. That allows both tighter representation before turning on the relatively expensive zlib or even tighter encodings when combined with zlib.&lt;/p&gt;</comment>
                            <comment id="13628470" author="owen.omalley" created="Thu, 11 Apr 2013 00:04:43 +0000"  >&lt;p&gt;You should also look at the other types from Hive:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Byte&lt;/li&gt;
	&lt;li&gt;Timestamp&lt;/li&gt;
	&lt;li&gt;List&lt;/li&gt;
	&lt;li&gt;Map&lt;/li&gt;
	&lt;li&gt;Union&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Hive includes a standard serialization library that produces serializations that memcmp into the natural sort order, which it uses for MapReduce key serialization.&lt;/p&gt;</comment>
                            <comment id="13628518" author="ndimiduk" created="Thu, 11 Apr 2013 00:53:22 +0000"  >&lt;blockquote&gt;&lt;p&gt;Hive includes a standard serialization library that produces serializations that memcmp into the natural sort order, which it uses for MapReduce key serialization.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I didn&apos;t know about this feature in Hive, I&apos;ll check it out. Thanks for the reference, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=owen.omalley&quot; class=&quot;user-hover&quot; rel=&quot;owen.omalley&quot;&gt;Owen O&apos;Malley&lt;/a&gt;. The memcmp feature is critical for our needs; this is why most existing tools (ie, protobuf) don&apos;t work in this context. Do these Hive formats support NULLs &amp;#8211; I&apos;m curious how the trade-off for fixed-width types was handled. How does it handle compound keys? It looks like I have more homework to do &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13628523" author="ndimiduk" created="Thu, 11 Apr 2013 01:02:43 +0000"  >&lt;p&gt;Updates the definition of &lt;tt&gt;BOOLEAN&lt;/tt&gt; type to support NULL. Updates serialized definition for {&lt;tt&gt;VAR,}CHAR&lt;/tt&gt; to also invert the termination byte, thus preserving sort order. Add a working definition for &lt;tt&gt;STRUCT&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="13628566" author="owen.omalley" created="Thu, 11 Apr 2013 01:50:57 +0000"  >&lt;p&gt;Nick,&lt;br/&gt;
  The documentation BinarySortableSerde is here: &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://hive.apache.org/docs/r0.10.0/api/org/apache/hadoop/hive/serde2/binarysortable/BinarySortableSerDe.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://hive.apache.org/docs/r0.10.0/api/org/apache/hadoop/hive/serde2/binarysortable/BinarySortableSerDe.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In Hive, it is only used in MapReduce to cut down the cost of the sort during the shuffle.&lt;/p&gt;</comment>
                            <comment id="13642054" author="ndimiduk" created="Thu, 25 Apr 2013 18:28:04 +0000"  >&lt;p&gt;I like the looks of SQLite4&apos;s encoding structure &lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;. Specifically, numeric values &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;, regardless of type, are directly comparable. I think it could be easily extended to support maps and lists.&lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;: &lt;a href=&quot;http://sqlite.org/src4/doc/trunk/www/key_encoding.wiki&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://sqlite.org/src4/doc/trunk/www/key_encoding.wiki&lt;/a&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;: &lt;a href=&quot;http://sqlite.org/src4/doc/trunk/www/decimal.wiki&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://sqlite.org/src4/doc/trunk/www/decimal.wiki&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13644873" author="ndimiduk" created="Mon, 29 Apr 2013 21:20:52 +0000"  >&lt;p&gt;The advantages I see for following SQLite4 include:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Serialized values are marked with their type as an initial byte. This is advantageous as serialized values can be sniffed and deserialized by tools ignorant of the application schema.&lt;/li&gt;
	&lt;li&gt;Numeric types (integral and real numbers) are all normalized to identical encoding. This allows them to be compared directly and provides more flexibility to users.&lt;/li&gt;
	&lt;li&gt;A C language implementation and tools are readily available for validation, providing test scenarios and as near-complete implementation when we&apos;re ready to work on the non-JVM client.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The primary detriment I see with using their encoding is the limitation on disallowing null bytes in Strings. The same restriction applies to blobs except for those used as the last value in a compound key. IIRC, this restriction is identical to that imposed by Phoenix.&lt;/p&gt;</comment>
                            <comment id="13645071" author="mcorgan" created="Tue, 30 Apr 2013 00:18:12 +0000"  >&lt;p&gt;It sounds well thought out.  Are you thinking we&apos;d be able to add custom types on top of their base types?&lt;/p&gt;

&lt;p&gt;&lt;blockquote&gt;&lt;p&gt;The primary detriment I see with using their encoding is the limitation on disallowing null bytes in Strings&lt;/p&gt;&lt;/blockquote&gt;Could we allow nulls in values?  I personally don&apos;t mind disallowing them in row keys.&lt;/p&gt;</comment>
                            <comment id="13645111" author="ndimiduk" created="Tue, 30 Apr 2013 00:55:18 +0000"  >&lt;p&gt;I don&apos;t see why not. We could also cherry-pick the null-safe String and Blob implementations from Orderly if it&apos;s a critical feature.&lt;/p&gt;</comment>
                            <comment id="13677560" author="ndimiduk" created="Thu, 6 Jun 2013 21:51:50 +0000"  >&lt;p&gt;I&apos;m leaving a comment here since there&apos;s way more watchers on this parent ticket. Check out the patch on &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8201&quot; title=&quot;OrderedBytes: an ordered encoding strategy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8201&quot;&gt;&lt;del&gt;HBASE-8201&lt;/del&gt;&lt;/a&gt; for an implementation of serialization primitives based on the SQLite4 spec.&lt;/p&gt;</comment>
                            <comment id="13694264" author="ndimiduk" created="Wed, 26 Jun 2013 21:42:41 +0000"  >&lt;p&gt;Attaching my slides from the Hadoop Summit BoF talk per &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;&apos;s suggestion.&lt;/p&gt;</comment>
                            <comment id="13725451" author="mcorgan" created="Wed, 31 Jul 2013 17:23:29 +0000"  >&lt;p&gt;Nick - what other dependencies does your whole new type library have on HBase besides ByteRange?  It would be grand if it were a standalone jar that could be used by other projects without importing hbase-specific libs (which then drag in other dependencies).  All of this functionality is really cool and is more likely to gain adoption if it&apos;s as easy as possible to drop in existing projects.&lt;/p&gt;</comment>
                            <comment id="13725694" author="ndimiduk" created="Wed, 31 Jul 2013 20:44:24 +0000"  >&lt;p&gt;Matt - the only other thing is a dependency on HBase&apos;s Bytes in a couple places. I think this can easily be removed. Part of the point of this effort is to have HBase ship a standard implementation that other Hadoop ecosystem components can rely on. If I just wanted something for my own application, I&apos;d use Orderly and be done with it.&lt;/p&gt;</comment>
                            <comment id="13732672" author="eli" created="Wed, 7 Aug 2013 20:07:15 +0000"  >&lt;p&gt;Hey Nick,&lt;/p&gt;

&lt;p&gt;It might be worth updating this jira to reflect the latest state of the work. IIUC this work is about proving a client-side library that does the order-preserving serialization, that higher level projects (eg Phoenix &amp;amp; Kiji) can use for row keys and column qualifiers. Per the other jiras, cell serialization, defining types, and schema are out of scope. These are left to higher-level systems which may make different choices (eg in terms of how to create compound keys) and may have different type models, but at least will be able to share serialization.&lt;/p&gt;

&lt;p&gt;IMO it&apos;s worth considering creating a separate project for this as this is genuinely useful outside HBase (eg container formats) and would benefit from multiple language implementations (the serialization here is language agnostic right?) and so the HBase project may end up being a clunky place to maintain things.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Eli&lt;/p&gt;</comment>
                            <comment id="13733695" author="ndimiduk" created="Thu, 8 Aug 2013 17:07:26 +0000"  >&lt;p&gt;Hi Eli,&lt;/p&gt;

&lt;p&gt;You&apos;re right, I&apos;ve left this ticket untouched while working through the initial subtasks.&lt;/p&gt;

&lt;p&gt;The order-preserving serialization is a critical component of the work. I think this is a feature that HBase absolutely must provide if there&apos;s to be any hope for interoperability. I also think the serialization format is necessary but not sufficient. An HBase that ships with an API for describing data types and implementations of a set of common definitions takes the next step in interoperability. By defining the type interface, type implementations provided by 3rd parties become pluggable &amp;#8211; it becomes feasible for a user to plug a type from Phoenix into their Kiji application. Systems like Phoenix, Kiji, and HCatalog are all choices for defining and managing schema. It may be the case that HBase should define the schema interfaces as well, but that&apos;s definitely beyond the scope here. But if those tools are going to interoperate, they need a common language of types with which to do so. Serialization, IMHO, is insufficient.&lt;/p&gt;

&lt;p&gt;I don&apos;t know if there&apos;s a new project to be built out of this work. I see no need to create such a thing when the needs and use are not yet proven. The introduction of types in HBase will shake things up enough as it is, let&apos;s see how people and projects use them before promoting this stuff to its own project.&lt;/p&gt;

&lt;p&gt;Yes, the serialization formats defined in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8201&quot; title=&quot;OrderedBytes: an ordered encoding strategy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8201&quot;&gt;&lt;del&gt;HBASE-8201&lt;/del&gt;&lt;/a&gt; are designed to be language agnostic. It&apos;s highly likely that I&apos;ve missed some critical details here or there in the specification. Time will tell &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;-n&lt;/p&gt;</comment>
                            <comment id="13733898" author="stack" created="Thu, 8 Aug 2013 19:49:24 +0000"  >&lt;blockquote&gt;&lt;p&gt;An HBase that ships with an API for describing data types and implementations of a set of common definitions takes the next step in interoperability.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So you are thinking more than just a client-side utility lib but an actual facade that does typing (though it is all client-side) as in for example TypedHTable that does something like typedHTable.put(new Put(row).addInteger(12345)) and int i = typedHTable.get(new Get(row).getInteger());?  HBase internally is still all byte arrays but it&apos;d have this new class that made it look like we could exploit this typing info server-side (e.g. better compression)?  I suppose I&apos;d have to register a serializer w/ this new TypedHTable too?  Would the serializer be per table?&lt;/p&gt;
</comment>
                            <comment id="13734054" author="ndimiduk" created="Thu, 8 Aug 2013 21:48:53 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt; This is a possible direction which I have not thoroughly explored. Some discussion around client-side ease-of-use has started on &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-7941&quot; title=&quot;Provide client API with support for primitive types&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-7941&quot;&gt;HBASE-7941&lt;/a&gt;. I&apos;ve had a couple hallway conversations about bringing type awareness into the RegionServer, but none of it concrete.&lt;/p&gt;</comment>
                            <comment id="13740352" author="eli" created="Wed, 14 Aug 2013 22:52:26 +0000"  >&lt;p&gt;Thanks Nick. Probably worth a broader discussion. The view in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-7941&quot; title=&quot;Provide client API with support for primitive types&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-7941&quot;&gt;HBASE-7941&lt;/a&gt; that HBase is a database and should therefore provide types is pretty different from Bigtable&apos;s design:&lt;/p&gt;

&lt;p&gt;&quot;In many ways, Bigtable resembles a database: it shares many implementation strategies with databases...  but Bigtable provides a different interface than such systems. Bigtable does not support a full relational data model; instead, it provides clients with a simple data model that supports dynamic control over data layout and format, and allows clients to reason about the locality properties of the data represented in the underlying storage... Bigtable also treats data as uninterpreted strings, although clients often serialize various forms of structured and semi-structured data into these strings. Clients can control the locality of their data through careful choices in their schemas.&quot;&lt;/p&gt;

&lt;p&gt;While you could preserve the flexibility here while providing one implementation of a type model in HBase I think it&apos;s an explicit, existing design decision to have HBase support multiple distinct type models in higher level systems. And if those systems want to share code and type models that&apos;s great, but IMO HBase is a storage system w/o an explicit type model by design, and we start to lose the above benefits as we bring type awareness into core HBase components like the RS.&lt;/p&gt;</comment>
                            <comment id="13834347" author="apurtell" created="Wed, 27 Nov 2013 23:32:04 +0000"  >&lt;p&gt;What is currently actionable for 0.98, a timeframe of a few weeks... ?&lt;/p&gt;</comment>
                            <comment id="13837073" author="ndimiduk" created="Mon, 2 Dec 2013 23:38:02 +0000"  >&lt;p&gt;Of these subtasks, probably performance improvements (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8694&quot; title=&quot;Performance evaluation of encoding implementations&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8694&quot;&gt;HBASE-8694&lt;/a&gt;) and type comparisons (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8863&quot; title=&quot;Enhance data type API with type vs type comparison methods&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8863&quot;&gt;HBASE-8863&lt;/a&gt;) could be tackled by a willing individual. Client-side API enhancements will take some time for discussion. I think the ImportTSV stuff should be tackled after we&apos;ve defined a language for type declaration (similar to what we have for Filters in &lt;tt&gt;ParseFilter&lt;/tt&gt;).&lt;/p&gt;</comment>
                            <comment id="13838692" author="apurtell" created="Wed, 4 Dec 2013 07:45:02 +0000"  >&lt;p&gt;Unscheduling from 0.98&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12660759">HBASE-9091</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12629482">HBASE-7692</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12617698">HBASE-7221</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12578125" name="HBASE-8089-types.txt" size="10061" author="ndimiduk" created="Thu, 11 Apr 2013 01:02:43 +0000"/>
                            <attachment id="12577078" name="HBASE-8089-types.txt" size="9504" author="ndimiduk" created="Thu, 4 Apr 2013 22:01:27 +0000"/>
                            <attachment id="12575630" name="HBASE-8089-types.txt" size="8772" author="ndimiduk" created="Wed, 27 Mar 2013 01:03:24 +0000"/>
                            <attachment id="12573529" name="HBASE-8089-types.txt" size="6319" author="ndimiduk" created="Wed, 13 Mar 2013 16:19:14 +0000"/>
                            <attachment id="12589798" name="hbase data types WIP.pdf" size="632155" author="ndimiduk" created="Wed, 26 Jun 2013 21:42:41 +0000"/>
                    </attachments>
                <subtasks>
                            <subtask id="12660759">HBASE-9091</subtask>
                            <subtask id="12639244">HBASE-8201</subtask>
                            <subtask id="12651164">HBASE-8693</subtask>
                            <subtask id="12651165">HBASE-8694</subtask>
                            <subtask id="12656139">HBASE-8863</subtask>
                            <subtask id="12634212">HBASE-7941</subtask>
                            <subtask id="12648821">HBASE-8593</subtask>
                            <subtask id="12683019">HBASE-10091</subtask>
                            <subtask id="12714018">HBASE-11161</subtask>
                            <subtask id="12715439">HBASE-11207</subtask>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 18 Mar 2013 08:43:24 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>317289</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            3 years, 2 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1iqyv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>317630</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>