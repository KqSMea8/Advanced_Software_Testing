<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 20:31:37 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-12295/HBASE-12295.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-12295] Prevent block eviction under us if reads are in progress from the BBs</title>
                <link>https://issues.apache.org/jira/browse/HBASE-12295</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;While we try to serve the reads from the BBs directly from the block cache, we need to ensure that the blocks does not get evicted under us while reading.  This JIRA is to discuss and implement a strategy for the same.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12749148">HBASE-12295</key>
            <summary>Prevent block eviction under us if reads are in progress from the BBs</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12724166">HBASE-11425</parent>
                                    <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="ram_krish">ramkrishna.s.vasudevan</assignee>
                                    <reporter username="ram_krish">ramkrishna.s.vasudevan</reporter>
                        <labels>
                    </labels>
                <created>Mon, 20 Oct 2014 03:16:20 +0000</created>
                <updated>Sun, 26 Jul 2015 16:26:03 +0000</updated>
                            <resolved>Thu, 23 Jul 2015 09:02:44 +0000</resolved>
                                                    <fixVersion>2.0.0</fixVersion>
                                    <component>regionserver</component>
                    <component>Scanners</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>11</watches>
                                                                <comments>
                            <comment id="14311886" author="apache9" created="Mon, 9 Feb 2015 07:18:23 +0000"  >&lt;p&gt;Oh, here it is.&lt;/p&gt;

&lt;p&gt;I would say this is the most important thing if we want to avoid copying.&lt;/p&gt;

&lt;p&gt;A simple way is using phantom reference, but the disadvantage is also evident, we can not trigger a gc that only scan BucketCacheEntries when BucketCache is full(Actually I only know that System.gc() can trigger a FullGC on hotspot JVM).&lt;/p&gt;

&lt;p&gt;Another way is maintaining reference counting by ourselves. But this is also hard since we even want to use the BB that fetched from BucketCache in RpcServer. There are too many places we need to decrease reference count because we can drop the BB in many ways(rpc send message over, scanner skip, exception...).&lt;/p&gt;

&lt;p&gt;What do you guys think? Thanks~&lt;/p&gt;</comment>
                            <comment id="14315670" author="ram_krish" created="Wed, 11 Feb 2015 06:43:16 +0000"  >&lt;blockquote&gt;&lt;p&gt;Another way is maintaining reference counting by ourselves. But this is also hard since we even want to use the BB that fetched from BucketCache in RpcServer&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thanks for the ping on this issue.  Just seeing that.  We are planning to go with ref counting way.  As you said to account for the places where all it should be decreased and incremented is quite challenging.  Currently the block being referenced is just GC&apos;ed once a new block is loaded.  We have tried out a code for this (like POC - may need some clean up ) and verify the correctness for all cases. But it seems to work.  We have tested for positive cases.  But not for much of the exception cases. We are in the process of reviewing it and improving it.&lt;/p&gt;</comment>
                            <comment id="14487884" author="ram_krish" created="Thu, 9 Apr 2015 18:28:27 +0000"  >&lt;p&gt;I would this is a WIP patch. Just parking here for initial reviews. This is nothing but a portion of the patch that was posted in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-11425&quot; title=&quot;Cell/DBB end-to-end on the read-path&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-11425&quot;&gt;&lt;del&gt;HBASE-11425&lt;/del&gt;&lt;/a&gt;.  The recent purge of V2 and V3 has got lot of rework in getting this part of the code ready again.  Just for review parking here.  Will work on this tomorrow to give a final patch if there are any thing left/missed out.&lt;/p&gt;</comment>
                            <comment id="14528311" author="ram_krish" created="Tue, 5 May 2015 11:49:18 +0000"  >&lt;p&gt;Just adding the RB link for reference.  We will take this upto completion only after sub jiras of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-11425&quot; title=&quot;Cell/DBB end-to-end on the read-path&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-11425&quot;&gt;&lt;del&gt;HBASE-11425&lt;/del&gt;&lt;/a&gt; are done.&lt;br/&gt;
&lt;a href=&quot;https://reviews.apache.org/r/33844/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/33844/&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14562981" author="ram_krish" created="Thu, 28 May 2015 14:35:26 +0000"  >&lt;p&gt;Uploading a design doc that addresses all possible scenarios where we need to prevent block eviction from happening before the results are consumed. &lt;/p&gt;</comment>
                            <comment id="14563069" author="stack" created="Thu, 28 May 2015 15:29:18 +0000"  >&lt;p&gt;Thank you for the nice writeup. It helps. It looks great. It is easier discussing around a doc like this than looking at a ream of code (smile).&lt;/p&gt;

&lt;p&gt;returnBlock(BlockCacheKey cacheKey, HFileBlock block)&lt;/p&gt;

&lt;p&gt;Do we need to return the block too in the above? Won&apos;t the key be enough?&lt;/p&gt;

&lt;p&gt;&quot;As mentioned earlier the cellblock creation would ensure that the cells are copied to an output&lt;br/&gt;
stream and thus we are sure that the reference of these cells to the shared memory area is&lt;br/&gt;
removed.&quot;&lt;/p&gt;

&lt;p&gt;I would say that the creation of the CellBlock in memory is something we would like to get away from some day. We would like to just put the bytes on the wire directly. Or, consider that we will want to stream out Cells as they come up out of the server when we implement a streaming Interface on the server.  Just something to keep in mind.&lt;/p&gt;

&lt;p&gt;&quot; To achieve this, we are converting the cells in the result to a Cellblock buffer (in&lt;br/&gt;
Region level itself) and pass it to RpcServer via the Payload of the controller as opposed to how&lt;br/&gt;
it happens currently (currently the cell block is created in RPC layer).&quot;&lt;/p&gt;

&lt;p&gt;Hmm... pulling the CellBlock into the Region from the ipc layer? I have thought that Result should carry CellBlocks.... This would be an extra copy, right? If we wanted to get to zero copy, would it be possible if we went this route?&lt;/p&gt;

&lt;p&gt;&quot;We have added an overridden API in HRegion which takes RpcController as parameter. &quot;&lt;/p&gt;

&lt;p&gt;HRegion.get(get, RpcController)&lt;/p&gt;

&lt;p&gt;Nah. You can&apos;t pull an oddball RPC datastructure back into HRegion. Could it be done in the Result itself?&lt;/p&gt;

&lt;p&gt;Ditto here: HRegion.getScanner(scan, RPCController).&lt;/p&gt;

&lt;p&gt;Have you seen Jonathan Lawlor&apos;s ScanContext? He has added a bunch of accounting on where scan is at... state, and has scans doing heartbeating, and early returns. Can you make use of this work of his?&lt;/p&gt;

&lt;p&gt;Tell us more about the marking of Cells from L2 with a new Interface and why CP need special treatment, need Cells copied when read from CP. We have to do this?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Only the required results are copied.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This is a good point to make. May be raise it in the design doc higher... A &apos;benefits&apos; section.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt; finalizeScan(boolean finalizeAll). &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Why we need this? Why not close (sorry if I&apos;m being thick).&lt;/p&gt;

&lt;p&gt;I don&apos;t follow this sentence: &quot;In such a case we don&#8217;t evict the block if the ref count &amp;gt; 0, instead we mark those&lt;br/&gt;
blocks with a Boolean.&quot;&lt;/p&gt;
</comment>
                            <comment id="14563359" author="ram_krish" created="Thu, 28 May 2015 17:59:20 +0000"  >&lt;blockquote&gt;&lt;p&gt;returnBlock(BlockCacheKey cacheKey, HFileBlock block)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Do we need to return the block too in the above? Won&apos;t the key be enough?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Ideally yes. But as per our current impl we have a type of block whether it is from L2 or L1 and hence needed the block there.  May be we can only pass the type of the block there?  That should be possible. Not a big deal.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Or, consider that we will want to stream out Cells as they come up out of the server when we implement a streaming Interface on the server.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Okie.  When we tried to directly write the cells to the socket as part of the POC things were directly slow. May be a different type of protocol/approach may be needed there.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Hmm... pulling the CellBlock into the Region from the ipc layer? I have thought that Result should carry CellBlocks.... This would be an extra copy, right? If we wanted to get to zero copy, would it be possible if we went this route?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, this will be a zero copy.  Currently while creating cell block there is no copy we do and directly use the encoder to create it.  same here except that it is now in HRegion.&lt;br/&gt;
Making Result carry it is one option, I think you mean the PB result right? The approach here was to be simple use the existing Payload. When you say Result - will that not be the current way as how we do for non-java clients?&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Nah. You can&apos;t pull an oddball RPC datastructure back into HRegion. Could it be done in the Result itself?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Same as above.  &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;He has added a bunch of accounting on where scan is at... state, and has scans doing heartbeating, and early returns. Can you make use of this work of his?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I had a look at it. Will check once more before commenting back.  But in our case we need to handle both scans and gets.  Scans have states and gets do not have states as gets operate with in Region.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Tell us more about the marking of Cells from L2 with a new Interface and why CP need special treatment, need Cells copied when read from CP. We have to do this?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;CPs are bit tricky.  Take a CP which is trying to implement a postScannerOpen hook by wrapping the original scanner. &lt;br/&gt;
Now in a non CP approach we have the control on the result and the cellblock creation and we are sure that once the cell block is created we no longer refer to the cells from the hfileblocks.  But when you have a CP there is a high chance that those cells are referred for a longer time and the CP tries to use those Cells as its state. In those cases, if we think that the blocks ref count can be decremented just because  the results have been fetched, we end up corrupting the states of those CPs.  Hence we need to do a copy of the result.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;finalizeScan(boolean finalizeAll).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Though we have completed the implementation, we are still seeing if there is a better way,, but I have done some analysis and I fear that may be very very tricky.  I can come up with a write up after some more analysis but overall the problem is that the scanner flow has some optimizaitons where we proactively close some of the scanner from the heap just because they don&apos;t return any result (infact we nullify them also).  In such cases just calling close will not be enough because already those StoreFileScanners could be closed and we will lose the reference to those scanners. &lt;br/&gt;
Hence thought of adding an explicit API to do it.  And added to that for the scan case the close() call alone won&apos;t work because there are going to be set of next() calls for a scan to finish and it makes it better if we clear the references of those cells then and there.  And in case of scans the latest block would be needed for the subsequent next() calls as Scans are with States.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&quot;In such a case we don&#8217;t evict the block if the ref count &amp;gt; 0, instead we mark those&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;blocks with a Boolean.&quot;&lt;br/&gt;
This is a special case.  In case of compaction after the files are compacted we know that the compacted files are no longer needed and we forcefully try to evict them from the block cache.  But now if there were any parallel scans operating on those files we just cannot evict them. So we use the same ref count mechanism and see if the block can really evicted (even if it is forceful). All such blocks would automatically be evicted once the read operation using that block gets completed.  (in the sense on decrementing a &apos;marked&apos; block to 0 we call evict forcefully).  This ensures that the results are not corrupted.&lt;/p&gt;</comment>
                            <comment id="14563680" author="stack" created="Thu, 28 May 2015 20:58:36 +0000"  >&lt;blockquote&gt;&lt;p&gt;May be we can only pass the type of the block there? That should be possible. Not a big deal.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You can&apos;t figure whether L1 or L2 looking at the key?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;When we tried to directly write the cells to the socket as part of the POC things were directly slow. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We&apos;ll have to dig in on why. You&apos;d think w/ less intermediaries that it would be faster.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Making Result carry it is one option, I think you mean the PB result right?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ain&apos;t sure (smile). I was thinking in both cases. Result would give you a CellScanner... client or server side.&lt;/p&gt;

&lt;p&gt;Result cuts at a different dimension from CellBlock though, right? You get a Result per Get and per Scan response (could be full row or partial). CellBlock is an RPC primitive. Thought was that CellBlock could go other places in HBase too to save space (encoding/compression): e.g. in hfileblock or backing a Result.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The approach here was to be simple use the existing Payload. When you say Result - will that not be the current way as how we do for non-java clients?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Understood.&lt;/p&gt;

&lt;p&gt;But pulling the rpc controller back into HRegion is a little perverse. HRegion should not have any rpc pollution. Also, we already pervert rpc controller to carry the payload across the server/rpc barrier, an unnatural usage. Then, controller itself is not actually doing any &apos;controlling&apos; of the rpc &amp;#8211; it is just a place holder in rpc that protobuf actually recommends we avoid (i.e. generate own rpc interface rather than use the one protoc generates).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Yes, this will be a zero copy. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But we are copying Cells into CellBlock in memory and then we put the CellBlock on the wire? Would be nice if we could write the CellBlock directly on the wire (maybe this is not possible....). That said, for now at least, the creation of CellBlock is a good place for triggering decrement of backing block reference.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Scans have states and gets do not have states as gets operate with in Region.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Scans are Gets. If that is not enough, can we mimic scan context in Get? Would that help?  Then we could have one means rather than two keeping account.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;...and the CP tries to use those Cells as its state.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So, as is, we&apos;ll make a copy per registered CP?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;finalizeScan(boolean finalizeAll).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You want a delayed close, one that completes only after all outstanding scanners are done? Can we have scanner close set up one of these?&lt;/p&gt;

&lt;p&gt;So the boolean does what for compacted files? It says, don&apos;t evict files that are being read though they have been compacted? (Is this like the finalizeScan case at all?  Where you want to do a delayed close until no more references?)&lt;/p&gt;

&lt;p&gt;One other thought is how you folks thinking of testing this stuff?&lt;/p&gt;

</comment>
                            <comment id="14564140" author="ram_krish" created="Fri, 29 May 2015 03:20:29 +0000"  >&lt;blockquote&gt;&lt;p&gt;You can&apos;t figure whether L1 or L2 looking at the key?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;You mean add some different type of keys for the L1 or L2 case?  Can check this.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;We&apos;ll have to dig in on why. You&apos;d think w/ less intermediaries that it would be faster.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes that was the reason.  When we were writing every cell to the socket directly things were really slow.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;But pulling the rpc controller back into HRegion is a little perverse.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Okie, we could see if we can make the REsult carry this cellblock.  Will check on this once again.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;(maybe this is not possible....). That said, for now at least, the creation of CellBlock is a good place for triggering decrement of backing block reference.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes. Right.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;If that is not enough, can we mimic scan context in Get?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Will see on this if it is really possible. &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;So, as is, we&apos;ll make a copy per registered CP?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes but only if the scanner returned from the CP hook is not implementing the new interface. But if we allow the REgionScanner itself to use that new interface and the CP tries to use that new API diligently like how close() would be used, then we are safe we don&apos;t need to do that copy. Anyway for non-java case we need to do that copy.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;You want a delayed close, one that completes only after all outstanding scanners are done? Can we have scanner close set up one of these?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Ya, I tried out something yesterday. Seems to work.  But checking on all the corner cases, the next patch may have this change.  However I doubt on how a scan next() can be handled.  It needs some explicit way of decrementing the ref count alone.&lt;br/&gt;
But generally the call to close() would be an logical end to the ongoing read process including decrementing the ref count on the current list of blocks.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;So the boolean does what for compacted files? It says, don&apos;t evict files that are being read though they have been compacted? (Is this like the finalizeScan case at all? Where you want to do a delayed close until no more references?)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;A kind of.  But this would happen purely internally. Nothing like explicitly calling from the compaciton scanners to set this boolean.  Just the block block in the Bucket cache itself would know this and do it.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;One other thought is how you folks thinking of testing this stuff?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Ya as a first measure we have written unit tests to test out these scenarios and ensure we are doing the ref counting correctly. We are adding more tests to it so that we cover the basic scenarios.  &lt;br/&gt;
For the cluster testing we are planning to reduce the bucket cache size and ensure we have frequent eviction scenarios and verify whether any of the results are getting corrupted. Any other suggestion you have here?&lt;/p&gt;</comment>
                            <comment id="14564180" author="stack" created="Fri, 29 May 2015 04:33:26 +0000"  >&lt;blockquote&gt;&lt;p&gt;You mean add some different type of keys for the L1 or L2 case? Can check this.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah. Type or you check L2 and there is no corresponding count associated. It is just odd passing in the actual object when done with it. You going to mark the object as from L2 or something?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;When we were writing every cell to the socket directly things were really slow.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok. Would be good to see what is going on at that time. Can do later.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;...see if we can make the REsult carry this cellblock. Will check on this once again.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Will you want to return many Results in the one go? I&apos;m am wondering if Result operates on a different dimension to what you need.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Yes but only if the scanner returned from the CP hook is not implementing the new interface....&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;New Interface? I missed that. Let me reread the doc.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Ya, I tried out something yesterday. Seems to work. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok. Good. Better than introducing a new close-like method. Complicated.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Just the block block in the Bucket cache itself would know this and do it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Could we not have the special casing here (I don&apos;t know what I&apos;m talking about ... this is a totally removed, high-level comment... ignore if nonsense)&lt;/p&gt;

&lt;p&gt;Sounds good on testing.&lt;/p&gt;

&lt;p&gt;Where are the refcounts to be kept? In the block key itself? Or in a Map keyed by the block key? Or in the HFileScanner? Or in the HFile reader implementation?&lt;/p&gt;

&lt;p&gt;What if we had an encoder that could concatenate CellBlocks?  Would that help?&lt;/p&gt;

&lt;p&gt;Cells come up out of HRegion in Results, right? Its like the Result should have a reference to the backing block and when RPC is &apos;done&apos; with a Result, it calls &apos;close&apos; or &apos;done&apos; or &apos;finally&apos; on the Result and that means the Result and its backing block can be let go. Its like you want to have a &apos;finally&apos; on Result but you want to call it yourself rather than have the GC do it.&lt;/p&gt;

&lt;p&gt;For Scan, I think you need to look at the context object that was recently added. It determines when it is time to go back to the client. Again it is returning a Result. When the Result has been copied to the CellBlock, call its &apos;finally&apos;?&lt;/p&gt;

&lt;p&gt;For scan you say, &quot;...we return back all the blocks used in the read except the current block (the latest block that was read). The latest block cannot be returned back because it could be used for the scan&#8217;s next &#8216;next()&#8217; call. &quot;&lt;/p&gt;

&lt;p&gt;Why not just let the current block go?  Deprecate its count? It might get evicted before the scanner comes back with a next, but that&apos;d be ok?  The block must have been cold?  Otherwise, it&apos;ll just be in cache next time we come in.&lt;/p&gt;

&lt;p&gt;For CPs, if Result had a &apos;finally&apos; or &apos;release&apos; or &apos;close&apos; on it, they could let it go when done with it rather than have us do copy? Or, could we have a Result that explicity has all Cells copied into it and another which has reference to backing blocks?  We would default passing CPs Results that have had Cells copied into them with all kinds of warning that this is horrid and they need to switch to do reference Results?&lt;/p&gt;

&lt;p&gt;In non-java cases, is there a barrier like there is in rpc for CellBlocks... so we could do similar for them?  Could do the copy for first cut.&lt;/p&gt;

&lt;p&gt;I think I understand the compaction case. You are setting a flag so that when the refcounts go to zero, instead of leaving the block in the bucketcache, you force it out.  Is that it?  If so, makes sense.&lt;/p&gt;

&lt;p&gt;Thanks lads.&lt;/p&gt;







</comment>
                            <comment id="14564184" author="anoop.hbase" created="Fri, 29 May 2015 04:37:00 +0000"  >&lt;blockquote&gt;&lt;p&gt;So, as is, we&apos;ll make a copy per registered CP?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Not really.  We will make copy once.  Basically the scan/get we have distiguished as 2 path. One in which there is no need for copy and other needs copy. The second case uses the old API itself.  Here once we get the cells, we will see whether it is marked using the new Interface, if so we will do copy to a new Cell. And then this new cell is going to be passed to CPs as well as HRS and above layers.  Am I making it clear now?&lt;/p&gt;</comment>
                            <comment id="14564194" author="anoop.hbase" created="Fri, 29 May 2015 04:47:57 +0000"  >&lt;blockquote&gt;&lt;p&gt;Why not just let the current block go? Deprecate its count? It might get evicted before the scanner comes back with a next, but that&apos;d be ok? The block must have been cold? Otherwise, it&apos;ll just be in cache next time we come in.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Not really we can. Because if we do so, every time next() comes, we have to ask the cache to give me the cached block. This is not happening now.  So we would like to avoid this overhead.  &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;ts like the Result should have a reference to the backing block and when RPC is &apos;done&apos; with a Result, it calls &apos;close&apos; or &apos;done&apos; or &apos;finally&apos; on the Result and that means the Result and its backing block can be let go&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But there can be N results which have the ref to same block(s) no? So it is bit complicated then. Also we did not want the concept of blocks or cache to come to upper layers after the HFileScanner layer.  &lt;br/&gt;
The ref counting is happening within the BC impl. Not even all BCs need this. Say the File based BC, we better copy buckets to a single buffer.  This also we try to handle..&lt;/p&gt;</comment>
                            <comment id="14564311" author="anoop.hbase" created="Fri, 29 May 2015 07:01:27 +0000"  >&lt;blockquote&gt;&lt;p&gt;We&apos;ll have to dig in on why. You&apos;d think w/ less intermediaries that it would be faster.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;It should be the cost at socket layer and we will need N transfers instead of one. This one time transfer was looking better even if we need a temp copy.&lt;/p&gt;

&lt;p&gt;Regarding knowing whether L1 or L2 looking at key, actually this info of whether L1 or L2 is a state of HFileBlock.  We have added this with an enum L1/L2/NOT_CACHED.  Based on this type, we decided at the HFileScanner layer (on close) whether to call return on BlockCache. Also within the BlockCache impl, we might need to know the type. This is for CombineBC.  If it is L2, then we call the BucketCache return and else call LRU cache return.  So if we add the L1/L2 info also to BlockCacheKey, I am not sure whether this looks clean. BlockCacheKey is some thing which we will be creating while fetching the block from BC. While return, we can just pass the info by setting it in BlockCacheKey. It will just act as a carrier then.  Or may be we can use HFileBlock object alone in the return API? Using a key we have got an object from a cache and we return &lt;b&gt;that&lt;/b&gt; object back to the cache.  It is always possible to make the BlockCacheKey from HFileBlock.  &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;You going to mark the object as from L2 or something&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes. HFileBlock will contain state info whether it is from L1 or L2 or NOT_CACHED one.   When it is CombinedBC, HFileReader ask the cache to give block and it returns the HFileBlock. So we are not sure from where it has come L1/L2. So better set it as a state info in HFileBlock&lt;/p&gt;

&lt;p&gt;carry the cellBlock in Result, am not sure..  At HRegion level, the get() return a Result but the scanner returns a List of Cells.  Then in RsRpcServer level, we call in al loop to make those many rows/results as per caching/max size limit.  Even if we make it to return a Result in scan area also, it will make overhead of creating smaller sized cellBlock buffer for each of the rows. So finally we will have to deal with more smaller size block buffers. It will be better to collect all rows and then make a single cellBlock at once for the scan case. Making sense?  Agree to your point of not passing RPC stuff even to HRegion level. We have to see what else we can do to return this payload. &lt;/p&gt;

&lt;p&gt;I think I got now what is in your mind on saying finalize/close on Result and handle things that way.  Right now, when we get a block from BC, we increase its ref count by 1, means one scanner is working on this. So if we have to do in this suggestion, then whenever we are creating a cell from this block, we have to again increment the ref count.  Some thing like java ref counting way.  Only Q is Result/Cell is a client side thing and am not sure how we can add server only BlockCache/ HFileBlock...  But this would have made max NOT copy to happen.. Thinking more...&lt;br/&gt;
When the cell is written to stream, we have to close/finalize it. Also if the cell is filtered we have to do the same.  It can get filtered out from the o/p result by filterRow(List&amp;lt;Cell&amp;gt;) also...  If the cell is transformed by Filter#transformCell(Cell v)  then also do the same on old..  I would say this will add more complexity and chances we miss the close.  What do you think?&lt;/p&gt;</comment>
                            <comment id="14564689" author="anoop.hbase" created="Fri, 29 May 2015 12:15:23 +0000"  >&lt;p&gt;In CP case also, then we have expectation from user to explicitely call close().  We are copying cell considering the fact that it might get stored and used later (by CP). Those kind of use cases (HIndex for eg) might not be always the case.  So we can say if the CP has such a case then they have to be aware of this SharedMemoryCell and do copy on their own? Just throwing thoughts coming.&lt;/p&gt;

&lt;p&gt;For non java case, any way we will need a copy. Right now using HBaseZeroCopyByteString we avoid the copy need to make a PBCell from Cell. But all types of ByteString from PB need a byte[] as backing data structure. When the cells are backed by DBB, we have to copy here.  So there is not much adv we get. I would say in such a scenario copy the cell at one shot in Region level is better. &lt;/p&gt;</comment>
                            <comment id="14564705" author="ram_krish" created="Fri, 29 May 2015 12:25:19 +0000"  >&lt;p&gt;Was not available for some time during the day today.  Anyway Anoop had chimed in.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Where are the refcounts to be kept? In the block key itself? Or in a Map keyed by the block key? Or in the HFileScanner? Or in the HFile reader implementation?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Ref counts purely happens in the L2_CACHE layer alone and the ref count is associated with the bucket entry.  None of the above layers know about it.&lt;br/&gt;
The list of blocks to be used is there in the HFileREader (HfileScanner internally).&lt;br/&gt;
The current scan case is quite complex and handling the pseudo close call for intermedidate cases seems will have more involved changes - let&apos;s see.&lt;/p&gt;

&lt;p&gt;Scannercontext, I had a look but all cases we have hasMoreValues as true except for NO_MORE_VALUES. I think we just need this information before confirming if we can decrement the blocks ref count.  &lt;br/&gt;
Regarding the result part, your idea is right, but apart from the concerns that Anoop raised as Result is a client side thing, if Result needs to do the &apos;finally&apos; may be it should be exposed to some more internals of the scans and the scanners? &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Will you want to return many Results in the one go? I&apos;m am wondering if Result operates on a different dimension to what you need.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I think you make that point here.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Why not just let the current block go? Deprecate its count? It might get evicted before the scanner comes back with a next, but that&apos;d be ok? The block must have been cold? Otherwise, it&apos;ll just be in cache next time we come in&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Could be done but as Anoop said it has an overhead for then next next() call and logically holding that block is fine - as we really know it is a hot block.  If the current next() call would really know that there are no more results to be fetched it would have already ensured that the current block would not be reused.  So I feel that maintaining the last block is needed and logically right too.&lt;/p&gt;</comment>
                            <comment id="14566285" author="stack" created="Sun, 31 May 2015 01:30:02 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Here once we get the cells, we will see whether it is marked using the new Interface, if so we will do copy to a new Cell. And then this new cell is going to be passed to CPs as well as HRS and above layers. Am I making it clear now?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes&lt;/p&gt;

&lt;p&gt;CPs will have means of avoiding copy. Thats good.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Because if we do so, every time next() comes, we have to ask the cache to give me the cached block. This is not happening now. So we would like to avoid this overhead.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You mean, the scanners are parked at a particular location so when scan comes back in, we just continue? If it makes life easier, maybe we undo this and have each &apos;next&apos; invocation be a new scan (An old @nicolas liochon issue suggesting we copy an amz db was suggesting this... but some pushback). I understand though now that you want to preserve the old behavior.  Makes sense.  But if it makes it all more complicated, then we might want to reexamine (scan would be more like a get then?)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But there can be N results which have the ref to same block(s) no? So it is bit complicated then.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Don&apos;t these each have their own ref count?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also we did not want the concept of blocks or cache to come to upper layers after the HFileScanner layer. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1 on this (if my Result suggestion makes us go against this principal, then it is not a good suggestion)&lt;/p&gt;




</comment>
                            <comment id="14566406" author="anoop.hbase" created="Sun, 31 May 2015 07:28:44 +0000"  >&lt;blockquote&gt;&lt;p&gt;Don&apos;t these each have their own ref count?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Now in our impl, ref count is incremented per scanner. So it is not like normal java ref count. When we see one HFileBlock&apos;s ref count is 2 that means there are 2 active scanners still referring to this. Those refs might be in the read path places like comparators etc and/or by cells created from this block.   So if we have to make some thing like cell close() we will maintain the count incremented when a Cell is created also. This creation is at HFileScanner level. Then every cell, when closed has to decrement this count.  But the disadv for this wrt perf is we will make the counter incr/decr many times. This has to be an atomic long and so there will be some cost. But more than that , the complications will be in cell filtering area etc. When the Cell is created from Scanner level, we dont know whether this cell will get eliminated. The cell can get ignored at many places (due to version/ttl/acl/visibility/filter etc etc)..  All these impl has to handle the close of the cell when it is being ignored.  There can be custom filters which is doing this elimination. (by filterCell(Cell) or  by filterRowCells(List&amp;lt;Cell&amp;gt;) ) All these has to handle the close. And filter can transform an incoming cell into another and make that to be used from then on (transformCell(Cell))  Same way CPs also can do this filtering. There is the complication which I was telling.   I actually liked that idea so that changes in HRegion level can be avoided..  Then thinking more and more I landed in all these kind of practical issues...  Just adding here FYI  &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14568176" author="stack" created="Mon, 1 Jun 2015 22:48:01 +0000"  >&lt;blockquote&gt;&lt;p&gt;...Regarding knowing whether L1 or L2 looking at key...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Do what makes sense. If keeping type in HFileBlock makes more sense, then ok, no problem passing block on close/when done.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;We have to see what else we can do to return this payload.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, not sure how to encapsulate blockcache blocks while making it so we can delay the copy to cellblock long as possible... as far out as possible in the read path.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think I got now what is in your mind on saying finalize/close on Result and handle things that way. ...I would say this will add more complexity and chances we miss the close. What do you think?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not sure I follow the objection, but ok if you think it might make things more complex. Lets see how we figure getting from blockcache block to cellblock....&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Ref counts purely happens in the L2_CACHE layer alone and the ref count is associated with the bucket entry. None of the above layers know about it....&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That is good. Ignore my suggestions that would go against the above.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;if Result needs to do the &apos;finally&apos; may be it should be exposed to some more internals of the scans and the scanners?...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, serverside Result would have to know more about internals.... so could do release. Seems like Get needs to NOT return Result on serverside ... should be like scan.&lt;/p&gt;







</comment>
                            <comment id="14569481" author="anoop.hbase" created="Tue, 2 Jun 2015 17:44:11 +0000"  >&lt;p&gt;Regarding the complexity in close/finalize on Result/Cell.&lt;br/&gt;
I think we need to put it in Cell..  Cell is the one available through out the layers. So when a Cell is created at HFileScanner level and its data refers to bucket cache shared memory area, we have to incr the ref count.  When cell is closed decr it.  So after the usage, some one should call close on Cells. In a normal path assume the cell is getting written in IPC layer, there the call can happen..  All looks ok.  &lt;br/&gt;
The issue is the possible ways via which the cell wont reach that IPC layer and get filtered out. Can be by version expiry, TTL expiry, acl, visibility, filter, cp etc..  All the core places we can make sure to call. But Filter/CP can be custom made also.  Even when a Filter converts a Cell using transformCell(Cell) API, we have to make sure the old cell is being closed..  This was the part I was telling .. It looks all complex.. Am I explaining it clearly now?  Sorry for not being clear in old comments.&lt;/p&gt;</comment>
                            <comment id="14570334" author="ram_krish" created="Wed, 3 Jun 2015 06:12:21 +0000"  >&lt;p&gt;Given that we can solve this without using Result we could continue the way we handle with scanners and scanners doing the ref counting part.&lt;br/&gt;
I would any way think that if we use Result, may be we need not increment every cell coming from that block.  Per block used in the result we can increment the count. &lt;br/&gt;
But doing anything with Result would need to have a Server side result object that may do some extra APIs/methods to handle these return/close stuff. &lt;br/&gt;
As Stack points out &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I would say that the creation of the CellBlock in memory is something we would like to get away from some day. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;If this has to happen then its better we handle things with the Result - but incrementing the ref count for every cell in the block may be we can see if there is another way.  &lt;br/&gt;
For now we are not handling this through Result and handling things using CellBlock and existing scanners. &lt;/p&gt;</comment>
                            <comment id="14572139" author="ram_krish" created="Thu, 4 Jun 2015 04:54:34 +0000"  >&lt;p&gt;Updated patch and corresponding document.  It also includes &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-13287&quot; title=&quot;Append is missing methods, such as addColumn()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-13287&quot;&gt;HBASE-13287&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;-&amp;gt; Creates a ref count mechanism for the blocks being referred in a read.&lt;br/&gt;
-&amp;gt; Allows the cellblocks to be created in the layers before the RPCServer for the scans and gets.&lt;br/&gt;
-&amp;gt; Block eviction happens only after the ref count becomes 0 and the decrement of the ref count happens after the creation of cells blocks for the java case and when the results are copied for the non-java case.  &lt;br/&gt;
More details in the doc attached.&lt;/p&gt;</comment>
                            <comment id="14572169" author="ram_krish" created="Thu, 4 Jun 2015 05:12:50 +0000"  >&lt;p&gt;New RB link -&lt;a href=&quot;https://reviews.apache.org/r/35045/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://reviews.apache.org/r/35045/&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14572232" author="hadoopqa" created="Thu, 4 Jun 2015 06:09:55 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12737459/HBASE-12295_1.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12737459/HBASE-12295_1.patch&lt;/a&gt;&lt;br/&gt;
  against master branch at commit bb62d5b2e8db1677568723bb8d0d8ea4fd2c6f46.&lt;br/&gt;
  ATTACHMENT ID: 12737459&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 53 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop versions&lt;/font&gt;. The patch compiles with all supported hadoop versions (2.4.1 2.5.2 2.6.0)&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 protoc&lt;/font&gt;.  The applied patch does not increase the total number of protoc compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 javadoc&lt;/font&gt;.  The javadoc tool appears to have generated 2 warning messages.&lt;/p&gt;

&lt;p&gt;                &lt;font color=&quot;red&quot;&gt;-1 checkstyle&lt;/font&gt;.  The applied patch generated 1936 checkstyle errors (more than the master&apos;s current 1920 errors).&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any  new Findbugs (version 2.0.3) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 lineLengths&lt;/font&gt;.  The patch introduces the following lines longer than 100:&lt;br/&gt;
    +    cellScanner = IPCUtil.getInstance().createCellScanner(codec, compressor, bb.array(), 0, bb.limit());&lt;br/&gt;
+ * read data from such cache, we will make a cell referring to the same memory and will avoid any copy.&lt;br/&gt;
+   * Cell. This is useful when we want to consume the Cell before even the block referring to these cells&lt;br/&gt;
+   * done with this instance by calling &lt;/p&gt;
{@link #flipAndReturnBuffer()}
&lt;p&gt;. All this encapsulation violation&lt;br/&gt;
+      if (block != null &amp;amp;&amp;amp; this.curBlock != null &amp;amp;&amp;amp; block.getOffset() == this.curBlock.getOffset()) {&lt;br/&gt;
+      // Ideally if we can make the scanner to work at this level it is much easier because this method&lt;br/&gt;
+      // surely knows what was fetched from the cache and based on that we could keep returning the prev&lt;br/&gt;
+                + &quot; readers. Can not be freed now. Hence will mark this for evicting at a later point&quot;);&lt;br/&gt;
+  Triple&amp;lt;Message, CellScanner, ByteBuffer&amp;gt; call(BlockingService service, MethodDescriptor md, Message param,&lt;br/&gt;
+      //((PayloadCarryingRpcController) controller).setCellScanner(CellUtil.createCellScanner(results));&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;     &lt;font color=&quot;red&quot;&gt;-1 core tests&lt;/font&gt;.  The patch failed these unit tests:&lt;br/&gt;
                       org.apache.hadoop.hbase.regionserver.TestKeyValueHeap&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14279//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14279//testReport/&lt;/a&gt;&lt;br/&gt;
Release Findbugs (version 2.0.3) 	warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14279//artifact/patchprocess/newFindbugsWarnings.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14279//artifact/patchprocess/newFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Checkstyle Errors: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14279//artifact/patchprocess/checkstyle-aggregate.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14279//artifact/patchprocess/checkstyle-aggregate.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;                Javadoc warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14279//artifact/patchprocess/patchJavadocWarnings.txt&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14279//artifact/patchprocess/patchJavadocWarnings.txt&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14279//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14279//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14572279" author="ram_krish" created="Thu, 4 Jun 2015 06:55:52 +0000"  >&lt;p&gt;Wraps all the long lines.  It was contributing to the checkstyle also.  The test case change was not done for TestKVHeap. Updated that too.  Java doc warnings also corrected. &lt;/p&gt;</comment>
                            <comment id="14574445" author="ram_krish" created="Fri, 5 Jun 2015 12:54:47 +0000"  >&lt;p&gt;Ping for reviews!!!.&lt;/p&gt;</comment>
                            <comment id="14575331" author="stack" created="Fri, 5 Jun 2015 22:11:41 +0000"  >&lt;blockquote&gt;&lt;p&gt;Then thinking more and more I landed in all these kind of practical issues... &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Am I explaining it clearly now?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt; A close on Cell won&apos;t fly. Agree.&lt;/p&gt;

&lt;p&gt;Looking at last patch now...&lt;/p&gt;
</comment>
                            <comment id="14575732" author="ram_krish" created="Sat, 6 Jun 2015 14:01:09 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=saint.ack%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;saint.ack@gmail.com&quot;&gt;Stack&lt;/a&gt;&lt;br/&gt;
Thanks for a detailed review.  I have responded to your questions in RB. Let us know if they are not clear or need more inputs. Will work on the changes after we discuss things based on the reply. &lt;br/&gt;
Thanks once again.&lt;/p&gt;</comment>
                            <comment id="14583173" author="ram_krish" created="Fri, 12 Jun 2015 09:09:45 +0000"  >&lt;p&gt;Had some internal discussions on some of the questions raised&lt;br/&gt;
Thanks for the reviews so far over in RB. We discussed some of your comments and thought of finalizing things and also thought it would help to clarify certain aspects as why it was done.&lt;/p&gt;

&lt;p&gt;-&amp;gt; CellBlock creation &lt;br/&gt;
The first area is the cellblock creation.  As per the previous mail discussion now we will have now create the cellBlock in the RsRpcServices layer both for scan and gets.&lt;br/&gt;
The scans already were creating the cellScanner in the RsRpcServices layer - now that we have added the cellBlock creation here.&lt;/p&gt;

&lt;p&gt;But in order to do this we are creating a new getScanner() API in HRegion - (note that it is not in Region.java) so it is not exposed to CPs. &lt;br/&gt;
This new API would indicate if the client is java based or not.  For java based client we will allow the cellblock creation in the RsRpcServices layer and then the blocks are returned back (ref count decremented).  &lt;br/&gt;
But for the non-java cases we will go with the old getScanner() API only but internally it would set a state in the RegionScanner saying that the results are to be copied then and there as there is no cellblock creation for it. (We don&apos;t create cellblock for non-java cases as you may be already knowing it). Once the copying of the results are done we are sure that we can return the blocks back.&lt;/p&gt;

&lt;p&gt;This new state in the REgionScanner also helps us with the case of CPs wrapping the scanner where though the scan is from java -client the partial results could be used in the CPs and we may not know how the CPs will use the result. Hence it is better to copy those results like we do for non-java client cases.&lt;br/&gt;
In case of scan() after every next() we make a call to return the blocks so that we don&apos;t hold them up till the scanners are done. &lt;/p&gt;

&lt;p&gt;Now coming to get(), we have now tweaked the logic of get() in RsrpcServices such that what ever was being done in Region.get() is now moved to RsRpcServices included CP hooks and once the result is formed we create the cellblock in RsRpcServices.  &lt;br/&gt;
For the non-java case the old Region.get() API is still used.  Just like in scan the results would be copied once it is formed. &lt;br/&gt;
Remember we need to use it for CP when it needs to do a get() on a region directly.  &lt;br/&gt;
In case of gets() the scanner.close() woudl ensure that the block ref count decrement happens. &lt;/p&gt;

&lt;p&gt;-&amp;gt; MemType and CacheType&lt;br/&gt;
First of all we can be sure that none of the blocks coming from L1 cache needs to go through all these shared memory or copying stuff.  Because they are just objects referring to the blocks created from HDFS and nothing is serialized and there is no problem of eviction.&lt;/p&gt;

&lt;p&gt;We need to do this only for Bucketcache.  BucketCache again has 3 things&lt;br/&gt;
-&amp;gt; RamQueue - which is like initially the blocks are added to this queue and then moved to the actual buckets. So there are chances the reads are served from these queue itself. Those cases there is no need for any copying or sharing of memory. (this is similar to L1).&lt;br/&gt;
-&amp;gt; ByteBufferIOEngine&lt;br/&gt;
This is the actual case where we need to solve.  Here the block is for sure from L2 and also the memory is shared.  So if you see in our patch we would have set this L2 and shared_memory only at this layer.&lt;br/&gt;
-&amp;gt; fileIOEngine&lt;br/&gt;
Here though it is a bucketcache impl there is no need for having a shared_mem because already there is copy from the file. &lt;/p&gt;

&lt;p&gt;But who is responsible for setting the memory type-? It should be the engine.  The engine knows what type of memory it is creating.  The engines just return a BB and we don&apos;t know the type of it. so better the engine set the type of the memory also.&lt;/p&gt;

&lt;p&gt;-&amp;gt; ReturnBlock in between code in HFileREaders&lt;br/&gt;
This is important.  As I earlier commented in the RB, the index or bloom blocks from L1 cache can get demoted to L2 cache.  Our code is such that in some case we try to read a block and we iterate till we reach a data block. Those blocks could have been from L1 or L2 - we are not sure. &lt;br/&gt;
So we have analysed the code and ensured that where ever we read blocks and just throw it away till we end up in a data block- all such blocks have to be returned back. If the block is from L1 it is going to be a noop.  &lt;/p&gt;

&lt;p&gt;I verified it once again and to be safe added some try/finally around it.  I can explain more on this if you have some queries.&lt;/p&gt;

&lt;p&gt;-&amp;gt;IPCUtil singleton&lt;br/&gt;
IPCUtil singleton was mainly for ease of use.  The IPCutil had the code to create Cellblock. So we wanted to reuse that code rather than duplicating it. &lt;br/&gt;
We could create IPCUTil inside Payload also.  But for doing that we need the &apos;conf&apos; object. Most of the cases Payload is created from RPcControllerfactory where already we have &apos;conf&apos;.  But in case of AbstractRPcClient, AbstractRpcCaller etc we need to get the access to these conf object so that we can pass a &apos;conf&apos; to Payload and use that conf to create the IPCUtil object.&lt;br/&gt;
So in order to avoid this in the latest will pass the IPCtuil to the Payload using a helper class which will also have all the other ingredients needed to create  a cellblock.  This wil avoid all the singleton related changes to IPCUtil.&lt;/p&gt;

&lt;p&gt;To which Stack had some comments&lt;br/&gt;
Hmm.&lt;/p&gt;

&lt;p&gt;RsRpcServices is a weird class. It has not character. It is just something Jimmy made to move a bunch of HRegionServer to its own class.&lt;/p&gt;

&lt;p&gt;So, will Get be the only thing in Region that cannot be intercepted by CPs?  Other methods in Region can be intercepted by CPs? Having Get be an exception will cause confusion.&lt;/p&gt;

&lt;p&gt;Or is it that you are saying that the old Get can be used by CPs to intercept... and in this case there will be the unavoidable copy. If so, that sounds ok (where can I see current state of code?)&lt;/p&gt;

&lt;p&gt;For the MemType and CacheType his reply was&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Thats fine. I just don&apos;t like labeling each individual block. High-level, the engine knows where the block came from, right? It can stamp the return with where it came from rather than do it per block?&lt;/p&gt;
</comment>
                            <comment id="14583177" author="ram_krish" created="Fri, 12 Jun 2015 09:13:59 +0000"  >&lt;p&gt;We had more discussions on the Cache type and memory type&lt;br/&gt;
Let me try to explain use of each (Part is already said by Ram as well as me in RB. Pardon for the repetition)&lt;br/&gt;
CacheType is saying whether the block is from which cache or not at all from cache. This is useful while returning back the block.  The return back is what is doing the ref count decrement now. But the return block can do any other kind of cleanup. We tried to make it general. So while return back, we have to know to which cache the block has to be returned (L1 or L2). As of today the L1 return is a noop still we are doing it. If we dont have the CacheType in block, we have to return it to both and search in both places. This is an overhead. Also there is another problem with CombinedCache. Consider a block is demoted from L1 to L2. While it was in L1, it was served from it to a scanner. But before it is returned back, it got moved to L2. Then another scanner get this same block and this time from L2. So the ref count for this block (block key) got incremented and now it is 1. (Remember the old scanner got from L1 and so ref count increment at that time).. Now the old scanner returning block and we return it to both L1 and L2. L2 will have an entry and ref count will become zero. Still an active scanner refering this.  This can cause issues. Tomorrow if L3 cache also comes, if we mark the block from where it has come, we can do correct return and correct action.&lt;br/&gt;
The usage of MemType (as of now Shared or NonShared) is for cell creation. We have to make Cells backed by shared cache memory location as SharedMemoryCell marked. Cells which are not coming from shared mem backed blocks, need not be SharedMemoryCell marked. CacheType of L2 does not mean always that the block is backed by shared memory. An eg: is FileIOEngine. Here while reading the blocks, we will have to read the data to a heap memory area (byte[]) from files.  &lt;/p&gt;

&lt;p&gt;May be we can say for SharedMem type only the return is needed as of today.  Still we wanted these 2 to be independent general things and f/w.  IMHO, this looks cleaner and more extendable for future.&lt;/p&gt;

&lt;p&gt;To which Stack replied&lt;/p&gt;

&lt;p&gt;One more Q from Stack was why we need CacheType and MemType 2 enums? Will one be enough?&lt;br/&gt;
Let me try to explain use of each (Part is already said by Ram as well as me in RB. Pardon for the repetition)&lt;br/&gt;
CacheType is saying whether the block is from which cache or not at all from cache. This is useful while returning back the block.  The return back is what is doing the ref count decrement now. But the return block can do any other kind of cleanup. We tried to make it general. So while return back, we have to know to which cache the block has to be returned (L1 or L2). As of today the L1 return is a noop still we are doing it. If we dont have the CacheType in block, we have to return it to both and search in both places.&lt;/p&gt;


&lt;p&gt;&amp;gt;&amp;gt;Can you mark the HFileBlock with where it came form when you cache it rather than write out the type with the data?&lt;/p&gt;

&lt;p&gt;This is an overhead. Also there is another problem with CombinedCache.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;CombinedCache is one possible combination. Change it if is making your life more difficult.&lt;/p&gt;


&lt;p&gt;Consider a block is demoted from L1 to L2.&lt;/p&gt;

&lt;p&gt;For CombinedCache, this would be an index or bloom block only.&lt;/p&gt;


&lt;p&gt;While it was in L1, it was served from it to a scanner. But before it is returned back, it got moved to L2. Then another scanner get this same block and this time from L2. So the ref count for this block (block key) got incremented and now it is 1. (Remember the old scanner got from L1 and so ref count increment at that time).. Now the old scanner returning block and we return it to both L1 and L2. L2 will have an entry and ref count will become zero. Still an active scanner refering this.  This can cause issues. Tomorrow if L3 cache also comes, if we mark the block from where it has come, we can do correct return and correct action.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;They&apos;d be the same HFileBlock instance? The same item in cache?  We&apos;re talking now of moving between caches while something is being used. That&apos;d be a no-no, right? If its referenced you can&apos;t move it, not unless its L1 where it is safe to move it (you&apos;d just scrub refcounts)&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;Can keep type specific refcounts if an issue?&lt;/p&gt;


&lt;p&gt;The usage of MemType (as of now Shared or NonShared) is for cell creation. We have to make Cells backed by shared cache memory location as SharedMemoryCell marked. Cells which are not coming from shared mem backed blocks, need not be SharedMemoryCell marked. CacheType of L2 does not mean always that the block is backed by shared memory. An eg: is FileIOEngine. Here while reading the blocks, we will have to read the data to a heap memory area (byte[]) from files.  &lt;/p&gt;


&lt;p&gt;&amp;gt;&amp;gt;Ok&lt;/p&gt;


&lt;p&gt;May be we can say for SharedMem type only the return is needed as of today.  Still we wanted these 2 to be independent general things and f/w.  IMHO, this looks cleaner and more extendable for future.&lt;/p&gt;


&lt;p&gt;&amp;gt;&amp;gt;Ok.&lt;/p&gt;</comment>
                            <comment id="14583178" author="ram_krish" created="Fri, 12 Jun 2015 09:14:54 +0000"  >&lt;p&gt;Based on review comments if callBack mode can be made from the RPcServer - few things are being tried out. Once we finalize on it can post a patch for that part. &lt;/p&gt;</comment>
                            <comment id="14583605" author="stack" created="Fri, 12 Jun 2015 15:58:49 +0000"  >&lt;p&gt;Thanks for updating the issue w/ our off-list discussion &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ram_krish&quot; class=&quot;user-hover&quot; rel=&quot;ram_krish&quot;&gt;ramkrishna.s.vasudevan&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In short, we are trying to figure how we can release the offheap blocks when done with them after sending the response.&lt;/p&gt;</comment>
                            <comment id="14584222" author="stack" created="Fri, 12 Jun 2015 22:57:00 +0000"  >&lt;p&gt;I had a nice chat with &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mbertozzi&quot; class=&quot;user-hover&quot; rel=&quot;mbertozzi&quot;&gt;Matteo Bertozzi&lt;/a&gt; on how to figure when we can let go of offheap bucketcache blocks.&lt;/p&gt;

&lt;p&gt;Would the following work?&lt;/p&gt;

&lt;p&gt;Add a &lt;tt&gt;done&lt;/tt&gt; or &lt;tt&gt;release&lt;/tt&gt; method on serverside Cells. It is called when the Cell has been used up; i.e. the Cell has been dumped out on the RPC. It is a noop unless Cell is an instance of RefCountedDBBBackedCell. In this case, we decrement our refcounter.  How we get to our refcounter you say? Well, a RefCountedDBBBackedCell is backed by a byte array. Let the refcounter be at location zero in the backing byte array (In the BucketCache case, this would be offset zero in a bucket I believe &amp;#8211; haven&apos;t checked). Changing refcount would have to be threadsafe so synchronize on the backing DBB doing any access would be a coarse first cut means of doing this.  When we make Cells &amp;#8211; in HFileScannerImpl &amp;#8211; we&apos;d have to ask the HFileBlock, what type it was... and if a refcounting block, we&apos;d make RefCountedDBBBackedCell and up the refcount per one made (could try and do bit increment/decrement so don&apos;t have to parse as an int each time we want to increment).&lt;/p&gt;
</comment>
                            <comment id="14584395" author="anoop.hbase" created="Sat, 13 Jun 2015 02:21:59 +0000"  >&lt;p&gt;Bq.call cell.done/release when it is dumped at RPC&lt;br/&gt;
The issue is there is no guarentee that a cell, created from hfileblock will reach thia rpc layer. What if it was version expired or ttl expired.  We can make sure to call it before discarding cell. What if it is filtered by a filter. I would say this will add all complexity and and chances of we missinh this done call&lt;/p&gt;</comment>
                            <comment id="14588047" author="ram_krish" created="Tue, 16 Jun 2015 13:44:22 +0000"  >&lt;p&gt;-&amp;gt; Updated doc with the recent callBack approach discussed. Different options were tried out before finalizing this.&lt;br/&gt;
-&amp;gt; Explains the need for Cachetype and MemType based enums while doing the ref counting. &lt;br/&gt;
-&amp;gt; No change in the cellBlock creation and the RpcServer layer except that the callback is executed after the cellblock creation so that the scan/gets are either partiallyClosed or fully closed based on the type of the callback getting executed. &lt;/p&gt;</comment>
                            <comment id="14589705" author="ram_krish" created="Wed, 17 Jun 2015 12:31:33 +0000"  >&lt;p&gt;Updated doc &lt;br/&gt;
the difference between the previous doc is that here it considers only MemoryType and there is no cacheType. &lt;br/&gt;
The non-java clients can also work with the callback way without doing any copy.  The Hregion API needed for getScanner() will not be needed.&lt;/p&gt;</comment>
                            <comment id="14589720" author="ram_krish" created="Wed, 17 Jun 2015 12:38:14 +0000"  >&lt;p&gt;Updated patch available in RB.&lt;br/&gt;
The callback approach is also included in the patch. The callback approach can be a seperate patch too - I think Anoop is planning to upload it seperately.  If needed we can commit that seperately.&lt;/p&gt;</comment>
                            <comment id="14590051" author="stack" created="Wed, 17 Jun 2015 16:35:42 +0000"  >&lt;p&gt;Chatted w/ &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ram_krish&quot; class=&quot;user-hover&quot; rel=&quot;ram_krish&quot;&gt;ramkrishna.s.vasudevan&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoopsamjohn&quot; class=&quot;user-hover&quot; rel=&quot;anoopsamjohn&quot;&gt;Anoop Sam John&lt;/a&gt; about cell-based vs scan-based approach doing refcounting. They argued cell-based would involve a finer level of accounting and that it will have to be done in many locations &amp;#8211; e.g. check return from filters &amp;#8211; makes this approach untenable. Another strong objection was that the assumption that we backing BB location zero was start of a block is actually wrong (a block will be made of many fixed sized BBs from bucketcache... location zero could be start of any one of these bucketcache BBs). So, RPC call-backs across the great &apos;call&apos; divide at the end of a session with the callback going all the ways down the scan stack and into the HFileBlock for it to do ref counting is the way to go.&lt;/p&gt;</comment>
                            <comment id="14590079" author="anoop.hbase" created="Wed, 17 Jun 2015 16:48:40 +0000"  >&lt;p&gt;Thanks Stack for the discussion. I have raised &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-13926&quot; title=&quot;Close the scanner only after Call#setResponse&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-13926&quot;&gt;&lt;del&gt;HBASE-13926&lt;/del&gt;&lt;/a&gt; to give a patch for this RpcCallback based change alone.That will make this jira patch to concentrate only on the bucket cache ref counting area.&lt;/p&gt;</comment>
                            <comment id="14597329" author="ram_krish" created="Tue, 23 Jun 2015 08:21:34 +0000"  >&lt;p&gt;Updated patch - Rebased based on the latest trunk. &lt;br/&gt;
Purely consists of only ref couting related code.  &lt;br/&gt;
The blocktype has only one type  ie. MemoryType (SHARED_MEM and NON_SHARED_MEM).&lt;br/&gt;
Any cell coming block formed from the ByteBufferIOEngine of the bucket cache is marked as SHARED_MEM - helps to do the copy of the cells in case of CP wrapping the region scanner.&lt;br/&gt;
All other blocks are marked as NON_SHARED_MEM.&lt;/p&gt;</comment>
                            <comment id="14597409" author="hadoopqa" created="Tue, 23 Jun 2015 09:38:18 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12741247/HBASE-12295_9.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12741247/HBASE-12295_9.patch&lt;/a&gt;&lt;br/&gt;
  against master branch at commit 6a537eb8545c7dd6c01c0d911ad12e789eeab3ae.&lt;br/&gt;
  ATTACHMENT ID: 12741247&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 45 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop versions&lt;/font&gt;. The patch compiles with all supported hadoop versions (2.4.1 2.5.2 2.6.0)&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 protoc&lt;/font&gt;.  The applied patch does not increase the total number of protoc compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javadoc&lt;/font&gt;.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;                &lt;font color=&quot;red&quot;&gt;-1 checkstyle&lt;/font&gt;.  The applied patch generated 1919 checkstyle errors (more than the master&apos;s current 1906 errors).&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any  new Findbugs (version 2.0.3) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 lineLengths&lt;/font&gt;.  The patch introduces the following lines longer than 100:&lt;br/&gt;
    + * read data from such cache, we will make a cell referring to the same memory and will avoid any copy.&lt;br/&gt;
+    if (blockCache != null &amp;amp;&amp;amp; block != null &amp;amp;&amp;amp; block.getMemoryType() != MemoryType.NON_SHARED_MEMORY) {&lt;br/&gt;
+          ret = new SharedMemorySizeCachedNoTagsKeyValue(blockBuffer.array(), blockBuffer.arrayOffset()&lt;br/&gt;
+    // those cells are referring to a shared memory area which if evicted by the BucketCache would lead&lt;br/&gt;
+    // readers using this block are aware of this fact and do the necessary action to prevent eviction&lt;br/&gt;
+  public Result internalGet(Get get, boolean withCoprocessor, ListRegionScannerCloseCallBack closeCallBack,&lt;br/&gt;
+    // An RpcCallBack that creates a list of scanners that needs to perform callBack operation on completion of multiGets&lt;br/&gt;
+      // HBaseAdmin only waits for regions to appear in hbase:meta we should wait until they are assigned&lt;br/&gt;
+  public void testGetsWithMultiColumnsAndExplicitTracker() throws IOException, InterruptedException {&lt;br/&gt;
+    private void slowdownCode(final ObserverContext&amp;lt;RegionCoprocessorEnvironment&amp;gt; e, boolean isGet) {&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 site&lt;/font&gt;.  The patch appears to cause mvn post-site goal to fail.&lt;/p&gt;

&lt;p&gt;     &lt;font color=&quot;red&quot;&gt;-1 core tests&lt;/font&gt;.  The patch failed these unit tests:&lt;/p&gt;


&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14527//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14527//testReport/&lt;/a&gt;&lt;br/&gt;
Release Findbugs (version 2.0.3) 	warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14527//artifact/patchprocess/newFindbugsWarnings.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14527//artifact/patchprocess/newFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Checkstyle Errors: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14527//artifact/patchprocess/checkstyle-aggregate.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14527//artifact/patchprocess/checkstyle-aggregate.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;                Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14527//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14527//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14616454" author="ram_krish" created="Tue, 7 Jul 2015 10:03:38 +0000"  >&lt;p&gt;Updated patch based on RB comments.&lt;/p&gt;</comment>
                            <comment id="14616633" author="hadoopqa" created="Tue, 7 Jul 2015 12:53:17 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12743926/HBASE-12295_10.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12743926/HBASE-12295_10.patch&lt;/a&gt;&lt;br/&gt;
  against master branch at commit 7acb061e63614ad957da654f920f54ac7a02edd6.&lt;br/&gt;
  ATTACHMENT ID: 12743926&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 41 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop versions&lt;/font&gt;. The patch compiles with all supported hadoop versions (2.4.0 2.4.1 2.5.0 2.5.1 2.5.2 2.6.0 2.7.0)&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 protoc&lt;/font&gt;.  The applied patch does not increase the total number of protoc compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javadoc&lt;/font&gt;.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;                &lt;font color=&quot;red&quot;&gt;-1 checkstyle&lt;/font&gt;.  The applied patch generated 1908 checkstyle errors (more than the master&apos;s current 1898 errors).&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any  new Findbugs (version 2.0.3) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 lineLengths&lt;/font&gt;.  The patch introduces the following lines longer than 100:&lt;br/&gt;
    +          ret = new SharedMemorySizeCachedNoTagsKeyValue(blockBuffer.array(), blockBuffer.arrayOffset()&lt;br/&gt;
+    // those cells are referring to a shared memory area which if evicted by the BucketCache would lead&lt;br/&gt;
+    // readers using this block are aware of this fact and do the necessary action to prevent eviction&lt;br/&gt;
+    // An RpcCallBack that creates a list of scanners that needs to perform callBack operation on completion of multiGets&lt;br/&gt;
+        return Result.create(results, get.isCheckExistenceOnly() ? !results.isEmpty() : null, stale);&lt;br/&gt;
+      // HBaseAdmin only waits for regions to appear in hbase:meta we should wait until they are assigned&lt;br/&gt;
+  public void testGetsWithMultiColumnsAndExplicitTracker() throws IOException, InterruptedException {&lt;br/&gt;
+    private void slowdownCode(final ObserverContext&amp;lt;RegionCoprocessorEnvironment&amp;gt; e, boolean isGet) {&lt;br/&gt;
+        // call return twice because for the isCache cased the counter would have got incremented twice&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn post-site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 core tests&lt;/font&gt;.  The patch passed unit tests in .&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14690//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14690//testReport/&lt;/a&gt;&lt;br/&gt;
Release Findbugs (version 2.0.3) 	warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14690//artifact/patchprocess/newFindbugsWarnings.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14690//artifact/patchprocess/newFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Checkstyle Errors: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14690//artifact/patchprocess/checkstyle-aggregate.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14690//artifact/patchprocess/checkstyle-aggregate.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;                Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14690//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14690//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14617158" author="ram_krish" created="Tue, 7 Jul 2015 18:42:02 +0000"  >&lt;p&gt;Will correct the long lines in my next revision based on the comments from RB.&lt;/p&gt;</comment>
                            <comment id="14624470" author="ram_krish" created="Mon, 13 Jul 2015 09:56:52 +0000"  >&lt;p&gt;Updated patch addressing the comments. For QA report.&lt;/p&gt;</comment>
                            <comment id="14624575" author="hadoopqa" created="Mon, 13 Jul 2015 12:20:31 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12745012/HBASE-12295_12.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12745012/HBASE-12295_12.patch&lt;/a&gt;&lt;br/&gt;
  against master branch at commit 5e708746b8d301c2fb22a85b8756129147012374.&lt;br/&gt;
  ATTACHMENT ID: 12745012&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 49 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop versions&lt;/font&gt;. The patch compiles with all supported hadoop versions (2.4.0 2.4.1 2.5.0 2.5.1 2.5.2 2.6.0 2.7.0)&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 protoc&lt;/font&gt;.  The applied patch does not increase the total number of protoc compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 javadoc&lt;/font&gt;.  The javadoc tool appears to have generated 1 warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 checkstyle&lt;/font&gt;.  The applied patch does not increase the total number of checkstyle errors&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any  new Findbugs (version 2.0.3) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;red&quot;&gt;-1 lineLengths&lt;/font&gt;.  The patch introduces the following lines longer than 100:&lt;br/&gt;
    +        return Result.create(results, get.isCheckExistenceOnly() ? !results.isEmpty() : null, stale);&lt;br/&gt;
+      // HBaseAdmin only waits for regions to appear in hbase:meta we should wait until they are assigned&lt;br/&gt;
+        // call return twice because for the isCache cased the counter would have got incremented twice&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn post-site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;     &lt;font color=&quot;red&quot;&gt;-1 core tests&lt;/font&gt;.  The patch failed these unit tests:&lt;/p&gt;


&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14755//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14755//testReport/&lt;/a&gt;&lt;br/&gt;
Release Findbugs (version 2.0.3) 	warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14755//artifact/patchprocess/newFindbugsWarnings.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14755//artifact/patchprocess/newFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Checkstyle Errors: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14755//artifact/patchprocess/checkstyle-aggregate.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14755//artifact/patchprocess/checkstyle-aggregate.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;  Javadoc warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14755//artifact/patchprocess/patchJavadocWarnings.txt&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14755//artifact/patchprocess/patchJavadocWarnings.txt&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14755//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14755//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14627551" author="stack" created="Wed, 15 Jul 2015 05:26:48 +0000"  >&lt;p&gt;Out of interest, server-side, how many Interfaces and abstract classes might a Cell implementation be implementing now?&lt;/p&gt;

&lt;p&gt;Nit: SharedMemoryBackedCell should be SharedMemoryCell ?&lt;/p&gt;

&lt;p&gt;I like your removal of setters from HFileContext&lt;/p&gt;

&lt;p&gt;Do you want to remove this:&lt;/p&gt;

&lt;p&gt;//Empty constructor.  Go with setters&lt;br/&gt;
public HFileContext() &lt;/p&gt;

&lt;p&gt;The below comment is a little soft:&lt;/p&gt;

&lt;p&gt;&quot;121	   * Called when the scanner using the block decides to safely decrement&lt;br/&gt;
122	   * the reference count of the block since the block is no longer in use.&quot;&lt;/p&gt;

&lt;p&gt;Should it be something like YOU MUST RETURN BLOCKS TO BC WHEN DONE!!!! OR ELSE!!!!&lt;/p&gt;

&lt;p&gt;Should Type be MemoryType enum? (I think you or Anoop suggested this and it a good idea).. would match the getMemoryType method in Cacheable.&lt;/p&gt;

&lt;p&gt;I haven&apos;t poke aorund but would it make sense passing Cacheable here:&lt;/p&gt;

&lt;p&gt;	  T deserialize(ByteBuffer b, boolean reuse, Type memType) throws IOException;&lt;/p&gt;

&lt;p&gt;Maybe not. Just a thought.&lt;/p&gt;

&lt;p&gt;Skimmed the rest. Let me come back to this again. Is it up in RB? I think this stuff is starting to come together nicely.&lt;/p&gt;
</comment>
                            <comment id="14627559" author="ram_krish" created="Wed, 15 Jul 2015 05:41:29 +0000"  >&lt;blockquote&gt;&lt;p&gt;Let me come back to this again. Is it up in RB?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Ya. The patch is in RB.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;T deserialize(ByteBuffer b, boolean reuse, Type memType) throws IOException;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This CacheableDeserializer is the one creating the Cacheable.  So we cannot pass a Cacheable there I think.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Should Type be MemoryType enum?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We can make it MemoryType.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Out of interest, server-side, how many Interfaces and abstract classes might a Cell implementation be implementing now?&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Nit: SharedMemoryBackedCell should be SharedMemoryCell ?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Okie.&lt;br/&gt;
Keyvalue, NoTagsKeyValue, SharedMemoryCell, the different fake keys, Prefix Tree cells, the DBE cells.  The last two will have two variants one with byte[] backed and other with BB backed. &lt;/p&gt;</comment>
                            <comment id="14627586" author="anoop.hbase" created="Wed, 15 Jul 2015 06:06:51 +0000"  >&lt;p&gt;Just adding to what Ram said abt diff Cell impl&lt;/p&gt;

&lt;p&gt;Write path &lt;br/&gt;
-----------&lt;br/&gt;
KeyValue  and NoTagsKeyValue&lt;/p&gt;

&lt;p&gt;Read path&lt;br/&gt;
----------&lt;br/&gt;
SizeCachedKeyValue, SizeCachedNoTagsKeyValue&lt;br/&gt;
OffheapCell, OffheapNoTagsCell  (this will be having size cached and it will be extending ByteBufferedCell  and also will be marked as Shared memory using the new interface)&lt;br/&gt;
DBE was/is having an impl already (ClonedSeekerState)  We will add one more counterpart for this which will be offheap backed - We need a rename. ClonedSeekerState does not look like a Cell at all&lt;br/&gt;
Prefix tree was/is having an impl already (ClonedPrefixCell) - We will add one more counterpart for this which will be offheap backed - We need a rename?&lt;/p&gt;

&lt;p&gt;also read path will have KeyOnlyKeyValue stuff as well as the FakeCell impls for FirstOnROw, LastOnRow etc.&lt;/p&gt;</comment>
                            <comment id="14627935" author="ram_krish" created="Wed, 15 Jul 2015 11:53:25 +0000"  >&lt;p&gt;Patch for QA.&lt;/p&gt;</comment>
                            <comment id="14628058" author="hadoopqa" created="Wed, 15 Jul 2015 13:35:04 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12745431/HBASE-12295_14.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12745431/HBASE-12295_14.patch&lt;/a&gt;&lt;br/&gt;
  against master branch at commit a63e3ac83ffb91948f464e4f62111d29adc02812.&lt;br/&gt;
  ATTACHMENT ID: 12745431&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 49 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop versions&lt;/font&gt;. The patch compiles with all supported hadoop versions (2.4.0 2.4.1 2.5.0 2.5.1 2.5.2 2.6.0 2.7.0)&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 protoc&lt;/font&gt;.  The applied patch does not increase the total number of protoc compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javadoc&lt;/font&gt;.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 checkstyle&lt;/font&gt;.  The applied patch does not increase the total number of checkstyle errors&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any  new Findbugs (version 2.0.3) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn post-site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;     &lt;font color=&quot;red&quot;&gt;-1 core tests&lt;/font&gt;.  The patch failed these unit tests:&lt;/p&gt;


&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14783//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14783//testReport/&lt;/a&gt;&lt;br/&gt;
Release Findbugs (version 2.0.3) 	warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14783//artifact/patchprocess/newFindbugsWarnings.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14783//artifact/patchprocess/newFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Checkstyle Errors: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14783//artifact/patchprocess/checkstyle-aggregate.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14783//artifact/patchprocess/checkstyle-aggregate.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;  Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14783//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14783//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14628061" author="stack" created="Wed, 15 Jul 2015 13:36:04 +0000"  >&lt;p&gt;Can we cut down the number of variants? For example, if serverside-only, can Interfaces include hasTags method rather than have an Interface for tags and another for no tags?  New issue? Thanks lads.&lt;/p&gt;</comment>
                            <comment id="14628237" author="anoop.hbase" created="Wed, 15 Jul 2015 15:29:06 +0000"  >&lt;p&gt;The new method hasTags  to go in where? In read path we will deal with Cell type and we can add this to Cell interface.&lt;/p&gt;

&lt;p&gt;May be we can avoid 2 impls one with out tags and one with.  Have a state (boolean) in Cell impl. We have SizeCachedKeyValue abd SizeCachedNoTagsKeyValue now. May be we will only have SizeCachedKeyValue and it will have a boolean state whether it has tags or not. The getTagsLength() can check this state ad return 0 or decode tags length.  We have extra 6 bytes per cell in this SizeCachedKeyValue now. Make it 7 is ok IMO&lt;/p&gt;</comment>
                            <comment id="14629591" author="ram_krish" created="Thu, 16 Jul 2015 11:34:02 +0000"  >&lt;p&gt;Updated patch addressing the comments in RB. &lt;/p&gt;</comment>
                            <comment id="14629595" author="ram_krish" created="Thu, 16 Jul 2015 11:35:17 +0000"  >&lt;p&gt;The 4 varieties of SizeCachedKeyValue and NoSizeCachedKeyValue has been removed and now we have only one SizecacheKeyvalue.  The SharedMemory interface impl Cell is the other one that is added by this patch. &lt;/p&gt;</comment>
                            <comment id="14631261" author="ram_krish" created="Fri, 17 Jul 2015 12:40:52 +0000"  >&lt;p&gt;Updated patch addressing comments from RB.&lt;/p&gt;</comment>
                            <comment id="14631437" author="hadoopqa" created="Fri, 17 Jul 2015 15:03:06 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12745808/HBASE-12295_16.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12745808/HBASE-12295_16.patch&lt;/a&gt;&lt;br/&gt;
  against master branch at commit 834f87b23de533783ba5f5b858327a6164f17f55.&lt;br/&gt;
  ATTACHMENT ID: 12745808&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 49 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop versions&lt;/font&gt;. The patch compiles with all supported hadoop versions (2.4.0 2.4.1 2.5.0 2.5.1 2.5.2 2.6.0 2.7.0)&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 protoc&lt;/font&gt;.  The applied patch does not increase the total number of protoc compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javadoc&lt;/font&gt;.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;                &lt;font color=&quot;red&quot;&gt;-1 checkstyle&lt;/font&gt;.  The applied patch generated 1873 checkstyle errors (more than the master&apos;s current 1871 errors).&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any  new Findbugs (version 2.0.3) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn post-site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;     &lt;font color=&quot;red&quot;&gt;-1 core tests&lt;/font&gt;.  The patch failed these unit tests:&lt;br/&gt;
                       org.apache.hadoop.hbase.regionserver.TestEndToEndSplitTransaction&lt;br/&gt;
                  org.apache.hadoop.hbase.regionserver.TestRegionReplicas&lt;br/&gt;
                  org.apache.hadoop.hbase.master.TestDistributedLogSplitting&lt;/p&gt;

&lt;p&gt;     &lt;font color=&quot;red&quot;&gt;-1 core zombie tests&lt;/font&gt;.  There are 4 zombie test(s): 	at org.apache.hadoop.hbase.client.TestBlockEvictionFromClient.testScanWithCompactionInternals(TestBlockEvictionFromClient.java:837)&lt;br/&gt;
	at org.apache.hadoop.hbase.client.TestBlockEvictionFromClient.testScanWithCompaction(TestBlockEvictionFromClient.java:799)&lt;br/&gt;
	at org.apache.hadoop.hbase.client.TestReplicasClient.testSmallScanWithReplicas(TestReplicasClient.java:606)&lt;br/&gt;
	at org.apache.hadoop.hbase.client.TestRestoreSnapshotFromClient.testRestoreSnapshot(TestRestoreSnapshotFromClient.java:162)&lt;br/&gt;
	at org.apache.hadoop.hbase.client.TestMetaWithReplicas.testMetaAddressChange(TestMetaWithReplicas.java:392)&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14816//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14816//testReport/&lt;/a&gt;&lt;br/&gt;
Release Findbugs (version 2.0.3) 	warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14816//artifact/patchprocess/newFindbugsWarnings.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14816//artifact/patchprocess/newFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Checkstyle Errors: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14816//artifact/patchprocess/checkstyle-aggregate.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14816//artifact/patchprocess/checkstyle-aggregate.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;                Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14816//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14816//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14631511" author="ram_krish" created="Fri, 17 Jul 2015 16:01:29 +0000"  >&lt;p&gt;Once again uploading correcting the checkstyle. The test case failure seems suspicious. But it is passing for me locally. Trying again.&lt;/p&gt;</comment>
                            <comment id="14631516" author="ram_krish" created="Fri, 17 Jul 2015 16:07:58 +0000"  >&lt;p&gt;TestRegionReplica is failing for me. Will correct that.&lt;/p&gt;</comment>
                            <comment id="14631565" author="ram_krish" created="Fri, 17 Jul 2015 16:45:40 +0000"  >&lt;p&gt;Updated patch. Test cases are passing now.  There are some mock scenarios where there will not be any RpcServerContext.&lt;/p&gt;</comment>
                            <comment id="14631568" author="ram_krish" created="Fri, 17 Jul 2015 16:48:43 +0000"  >&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Running org.apache.hadoop.hbase.client.TestBlockEvictionFromClient
Tests run: 11, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 59.38 sec - in org.apache.hadoop.hbase.client.TestBlockEvictionFromClient

Results :
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14631724" author="hadoopqa" created="Fri, 17 Jul 2015 18:42:22 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12745832/HBASE-12295_16.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12745832/HBASE-12295_16.patch&lt;/a&gt;&lt;br/&gt;
  against master branch at commit 834f87b23de533783ba5f5b858327a6164f17f55.&lt;br/&gt;
  ATTACHMENT ID: 12745832&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 49 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop versions&lt;/font&gt;. The patch compiles with all supported hadoop versions (2.4.0 2.4.1 2.5.0 2.5.1 2.5.2 2.6.0 2.7.0)&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 protoc&lt;/font&gt;.  The applied patch does not increase the total number of protoc compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javadoc&lt;/font&gt;.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 checkstyle&lt;/font&gt;.  The applied patch does not increase the total number of checkstyle errors&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any  new Findbugs (version 2.0.3) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn post-site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;     &lt;font color=&quot;red&quot;&gt;-1 core tests&lt;/font&gt;.  The patch failed these unit tests:&lt;br/&gt;
                       org.apache.hadoop.hbase.regionserver.TestRegionReplicas&lt;br/&gt;
                  org.apache.hadoop.hbase.regionserver.TestEndToEndSplitTransaction&lt;/p&gt;

&lt;p&gt;     &lt;font color=&quot;red&quot;&gt;-1 core zombie tests&lt;/font&gt;.  There are 1 zombie test(s): 	at org.apache.flume.channel.kafka.TestKafkaChannel.testSuccessInterleave(TestKafkaChannel.java:86)&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14817//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14817//testReport/&lt;/a&gt;&lt;br/&gt;
Release Findbugs (version 2.0.3) 	warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14817//artifact/patchprocess/newFindbugsWarnings.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14817//artifact/patchprocess/newFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Checkstyle Errors: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14817//artifact/patchprocess/checkstyle-aggregate.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14817//artifact/patchprocess/checkstyle-aggregate.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;  Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14817//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14817//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14631782" author="hadoopqa" created="Fri, 17 Jul 2015 19:30:10 +0000"  >&lt;p&gt;&lt;font color=&quot;green&quot;&gt;+1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12745836/HBASE-12295_17.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12745836/HBASE-12295_17.patch&lt;/a&gt;&lt;br/&gt;
  against master branch at commit 834f87b23de533783ba5f5b858327a6164f17f55.&lt;br/&gt;
  ATTACHMENT ID: 12745836&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 49 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop versions&lt;/font&gt;. The patch compiles with all supported hadoop versions (2.4.0 2.4.1 2.5.0 2.5.1 2.5.2 2.6.0 2.7.0)&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 protoc&lt;/font&gt;.  The applied patch does not increase the total number of protoc compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javadoc&lt;/font&gt;.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 checkstyle&lt;/font&gt;.  The applied patch does not increase the total number of checkstyle errors&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any  new Findbugs (version 2.0.3) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn post-site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 core tests&lt;/font&gt;.  The patch passed unit tests in .&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14818//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14818//testReport/&lt;/a&gt;&lt;br/&gt;
Release Findbugs (version 2.0.3) 	warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14818//artifact/patchprocess/newFindbugsWarnings.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14818//artifact/patchprocess/newFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Checkstyle Errors: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14818//artifact/patchprocess/checkstyle-aggregate.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14818//artifact/patchprocess/checkstyle-aggregate.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;  Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14818//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14818//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14631844" author="stack" created="Fri, 17 Jul 2015 20:24:14 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anoop.hbase&quot; class=&quot;user-hover&quot; rel=&quot;anoop.hbase&quot;&gt;Anoop Sam John&lt;/a&gt; Anything to cut down on the combinatorial explosion.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In read path we will deal with Cell type and we can add this to Cell interface.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Server-side only?&lt;/p&gt;

&lt;p&gt;&quot;May be we can avoid 2 impls one with out tags and one with. Have a state (boolean) in Cell impl. We have SizeCachedKeyValue abd SizeCachedNoTagsKeyValue now. May be we will only have SizeCachedKeyValue and it will have a boolean state whether it has tags or not. The getTagsLength() can check this state ad return 0 or decode tags length. We have extra 6 bytes per cell in this SizeCachedKeyValue now. Make it 7 is ok IMO&quot;&lt;/p&gt;

&lt;p&gt;Above seems fine though just one-byte we should profile; stuff might run better if padding &amp;#8211; TBD. More ideal would be the case where if no tags, then no cost but don&apos;t know how to do that.&lt;/p&gt;</comment>
                            <comment id="14633185" author="ram_krish" created="Mon, 20 Jul 2015 08:48:05 +0000"  >&lt;p&gt;Patch for QA.&lt;/p&gt;</comment>
                            <comment id="14634870" author="ram_krish" created="Tue, 21 Jul 2015 09:50:52 +0000"  >&lt;p&gt;Patch for QA. Addresses the final minor comments over in RB. &lt;/p&gt;</comment>
                            <comment id="14634917" author="anoop.hbase" created="Tue, 21 Jul 2015 10:21:27 +0000"  >&lt;p&gt;+1 for latest patch.&lt;/p&gt;</comment>
                            <comment id="14635031" author="hadoopqa" created="Tue, 21 Jul 2015 12:28:24 +0000"  >&lt;p&gt;&lt;font color=&quot;red&quot;&gt;-1 overall&lt;/font&gt;.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12746310/HBASE-12295_21.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12746310/HBASE-12295_21.patch&lt;/a&gt;&lt;br/&gt;
  against master branch at commit 3b6db2686380631027975c46b4a73478e299c82f.&lt;br/&gt;
  ATTACHMENT ID: 12746310&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 @author&lt;/font&gt;.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 tests included&lt;/font&gt;.  The patch appears to include 53 new or modified tests.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 hadoop versions&lt;/font&gt;. The patch compiles with all supported hadoop versions (2.4.0 2.4.1 2.5.0 2.5.1 2.5.2 2.6.0 2.7.0)&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javac&lt;/font&gt;.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 protoc&lt;/font&gt;.  The applied patch does not increase the total number of protoc compiler warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 javadoc&lt;/font&gt;.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;                &lt;font color=&quot;red&quot;&gt;-1 checkstyle&lt;/font&gt;.  The applied patch generated 1871 checkstyle errors (more than the master&apos;s current 1870 errors).&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 findbugs&lt;/font&gt;.  The patch does not introduce any  new Findbugs (version 2.0.3) warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 release audit&lt;/font&gt;.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    &lt;font color=&quot;green&quot;&gt;+1 lineLengths&lt;/font&gt;.  The patch does not introduce lines longer than 100&lt;/p&gt;

&lt;p&gt;  &lt;font color=&quot;green&quot;&gt;+1 site&lt;/font&gt;.  The mvn post-site goal succeeds with this patch.&lt;/p&gt;

&lt;p&gt;     &lt;font color=&quot;red&quot;&gt;-1 core tests&lt;/font&gt;.  The patch failed these unit tests:&lt;/p&gt;


&lt;p&gt;     &lt;font color=&quot;red&quot;&gt;-1 core zombie tests&lt;/font&gt;.  There are 1 zombie test(s): 	at org.jboss.arquillian.test.impl.context.SuiteContextImpl.activate(SuiteContextImpl.java:52)&lt;br/&gt;
	at org.jboss.arquillian.test.impl.TestContextHandler.createSuiteContext(TestContextHandler.java:72)&lt;br/&gt;
	at org.jboss.arquillian.test.impl.TestContextHandler.createTestContext(TestContextHandler.java:130)&lt;br/&gt;
	at org.jboss.arquillian.test.impl.EventTestRunnerAdaptor.test(EventTestRunnerAdaptor.java:136)&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14850//testReport/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14850//testReport/&lt;/a&gt;&lt;br/&gt;
Release Findbugs (version 2.0.3) 	warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14850//artifact/patchprocess/newFindbugsWarnings.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14850//artifact/patchprocess/newFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Checkstyle Errors: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14850//artifact/patchprocess/checkstyle-aggregate.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14850//artifact/patchprocess/checkstyle-aggregate.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;                Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-HBASE-Build/14850//console&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/PreCommit-HBASE-Build/14850//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14635291" author="ram_krish" created="Tue, 21 Jul 2015 15:49:16 +0000"  >&lt;p&gt;This is what I committed. There was one checkstyle comment due to unused import in CombinedBlockCache.  It is removed now.&lt;br/&gt;
Test failure seems unrelated. &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Failed to read test report file /home/jenkins/jenkins-slave/workspace/PreCommit-HBASE-Build/hbase-server/target/surefire-reports/TEST-org.apache.hadoop.hbase.master.TestDistributedLogSplitting.xml
org.dom4j.DocumentException: Error on line 85 of document file:&lt;span class=&quot;code-comment&quot;&gt;///home/jenkins/jenkins-slave/workspace/PreCommit-HBASE-Build/hbase-server/target/surefire-reports/TEST-org.apache.hadoop.hbase.master.TestDistributedLogSplitting.xml : XML document structures must start and end within the same entity. Nested exception: XML document structures must start and end within the same entity.
&lt;/span&gt;	at org.dom4j.io.SAXReader.read(SAXReader.java:482)
	at org.dom4j.io.SAXReader.read(SAXReader.java:264)
	at hudson.tasks.junit.SuiteResult.parse(SuiteResult.java:123)
	at hudson.tasks.junit.TestResult.parse(TestResult.java:273)
	at hudson.tasks.junit.TestResult.parsePossiblyEmpty(TestResult.java:229)
	at hudson.tasks.junit.TestResult.parse(TestResult.java:164)
	at hudson.tasks.junit.TestResult.parse(TestResult.java:147)
	at hudson.tasks.junit.TestResult.&amp;lt;init&amp;gt;(TestResult.java:123)
	at hudson.tasks.junit.JUnitParser$ParseResultCallable.invoke(JUnitParser.java:117)
	at hudson.tasks.junit.JUnitParser$ParseResultCallable.invoke(JUnitParser.java:90)
	at hudson.FilePath$FileCallableWrapper.call(FilePath.java:2474)
	at hudson.remoting.UserRequest.perform(UserRequest.java:118)
	at hudson.remoting.UserRequest.perform(UserRequest.java:
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This test failure happens in other builds also. Thanks for the excellent reviews, ideas and suggestions to Anoop and Stack.&lt;/p&gt;</comment>
                            <comment id="14635585" author="hudson" created="Tue, 21 Jul 2015 18:44:49 +0000"  >&lt;p&gt;FAILURE: Integrated in HBase-TRUNK #6669 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-TRUNK/6669/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-TRUNK/6669/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12295&quot; title=&quot;Prevent block eviction under us if reads are in progress from the BBs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12295&quot;&gt;&lt;del&gt;HBASE-12295&lt;/del&gt;&lt;/a&gt; Prevent block eviction under us if reads are in progress from (ramkrishna: rev ccb22bd80dfae64ff27f660254afb224dce268f0)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/bucket/TestByteBufferIOEngine.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestScannerHeartbeatMessages.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFile.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFileBlockIndex.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/CompoundBloomFilter.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHeapMemoryManager.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestBlockEvictionFromClient.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/MemcachedBlockCache.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/ReversedRegionScannerImpl.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/bucket/BucketCache.java&lt;/li&gt;
	&lt;li&gt;hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/BufferedDataBlockEncoder.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/bucket/IOEngine.java&lt;/li&gt;
	&lt;li&gt;hbase-common/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileContextBuilder.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreFile.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestCacheConfig.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/bucket/ByteBufferIOEngine.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/CombinedBlockCache.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/CacheTestUtils.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/HBaseTestingUtility.java&lt;/li&gt;
	&lt;li&gt;hbase-common/src/main/java/org/apache/hadoop/hbase/ShareableMemory.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlock.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileBlockIndex.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestLruBlockCache.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/BlockCache.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFile.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/CacheableDeserializer.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestCacheOnWrite.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/StoreScanner.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestCachedBlockQueue.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/KeyValueHeap.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/Cacheable.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/LruBlockCache.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/TestHFileBlock.java&lt;/li&gt;
	&lt;li&gt;hbase-common/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileContext.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/io/hfile/bucket/TestFileIOEngine.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/bucket/FileIOEngine.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14636226" author="ram_krish" created="Wed, 22 Jul 2015 04:55:44 +0000"  >&lt;p&gt;The test TestIOFencing runs fine&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
 T E S T S
-------------------------------------------------------
Running org.apache.hadoop.hbase.TestIOFencing
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 186.111 sec - in org.apache.hadoop.hbase.TestIOFencing

Results :
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I tried on the latest code and it runs fine. Also the same patch when ran in QA bot it passed. So i think it is flakey and nothing specific to this commit.&lt;/p&gt;</comment>
                            <comment id="14638345" author="ram_krish" created="Thu, 23 Jul 2015 07:05:28 +0000"  >&lt;p&gt;A critical addendum that would be needed for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12295&quot; title=&quot;Prevent block eviction under us if reads are in progress from the BBs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12295&quot;&gt;&lt;del&gt;HBASE-12295&lt;/del&gt;&lt;/a&gt; to work with multiGets. While testing with random multiGets found that the place we are creating the callBack was like we were overriding the initially created callbacks and because of that the scanners that were created for the older regions were not getting closed.  This addendum fixes that issue. It is now tested and there are no issues with it.&lt;/p&gt;</comment>
                            <comment id="14638493" author="anoop.hbase" created="Thu, 23 Jul 2015 08:44:44 +0000"  >&lt;p&gt;+1&lt;/p&gt;</comment>
                            <comment id="14638514" author="ram_krish" created="Thu, 23 Jul 2015 09:02:44 +0000"  >&lt;p&gt;Committed. Thanks for the review Anoop.&lt;/p&gt;</comment>
                            <comment id="14638713" author="hudson" created="Thu, 23 Jul 2015 12:07:58 +0000"  >&lt;p&gt;FAILURE: Integrated in HBase-TRUNK #6675 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-TRUNK/6675/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-TRUNK/6675/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12295&quot; title=&quot;Prevent block eviction under us if reads are in progress from the BBs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12295&quot;&gt;&lt;del&gt;HBASE-12295&lt;/del&gt;&lt;/a&gt; - Addendum for multiGets to add the call back(Ram) (ramkrishna: rev 4ec69ccf3ae8701727299179ac6b5002bbd72c55)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14641958" author="ashish singhi" created="Sun, 26 Jul 2015 12:59:29 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ram_krish&quot; class=&quot;user-hover&quot; rel=&quot;ram_krish&quot;&gt;ramkrishna.s.vasudevan&lt;/a&gt;, this seems to have broke org.apache.hadoop.hbase.coprocessor.TestOpenTableInCoprocessor, do you want to take a look ?&lt;/p&gt;</comment>
                            <comment id="14642014" author="anoop.hbase" created="Sun, 26 Jul 2015 16:26:03 +0000"  >&lt;p&gt;Yes Ashish. Thanks for digging in. Fix available in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-14156&quot; title=&quot;Fix test failure in TestOpenTableInCoprocessor&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-14156&quot;&gt;&lt;del&gt;HBASE-14156&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                                                <inwardlinks description="is blocked by">
                                        <issuelink>
            <issuekey id="12838485">HBASE-13926</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12735876" name="HBASE-12295.pdf" size="83239" author="ram_krish" created="Thu, 28 May 2015 14:35:25 +0000"/>
                            <attachment id="12737459" name="HBASE-12295_1.patch" size="233834" author="ram_krish" created="Thu, 4 Jun 2015 04:54:34 +0000"/>
                            <attachment id="12737458" name="HBASE-12295_1.pdf" size="83572" author="ram_krish" created="Thu, 4 Jun 2015 04:54:34 +0000"/>
                            <attachment id="12743926" name="HBASE-12295_10.patch" size="175581" author="ram_krish" created="Tue, 7 Jul 2015 10:03:38 +0000"/>
                            <attachment id="12745012" name="HBASE-12295_12.patch" size="178456" author="ram_krish" created="Mon, 13 Jul 2015 09:56:52 +0000"/>
                            <attachment id="12745431" name="HBASE-12295_14.patch" size="180497" author="ram_krish" created="Wed, 15 Jul 2015 11:53:25 +0000"/>
                            <attachment id="12745608" name="HBASE-12295_15.patch" size="185247" author="ram_krish" created="Thu, 16 Jul 2015 11:34:02 +0000"/>
                            <attachment id="12745832" name="HBASE-12295_16.patch" size="184729" author="ram_krish" created="Fri, 17 Jul 2015 16:01:29 +0000"/>
                            <attachment id="12745808" name="HBASE-12295_16.patch" size="184126" author="ram_krish" created="Fri, 17 Jul 2015 12:40:52 +0000"/>
                            <attachment id="12745836" name="HBASE-12295_17.patch" size="184872" author="ram_krish" created="Fri, 17 Jul 2015 16:45:40 +0000"/>
                            <attachment id="12746057" name="HBASE-12295_18.patch" size="184807" author="ram_krish" created="Mon, 20 Jul 2015 08:48:05 +0000"/>
                            <attachment id="12737486" name="HBASE-12295_2.patch" size="237515" author="ram_krish" created="Thu, 4 Jun 2015 06:55:52 +0000"/>
                            <attachment id="12746310" name="HBASE-12295_21.patch" size="185137" author="ram_krish" created="Tue, 21 Jul 2015 09:50:52 +0000"/>
                            <attachment id="12738580" name="HBASE-12295_4.patch" size="217833" author="ram_krish" created="Tue, 9 Jun 2015 12:49:06 +0000"/>
                            <attachment id="12739865" name="HBASE-12295_4.pdf" size="87973" author="ram_krish" created="Tue, 16 Jun 2015 13:44:22 +0000"/>
                            <attachment id="12740100" name="HBASE-12295_5.pdf" size="85252" author="ram_krish" created="Wed, 17 Jun 2015 12:31:33 +0000"/>
                            <attachment id="12741247" name="HBASE-12295_9.patch" size="184885" author="ram_krish" created="Tue, 23 Jun 2015 08:21:34 +0000"/>
                            <attachment id="12746732" name="HBASE-12295_addendum.patch" size="4168" author="ram_krish" created="Thu, 23 Jul 2015 07:05:28 +0000"/>
                            <attachment id="12746370" name="HBASE-12295_final.patch" size="184979" author="ram_krish" created="Tue, 21 Jul 2015 15:49:16 +0000"/>
                            <attachment id="12724289" name="HBASE-12295_trunk.patch" size="65815" author="ram_krish" created="Thu, 9 Apr 2015 18:28:27 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>20.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 9 Feb 2015 07:18:23 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310191" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Hadoop Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10343"><![CDATA[Reviewed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            1 year, 20 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i21c9b:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310192" key="com.atlassian.jira.plugin.system.customfieldtypes:textarea">
                        <customfieldname>Release Note</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>We try to delay the eviction of the block till the cellblocks are formed at the Rpc layer. A simple reference counting mechanism is introduced when ever a block is accessed from the Bucket cache.  Once a scanner completes using a block the reference count is decremented.  The eviction of the block happens only when the reference count of that block is 0.&lt;br/&gt;
We also introduce a concept of ShareableMemory based on the type of blocks we create from the Block cache. The blocks from the ByteBufferIOEngine directly refer to the buckets in offheap and such blocks are marked SHARED memory type. The blocks from LRU, HDFS and file mode of Bucket cache are all marked EXCLUSIVE because these blocks have their own exclusive memory.&lt;br/&gt;
For the CP case, any cell coming out of SHARED memory block is copied before returning the results, because CPs can use the results as its state so that eviction cannot corrupt the results.</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>