<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:28:07 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-5479/HBASE-5479.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-5479] Postpone CompactionSelection to compaction execution time</title>
                <link>https://issues.apache.org/jira/browse/HBASE-5479</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;It can be commonplace for regionservers to develop long compaction queues, meaning a CompactionRequest may execute hours after it was created.  The CompactionRequest holds a CompactionSelection that was selected at request time but may no longer be the optimal selection.  The CompactionSelection should be created at compaction execution time rather than compaction request time.&lt;/p&gt;

&lt;p&gt;The current mechanism breaks down during high volume insertion.  The inefficiency is clearest when the inserts are finished.  Inserting for 5 hours may build up 50 storefiles and a 40 element compaction queue.  When finished inserting, you would prefer that the next compaction merges all 50 files (or some large subset), but the current system will churn through each of the 40 compaction requests, the first of which may be hours old.  This ends up re-compacting the same data many times.  &lt;/p&gt;

&lt;p&gt;The current system is especially inefficient when dealing with time series data where the data in the storefiles has minimal overlap.  With time series data, there is even less benefit to intermediate merges because most storefiles can be eliminated based on their key range during a read, even without bloomfilters.  The only goal should be to reduce file count, not to minimize number of files merged for each read.&lt;/p&gt;

&lt;p&gt;There are other aspects to the current queuing mechanism that would need to be looked at.  You would want to avoid having the same Store in the queue multiple times.  And you would want the completion of one compaction to possibly queue another compaction request for the store.&lt;/p&gt;

&lt;p&gt;A alternative architecture to the current style of queues would be to have each Store (all open in memory) keep a compactionPriority score up to date after events like flushes, compactions, schema changes, etc.  Then you create a &quot;CompactionPriorityComparator implements Comparator&amp;lt;Store&amp;gt;&quot; and stick all the Stores into a PriorityQueue (synchronized remove/add from the queue when the value changes).  The async compaction threads would keep pulling off the head of that queue as long as the head has compactionPriority &amp;gt; X.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12544149">HBASE-5479</key>
            <summary>Postpone CompactionSelection to compaction execution time</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="10">Implemented</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="mcorgan">Matt Corgan</reporter>
                        <labels>
                    </labels>
                <created>Sun, 26 Feb 2012 00:50:11 +0000</created>
                <updated>Tue, 9 Jul 2013 22:04:05 +0000</updated>
                            <resolved>Tue, 9 Jul 2013 22:04:05 +0000</resolved>
                                                                    <component>io</component>
                    <component>Performance</component>
                    <component>regionserver</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>16</watches>
                                                                <comments>
                            <comment id="13216608" author="stack" created="Sun, 26 Feb 2012 01:32:37 +0000"  >&lt;p&gt;Todd suggests something like a scoring over here Matt: &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2457?focusedCommentId=12857705&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12857705&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-2457?focusedCommentId=12857705&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12857705&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Lets verify that we do indeed do selection at queuing time.  Thats my suspicion.  If thats the case, for sure needs fixing.  Thanks for filing this one Matt.&lt;/p&gt;</comment>
                            <comment id="13216639" author="zhihyu@ebaysf.com" created="Sun, 26 Feb 2012 05:45:55 +0000"  >&lt;p&gt;I think compactionPriority score needs to be designed in such a way, when multiple column families are involved, that no single column family would exclusively come off the head of PriorityQueue for extended period of time.&lt;/p&gt;</comment>
                            <comment id="13217352" author="nspiegelberg" created="Mon, 27 Feb 2012 18:25:38 +0000"  >&lt;p&gt;A couple things here:&lt;/p&gt;

&lt;p&gt;1. If you are enqueuing compactions that quickly, you either have a problem where you need to do a bulk import MR (vs Put-based) or you have your compaction algorithm tuned incorrectly.  Considering that you have TS data, it strongly suggests the latter.  Read this thread: &lt;a href=&quot;http://search-hadoop.com/m/GHUWQ1xnbj21&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://search-hadoop.com/m/GHUWQ1xnbj21&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Basically, you probably want to switch your compaction ratio to 0.125 and play with it from there.&lt;/p&gt;

&lt;p&gt;2. &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5334&quot; title=&quot;Pluggable Compaction Algorithms&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5334&quot;&gt;&lt;del&gt;HBASE-5334&lt;/del&gt;&lt;/a&gt; is really what we need.  A framework to write other compaction algorithms.  Really, TS data needs its own algorithm because it&apos;s disjoint data you want to scan over a deterministic timerange.&lt;/p&gt;

&lt;p&gt;3. It would be nice to have a feedback loop like Todd suggests in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2457&quot; title=&quot;RS gets stuck compacting region ad infinitum&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2457&quot;&gt;&lt;del&gt;HBASE-2457&lt;/del&gt;&lt;/a&gt;.  Right now, you have to calculate the (1+WF) constant yourself.&lt;/p&gt;

&lt;p&gt;4.  You are correct that we&apos;re pinning the storefiles at selection versus compaction time.  This is standard in all LSMT systems because you need static state for prioritization, so it does not need to change.&lt;/p&gt;</comment>
                            <comment id="13217358" author="nspiegelberg" created="Mon, 27 Feb 2012 18:31:57 +0000"  >&lt;p&gt;@Ted: right now, compaction priority is based upon congestion, so you want a single CF to get the top queue entries if it&apos;s the only one congested.  the real problem is that we need to calculate the IO overhead for not compacting files and prioritize the queue so that compaction to provide the maximum IO savings is done first.  That related to Todd&apos;s comment in point #3.  That said, we need to write the scaffolding so it&apos;s easy for us to calculate IO per file and average per-file seek redundancy.  This is a very complicated problem, not a trivial feature, so manual tuning right now is the best strategy until someone wants to dedicate enough time &amp;amp; resources to conquer that problem.&lt;/p&gt;</comment>
                            <comment id="13217410" author="mcorgan" created="Mon, 27 Feb 2012 19:16:52 +0000"  >&lt;blockquote&gt;&lt;p&gt;you need to do a bulk import MR (vs Put-based) or you have your compaction algorithm tuned incorrectly... you probably want to switch your compaction ratio to 0.125 and play with it from there&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;yeah, just using it as an opportunity to push HBase with real data to see what breaks first.  i hesitate to change the global compaction ratio when it&apos;s just a couple out of ~20 tables&lt;/p&gt;

&lt;p&gt;Agree pluggable compaction strategies would be great, as would many other per-CF settings.  Making them pluggable would be far more useful than perfecting a general algorithm.&lt;/p&gt;

&lt;p&gt;Is there a quick fix that could deal with outdated requests?  Like ignoring a CompactionRequest if the files in its CompactionSelection are not all there.  Or when pulling a CompactionRequest from the head of the queue, iterate the entire queue to check if there&apos;s a newer CompactionRequest for the same Store.&lt;/p&gt;</comment>
                            <comment id="13217456" author="nspiegelberg" created="Mon, 27 Feb 2012 19:47:25 +0000"  >&lt;p&gt;@Matt: Also see &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-5335&quot; title=&quot;Dynamic Schema Configurations&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-5335&quot;&gt;&lt;del&gt;HBASE-5335&lt;/del&gt;&lt;/a&gt;, which will allow you to change the compaction ratio on a per-cf basis for multi-flow clusters.  I am currently working on that JIRA, so I suggest you watch it.  &lt;/p&gt;

&lt;p&gt;i.r.t. outdated requests.  The fact that you have outdated requests should mean an HBase bug, not design.  A compaction request should lock all the StoreFiles in question.  These storefiles should only be removed by the compaction &amp;amp; compaction requests should be disjoint.  Any break of this contract is a bug &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/tongue.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.  Did this arise because of splitting?&lt;/p&gt;</comment>
                            <comment id="13217550" author="mcorgan" created="Mon, 27 Feb 2012 20:57:35 +0000"  >&lt;p&gt;re, outdated requests: i now see that in Store.requestCompaction, you are eliminating already queued files from consideration, so requested files will never have disappeared between when a compaction is requested vs executed.&lt;/p&gt;

&lt;p&gt;Let me take another stab at explaining the problem.  Say you have hbase.hstore.compactionThreshold=3, hbase.hstore.compaction.max=20.  You are flushing a particular memstore every minute and compactions are backed up by an hour for whatever reason.  After 3 minutes of inserting, the CompactSplitThread will create a CompactionRequest for the first 3 StoreFiles.  During the next hour, while that first CompactionRequest is sitting in the queue, 60 new StoreFiles were added, and 20 additional CompactionRequests were queued.&lt;/p&gt;

&lt;p&gt;Finally, the first CompactionRequest makes it to the head of the queue and is ready to be executed.  At this point, there are 63 small StoreFiles in the Store.  While this original CompactionRequest was correct at the time it was created, I would now prefer that it compacted the first 20 files, not just the first 3.&lt;/p&gt;

&lt;p&gt;Maybe it could abort a CompactionRequest if there are already items in Store.filesCompacting.&lt;/p&gt;</comment>
                            <comment id="13217572" author="nspiegelberg" created="Mon, 27 Feb 2012 21:19:44 +0000"  >&lt;p&gt;I think that adding mutability to compaction enqueuing is a little bit of an advanced topic that really masks the true problem of wrong compaction settings.  The most important thing is to ensure that we eventually get down to 1 file over time instead of minimizing IO for a bad configuration that more-dramatically inflates IO.&lt;/p&gt;</comment>
                            <comment id="13217655" author="mcorgan" created="Mon, 27 Feb 2012 22:46:56 +0000"  >&lt;p&gt;Rather than postponing file selection till execution time, what do you think about halting new CompactionsRequests for a Store if there is already one in the queue?  That would allow files to build up in bigger batches.&lt;/p&gt;

&lt;p&gt;Seems rare that the hbase.hstore.compaction.max variable will come into play under the current system.&lt;/p&gt;</comment>
                            <comment id="13246405" author="kturner" created="Wed, 4 Apr 2012 16:06:59 +0000"  >&lt;p&gt;Accumulo does something similar to what this ticket describes.  It has a priority queue of tablets/regions that need to be major compacted. There is a thread that scans all tablets every 30 seconds to see if a compaction is needed and if so throws it on the queue.  Should probably check after flush and bulk import.  I do not think multiple entries are placed on the queue.  When something is pulled of of the queue it decides then which files to compact.   &lt;/p&gt;

&lt;p&gt;The priority queue is sorted on compaction type and then number of files per tablet.  User requested compactions come first, then chops (special compaction for merging tablets), then system initiated compactions, then idle compactions.   Among the same type of compaction, it will take the tablet/region with the most files.  To find the tablet/region with the most files it does a linear scan of all of the tablets in the queue.  I do not like the linear scan, but I am not sure of a better way to do this since the number of files could change while something is in the queue.  Once we started taking the tablet w/ the most files it really helped overall query performance by keeping the avg files per tablet and std dev as low as possible. &lt;/p&gt;

&lt;p&gt;One other wrinkle is that Accumulo will only compact up to 10 files at a time (configurable).  If a tablet has 30 files, it will compact the smallest 10 files and throw the tablet back on the major compaction queue.  From a tablet/region server perspective this also helps keep the number of total files in the server down.  We used to do compaction depth first, where the tablet with 30 files would be compacted to one file.  However this could take a long time and a lot of compaction work could back up.  Doing compactions breadth first and taking the tablet with the most files has really helped keep the number of files manageable under continuous ingest.  Our continuous ingest test tracks statistics (min, max, avg, std dev) on files per tablet over time and we plot this info using gnuplot at the end of test.  Doing this type of test and looking at the data helped us formulate our current strategy.  I would encourage starting with test.&lt;/p&gt;</comment>
                            <comment id="13246443" author="kturner" created="Wed, 4 Apr 2012 16:35:32 +0000"  >&lt;p&gt;There is exception to what I said above.  User requested compaction are still done depth first with an optimization.  If a user request a tablet with 30 files compact, it will allocate a compaction thread to compact that tablet to one file.  It still only does up to 10 files at time though.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;compact 10 smallest, results in 21 files&lt;/li&gt;
	&lt;li&gt;compact 10 smallest, results in 12 files&lt;/li&gt;
	&lt;li&gt;compact 3 smallest, results in 10 files  &amp;lt;--this is the optimization to avoid redundant work&lt;/li&gt;
	&lt;li&gt;compact 10 smallest, results in 1 file&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13411799" author="mikhail" created="Wed, 11 Jul 2012 18:12:04 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-6361&quot; title=&quot;Change the compaction queue to a round robin scheduler&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-6361&quot;&gt;&lt;del&gt;HBASE-6361&lt;/del&gt;&lt;/a&gt; (closed as duplicate) has additional relevant discussion and ideas.&lt;/p&gt;</comment>
                            <comment id="13703872" author="sershe" created="Tue, 9 Jul 2013 22:04:05 +0000"  >&lt;p&gt;For system compactions, this was done as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8665&quot; title=&quot;bad compaction priority behavior in queue can cause store to be blocked&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8665&quot;&gt;&lt;del&gt;HBASE-8665&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12541160">HBASE-5334</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12598117">HBASE-6361</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12629240">HBASE-7672</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sun, 26 Feb 2012 01:32:37 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>229386</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            3 years, 23 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0hti7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>102042</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>