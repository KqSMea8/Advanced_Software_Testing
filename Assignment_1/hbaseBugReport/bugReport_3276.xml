<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 19:08:52 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-3276/HBASE-3276.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-3276] delete followed by a put with the same timestamp</title>
                <link>https://issues.apache.org/jira/browse/HBASE-3276</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;Note: This issue is relevant only for cases that don&amp;#39;t use the default &amp;quot;time&amp;quot; based versions, but provide/manage versions explicitly.&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;The fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1485&quot; title=&quot;Wrong or indeterminate behavior when there are duplicate versions of a column&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1485&quot;&gt;&lt;del&gt;HBASE-1485&lt;/del&gt;&lt;/a&gt; ensures that if there are multiple puts with the same timestamp the later one wins.&lt;/p&gt;

&lt;p&gt;However, if there is a delete for a specific timestamp, then the later put doesn&apos;t win. &lt;/p&gt;

&lt;p&gt;Say for example the following is the sequence of operations:&lt;/p&gt;

&lt;p&gt;put                         row/col/v1 - value1&lt;br/&gt;
deleteColumn     row/col/v1&lt;br/&gt;
put                         row/col/v1 - value2&lt;/p&gt;

&lt;p&gt;Without the deleteColumn(), &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1485&quot; title=&quot;Wrong or indeterminate behavior when there are duplicate versions of a column&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1485&quot;&gt;&lt;del&gt;HBASE-1485&lt;/del&gt;&lt;/a&gt; ensures that &quot;value2&quot; is the winner.&lt;/p&gt;

&lt;p&gt;However, with the deleteColumn() thrown into the mix, the delete wins, and one cannot insert a new value at that version. &lt;span class=&quot;error&quot;&gt;&amp;#91;The only, unsatisfactory, workaround at this point seems to be trigger a major compaction. The major compact would clear the delete marker, and allow new cells to be created with that version again.&amp;#93;&lt;/span&gt; &lt;/p&gt;

&lt;p&gt;&amp;#8212;&lt;/p&gt;

&lt;p&gt;Seems like it might not be too complicated to extend the fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1485&quot; title=&quot;Wrong or indeterminate behavior when there are duplicate versions of a column&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1485&quot;&gt;&lt;del&gt;HBASE-1485&lt;/del&gt;&lt;/a&gt; to also respect ordering between delete/put operations. I&apos;ll look into this further.&lt;/p&gt;





</description>
                <environment></environment>
        <key id="12480853">HBASE-3276</key>
            <summary>delete followed by a put with the same timestamp</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="3">Duplicate</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="kannanm">Kannan Muthukkaruppan</reporter>
                        <labels>
                    </labels>
                <created>Wed, 24 Nov 2010 19:45:02 +0000</created>
                <updated>Sat, 19 Jul 2014 00:31:22 +0000</updated>
                            <resolved>Sat, 19 Jul 2014 00:31:22 +0000</resolved>
                                                                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                <comments>
                            <comment id="12935604" author="kannanm" created="Thu, 25 Nov 2010 01:09:59 +0000"  >&lt;p&gt;I wrote: &amp;lt;&amp;lt;&amp;lt; &lt;span class=&quot;error&quot;&gt;&amp;#91;Note: This issue is relevant only for cases that don&amp;#39;t use the default &amp;quot;time&amp;quot; based versions, but provide/manage versions explicitly.&amp;#93;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;On second thoughts, this should also help cases where a delete followed by a put arrives within the same millisec.&lt;/p&gt;


</comment>
                            <comment id="12935917" author="pranavkhaitan" created="Fri, 26 Nov 2010 00:42:00 +0000"  >&lt;p&gt;Kannan, this is easy. I can take care of this.&lt;/p&gt;</comment>
                            <comment id="12936040" author="hbasereviewboard" created="Fri, 26 Nov 2010 15:49:15 +0000"  >&lt;p&gt;Message from: &quot;Pranav Khaitan&quot; &amp;lt;pranavkhaitan@gmail.com&amp;gt;&lt;/p&gt;

&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;http://review.cloudera.org/r/1252/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://review.cloudera.org/r/1252/&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;

&lt;p&gt;Review request for hbase, Jonathan Gray and Kannan Muthukkaruppan.&lt;/p&gt;


&lt;p&gt;Summary&lt;br/&gt;
-------&lt;/p&gt;

&lt;p&gt;This is a design change suggested in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3276&quot; title=&quot;delete followed by a put with the same timestamp&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3276&quot;&gt;&lt;del&gt;HBASE-3276&lt;/del&gt;&lt;/a&gt; so adequate thought should be given before proceeding. &lt;/p&gt;

&lt;p&gt;The main code change is just one line which is to ignore key type while doing KV comparisons. When the key type is ignored, then all the keys for the same timestamp are sorted according the order in which they were interested. It is still ensured that the delete family and delete column will be at the top because they have the default column name and default timestamp.&lt;/p&gt;


&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3276&quot; title=&quot;delete followed by a put with the same timestamp&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3276&quot;&gt;&lt;del&gt;HBASE-3276&lt;/del&gt;&lt;/a&gt;.&lt;br/&gt;
    &lt;a href=&quot;http://issues.apache.org/jira/browse/HBASE-3276&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/HBASE-3276&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;Diffs&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;  trunk/src/main/java/org/apache/hadoop/hbase/KeyValue.java 1039233 &lt;br/&gt;
  trunk/src/test/java/org/apache/hadoop/hbase/regionserver/KeyValueScanFixture.java 1039233 &lt;br/&gt;
  trunk/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreScanner.java 1039233 &lt;/p&gt;

&lt;p&gt;Diff: &lt;a href=&quot;http://review.cloudera.org/r/1252/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://review.cloudera.org/r/1252/diff&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;Testing&lt;br/&gt;
-------&lt;/p&gt;

&lt;p&gt;Test cases added. Since there is a change in semantics, some previous tests were failing because of this change. Those tests have been modified to test the newer behavior.&lt;/p&gt;


&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Pranav&lt;/p&gt;

</comment>
                            <comment id="12936119" author="hbasereviewboard" created="Fri, 26 Nov 2010 22:56:15 +0000"  >&lt;p&gt;Message from: &quot;Ryan Rawson&quot; &amp;lt;ryanobjc@gmail.com&amp;gt;&lt;/p&gt;

&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;http://review.cloudera.org/r/1252/#review1993&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://review.cloudera.org/r/1252/#review1993&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;



&lt;p&gt;trunk/src/main/java/org/apache/hadoop/hbase/KeyValue.java&lt;br/&gt;
&amp;lt;&lt;a href=&quot;http://review.cloudera.org/r/1252/#comment6297&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://review.cloudera.org/r/1252/#comment6297&lt;/a&gt;&amp;gt;&lt;/p&gt;

&lt;p&gt;    what are all the consequences for not sorting by type when using KVComparator?  Does this mean we might create HFiles that not sorted properly, because the HFile comparator uses the KeyComparator directly with ignoreType = false. &lt;/p&gt;

&lt;p&gt;    While in memstore we can rely on memstoreTS to roughly order by insertion time, and the Put/Delete should probably work in that situation, you are talking about modifiying a pretty core and important concept in how we sort things.&lt;/p&gt;

&lt;p&gt;    There are other ways to reconcile bugs like this, one of them is to extend the memstoreTS concept into the HFile and use that to reconcile during reads.  There is another JIRA where I proposed this.  &lt;/p&gt;

&lt;p&gt;    If we are talking about 0.92 and beyond I&apos;d prefer building a solid base rather than dangerous hacks like this.  Our unit tests are not extremely extensive, so while they might pass, that doesnt guarantee lack of bad behaviour later on.&lt;/p&gt;



&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Ryan&lt;/li&gt;
&lt;/ul&gt;



</comment>
                            <comment id="12936123" author="hbasereviewboard" created="Fri, 26 Nov 2010 23:15:15 +0000"  >&lt;p&gt;Message from: &quot;Pranav Khaitan&quot; &amp;lt;pranavkhaitan@gmail.com&amp;gt;&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2010-11-26 14:54:45, Ryan Rawson wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; trunk/src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 1373&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;http://review.cloudera.org/r/1252/diff/1/?file=17712#file17712line1373&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://review.cloudera.org/r/1252/diff/1/?file=17712#file17712line1373&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     what are all the consequences for not sorting by type when using KVComparator?  Does this mean we might create HFiles that not sorted properly, because the HFile comparator uses the KeyComparator directly with ignoreType = false. &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     While in memstore we can rely on memstoreTS to roughly order by insertion time, and the Put/Delete should probably work in that situation, you are talking about modifiying a pretty core and important concept in how we sort things.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     There are other ways to reconcile bugs like this, one of them is to extend the memstoreTS concept into the HFile and use that to reconcile during reads.  There is another JIRA where I proposed this.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     If we are talking about 0.92 and beyond I&apos;d prefer building a solid base rather than dangerous hacks like this.  Our unit tests are not extremely extensive, so while they might pass, that doesnt guarantee lack of bad behaviour later on.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agree. As I mentioned, this is a major change and more thought needs to be given to it.&lt;/p&gt;

&lt;p&gt;However, to resolve issues like &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3276&quot; title=&quot;delete followed by a put with the same timestamp&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3276&quot;&gt;&lt;del&gt;HBASE-3276&lt;/del&gt;&lt;/a&gt;, we need either such a change or extend the memstoreTS concept to HFile as you mentioned.&lt;/p&gt;

&lt;p&gt;About consequences, I don&apos;t see anything negative here. This change only affects the sorting of keys having same row, col, timestamp. After this change, all keys with the same row, col, ts will be sorted purely based on the order in which they were inserted. When a memstore is flushed to HFile, the memstoreTS takes care of ordering. During compactions, the KeyValueHeap breaks ties by using the sequence ids of storefiles. &lt;/p&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Pranav&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;http://review.cloudera.org/r/1252/#review1993&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://review.cloudera.org/r/1252/#review1993&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;


</comment>
                            <comment id="12936128" author="hbasereviewboard" created="Fri, 26 Nov 2010 23:35:13 +0000"  >&lt;p&gt;Message from: &quot;Ryan Rawson&quot; &amp;lt;ryanobjc@gmail.com&amp;gt;&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2010-11-26 14:54:45, Ryan Rawson wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; trunk/src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 1373&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;http://review.cloudera.org/r/1252/diff/1/?file=17712#file17712line1373&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://review.cloudera.org/r/1252/diff/1/?file=17712#file17712line1373&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     what are all the consequences for not sorting by type when using KVComparator?  Does this mean we might create HFiles that not sorted properly, because the HFile comparator uses the KeyComparator directly with ignoreType = false. &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     While in memstore we can rely on memstoreTS to roughly order by insertion time, and the Put/Delete should probably work in that situation, you are talking about modifiying a pretty core and important concept in how we sort things.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     There are other ways to reconcile bugs like this, one of them is to extend the memstoreTS concept into the HFile and use that to reconcile during reads.  There is another JIRA where I proposed this.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     If we are talking about 0.92 and beyond I&apos;d prefer building a solid base rather than dangerous hacks like this.  Our unit tests are not extremely extensive, so while they might pass, that doesnt guarantee lack of bad behaviour later on.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Pranav Khaitan wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Agree. As I mentioned, this is a major change and more thought needs to be given to it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;However, to resolve issues like &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3276&quot; title=&quot;delete followed by a put with the same timestamp&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3276&quot;&gt;&lt;del&gt;HBASE-3276&lt;/del&gt;&lt;/a&gt;, we need either such a change or extend the memstoreTS concept to HFile as you mentioned.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;About consequences, I don&apos;t see anything negative here. This change only affects the sorting of keys having same row, col, timestamp. After this change, all keys with the same row, col, ts will be sorted purely based on the order in which they were inserted. When a memstore is flushed to HFile, the memstoreTS takes care of ordering. During compactions, the KeyValueHeap breaks ties by using the sequence ids of storefiles.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;the problem is you are now changing how things are ordered sometimes but not all the time.  HFile directly uses the rawcomparator, instantiating it directly rather than getting it via the code path you changed.  So now you create a memstore in this order:&lt;/p&gt;

&lt;p&gt;row,col,100,Put  (memstoreTS=1)&lt;br/&gt;
row,col,100,Delete (memstoreTS=2)&lt;br/&gt;
row,col,100,Put (memstoreTS=3)&lt;/p&gt;

&lt;p&gt;But the HFile comparator will consider this out of order since it doesnt know about memstoreTS and it still expects things to be in a certain order.&lt;/p&gt;

&lt;p&gt;I&apos;m a little wary of having implicit ordering in the HFiles... in your new scheme, Put,Delete,Put are in that order &apos;just because they are&apos;, and the comparator cannot put them back in order, and must rely on scanner order.  During compactions we would place keys in order based on which files they came from, but they wouldn&apos;t themselves have an order.  Basically we should get rid of &apos;type sorting&apos; and use memstoreTS sorting in memory and implicit sorting in the HFiles.  &lt;/p&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Ryan&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;http://review.cloudera.org/r/1252/#review1993&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://review.cloudera.org/r/1252/#review1993&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;


</comment>
                            <comment id="12936131" author="hbasereviewboard" created="Fri, 26 Nov 2010 23:51:13 +0000"  >&lt;p&gt;Message from: &quot;Pranav Khaitan&quot; &amp;lt;pranavkhaitan@gmail.com&amp;gt;&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2010-11-26 14:54:45, Ryan Rawson wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; trunk/src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 1373&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;http://review.cloudera.org/r/1252/diff/1/?file=17712#file17712line1373&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://review.cloudera.org/r/1252/diff/1/?file=17712#file17712line1373&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     what are all the consequences for not sorting by type when using KVComparator?  Does this mean we might create HFiles that not sorted properly, because the HFile comparator uses the KeyComparator directly with ignoreType = false. &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     While in memstore we can rely on memstoreTS to roughly order by insertion time, and the Put/Delete should probably work in that situation, you are talking about modifiying a pretty core and important concept in how we sort things.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     There are other ways to reconcile bugs like this, one of them is to extend the memstoreTS concept into the HFile and use that to reconcile during reads.  There is another JIRA where I proposed this.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     If we are talking about 0.92 and beyond I&apos;d prefer building a solid base rather than dangerous hacks like this.  Our unit tests are not extremely extensive, so while they might pass, that doesnt guarantee lack of bad behaviour later on.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Pranav Khaitan wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Agree. As I mentioned, this is a major change and more thought needs to be given to it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;However, to resolve issues like &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3276&quot; title=&quot;delete followed by a put with the same timestamp&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3276&quot;&gt;&lt;del&gt;HBASE-3276&lt;/del&gt;&lt;/a&gt;, we need either such a change or extend the memstoreTS concept to HFile as you mentioned.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;About consequences, I don&apos;t see anything negative here. This change only affects the sorting of keys having same row, col, timestamp. After this change, all keys with the same row, col, ts will be sorted purely based on the order in which they were inserted. When a memstore is flushed to HFile, the memstoreTS takes care of ordering. During compactions, the KeyValueHeap breaks ties by using the sequence ids of storefiles.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Ryan Rawson wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the problem is you are now changing how things are ordered sometimes but not all the time.  HFile directly uses the rawcomparator, instantiating it directly rather than getting it via the code path you changed.  So now you create a memstore in this order:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;row,col,100,Put  (memstoreTS=1)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;row,col,100,Delete (memstoreTS=2)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;row,col,100,Put (memstoreTS=3)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But the HFile comparator will consider this out of order since it doesnt know about memstoreTS and it still expects things to be in a certain order.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;I&apos;m a little wary of having implicit ordering in the HFiles... in your new scheme, Put,Delete,Put are in that order &apos;just because they are&apos;, and the comparator cannot put them back in order, and must rely on scanner order.  During compactions we would place keys in order based on which files they came from, but they wouldn&apos;t themselves have an order.  Basically we should get rid of &apos;type sorting&apos; and use memstoreTS sorting in memory and implicit sorting in the HFiles.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right. I see that HFile does an extra check and throws an IOException when it gets data out of the order. So if we go forward with this change, we will have to ensure that the comparator used by HFile knows about this change. This change be achieved in two ways: Firstly, by setting the default value of ignoreType = true. Alternately, the HFile can explicitly set ignoreType = true.&lt;/p&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Pranav&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;http://review.cloudera.org/r/1252/#review1993&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://review.cloudera.org/r/1252/#review1993&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;


</comment>
                            <comment id="12936134" author="hbasereviewboard" created="Sat, 27 Nov 2010 00:05:13 +0000"  >&lt;p&gt;Message from: &quot;Pranav Khaitan&quot; &amp;lt;pranavkhaitan@gmail.com&amp;gt;&lt;/p&gt;

&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;http://review.cloudera.org/r/1252/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://review.cloudera.org/r/1252/&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;

&lt;p&gt;(Updated 2010-11-26 16:02:47.462170)&lt;/p&gt;


&lt;p&gt;Review request for hbase, Jonathan Gray and Kannan Muthukkaruppan.&lt;/p&gt;


&lt;p&gt;Summary (updated)&lt;br/&gt;
-------&lt;/p&gt;

&lt;p&gt;This is a design change suggested in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3276&quot; title=&quot;delete followed by a put with the same timestamp&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3276&quot;&gt;&lt;del&gt;HBASE-3276&lt;/del&gt;&lt;/a&gt; so adequate thought should be given before proceeding. &lt;/p&gt;

&lt;p&gt;The main code change is just one line which is to ignore key type while doing KV comparisons. When the key type is ignored, then all the keys for the same timestamp are sorted according the order in which they were inserted. It is still ensured that the delete family and delete column will be at the top because they have the default column name and default timestamp.&lt;/p&gt;


&lt;p&gt;This addresses bug &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3276&quot; title=&quot;delete followed by a put with the same timestamp&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3276&quot;&gt;&lt;del&gt;HBASE-3276&lt;/del&gt;&lt;/a&gt;.&lt;br/&gt;
    &lt;a href=&quot;http://issues.apache.org/jira/browse/HBASE-3276&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/browse/HBASE-3276&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;Diffs&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;  trunk/src/main/java/org/apache/hadoop/hbase/KeyValue.java 1039233 &lt;br/&gt;
  trunk/src/test/java/org/apache/hadoop/hbase/regionserver/KeyValueScanFixture.java 1039233 &lt;br/&gt;
  trunk/src/test/java/org/apache/hadoop/hbase/regionserver/TestStoreScanner.java 1039233 &lt;/p&gt;

&lt;p&gt;Diff: &lt;a href=&quot;http://review.cloudera.org/r/1252/diff&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://review.cloudera.org/r/1252/diff&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;Testing&lt;br/&gt;
-------&lt;/p&gt;

&lt;p&gt;Test cases added. Since there is a change in semantics, some previous tests were failing because of this change. Those tests have been modified to test the newer behavior.&lt;/p&gt;


&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Pranav&lt;/p&gt;

</comment>
                            <comment id="12964880" author="hbasereviewboard" created="Mon, 29 Nov 2010 19:05:16 +0000"  >&lt;p&gt;Message from: stack@duboce.net&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;On 2010-11-26 14:54:45, Ryan Rawson wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; trunk/src/main/java/org/apache/hadoop/hbase/KeyValue.java, line 1373&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt; &amp;lt;&lt;a href=&quot;http://review.cloudera.org/r/1252/diff/1/?file=17712#file17712line1373&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://review.cloudera.org/r/1252/diff/1/?file=17712#file17712line1373&lt;/a&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     what are all the consequences for not sorting by type when using KVComparator?  Does this mean we might create HFiles that not sorted properly, because the HFile comparator uses the KeyComparator directly with ignoreType = false. &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     While in memstore we can rely on memstoreTS to roughly order by insertion time, and the Put/Delete should probably work in that situation, you are talking about modifiying a pretty core and important concept in how we sort things.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     There are other ways to reconcile bugs like this, one of them is to extend the memstoreTS concept into the HFile and use that to reconcile during reads.  There is another JIRA where I proposed this.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;     If we are talking about 0.92 and beyond I&apos;d prefer building a solid base rather than dangerous hacks like this.  Our unit tests are not extremely extensive, so while they might pass, that doesnt guarantee lack of bad behaviour later on.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Pranav Khaitan wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Agree. As I mentioned, this is a major change and more thought needs to be given to it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;However, to resolve issues like &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3276&quot; title=&quot;delete followed by a put with the same timestamp&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3276&quot;&gt;&lt;del&gt;HBASE-3276&lt;/del&gt;&lt;/a&gt;, we need either such a change or extend the memstoreTS concept to HFile as you mentioned.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;About consequences, I don&apos;t see anything negative here. This change only affects the sorting of keys having same row, col, timestamp. After this change, all keys with the same row, col, ts will be sorted purely based on the order in which they were inserted. When a memstore is flushed to HFile, the memstoreTS takes care of ordering. During compactions, the KeyValueHeap breaks ties by using the sequence ids of storefiles.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Ryan Rawson wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;the problem is you are now changing how things are ordered sometimes but not all the time.  HFile directly uses the rawcomparator, instantiating it directly rather than getting it via the code path you changed.  So now you create a memstore in this order:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;row,col,100,Put  (memstoreTS=1)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;row,col,100,Delete (memstoreTS=2)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;row,col,100,Put (memstoreTS=3)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But the HFile comparator will consider this out of order since it doesnt know about memstoreTS and it still expects things to be in a certain order.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;I&apos;m a little wary of having implicit ordering in the HFiles... in your new scheme, Put,Delete,Put are in that order &apos;just because they are&apos;, and the comparator cannot put them back in order, and must rely on scanner order.  During compactions we would place keys in order based on which files they came from, but they wouldn&apos;t themselves have an order.  Basically we should get rid of &apos;type sorting&apos; and use memstoreTS sorting in memory and implicit sorting in the HFiles.  &lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Pranav Khaitan wrote:&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Right. I see that HFile does an extra check and throws an IOException when it gets data out of the order. So if we go forward with this change, we will have to ensure that the comparator used by HFile knows about this change. This change be achieved in two ways: Firstly, by setting the default value of ignoreType = true. Alternately, the HFile can explicitly set ignoreType = true.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;@Ryan, you say &quot;Basically we should get rid of &apos;type sorting&apos; and use memstoreTS sorting in memory and implicit sorting in the HFiles.&quot;  You think this a receipe we should adopt going forward?   Giving it cursory thought, it would seem like it should work.   What about migrating data that was sorted using current KV comparator?  Do we need to migrate files made using old sort order?  Should we mark files that have this new ordering type 2 files?&lt;/p&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;stack&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;-----------------------------------------------------------&lt;br/&gt;
This is an automatically generated e-mail. To reply, visit:&lt;br/&gt;
&lt;a href=&quot;http://review.cloudera.org/r/1252/#review1993&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://review.cloudera.org/r/1252/#review1993&lt;/a&gt;&lt;br/&gt;
-----------------------------------------------------------&lt;/p&gt;


</comment>
                            <comment id="12965900" author="kannanm" created="Wed, 1 Dec 2010 22:50:02 +0000"  >&lt;p&gt;On flushes, if we did what a minor compaction now does (after &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3048&quot; title=&quot;unify code for major/minor compactions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3048&quot;&gt;&lt;del&gt;HBASE-3048&lt;/del&gt;&lt;/a&gt;), i.e. process TTL/versions/overwrites etc. then a HFile would never contain a value that should be suppressed.&lt;/p&gt;

&lt;p&gt;And with regards to multiple HFiles containing conflicting data (i.e. corresponding to same TS), we could pick the &quot;sequenceId&quot; of the HFile to resolve the winner. (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-1485&quot; title=&quot;Wrong or indeterminate behavior when there are duplicate versions of a column&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-1485&quot;&gt;&lt;del&gt;HBASE-1485&lt;/del&gt;&lt;/a&gt; fix also relies on sequenceId ordering of HFiles to resolve winners between entries coming from multiple files).&lt;/p&gt;</comment>
                            <comment id="12965911" author="ryanobjc" created="Wed, 1 Dec 2010 23:00:42 +0000"  >&lt;p&gt;I&apos;m worried that an implicit ordering opens us to problems in the future.  The kind that involve &quot;i lost my data and there is no way to recover it&quot;. &lt;/p&gt;

&lt;p&gt;To that end, I propose we implement &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2856&quot; title=&quot;TestAcidGuarantee broken on trunk &quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-2856&quot;&gt;&lt;del&gt;HBASE-2856&lt;/del&gt;&lt;/a&gt;, specifically my comment &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-2856?focusedCommentId=12899119&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#action_12899119&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/HBASE-2856?focusedCommentId=12899119&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#action_12899119&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;which talks about bringing the memstoreTS (ish, an equivalent but not quite identical value) down into the HFile.  It will have many benefits, including fixing this JIRA, and also fixing the ACID stuff that has been waylaid for lack of this change.&lt;/p&gt;</comment>
                            <comment id="14067283" author="apurtell" created="Sat, 19 Jul 2014 00:31:22 +0000"  >&lt;p&gt;A mislaid now-duplicate of more recent issues filed on the same topic.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 26 Nov 2010 00:42:00 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>26754</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            2 years, 21 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i02e0f:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11871</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>