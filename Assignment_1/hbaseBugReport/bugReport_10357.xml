<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Dec 16 20:13:01 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-10357/HBASE-10357.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-10357] Failover RPC&apos;s for scans</title>
                <link>https://issues.apache.org/jira/browse/HBASE-10357</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;This is extension of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10355&quot; title=&quot;Failover RPC&amp;#39;s from client using region replicas&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10355&quot;&gt;&lt;del&gt;HBASE-10355&lt;/del&gt;&lt;/a&gt; to add failover support for scans. &lt;/p&gt;</description>
                <environment></environment>
        <key id="12689129">HBASE-10357</key>
            <summary>Failover RPC&apos;s for scans</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12682280">HBASE-10070</parent>
                                    <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="devaraj">Devaraj Das</assignee>
                                    <reporter username="enis">Enis Soztutar</reporter>
                        <labels>
                    </labels>
                <created>Thu, 16 Jan 2014 00:09:17 +0000</created>
                <updated>Sat, 21 Feb 2015 23:29:41 +0000</updated>
                            <resolved>Fri, 16 May 2014 23:39:57 +0000</resolved>
                                                    <fixVersion>0.99.0</fixVersion>
                    <fixVersion>hbase-10070</fixVersion>
                                    <component>Client</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>7</watches>
                                                                <comments>
                            <comment id="13973440" author="devaraj" created="Thu, 17 Apr 2014 21:29:24 +0000"  >&lt;p&gt;Patch. Still testing it. But can do with some early feedback.&lt;/p&gt;</comment>
                            <comment id="13973539" author="devaraj" created="Thu, 17 Apr 2014 23:03:46 +0000"  >&lt;p&gt;This is removing pom.xml changes and a more complete test.&lt;/p&gt;</comment>
                            <comment id="13974608" author="devaraj" created="Fri, 18 Apr 2014 23:07:20 +0000"  >&lt;p&gt;This has some bug fixes. Still testing. But good for review I think.&lt;/p&gt;</comment>
                            <comment id="13976456" author="devaraj" created="Tue, 22 Apr 2014 06:44:53 +0000"  >&lt;p&gt;This is a more complete patch. The way this works is that ScannerCallable mechanics is used to handle the replica logic (and the layer above, ClientScanner, is not aware of the replica mechanics that much). The logic is that when the client latches on to a replica (default/primary or not), it tries to get the maximum data out of it, and when there is a failure, it switches to some other replica...&lt;/p&gt;</comment>
                            <comment id="13977097" author="nkeywal" created="Tue, 22 Apr 2014 17:40:37 +0000"  >&lt;p&gt;The patch seems ok. I think the design with the replica logic outside of the main object makes the code simpler to read.&lt;br/&gt;
There is some code duplication in ScannerCallableWithReplicas (w/ the one used for the &quot;Get&quot; path) that could probably be avoided.&lt;/p&gt;</comment>
                            <comment id="13977814" author="stack" created="Wed, 23 Apr 2014 04:16:32 +0000"  >&lt;p&gt;May we have a high-level on what this patch is about?&lt;/p&gt;

&lt;p&gt;For example, the first constructor comment is about &quot; An HConnection will be&lt;br/&gt;
+     * retrieved using the passed Configuration....&quot; but we are passing in a ClusterConnection... &lt;/p&gt;

&lt;p&gt;And it likely is making for a javadoc complaint since non-doc&apos;d.&lt;/p&gt;

&lt;p&gt;Is this an old warning? &quot;+     * Note that the passed &lt;/p&gt;
{@link Scan}
&lt;p&gt;&apos;s start row maybe changed changed.&quot;&lt;/p&gt;

&lt;p&gt;What is a primaryOperationTimeout?  Primary&apos;s get their own special timeout now?  It is not explained.  Zero for a timeout means?&lt;/p&gt;

&lt;p&gt;So ClientScanner now is about replicas all the time? &lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected ScannerCallable callable = null;&lt;br/&gt;
+    protected ScannerCallableWithReplicas callable = null;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Now ClientScanner does retries where it used to be done inside the Callable#withRetries?&lt;/p&gt;

&lt;p&gt;+    private int retries;&lt;br/&gt;
+    protected final int primaryOperationTimeout;&lt;br/&gt;
+    protected final ExecutorService pool;&lt;/p&gt;

&lt;p&gt;We pass in a new pool.  Is this pool used by anything else or is it a new pool altogether?&lt;/p&gt;

&lt;p&gt;Here we have retries then we don&apos;t have do them if not Consistency.STRONG?&lt;/p&gt;

&lt;p&gt;+    if (scan.getConsistency() == Consistency.STRONG) &lt;/p&gt;
{
+      return caller.callWithRetries(callable);
+    }
&lt;p&gt; else {&lt;br/&gt;
+      return caller.callWithoutRetries(callable);&lt;/p&gt;

&lt;p&gt;Needs class comment on what is distinct about this new class:&lt;/p&gt;

&lt;p&gt;+  class ScannerCallableWithReplicas implements RetryingCallable&amp;lt;Result[]&amp;gt; &lt;/p&gt;
{

Above we avoid going into ScannerCallableWithReplicas#call if Consistency.STRONG but when inside the method, we do this:

+      if (scan.getConsistency() == Consistency.STRONG) return baseCallable.call();

Should we throw exception instead since unexpected code path? 

The call method is kinda ugly w/ all the returns happening all over the method.  Does it have to be this way?

What is going on here:

+      }
&lt;p&gt; catch (CancellationException e) &lt;/p&gt;
{
+        throw new InterruptedIOException();
+      }
&lt;p&gt; catch (InterruptedException e) &lt;/p&gt;
{
+        throw new InterruptedIOException();

A CancellationException is converted to IIOE w/o passing original exception.  Ditto on the IE?

No exceptions are going to come up out of this or it will provoke spew of exceptions in client log?

+        cs.cancelAll(true);

(Does hbase client handle cancel gracefully?)

Not even a trace log in below?

+        }
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
+          // ignore

Longer than line length max?

+    private int addCallsForCurrentReplica(BoundedCompletionService&amp;lt;Pair&amp;lt;Result[], ScannerCallablePerReplica&amp;gt;&amp;gt; cs,

Code dup in addCallsForCurrentReplica and next method?

This kind of baked in decision should be in a special method reusable by other parts of the code rather than one-off in getRegionLocations....

+      }
&lt;p&gt; catch (DoNotRetryIOException e) &lt;/p&gt;
{
+        throw e;
+      } catch (RetriesExhaustedException e) {
+        throw e;
+      }
&lt;p&gt; catch (InterruptedIOException e) &lt;/p&gt;
{
+        throw e;
+      }
&lt;p&gt; catch (IOException e) {&lt;/p&gt;

&lt;p&gt;We sure this is the right set to rethrow?  Is RetriesExhaustedException a DNRIOE?  If so, should DNRIOE fall through?  Hmm... it does not seem to be.  It seems like it should be a DNRIOE.&lt;/p&gt;

&lt;p&gt;So we have ScannerCallablePerReplica and ScannerCallablePerReplicas.  Neither has class comment.&lt;/p&gt;

&lt;p&gt;I made it almost to half-way and stopped.  Need some overview if I am to contribute a helpful code review.  Thanks.&lt;/p&gt;

</comment>
                            <comment id="13977860" author="devaraj" created="Wed, 23 Apr 2014 05:51:37 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;, thanks for taking a look. The patch sure needs cleanup. I was in the process of doing that. The approach taken here is similar to the one done in handling GET for cases that have region replicas. In general, the flow is:&lt;br/&gt;
1. A scan is attempted on the default region&lt;br/&gt;
2. The scanner sends all the RPCs to the default region until it is done, or, there is a timeout on the default (a timeout of zero should be disallowed). The primaryOperationTimeout is what is used for this timeout and it is set to a second by default.&lt;br/&gt;
3. If there is a timeout in (2) above, scanner(s) is opened on the non-default replica(s)&lt;br/&gt;
4. The results (and this applies to openScanner as well) from the first successful scanner are taken, and it is stored which server returned the results.&lt;br/&gt;
5. The next RPCs are done on the above stored server until it is done or there is a timeout, in which case, the other replicas are queried (as in (3) above).&lt;/p&gt;

&lt;p&gt;Does the above give a picture of what is being attempted in the patch? I&apos;ll clean up the patch some and post it shortly.&lt;/p&gt;</comment>
                            <comment id="13981776" author="enis" created="Fri, 25 Apr 2014 23:54:02 +0000"  >&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Can we default to 200ms or smt. 1s seems long. However, this rpc request seems that it would wait for the whole batch to complete. Maybe we should have different confs for switching from one replica to another. If the scan usually takes around that timeout, then we can be switching back and forth a lot causing open+close scanners very frequently.
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+        &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.configuration.getInt(&lt;span class=&quot;code-quote&quot;&gt;&quot;hbase.client.primaryCallTimeout.scan&quot;&lt;/span&gt;, 1000000); &lt;span class=&quot;code-comment&quot;&gt;// 1000 ms&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;Instead of wrapping ScannerCallable everytime, can we check the consistency and not wrap it if STRONG?&lt;/li&gt;
	&lt;li&gt;in addCallsForCurrentReplica, the location is always from the primary replica?&lt;/li&gt;
	&lt;li&gt;Would be good to have a test where we switch in the middle of the scan as well. I think current test only switching at start.&lt;/li&gt;
&lt;/ul&gt;





</comment>
                            <comment id="13986421" author="devaraj" created="Thu, 1 May 2014 07:37:37 +0000"  >&lt;p&gt;Thanks for the reviews earlier &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=enis&quot; class=&quot;user-hover&quot; rel=&quot;enis&quot;&gt;Enis Soztutar&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=nkeywal&quot; class=&quot;user-hover&quot; rel=&quot;nkeywal&quot;&gt;Nicolas Liochon&lt;/a&gt;. &lt;br/&gt;
Attaching a patch that should take care of most feedback. In this patch, I bit the bullet and used the replica code path for all scans (with or without replicas, STRONG or TIMELINE). That way it&apos;d be tested well. Also, had to refactor a little bit of ClusterConnection&apos;s replica methods and make it part of public interface since I needed to access replica methods in in a unit test.&lt;br/&gt;
Left the default value for replica-timeout as 1 second. I think this is decent for scans (there are two RPCs involved in the beginning for example). The switching of replicas is per RPC call from the ScannerCallable&apos;s call method (&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=enis&quot; class=&quot;user-hover&quot; rel=&quot;enis&quot;&gt;Enis Soztutar&lt;/a&gt;, by batch are you referring to this per RPC request/response or the whole scan?).&lt;br/&gt;
I&apos;ll try to come up with a unit test for the switching of replicas between a scan but it&apos;d require some hackery with coprocessors. Let me see if i can do it cleanly. But otherwise, this patch should be close...&lt;/p&gt;</comment>
                            <comment id="13990943" author="devaraj" created="Tue, 6 May 2014 18:24:10 +0000"  >&lt;p&gt;Patch with more tests and explanatory comments.&lt;/p&gt;</comment>
                            <comment id="13992970" author="enis" created="Thu, 8 May 2014 18:01:04 +0000"  >&lt;p&gt;Mind putting this to RB? &lt;/p&gt;</comment>
                            <comment id="13993330" author="enis" created="Fri, 9 May 2014 02:39:25 +0000"  >&lt;p&gt;Looks in good shape. A couple of remaining points. &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;SmallScannerCallable looks good. Does it have to extend ScannerCallable? Previously it extended RegionServerCallable.&lt;/li&gt;
	&lt;li&gt;ClusterConnectionWithReplicaId seems unnecessary. If we need those methods in UT context, it should be ok to make ClusterConnection public, but with explicit annotation that it is a hbase-private interface.&lt;/li&gt;
	&lt;li&gt;remove printstacktrace:
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-        &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RuntimeException(t2);
 +        t2.printStackTrace(); &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RuntimeException(t2);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;ScannerCallableWithReplicas is a callable, however, itself calls the passed ScannerCallables with retries. I can see why this implementing the RetryingCallable&amp;lt;Result[]&amp;gt; interface is convenient, but it is breaking the callable pattern? Should we name it ScannerRetyingCallerWithReplicas (similar to RpcRetryingCallerWithReadReplicas) and not implement a callable? Just to think about it.&lt;/li&gt;
	&lt;li&gt;scanners other than the ones we hear back  -&amp;gt; should be only one scanner, no?&lt;/li&gt;
	&lt;li&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (pool == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; || pool.isShutdown()) {
 +      &lt;span class=&quot;code-comment&quot;&gt;// we definitely need an executor service!&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Will there be any case where our passed pool is null? If we construct a new pool via HTable.getDefaultExecutor(conf), how does it get shutdown ? &lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
 +          Future&amp;lt;Pair&amp;lt;Result[], ScannerCallable&amp;gt;&amp;gt; f = cs.take();
 +          &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (f != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;cs.take() cannot return null.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;When we have a response, how does the other scanners get closed. The CS will interrupt, but those scanners might have already finished.
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; someone &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; already completed the RPC
 +      &lt;span class=&quot;code-comment&quot;&gt;// close ourself since we are out of sync with
&lt;/span&gt; +      &lt;span class=&quot;code-comment&quot;&gt;// client state&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I can understand this, but some other scanners might be in the middle of execution, or just finished. &lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;Why are we adding another stale field in message ScanResponse? Every Result object already contains this info over the wire, right?
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+  optional bool stale = 6;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13993935" author="devaraj" created="Fri, 9 May 2014 21:31:06 +0000"  >&lt;blockquote&gt;&lt;p&gt;SmallScannerCallable looks good. Does it have to extend ScannerCallable? Previously it extended RegionServerCallable.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes this is required because the ScannerCallableWithReplicas takes a ScannerCallable in the current patch.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;ClusterConnectionWithReplicaId seems unnecessary. If we need those methods in UT context, it should be ok to make ClusterConnection public, but with explicit annotation that it is a hbase-private interface.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, I thought about that as well. I don&apos;t have any strong opinion on this and will update to have these methods in the ClusterConnection class.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;it is breaking the callable pattern? Should we name it ScannerRetyingCallerWithReplicas (similar to RpcRetryingCallerWithReadReplicas) and not implement a callable? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In my opinion, this is okay. The reason being that the upper layers can remain unchanged - they still see the callable, and, the same code is used for both timeline/strong.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;scanners other than the ones we hear back -&amp;gt; should be only one scanner, no?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, we hear back from one scanner but we could have started the RPCs with multiple.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Will there be any case where our passed pool is null? If we construct a new pool via HTable.getDefaultExecutor(conf), how does it get shutdown ?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, the pool can be null - for example the MetaScan methods don&apos;t invoke HTable constructors that create a pool internally. But yeah, you have a valid point - I should close the pool if i created it internally here.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;cs.take() cannot return null.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right..&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;When we have a response, how does the other scanners get closed. The CS will interrupt, but those scanners might have already finished.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, I need to handle this case.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Why are we adding another stale field in message ScanResponse? Every Result object already contains this info over the wire, right?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;There are two ways of returning the response. Result[] or CellScanner, depending on cell block support from the client. For the latter case, I think it was not straightforward to check whether something was stale or not without introducing &apos;stale&apos; notion in the Cell etc. Wanted to avoid all that and adding the stale in ScanResponse seemed logical. &lt;span class=&quot;error&quot;&gt;&amp;#91;look at the changes in ResponseConverter where i use the ScanResponse.getStale()&amp;#93;&lt;/span&gt;.&lt;/p&gt;</comment>
                            <comment id="13994023" author="enis" created="Fri, 9 May 2014 23:01:09 +0000"  >&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+        &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.configuration.getInt(&lt;span class=&quot;code-quote&quot;&gt;&quot;hbase.client.replicaCallTimeout.scan&quot;&lt;/span&gt;, 1000000); &lt;span class=&quot;code-comment&quot;&gt;// 1000 ms&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Should this be called hbase.client.primaryCallTimeout.scan? The get and multiGet are named like that. Is this because the timeout applies to replica requests for next call as well? &lt;/p&gt;
</comment>
                            <comment id="13994036" author="devaraj" created="Fri, 9 May 2014 23:16:05 +0000"  >&lt;blockquote&gt;&lt;p&gt;Should this be called hbase.client.primaryCallTimeout.scan? The get and multiGet are named like that. Is this because the timeout applies to replica requests for next call as well?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In the scan case, when a replica (be it primary or not) is latched onto, we try to get as much as possible from that replica (without switching to the primary in the middle of the scan). We&apos;d wait for the 1000 ms irrespective of whether the replica is primary or not. Hence the name doesn&apos;t have &quot;primary&quot; in it..&lt;/p&gt;</comment>
                            <comment id="13995619" author="devaraj" created="Mon, 12 May 2014 20:58:57 +0000"  >&lt;p&gt;Addresses the comments last raised.&lt;br/&gt;
The main change is that the &quot;close&quot; of the unneeded scanners are queued up in the executor service to make sure all scanners (primary or otherwise) are closed when not needed. &lt;br/&gt;
Also a semantic change - when a scanner is obtained, the underlying table shouldn&apos;t have been closed. Updated some unit tests to reflect this. So for example, one pattern is - one would create a table, do a bunch of puts, and then close the table. Subsequently, a scanner would be obtained from that table. In the approach on this jira, since the scanner uses the pool always, if the table is  closed, the underlying pool would be shut down as well. This would lead to issues. In earlier versions of the patch, I would create a new pool if the passed pool was shut down but it makes handling the closing of the pool, etc. an issue. I think for 1.0 we should make the change that a table shouldn&apos;t be closed if we want to invoke methods on that table.&lt;/p&gt;</comment>
                            <comment id="13995620" author="devaraj" created="Mon, 12 May 2014 20:59:47 +0000"  >&lt;p&gt;Ignore the pom.xml changes in the last patch.&lt;/p&gt;</comment>
                            <comment id="13995833" author="devaraj" created="Tue, 13 May 2014 00:01:33 +0000"  >&lt;p&gt;This is without the pom.xml change.&lt;/p&gt;</comment>
                            <comment id="13997113" author="enis" created="Wed, 14 May 2014 00:38:52 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think for 1.0 we should make the change that a table shouldn&apos;t be closed if we want to invoke methods on that table.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Agreed. I think this is already a requirement. &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;CellScanner, depending on cell block support from the client. For the latter case, I think it was not straightforward to check whether something was stale or not without introducing &apos;stale&apos; notion in the Cell etc.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I see. I did not take a closer look into how cell blocks are results are carried in rpc. If the Result objects for those are constructed at the receiving side, then yes we should pass the staleness of those in the response separately. I guess this change does it: &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
-        results[i] = Result.create(cells);
+        results[i] = Result.create(cells, &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, response.getStale());
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If Result would have more fields in the future, then we have to ensure that every field is also carried over at the ScanResponse. Other than passing in empty Result objects with cellblocks in ScanResponse, adding the field there makes sense. Just a note for future. &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Looked at how we are closing the scanners that did not return the result. We are scheduling the close in the thread pool to be executed later. This should be fine. If the close request comes while the actual scan is being executed (or not scheduled yet) it will still be fine I guess. What happens if the scanner is not opened yet (scannerId = -1). Can it happen that we try to close first, then open the scanner?&lt;/li&gt;
	&lt;li&gt;I think the printStackTrace() change is still in the patch.&lt;/li&gt;
	&lt;li&gt;This is not needed? &lt;tt&gt;+import org.apache.hadoop.util.ReflectionUtils;&lt;/tt&gt;&lt;/li&gt;
	&lt;li&gt;Sorry, one thing I forgot to mention was that, whether or not we can make the replicas transparent to the ClientScanner:
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; possiblyNextScanner(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; nbRows, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; done) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
+      &lt;span class=&quot;code-comment&quot;&gt;// If we have just switched replica, don&apos;t go to the next scanner yet. Rather, &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt;
&lt;/span&gt;+      &lt;span class=&quot;code-comment&quot;&gt;// the scanner operations on the &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; replica.
&lt;/span&gt;+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (callable != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; callable.switchedToADifferentReplica()) &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
+      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; nextScanner(nbRows, done);
+    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Conceptually, the RegionScanner should not leak that it is doing multi-rpc&apos;s to the client scanner which controls the scanners for multiple regions. What do you think? &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13997640" author="devaraj" created="Wed, 14 May 2014 15:24:53 +0000"  >&lt;blockquote&gt;&lt;p&gt;Can it happen that we try to close first, then open the scanner?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes there is some (rare) chance that this might happen. When this happens the scanner on the server side will eventually get closed when the lease expires. I think (and as discussed offline), let&apos;s leave it as is for now and if this becomes a problem, we can think of ways to address it (like via additional synchronization that will prevent close from getting called until scanner is opened, etc.)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Sorry, one thing I forgot to mention was that, whether or not we can make the replicas transparent to the ClientScanner&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I wanted to make the ClientScanner totally unaware of the replica logic as well but at the same time didn&apos;t want to make the ScannerCallableWithReplicas more complex than needed. So yes, there is some awareness of replicas in the ClientScanner but it&apos;s minimal and it falls in line with the way ClientScanner already handles scan exceptions. I have put in comments in the code explaining what is being done in ClientScanner.&lt;/p&gt;</comment>
                            <comment id="13998161" author="enis" created="Wed, 14 May 2014 22:38:42 +0000"  >&lt;blockquote&gt;&lt;p&gt;let&apos;s leave it as is for now and if this becomes a problem, we can think of ways to address it&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Agreed that it is rare and not trivial to order this properly. &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I wanted to make the ClientScanner totally unaware of the replica logic as well but at the same time didn&apos;t want to make the ScannerCallableWithReplicas more complex than needed&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I see. It seems that the model for openScanner + next from ClientScanner to ScannerCallable is a little more complex in the usual case as well from what I thought. It should be ok for now. &lt;/p&gt;

&lt;p&gt;+1 for the patch.&lt;/p&gt;</comment>
                            <comment id="14000444" author="devaraj" created="Fri, 16 May 2014 22:55:17 +0000"  >&lt;p&gt;This is a rebased patch for hbase-10070. Also has some fixes.&lt;/p&gt;</comment>
                            <comment id="14000505" author="enis" created="Fri, 16 May 2014 23:39:57 +0000"  >&lt;p&gt;Ok, checked the latest version as well and committed to branch on behalf of Devaraj (Still having some infra issues). Thanks Stack and Nicolas for looking.  &lt;/p&gt;</comment>
                            <comment id="14046639" author="enis" created="Sat, 28 Jun 2014 01:48:22 +0000"  >&lt;p&gt;Attaching rebased patch for master that is committed&lt;/p&gt;</comment>
                            <comment id="14046687" author="enis" created="Sat, 28 Jun 2014 02:09:25 +0000"  >&lt;p&gt;Committed to master as part of hbase-10070 branch merge&lt;/p&gt;</comment>
                            <comment id="14046754" author="hudson" created="Sat, 28 Jun 2014 06:13:58 +0000"  >&lt;p&gt;FAILURE: Integrated in HBase-TRUNK #5245 (See &lt;a href=&quot;https://builds.apache.org/job/HBase-TRUNK/5245/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/HBase-TRUNK/5245/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-10357&quot; title=&quot;Failover RPC&amp;#39;s for scans&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-10357&quot;&gt;&lt;del&gt;HBASE-10357&lt;/del&gt;&lt;/a&gt; Failover RPC&apos;s for scans (Devaraj Das) (enis: rev 5a8f3f7cefb553141084f36ccd7b3b72930e2692)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/protobuf/ProtobufUtil.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/ScannerCallableWithReplicas.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/ReversedScannerCallable.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/TestMultiVersions.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestRestoreSnapshotFromClient.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/RpcRetryingCallerWithReadReplicas.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/ClientSmallReversedScanner.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionManager.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestReplicasClient.java&lt;/li&gt;
	&lt;li&gt;hbase-protocol/src/main/protobuf/Client.proto&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/catalog/TestMetaReaderEditorNoCluster.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/ReversedClientScanner.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/ClientSmallScanner.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/MultiServerCallable.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/Scan.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/ScannerCallable.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/protobuf/ResponseConverter.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/client/HConnectionTestingUtility.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/ClientScanner.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/ClusterConnection.java&lt;/li&gt;
	&lt;li&gt;hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabels.java&lt;/li&gt;
	&lt;li&gt;hbase-protocol/src/main/java/org/apache/hadoop/hbase/protobuf/generated/ClientProtos.java&lt;/li&gt;
	&lt;li&gt;hbase-client/src/main/java/org/apache/hadoop/hbase/client/HTable.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14330594" author="enis" created="Sat, 21 Feb 2015 23:29:41 +0000"  >&lt;p&gt;Closing this issue after 0.99.0 release. &lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12652977" name="0039-HBASE-10357-Failover-RPC-s-for-scans-Devaraj-Das.patch" size="108672" author="enis" created="Sat, 28 Jun 2014 01:48:21 +0000"/>
                            <attachment id="12640710" name="10357-1.txt" size="31532" author="devaraj" created="Thu, 17 Apr 2014 21:29:24 +0000"/>
                            <attachment id="12640734" name="10357-2.txt" size="31248" author="devaraj" created="Thu, 17 Apr 2014 23:03:46 +0000"/>
                            <attachment id="12641194" name="10357-3.2.txt" size="53865" author="devaraj" created="Tue, 22 Apr 2014 06:44:53 +0000"/>
                            <attachment id="12640909" name="10357-3.txt" size="34381" author="devaraj" created="Fri, 18 Apr 2014 23:07:20 +0000"/>
                            <attachment id="12643603" name="10357-4.2.txt" size="93891" author="devaraj" created="Tue, 6 May 2014 18:24:10 +0000"/>
                            <attachment id="12644519" name="10357-4.3.1.txt" size="94146" author="devaraj" created="Tue, 13 May 2014 00:01:33 +0000"/>
                            <attachment id="12644837" name="10357-4.3.2.txt" size="93505" author="devaraj" created="Wed, 14 May 2014 15:24:53 +0000"/>
                            <attachment id="12644483" name="10357-4.3.txt" size="95285" author="devaraj" created="Mon, 12 May 2014 20:58:57 +0000"/>
                            <attachment id="12645353" name="10357-4.4.txt" size="89207" author="devaraj" created="Fri, 16 May 2014 22:55:17 +0000"/>
                            <attachment id="12642812" name="10357-4.txt" size="89646" author="devaraj" created="Thu, 1 May 2014 07:37:37 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 17 Apr 2014 21:29:24 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>368096</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310191" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Hadoop Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10343"><![CDATA[Reviewed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            1 year, 42 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1rg27:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>368401</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>